{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python-first access to R's brms with proper parameter names, ArviZ support, and cmdstanr performance. The easiest way to run brms models from Python. Key Features \u00b6 Proper parameter names : Returns b_Intercept , b_zAge , sd_patient__Intercept instead of generic names like b_dim_0 arviz integration : Returns arviz.InferenceData by default for Python workflow brms formula syntax : Full support for brms formula interface including random effects Dual access : Results include both .idata (arviz) and .r (brmsfit or other) attributes Prebuilt Binaries : Fast installation with precompiled runtimes containing brms and cmstanr (50x faster, 25 seconds on Google Colab) Installation \u00b6 pip install brmspy First-time setup (installs brms, cmdstanr, and CmdStan in R): from brmspy import brms brms . install_brms () # requires R to be installed already Prebuilt Runtimes (Optional) \u00b6 For faster installation (~20-60 seconds vs 20-30 minutes), use prebuilt runtime bundles: from brmspy import brms brms . install_brms ( use_prebuilt_binaries = True ) Windows RTools \u00b6 In case you don't have RTools installed, you can use the flag install_rtools = True. This is disabled by default, because the flag runs the full rtools installer and modifies system path. Use with caution! from brmspy import brms brms . install_brms ( use_prebuilt_binaries = True , install_rtools = True # works for both prebuilt and compiled binaries. ) System Requirements \u00b6 R >= 4.0 Linux (x86_64): - glibc >= 2.27 (Ubuntu 18.04+, Debian 10+, RHEL 8+) - g++ >= 9.0 macOS (Intel & Apple Silicon): - Xcode Command Line Tools: xcode-select --install - clang >= 11.0 Windows (x86_64): - Rtools 4.0+ with MinGW toolchain - g++ >= 9.0 Download Rtools from: https://cran.r-project.org/bin/windows/Rtools/ Quick Start \u00b6 from brmspy import brms , prior import arviz as az # Load data epilepsy = brms . get_brms_data ( \"epilepsy\" ) # Fit model model = brms . fit ( formula = \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , priors = [ prior ( \"normal(0, 1)\" , \"b\" ), prior ( \"exponential(1)\" , \"sd\" , group = \"patient\" ), prior ( \"student_t(3, 0, 2.5)\" , \"Intercept\" ) ], family = \"poisson\" , chains = 4 , iter = 2000 ) # Analyze az . summary ( model . idata ) az . plot_posterior ( model . idata ) Requirements \u00b6 Python 3.10-3.14 R with brms >= 2.20.0, cmdstanr, and posterior packages Links \u00b6 GitHub Repository API Reference Examples","title":"Home"},{"location":"#key-features","text":"Proper parameter names : Returns b_Intercept , b_zAge , sd_patient__Intercept instead of generic names like b_dim_0 arviz integration : Returns arviz.InferenceData by default for Python workflow brms formula syntax : Full support for brms formula interface including random effects Dual access : Results include both .idata (arviz) and .r (brmsfit or other) attributes Prebuilt Binaries : Fast installation with precompiled runtimes containing brms and cmstanr (50x faster, 25 seconds on Google Colab)","title":"Key Features"},{"location":"#installation","text":"pip install brmspy First-time setup (installs brms, cmdstanr, and CmdStan in R): from brmspy import brms brms . install_brms () # requires R to be installed already","title":"Installation"},{"location":"#prebuilt-runtimes-optional","text":"For faster installation (~20-60 seconds vs 20-30 minutes), use prebuilt runtime bundles: from brmspy import brms brms . install_brms ( use_prebuilt_binaries = True )","title":"Prebuilt Runtimes (Optional)"},{"location":"#windows-rtools","text":"In case you don't have RTools installed, you can use the flag install_rtools = True. This is disabled by default, because the flag runs the full rtools installer and modifies system path. Use with caution! from brmspy import brms brms . install_brms ( use_prebuilt_binaries = True , install_rtools = True # works for both prebuilt and compiled binaries. )","title":"Windows RTools"},{"location":"#system-requirements","text":"R >= 4.0 Linux (x86_64): - glibc >= 2.27 (Ubuntu 18.04+, Debian 10+, RHEL 8+) - g++ >= 9.0 macOS (Intel & Apple Silicon): - Xcode Command Line Tools: xcode-select --install - clang >= 11.0 Windows (x86_64): - Rtools 4.0+ with MinGW toolchain - g++ >= 9.0 Download Rtools from: https://cran.r-project.org/bin/windows/Rtools/","title":"System Requirements"},{"location":"#quick-start","text":"from brmspy import brms , prior import arviz as az # Load data epilepsy = brms . get_brms_data ( \"epilepsy\" ) # Fit model model = brms . fit ( formula = \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , priors = [ prior ( \"normal(0, 1)\" , \"b\" ), prior ( \"exponential(1)\" , \"sd\" , group = \"patient\" ), prior ( \"student_t(3, 0, 2.5)\" , \"Intercept\" ) ], family = \"poisson\" , chains = 4 , iter = 2000 ) # Analyze az . summary ( model . idata ) az . plot_posterior ( model . idata )","title":"Quick Start"},{"location":"#requirements","text":"Python 3.10-3.14 R with brms >= 2.20.0, cmdstanr, and posterior packages","title":"Requirements"},{"location":"#links","text":"GitHub Repository API Reference Examples","title":"Links"},{"location":"api/brms/","text":"Classes \u00b6 FitResult dataclass \u00b6 Result from fit() function. Attributes: Name Type Description idata InferenceData arviz InferenceData with posterior, posterior_predictive, log_likelihood, and observed_data groups r ListVector brmsfit R object from brms::brm() FormulaResult dataclass \u00b6 Result from formula() function. Attributes: Name Type Description r ListVector R brmsformula object dict Dict Python dictionary representation of formula See Also brmspy.brms.formula : Creates FormulaResult objects Examples: from brmspy import brms # Create formula with options f = brms . formula ( \"y ~ x\" , decomp = \"QR\" ) # Use in fit() model = brms . fit ( f , data = df , chains = 4 ) GenericResult dataclass \u00b6 Generic result container with arviz and R objects. Attributes: Name Type Description idata InferenceData arviz InferenceData object r ListVector R object from brms LogLikResult dataclass \u00b6 Result from log_lik() function. Attributes: Name Type Description idata IDLogLik arviz InferenceData with log-likelihood values r ListVector R matrix from brms::log_lik() See Also brmspy.brms.log_lik : Creates LogLikResult objects Examples: from brmspy import brms import arviz as az model = brms . fit ( \"y ~ x\" , data = df , chains = 4 ) loglik = brms . log_lik ( model ) # Use for model comparison loo = az . loo ( model . idata ) print ( loo ) PosteriorEpredResult dataclass \u00b6 Result from posterior_epred() function. Attributes: Name Type Description idata InferenceData arviz InferenceData with expected values in 'posterior' group r ListVector R matrix from brms::posterior_epred() PosteriorLinpredResult dataclass \u00b6 Result from posterior_linpred() function. Attributes: Name Type Description idata IDLinpred arviz InferenceData with linear predictor values r ListVector R matrix from brms::posterior_linpred() See Also brmspy.brms.posterior_linpred : Creates PosteriorLinpredResult objects Examples: from brmspy import brms model = brms . fit ( \"count ~ age\" , data = df , family = \"poisson\" , chains = 4 ) linpred = brms . posterior_linpred ( model ) # Linear predictor on log scale (for Poisson) print ( linpred . idata . predictions ) PosteriorPredictResult dataclass \u00b6 Result from posterior_predict() function. Attributes: Name Type Description idata InferenceData arviz InferenceData with predictions in 'posterior_predictive' group r ListVector R matrix from brms::posterior_predict() Functions \u00b6 prior ( prior , class_ = None , coef = None , group = None , dpar = None , resp = None , nlpar = None , lb = None , ub = None , ** kwargs ) \u00b6 Create a brms-style prior specification. This function mirrors the behavior of brms::prior_string() and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of prior_string() in brms. Parameters: Name Type Description Default prior str The prior definition as a string, exactly as brms expects it. Examples include :: \"normal(0, 1)\" \"student_t(3, 0, 1.5)\" \"exponential(2)\" \"lkj(2)\" required class_ str Parameter class (e.g. \"b\" , \"sd\" , \"Intercept\" ). This corresponds to class in brms. class cannot be used as a parameter in Python (reserved keyword), so class_ is used instead. None coef str Coefficient name for class-level effects. None group str Grouping variable for hierarchical/multilevel effects. None dpar str Distributional parameter (e.g. \"sigma\" or \"phi\" ). None resp str Response variable name for multivariate models. None nlpar str Nonlinear parameter name if using nonlinear formulas. None lb float Lower bound for truncated priors. None ub float Upper bound for truncated priors. None **kwargs Any Any additional keyword arguments supported by brms::prior_string() . These are forwarded unchanged. {} Returns: Type Description PriorSpec A typed prior specification object used by brmspy.fit() and brmspy.make_stancode() . Notes This function does not validate the prior expression string itself \u2014 validation occurs inside brms. Its purpose is to construct a structured, editor-friendly representation that seamlessly maps to rpy2 calls. Examples: Prior on the intercept :: p = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\") Prior on a coefficient :: p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\") Group-level (hierarchical) SD prior :: p = prior(\"exponential(2)\", class_=\"sd\", group=\"region\") Truncated prior :: p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0) Multiple priors passed to fit :: from brmspy import prior priors = [ prior(\"student_t(3, 0, 2)\", class_=\"b\", coef=\"zAge\"), prior(\"exponential(2)\", class_=\"sd\", group=\"patient\"), ] model = brms.fit(\"y ~ zAge + (1|patient)\", data=df, priors=priors) install_brms ( brms_version = 'latest' , repo = None , install_cmdstanr = True , install_rstan = False , cmdstanr_version = 'latest' , rstan_version = 'latest' , use_prebuilt_binaries = False , install_rtools = False ) \u00b6 Install brms R package, optionally cmdstanr and CmdStan compiler, or rstan. Parameters: Name Type Description Default brms_version str brms version: \"latest\", \"2.23.0\", or \">= 2.20.0\" \"latest\" repo str | None Extra CRAN repository URL None install_cmdstanr bool Whether to install cmdstanr and build CmdStan compiler True install_rstan bool Whether to install rstan (alternative to cmdstanr) False cmdstanr_version str cmdstanr version: \"latest\", \"0.8.1\", or \">= 0.8.0\" \"latest\" rstan_version str rstan version: \"latest\", \"2.32.6\", or \">= 2.32.0\" \"latest\" use_prebuilt_binaries bool Uses fully prebuilt binaries for cmdstanr and brms and their dependencies. Ignores system R libraries and uses the latest brms and cmdstanr available for your system. Requires R>=4 and might not be compatible with some older systems or missing toolchains. Can reduce setup time by 50x. False install_rtools bool Installs RTools (windows only) if they cant be found. WARNING: Modifies system path and runs the full rtools installer. Use with caution! False Examples: Basic installation: from brmspy import brms brms . install_brms () Install specific version: brms . install_brms ( brms_version = \"2.23.0\" ) Use rstan instead of cmdstanr: brms . install_brms ( install_cmdstanr = False , install_rstan = True ) Fast installation with prebuilt binaries: brms . install_brms ( use_prebuilt_binaries = True ) get_brms_version () \u00b6 Get installed brms R package version. Returns: Type Description str Version string (e.g., \"2.23.0\") Raises: Type Description ImportError If brms is not installed Examples: from brmspy import brms version = brms . get_brms_version () print ( f \"brms version: { version } \" ) get_brms_data ( dataset_name ) \u00b6 Load example dataset from brms package. Parameters: Name Type Description Default dataset_name str Dataset name. Available datasets include: - 'epilepsy': Epileptic seizure counts - 'kidney': Kidney infection data with censoring - 'inhaler': Inhaler usage study - 'btdata': British Telecom share price data - And many more from brms package required Returns: Type Description DataFrame Dataset as pandas DataFrame with column names preserved See Also brms::brmsdata : R documentation for available datasets https://paulbuerkner.com/brms/reference/index.html#data Examples: Load epilepsy dataset: from brmspy import brms epilepsy = brms . get_brms_data ( \"epilepsy\" ) print ( epilepsy . head ()) print ( epilepsy . columns ) Load kidney dataset with censoring: kidney = brms . get_brms_data ( \"kidney\" ) print ( f \"Shape: { kidney . shape } \" ) print ( f \"Censored observations: { kidney [ 'censored' ] . sum () } \" ) make_stancode ( formula , data , priors = None , family = 'poisson' , sample_prior = 'no' , formula_args = None ) \u00b6 Generate Stan code using brms::make_stancode(). Useful for inspecting the generated Stan model before fitting, understanding the model structure, or using the code with other Stan interfaces. Parameters: Name Type Description Default formula str or FormulaResult brms formula specification required data DataFrame Model data required priors list of PriorSpec Prior specifications from prior() function None family str Distribution family (gaussian, poisson, binomial, etc.) \"poisson\" sample_prior str Whether to sample from prior: - \"no\": No prior samples - \"yes\": Include prior samples alongside posterior - \"only\": Sample from prior only (no data) \"no\" formula_args dict Additional arguments passed to formula() None Returns: Type Description str Complete Stan program code as string See Also brms::make_stancode : R documentation https://paulbuerkner.com/brms/reference/make_stancode.html fit : Fit model instead of just generating code make_standata : Generate Stan data block Examples: Generate Stan code for simple model: from brmspy import brms epilepsy = brms . get_brms_data ( \"epilepsy\" ) stan_code = brms . make_stancode ( formula = \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , family = \"poisson\" ) print ( stan_code [: 500 ]) # Print first 500 characters With custom priors: from brmspy import prior stan_code = brms . make_stancode ( formula = \"count ~ zAge\" , data = epilepsy , priors = [ prior ( \"normal(0, 1)\" , class_ = \"b\" )], family = \"poisson\" ) For prior predictive checks (sample_prior=\"only\"): stan_code = brms.make_stancode( formula=\"count ~ zAge\", data=epilepsy, family=\"poisson\", sample_prior=\"only\" ) formula ( formula , ** formula_args ) \u00b6 Set up a model formula for brms package. Allows defining (potentially non-linear) additive multilevel models for all parameters of the assumed response distribution. Parameters: Name Type Description Default formula str brms formula specification, e.g., \"y ~ x + (1|group)\" required **formula_args dict Additional brms::brmsformula() arguments: decomp : str Decomposition method (e.g., \"QR\" for QR decomposition) center : bool Whether to center predictors (default True) sparse : bool Use sparse matrix representation nl : bool Whether formula is non-linear loop : bool Use loop-based Stan code {} Returns: Type Description FormulaResult Object with .r (R brmsformula object) and .dict (Python dict) attributes See Also brms::brmsformula : R documentation https://paulbuerkner.com/brms/reference/brmsformula.html fit : Fit model using formula Examples: Basic formula: from brmspy import brms f = brms . formula ( \"y ~ x1 + x2 + (1|group)\" ) With QR decomposition for numerical stability: f = brms . formula ( \"reaction ~ days + (days|subject)\" , decomp = \"QR\" ) Multivariate formula: f = brms.formula( \"mvbind(y1, y2) ~ x1 + x2\", center=True ) fit ( formula , data , priors = None , family = 'gaussian' , sample_prior = 'no' , sample = True , backend = 'cmdstanr' , formula_args = None , ** brm_args ) \u00b6 Fit Bayesian regression model using brms. Uses brms with cmdstanr backend for proper parameter naming. Returns FitResult with .idata (arviz.InferenceData) and .r (brmsfit) attributes. BRMS documentation and parameters Parameters: Name Type Description Default formula str brms formula: formula string, e.g \"y ~ x + (1|group)\" or FormulaResult from formula() required data dict or DataFrame Model data required priors list Prior specifications: [(\"normal(0,1)\", \"b\"), (\"cauchy(0,2)\", \"sd\")] [] family str Distribution family: \"gaussian\", \"poisson\", \"binomial\", etc. \"gaussian\" sample_prior str Sample from prior: \"no\", \"yes\", \"only\" \"no\" sample bool Whether to sample. If False, returns compiled model with empty=TRUE True backend str Stan backend: \"cmdstanr\" (recommended), \"rstan\" \"cmdstanr\" **brm_args Additional brms::brm() arguments: chains=4, iter=2000, warmup=1000, cores=4, seed=123, thin=1, etc. {} Returns: Type Description FitResult Object with .idata (arviz.InferenceData) and .r (brmsfit) attributes See Also brms::brm : R documentation https://paulbuerkner.com/brms/reference/brm.html posterior_epred : Expected value predictions posterior_predict : Posterior predictive samples formula : Create formula object with options Examples: Basic Poisson regression: from brmspy import brms import arviz as az epilepsy = brms . get_brms_data ( \"epilepsy\" ) model = brms . fit ( formula = \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , family = \"poisson\" , chains = 4 , iter = 2000 ) az . summary ( model . idata ) With custom priors: from brmspy import prior model = brms . fit ( formula = \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , priors = [ prior ( \"normal(0, 0.5)\" , class_ = \"b\" ), prior ( \"exponential(2)\" , class_ = \"sd\" , group = \"patient\" ) ], family = \"poisson\" , chains = 4 ) Survival model with censoring: kidney = brms . get_brms_data ( \"kidney\" ) survival_model = brms . fit ( formula = \"time | cens(censored) ~ age + sex + disease + (1|patient)\" , data = kidney , family = \"weibull\" , chains = 4 , iter = 4000 , warmup = 2000 , cores = 4 , seed = 42 ) Gaussian model with distributional regression: # Model both mean and variance model = brms . fit ( formula = brms . formula ( \"y ~ x\" , sigma ~ \"z\" # Model heteroscedasticity ), data = data , family = \"gaussian\" , chains = 4 ) posterior_epred ( model , newdata , ** kwargs ) \u00b6 Compute expected value of posterior predictive distribution. Calls brms::posterior_epred() to get E[Y|data] without observation noise. BRMS documentation and parameters Parameters: Name Type Description Default model FitResult Fitted model from fit() required newdata DataFrame Data for predictions required **kwargs Additional arguments to brms::posterior_epred() {} Returns: Type Description PosteriorEpredResult Object with .idata and .r attributes posterior_predict ( model , newdata = None , ** kwargs ) \u00b6 Generate posterior predictive samples with observation noise. Calls brms::posterior_predict() to get samples of Y_new|data. BRMS documentation and parameters Parameters: Name Type Description Default model FitResult Fitted model from fit() required newdata DataFrame Data for predictions. If None, uses original data None **kwargs Additional arguments to brms::posterior_predict() {} Returns: Type Description PosteriorPredictResult Object with .idata and .r attributes posterior_linpred ( model , newdata = None , ** kwargs ) \u00b6 Compute linear predictor of the model. Returns samples of the linear predictor (before applying the link function). Useful for understanding the model's predictions on the linear scale. Parameters: Name Type Description Default model FitResult Fitted model from fit() required newdata DataFrame Data for predictions. If None, uses original data None **kwargs dict Additional arguments to brms::posterior_linpred(): transform : bool - Apply inverse link function (default False) ndraws : int - Number of posterior draws summary : bool - Return summary statistics {} Returns: Type Description PosteriorLinpredResult Object with .idata (IDLinpred) and .r (R matrix) attributes See Also brms::posterior_linpred : R documentation https://paulbuerkner.com/brms/reference/posterior_linpred.brmsfit.html posterior_epred : Expected values on response scale Examples: from brmspy import brms epilepsy = brms . get_brms_data ( \"epilepsy\" ) model = brms . fit ( \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , family = \"poisson\" , chains = 4 ) # Linear predictor (log scale for Poisson) linpred = brms . posterior_linpred ( model ) print ( linpred . idata . predictions ) log_lik ( model , newdata = None , ** kwargs ) \u00b6 Compute log-likelihood values. Returns log p(y|theta) for each observation. Essential for model comparison via LOO-CV and WAIC. Parameters: Name Type Description Default model FitResult Fitted model from fit() required newdata DataFrame Data for predictions. If None, uses original data None **kwargs dict Additional arguments to brms::log_lik(): ndraws : int - Number of posterior draws combine_chains : bool - Combine chains (default True) {} Returns: Type Description LogLikResult Object with .idata (IDLogLik) and .r (R matrix) attributes See Also brms::log_lik : R documentation https://paulbuerkner.com/brms/reference/log_lik.brmsfit.html arviz.loo : Leave-One-Out Cross-Validation arviz.waic : Widely Applicable Information Criterion Examples: Compute log-likelihood for model comparison: from brmspy import brms import arviz as az epilepsy = brms . get_brms_data ( \"epilepsy\" ) model = brms . fit ( \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , family = \"poisson\" , chains = 4 ) # LOO-CV for model comparison loo = az . loo ( model . idata ) print ( loo ) Compare multiple models: model1 = brms . fit ( \"count ~ zAge + (1|patient)\" , data = epilepsy , family = \"poisson\" , chains = 4 ) model2 = brms . fit ( \"count ~ zAge + zBase + (1|patient)\" , data = epilepsy , family = \"poisson\" , chains = 4 ) comp = az . compare ({ 'model1' : model1 . idata , 'model2' : model2 . idata }) print ( comp ) summary ( model , ** kwargs ) \u00b6 Generate summary statistics for fitted model. Calls R's summary() function on brmsfit object and converts to pandas DataFrame. BRMS documentation and parameters Parameters: Name Type Description Default model FitResult Fitted model from fit() required **kwargs Additional arguments to summary(), e.g., probs=c(0.025, 0.975) {} Returns: Type Description DataFrame Summary statistics with columns for Estimate, Est.Error, and credible intervals See Also brms::summary.brmsfit : R documentation https://paulbuerkner.com/brms/reference/summary.brmsfit.html Examples: from brmspy import brms model = brms . fit ( \"y ~ x\" , data = data , chains = 4 ) summary_df = brms . summary ( model ) print ( summary_df )","title":"Main Module"},{"location":"api/brms/#brmspy.brms-classes","text":"","title":"Classes"},{"location":"api/brms/#brmspy.brms.FitResult","text":"Result from fit() function. Attributes: Name Type Description idata InferenceData arviz InferenceData with posterior, posterior_predictive, log_likelihood, and observed_data groups r ListVector brmsfit R object from brms::brm()","title":"FitResult"},{"location":"api/brms/#brmspy.brms.FormulaResult","text":"Result from formula() function. Attributes: Name Type Description r ListVector R brmsformula object dict Dict Python dictionary representation of formula See Also brmspy.brms.formula : Creates FormulaResult objects Examples: from brmspy import brms # Create formula with options f = brms . formula ( \"y ~ x\" , decomp = \"QR\" ) # Use in fit() model = brms . fit ( f , data = df , chains = 4 )","title":"FormulaResult"},{"location":"api/brms/#brmspy.brms.GenericResult","text":"Generic result container with arviz and R objects. Attributes: Name Type Description idata InferenceData arviz InferenceData object r ListVector R object from brms","title":"GenericResult"},{"location":"api/brms/#brmspy.brms.LogLikResult","text":"Result from log_lik() function. Attributes: Name Type Description idata IDLogLik arviz InferenceData with log-likelihood values r ListVector R matrix from brms::log_lik() See Also brmspy.brms.log_lik : Creates LogLikResult objects Examples: from brmspy import brms import arviz as az model = brms . fit ( \"y ~ x\" , data = df , chains = 4 ) loglik = brms . log_lik ( model ) # Use for model comparison loo = az . loo ( model . idata ) print ( loo )","title":"LogLikResult"},{"location":"api/brms/#brmspy.brms.PosteriorEpredResult","text":"Result from posterior_epred() function. Attributes: Name Type Description idata InferenceData arviz InferenceData with expected values in 'posterior' group r ListVector R matrix from brms::posterior_epred()","title":"PosteriorEpredResult"},{"location":"api/brms/#brmspy.brms.PosteriorLinpredResult","text":"Result from posterior_linpred() function. Attributes: Name Type Description idata IDLinpred arviz InferenceData with linear predictor values r ListVector R matrix from brms::posterior_linpred() See Also brmspy.brms.posterior_linpred : Creates PosteriorLinpredResult objects Examples: from brmspy import brms model = brms . fit ( \"count ~ age\" , data = df , family = \"poisson\" , chains = 4 ) linpred = brms . posterior_linpred ( model ) # Linear predictor on log scale (for Poisson) print ( linpred . idata . predictions )","title":"PosteriorLinpredResult"},{"location":"api/brms/#brmspy.brms.PosteriorPredictResult","text":"Result from posterior_predict() function. Attributes: Name Type Description idata InferenceData arviz InferenceData with predictions in 'posterior_predictive' group r ListVector R matrix from brms::posterior_predict()","title":"PosteriorPredictResult"},{"location":"api/brms/#brmspy.brms-functions","text":"","title":"Functions"},{"location":"api/brms/#brmspy.brms.prior","text":"Create a brms-style prior specification. This function mirrors the behavior of brms::prior_string() and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of prior_string() in brms. Parameters: Name Type Description Default prior str The prior definition as a string, exactly as brms expects it. Examples include :: \"normal(0, 1)\" \"student_t(3, 0, 1.5)\" \"exponential(2)\" \"lkj(2)\" required class_ str Parameter class (e.g. \"b\" , \"sd\" , \"Intercept\" ). This corresponds to class in brms. class cannot be used as a parameter in Python (reserved keyword), so class_ is used instead. None coef str Coefficient name for class-level effects. None group str Grouping variable for hierarchical/multilevel effects. None dpar str Distributional parameter (e.g. \"sigma\" or \"phi\" ). None resp str Response variable name for multivariate models. None nlpar str Nonlinear parameter name if using nonlinear formulas. None lb float Lower bound for truncated priors. None ub float Upper bound for truncated priors. None **kwargs Any Any additional keyword arguments supported by brms::prior_string() . These are forwarded unchanged. {} Returns: Type Description PriorSpec A typed prior specification object used by brmspy.fit() and brmspy.make_stancode() . Notes This function does not validate the prior expression string itself \u2014 validation occurs inside brms. Its purpose is to construct a structured, editor-friendly representation that seamlessly maps to rpy2 calls. Examples: Prior on the intercept :: p = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\") Prior on a coefficient :: p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\") Group-level (hierarchical) SD prior :: p = prior(\"exponential(2)\", class_=\"sd\", group=\"region\") Truncated prior :: p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0) Multiple priors passed to fit :: from brmspy import prior priors = [ prior(\"student_t(3, 0, 2)\", class_=\"b\", coef=\"zAge\"), prior(\"exponential(2)\", class_=\"sd\", group=\"patient\"), ] model = brms.fit(\"y ~ zAge + (1|patient)\", data=df, priors=priors)","title":"prior"},{"location":"api/brms/#brmspy.brms.install_brms","text":"Install brms R package, optionally cmdstanr and CmdStan compiler, or rstan. Parameters: Name Type Description Default brms_version str brms version: \"latest\", \"2.23.0\", or \">= 2.20.0\" \"latest\" repo str | None Extra CRAN repository URL None install_cmdstanr bool Whether to install cmdstanr and build CmdStan compiler True install_rstan bool Whether to install rstan (alternative to cmdstanr) False cmdstanr_version str cmdstanr version: \"latest\", \"0.8.1\", or \">= 0.8.0\" \"latest\" rstan_version str rstan version: \"latest\", \"2.32.6\", or \">= 2.32.0\" \"latest\" use_prebuilt_binaries bool Uses fully prebuilt binaries for cmdstanr and brms and their dependencies. Ignores system R libraries and uses the latest brms and cmdstanr available for your system. Requires R>=4 and might not be compatible with some older systems or missing toolchains. Can reduce setup time by 50x. False install_rtools bool Installs RTools (windows only) if they cant be found. WARNING: Modifies system path and runs the full rtools installer. Use with caution! False Examples: Basic installation: from brmspy import brms brms . install_brms () Install specific version: brms . install_brms ( brms_version = \"2.23.0\" ) Use rstan instead of cmdstanr: brms . install_brms ( install_cmdstanr = False , install_rstan = True ) Fast installation with prebuilt binaries: brms . install_brms ( use_prebuilt_binaries = True )","title":"install_brms"},{"location":"api/brms/#brmspy.brms.get_brms_version","text":"Get installed brms R package version. Returns: Type Description str Version string (e.g., \"2.23.0\") Raises: Type Description ImportError If brms is not installed Examples: from brmspy import brms version = brms . get_brms_version () print ( f \"brms version: { version } \" )","title":"get_brms_version"},{"location":"api/brms/#brmspy.brms.get_brms_data","text":"Load example dataset from brms package. Parameters: Name Type Description Default dataset_name str Dataset name. Available datasets include: - 'epilepsy': Epileptic seizure counts - 'kidney': Kidney infection data with censoring - 'inhaler': Inhaler usage study - 'btdata': British Telecom share price data - And many more from brms package required Returns: Type Description DataFrame Dataset as pandas DataFrame with column names preserved See Also brms::brmsdata : R documentation for available datasets https://paulbuerkner.com/brms/reference/index.html#data Examples: Load epilepsy dataset: from brmspy import brms epilepsy = brms . get_brms_data ( \"epilepsy\" ) print ( epilepsy . head ()) print ( epilepsy . columns ) Load kidney dataset with censoring: kidney = brms . get_brms_data ( \"kidney\" ) print ( f \"Shape: { kidney . shape } \" ) print ( f \"Censored observations: { kidney [ 'censored' ] . sum () } \" )","title":"get_brms_data"},{"location":"api/brms/#brmspy.brms.make_stancode","text":"Generate Stan code using brms::make_stancode(). Useful for inspecting the generated Stan model before fitting, understanding the model structure, or using the code with other Stan interfaces. Parameters: Name Type Description Default formula str or FormulaResult brms formula specification required data DataFrame Model data required priors list of PriorSpec Prior specifications from prior() function None family str Distribution family (gaussian, poisson, binomial, etc.) \"poisson\" sample_prior str Whether to sample from prior: - \"no\": No prior samples - \"yes\": Include prior samples alongside posterior - \"only\": Sample from prior only (no data) \"no\" formula_args dict Additional arguments passed to formula() None Returns: Type Description str Complete Stan program code as string See Also brms::make_stancode : R documentation https://paulbuerkner.com/brms/reference/make_stancode.html fit : Fit model instead of just generating code make_standata : Generate Stan data block Examples: Generate Stan code for simple model: from brmspy import brms epilepsy = brms . get_brms_data ( \"epilepsy\" ) stan_code = brms . make_stancode ( formula = \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , family = \"poisson\" ) print ( stan_code [: 500 ]) # Print first 500 characters With custom priors: from brmspy import prior stan_code = brms . make_stancode ( formula = \"count ~ zAge\" , data = epilepsy , priors = [ prior ( \"normal(0, 1)\" , class_ = \"b\" )], family = \"poisson\" ) For prior predictive checks (sample_prior=\"only\"): stan_code = brms.make_stancode( formula=\"count ~ zAge\", data=epilepsy, family=\"poisson\", sample_prior=\"only\" )","title":"make_stancode"},{"location":"api/brms/#brmspy.brms.formula","text":"Set up a model formula for brms package. Allows defining (potentially non-linear) additive multilevel models for all parameters of the assumed response distribution. Parameters: Name Type Description Default formula str brms formula specification, e.g., \"y ~ x + (1|group)\" required **formula_args dict Additional brms::brmsformula() arguments: decomp : str Decomposition method (e.g., \"QR\" for QR decomposition) center : bool Whether to center predictors (default True) sparse : bool Use sparse matrix representation nl : bool Whether formula is non-linear loop : bool Use loop-based Stan code {} Returns: Type Description FormulaResult Object with .r (R brmsformula object) and .dict (Python dict) attributes See Also brms::brmsformula : R documentation https://paulbuerkner.com/brms/reference/brmsformula.html fit : Fit model using formula Examples: Basic formula: from brmspy import brms f = brms . formula ( \"y ~ x1 + x2 + (1|group)\" ) With QR decomposition for numerical stability: f = brms . formula ( \"reaction ~ days + (days|subject)\" , decomp = \"QR\" ) Multivariate formula: f = brms.formula( \"mvbind(y1, y2) ~ x1 + x2\", center=True )","title":"formula"},{"location":"api/brms/#brmspy.brms.fit","text":"Fit Bayesian regression model using brms. Uses brms with cmdstanr backend for proper parameter naming. Returns FitResult with .idata (arviz.InferenceData) and .r (brmsfit) attributes. BRMS documentation and parameters Parameters: Name Type Description Default formula str brms formula: formula string, e.g \"y ~ x + (1|group)\" or FormulaResult from formula() required data dict or DataFrame Model data required priors list Prior specifications: [(\"normal(0,1)\", \"b\"), (\"cauchy(0,2)\", \"sd\")] [] family str Distribution family: \"gaussian\", \"poisson\", \"binomial\", etc. \"gaussian\" sample_prior str Sample from prior: \"no\", \"yes\", \"only\" \"no\" sample bool Whether to sample. If False, returns compiled model with empty=TRUE True backend str Stan backend: \"cmdstanr\" (recommended), \"rstan\" \"cmdstanr\" **brm_args Additional brms::brm() arguments: chains=4, iter=2000, warmup=1000, cores=4, seed=123, thin=1, etc. {} Returns: Type Description FitResult Object with .idata (arviz.InferenceData) and .r (brmsfit) attributes See Also brms::brm : R documentation https://paulbuerkner.com/brms/reference/brm.html posterior_epred : Expected value predictions posterior_predict : Posterior predictive samples formula : Create formula object with options Examples: Basic Poisson regression: from brmspy import brms import arviz as az epilepsy = brms . get_brms_data ( \"epilepsy\" ) model = brms . fit ( formula = \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , family = \"poisson\" , chains = 4 , iter = 2000 ) az . summary ( model . idata ) With custom priors: from brmspy import prior model = brms . fit ( formula = \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , priors = [ prior ( \"normal(0, 0.5)\" , class_ = \"b\" ), prior ( \"exponential(2)\" , class_ = \"sd\" , group = \"patient\" ) ], family = \"poisson\" , chains = 4 ) Survival model with censoring: kidney = brms . get_brms_data ( \"kidney\" ) survival_model = brms . fit ( formula = \"time | cens(censored) ~ age + sex + disease + (1|patient)\" , data = kidney , family = \"weibull\" , chains = 4 , iter = 4000 , warmup = 2000 , cores = 4 , seed = 42 ) Gaussian model with distributional regression: # Model both mean and variance model = brms . fit ( formula = brms . formula ( \"y ~ x\" , sigma ~ \"z\" # Model heteroscedasticity ), data = data , family = \"gaussian\" , chains = 4 )","title":"fit"},{"location":"api/brms/#brmspy.brms.posterior_epred","text":"Compute expected value of posterior predictive distribution. Calls brms::posterior_epred() to get E[Y|data] without observation noise. BRMS documentation and parameters Parameters: Name Type Description Default model FitResult Fitted model from fit() required newdata DataFrame Data for predictions required **kwargs Additional arguments to brms::posterior_epred() {} Returns: Type Description PosteriorEpredResult Object with .idata and .r attributes","title":"posterior_epred"},{"location":"api/brms/#brmspy.brms.posterior_predict","text":"Generate posterior predictive samples with observation noise. Calls brms::posterior_predict() to get samples of Y_new|data. BRMS documentation and parameters Parameters: Name Type Description Default model FitResult Fitted model from fit() required newdata DataFrame Data for predictions. If None, uses original data None **kwargs Additional arguments to brms::posterior_predict() {} Returns: Type Description PosteriorPredictResult Object with .idata and .r attributes","title":"posterior_predict"},{"location":"api/brms/#brmspy.brms.posterior_linpred","text":"Compute linear predictor of the model. Returns samples of the linear predictor (before applying the link function). Useful for understanding the model's predictions on the linear scale. Parameters: Name Type Description Default model FitResult Fitted model from fit() required newdata DataFrame Data for predictions. If None, uses original data None **kwargs dict Additional arguments to brms::posterior_linpred(): transform : bool - Apply inverse link function (default False) ndraws : int - Number of posterior draws summary : bool - Return summary statistics {} Returns: Type Description PosteriorLinpredResult Object with .idata (IDLinpred) and .r (R matrix) attributes See Also brms::posterior_linpred : R documentation https://paulbuerkner.com/brms/reference/posterior_linpred.brmsfit.html posterior_epred : Expected values on response scale Examples: from brmspy import brms epilepsy = brms . get_brms_data ( \"epilepsy\" ) model = brms . fit ( \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , family = \"poisson\" , chains = 4 ) # Linear predictor (log scale for Poisson) linpred = brms . posterior_linpred ( model ) print ( linpred . idata . predictions )","title":"posterior_linpred"},{"location":"api/brms/#brmspy.brms.log_lik","text":"Compute log-likelihood values. Returns log p(y|theta) for each observation. Essential for model comparison via LOO-CV and WAIC. Parameters: Name Type Description Default model FitResult Fitted model from fit() required newdata DataFrame Data for predictions. If None, uses original data None **kwargs dict Additional arguments to brms::log_lik(): ndraws : int - Number of posterior draws combine_chains : bool - Combine chains (default True) {} Returns: Type Description LogLikResult Object with .idata (IDLogLik) and .r (R matrix) attributes See Also brms::log_lik : R documentation https://paulbuerkner.com/brms/reference/log_lik.brmsfit.html arviz.loo : Leave-One-Out Cross-Validation arviz.waic : Widely Applicable Information Criterion Examples: Compute log-likelihood for model comparison: from brmspy import brms import arviz as az epilepsy = brms . get_brms_data ( \"epilepsy\" ) model = brms . fit ( \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , family = \"poisson\" , chains = 4 ) # LOO-CV for model comparison loo = az . loo ( model . idata ) print ( loo ) Compare multiple models: model1 = brms . fit ( \"count ~ zAge + (1|patient)\" , data = epilepsy , family = \"poisson\" , chains = 4 ) model2 = brms . fit ( \"count ~ zAge + zBase + (1|patient)\" , data = epilepsy , family = \"poisson\" , chains = 4 ) comp = az . compare ({ 'model1' : model1 . idata , 'model2' : model2 . idata }) print ( comp )","title":"log_lik"},{"location":"api/brms/#brmspy.brms.summary","text":"Generate summary statistics for fitted model. Calls R's summary() function on brmsfit object and converts to pandas DataFrame. BRMS documentation and parameters Parameters: Name Type Description Default model FitResult Fitted model from fit() required **kwargs Additional arguments to summary(), e.g., probs=c(0.025, 0.975) {} Returns: Type Description DataFrame Summary statistics with columns for Estimate, Est.Error, and credible intervals See Also brms::summary.brmsfit : R documentation https://paulbuerkner.com/brms/reference/summary.brmsfit.html Examples: from brmspy import brms model = brms . fit ( \"y ~ x\" , data = data , chains = 4 ) summary_df = brms . summary ( model ) print ( summary_df )","title":"summary"},{"location":"api/install/","text":"Functions \u00b6 install_prebuilt ( runtime_version = '0.1.0' , url = None , bundle = None , install_rtools = False ) \u00b6 Install prebuilt brmspy runtime bundle for fast setup. Downloads and activates a precompiled runtime containing: - R packages (brms, cmdstanr, dependencies) - Compiled CmdStan binary - Complete environment ready for immediate use This reduces setup time from ~30 minutes to ~1 minute by avoiding compilation. Available for specific platform/R version combinations. Parameters: Name Type Description Default runtime_version str Runtime schema version (not pip version) \"0.1.0\" url str Custom URL for runtime bundle. If None, uses GitHub releases None bundle str Local path to runtime bundle (.tar.gz or directory) None install_rtools bool Installs RTools (windows only) if they cant be found. WARNING: Modifies system path and runs the full rtools installer. False Returns: Type Description bool True if installation succeeded, False otherwise Raises: Type Description RuntimeError If prebuilt binaries not available for this platform Notes Platform Support : Prebuilt binaries are available for: - Linux: x86_64, glibc >= 2.27, g++ >= 9 - macOS: x86_64 and arm64, clang >= 11 - Windows: x86_64 with Rtools R Version : Runtime includes all R packages, so they must match your R installation's major.minor version (e.g., R 4.3.x). System Fingerprint : Runtime is selected based on: - Operating system (linux/macos/windows) - CPU architecture (x86_64/arm64) - R version (major.minor) Example: linux-x86_64-r4.3 See Also install_brms : Main installation function brmspy.binaries.install_and_activate_runtime : Low-level installer brmspy.binaries.system_fingerprint : Platform detection Examples: Install from GitHub releases: from brmspy.install import install_prebuilt install_prebuilt () Install from local bundle: install_prebuilt ( bundle = \"/path/to/runtime.tar.gz\" ) Install from custom URL: install_prebuilt ( url = \"https://example.com/runtime.tar.gz\" ) install_brms ( brms_version = 'latest' , repo = None , install_cmdstanr = True , install_rstan = False , cmdstanr_version = 'latest' , rstan_version = 'latest' , use_prebuilt_binaries = False , install_rtools = False ) \u00b6 Install brms R package, optionally cmdstanr and CmdStan compiler, or rstan. Parameters: Name Type Description Default brms_version str brms version: \"latest\", \"2.23.0\", or \">= 2.20.0\" \"latest\" repo str | None Extra CRAN repository URL None install_cmdstanr bool Whether to install cmdstanr and build CmdStan compiler True install_rstan bool Whether to install rstan (alternative to cmdstanr) False cmdstanr_version str cmdstanr version: \"latest\", \"0.8.1\", or \">= 0.8.0\" \"latest\" rstan_version str rstan version: \"latest\", \"2.32.6\", or \">= 2.32.0\" \"latest\" use_prebuilt_binaries bool Uses fully prebuilt binaries for cmdstanr and brms and their dependencies. Ignores system R libraries and uses the latest brms and cmdstanr available for your system. Requires R>=4 and might not be compatible with some older systems or missing toolchains. Can reduce setup time by 50x. False install_rtools bool Installs RTools (windows only) if they cant be found. WARNING: Modifies system path and runs the full rtools installer. Use with caution! False Examples: Basic installation: from brmspy import brms brms . install_brms () Install specific version: brms . install_brms ( brms_version = \"2.23.0\" ) Use rstan instead of cmdstanr: brms . install_brms ( install_cmdstanr = False , install_rstan = True ) Fast installation with prebuilt binaries: brms . install_brms ( use_prebuilt_binaries = True )","title":"Install"},{"location":"api/install/#brmspy.install-functions","text":"","title":"Functions"},{"location":"api/install/#brmspy.install.install_prebuilt","text":"Install prebuilt brmspy runtime bundle for fast setup. Downloads and activates a precompiled runtime containing: - R packages (brms, cmdstanr, dependencies) - Compiled CmdStan binary - Complete environment ready for immediate use This reduces setup time from ~30 minutes to ~1 minute by avoiding compilation. Available for specific platform/R version combinations. Parameters: Name Type Description Default runtime_version str Runtime schema version (not pip version) \"0.1.0\" url str Custom URL for runtime bundle. If None, uses GitHub releases None bundle str Local path to runtime bundle (.tar.gz or directory) None install_rtools bool Installs RTools (windows only) if they cant be found. WARNING: Modifies system path and runs the full rtools installer. False Returns: Type Description bool True if installation succeeded, False otherwise Raises: Type Description RuntimeError If prebuilt binaries not available for this platform Notes Platform Support : Prebuilt binaries are available for: - Linux: x86_64, glibc >= 2.27, g++ >= 9 - macOS: x86_64 and arm64, clang >= 11 - Windows: x86_64 with Rtools R Version : Runtime includes all R packages, so they must match your R installation's major.minor version (e.g., R 4.3.x). System Fingerprint : Runtime is selected based on: - Operating system (linux/macos/windows) - CPU architecture (x86_64/arm64) - R version (major.minor) Example: linux-x86_64-r4.3 See Also install_brms : Main installation function brmspy.binaries.install_and_activate_runtime : Low-level installer brmspy.binaries.system_fingerprint : Platform detection Examples: Install from GitHub releases: from brmspy.install import install_prebuilt install_prebuilt () Install from local bundle: install_prebuilt ( bundle = \"/path/to/runtime.tar.gz\" ) Install from custom URL: install_prebuilt ( url = \"https://example.com/runtime.tar.gz\" )","title":"install_prebuilt"},{"location":"api/install/#brmspy.install.install_brms","text":"Install brms R package, optionally cmdstanr and CmdStan compiler, or rstan. Parameters: Name Type Description Default brms_version str brms version: \"latest\", \"2.23.0\", or \">= 2.20.0\" \"latest\" repo str | None Extra CRAN repository URL None install_cmdstanr bool Whether to install cmdstanr and build CmdStan compiler True install_rstan bool Whether to install rstan (alternative to cmdstanr) False cmdstanr_version str cmdstanr version: \"latest\", \"0.8.1\", or \">= 0.8.0\" \"latest\" rstan_version str rstan version: \"latest\", \"2.32.6\", or \">= 2.32.0\" \"latest\" use_prebuilt_binaries bool Uses fully prebuilt binaries for cmdstanr and brms and their dependencies. Ignores system R libraries and uses the latest brms and cmdstanr available for your system. Requires R>=4 and might not be compatible with some older systems or missing toolchains. Can reduce setup time by 50x. False install_rtools bool Installs RTools (windows only) if they cant be found. WARNING: Modifies system path and runs the full rtools installer. Use with caution! False Examples: Basic installation: from brmspy import brms brms . install_brms () Install specific version: brms . install_brms ( brms_version = \"2.23.0\" ) Use rstan instead of cmdstanr: brms . install_brms ( install_cmdstanr = False , install_rstan = True ) Fast installation with prebuilt binaries: brms . install_brms ( use_prebuilt_binaries = True )","title":"install_brms"},{"location":"api/types/","text":"Result types for brmspy functions. Classes \u00b6 PriorSpec dataclass \u00b6 Python representation of a brms prior specification. This dataclass provides a typed interface to brms::prior_string() arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the prior() factory function to create instances. Attributes: Name Type Description prior str Prior distribution as string (e.g., \"normal(0, 1)\", \"exponential(2)\") class_ ( str , optional ) Parameter class: \"b\" (fixed effects), \"sd\" (group SD), \"Intercept\", \"sigma\", \"cor\", etc. coef ( str , optional ) Specific coefficient name for class-level priors group ( str , optional ) Grouping variable for hierarchical effects dpar ( str , optional ) Distributional parameter (e.g., \"sigma\", \"phi\", \"zi\") resp ( str , optional ) Response variable for multivariate models nlpar ( str , optional ) Non-linear parameter name lb ( float , optional ) Lower bound for truncated priors ub ( float , optional ) Upper bound for truncated priors See Also prior : Factory function to create PriorSpec instances brms::prior_string : R documentation https://paulbuerkner.com/brms/reference/prior_string.html Examples: Create prior specifications (prefer using prior() function): from brmspy.types import PriorSpec # Fixed effect prior p1 = PriorSpec ( prior = \"normal(0, 1)\" , class_ = \"b\" ) # Group-level SD prior p2 = PriorSpec ( prior = \"exponential(2)\" , class_ = \"sd\" , group = \"patient\" ) # Coefficient-specific prior with bounds p3 = PriorSpec ( prior = \"normal(0, 1)\" , class_ = \"b\" , coef = \"age\" , lb = 0 # Truncated at zero ) Functions \u00b6 to_brms_kwargs () \u00b6 Convert PriorSpec to keyword arguments for brms::prior_string(). Maps Python dataclass fields to R function arguments, handling the class_ -> class parameter name conversion. Returns: Type Description dict Keyword arguments ready for brms::prior_string() Examples: from brmspy import prior p = prior ( \"normal(0, 1)\" , class_ = \"b\" , coef = \"age\" ) kwargs = p . to_brms_kwargs () print ( kwargs ) # {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'} IDFit \u00b6 Bases: InferenceData Typed InferenceData for fitted brms models. Extends arviz.InferenceData with type hints for IDE autocomplete. Guarantees the presence of specific data groups returned by fit() . Attributes: Name Type Description posterior Dataset Posterior samples of model parameters posterior_predictive Dataset Posterior predictive samples (with observation noise) log_likelihood Dataset Log-likelihood values for each observation observed_data Dataset Original observed response data coords dict Coordinate mappings for dimensions dims dict Dimension specifications for variables See Also brmspy.brms.fit : Creates IDFit objects arviz.InferenceData : Base class documentation Examples: from brmspy import brms model = brms . fit ( \"y ~ x\" , data = df , chains = 4 ) # Type checking and autocomplete assert isinstance ( model . idata , IDFit ) print ( model . idata . posterior ) # IDE autocomplete works! IDEpred \u00b6 Bases: InferenceData Typed InferenceData for posterior_epred results. Contains expected values E[Y|X] without observation noise. Attributes: Name Type Description posterior Dataset Expected value samples (no observation noise) See Also brmspy.brms.posterior_epred : Creates IDEpred objects IDPredict \u00b6 Bases: InferenceData Typed InferenceData for posterior_predict results. Contains posterior predictive samples with observation noise. Attributes: Name Type Description posterior_predictive Dataset Posterior predictive samples (includes observation noise) See Also brmspy.brms.posterior_predict : Creates IDPredict objects IDLinpred \u00b6 Bases: InferenceData Typed InferenceData for posterior_linpred results. Contains linear predictor values (before applying link function). Attributes: Name Type Description predictions Dataset Linear predictor samples See Also brmspy.brms.posterior_linpred : Creates IDLinpred objects IDLogLik \u00b6 Bases: InferenceData Typed InferenceData for log_lik results. Contains log-likelihood values for model comparison. Attributes: Name Type Description log_likelihood Dataset Log-likelihood values for each observation See Also brmspy.brms.log_lik : Creates IDLogLik objects arviz.loo : LOO-CV using log-likelihood GenericResult dataclass \u00b6 Generic result container with arviz and R objects. Attributes: Name Type Description idata InferenceData arviz InferenceData object r ListVector R object from brms FitResult dataclass \u00b6 Result from fit() function. Attributes: Name Type Description idata InferenceData arviz InferenceData with posterior, posterior_predictive, log_likelihood, and observed_data groups r ListVector brmsfit R object from brms::brm() PosteriorEpredResult dataclass \u00b6 Result from posterior_epred() function. Attributes: Name Type Description idata InferenceData arviz InferenceData with expected values in 'posterior' group r ListVector R matrix from brms::posterior_epred() PosteriorPredictResult dataclass \u00b6 Result from posterior_predict() function. Attributes: Name Type Description idata InferenceData arviz InferenceData with predictions in 'posterior_predictive' group r ListVector R matrix from brms::posterior_predict() LogLikResult dataclass \u00b6 Result from log_lik() function. Attributes: Name Type Description idata IDLogLik arviz InferenceData with log-likelihood values r ListVector R matrix from brms::log_lik() See Also brmspy.brms.log_lik : Creates LogLikResult objects Examples: from brmspy import brms import arviz as az model = brms . fit ( \"y ~ x\" , data = df , chains = 4 ) loglik = brms . log_lik ( model ) # Use for model comparison loo = az . loo ( model . idata ) print ( loo ) PosteriorLinpredResult dataclass \u00b6 Result from posterior_linpred() function. Attributes: Name Type Description idata IDLinpred arviz InferenceData with linear predictor values r ListVector R matrix from brms::posterior_linpred() See Also brmspy.brms.posterior_linpred : Creates PosteriorLinpredResult objects Examples: from brmspy import brms model = brms . fit ( \"count ~ age\" , data = df , family = \"poisson\" , chains = 4 ) linpred = brms . posterior_linpred ( model ) # Linear predictor on log scale (for Poisson) print ( linpred . idata . predictions ) FormulaResult dataclass \u00b6 Result from formula() function. Attributes: Name Type Description r ListVector R brmsformula object dict Dict Python dictionary representation of formula See Also brmspy.brms.formula : Creates FormulaResult objects Examples: from brmspy import brms # Create formula with options f = brms . formula ( \"y ~ x\" , decomp = \"QR\" ) # Use in fit() model = brms . fit ( f , data = df , chains = 4 ) Functions \u00b6 prior ( prior , class_ = None , coef = None , group = None , dpar = None , resp = None , nlpar = None , lb = None , ub = None , ** kwargs ) \u00b6 Create a brms-style prior specification. This function mirrors the behavior of brms::prior_string() and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of prior_string() in brms. Parameters: Name Type Description Default prior str The prior definition as a string, exactly as brms expects it. Examples include :: \"normal(0, 1)\" \"student_t(3, 0, 1.5)\" \"exponential(2)\" \"lkj(2)\" required class_ str Parameter class (e.g. \"b\" , \"sd\" , \"Intercept\" ). This corresponds to class in brms. class cannot be used as a parameter in Python (reserved keyword), so class_ is used instead. None coef str Coefficient name for class-level effects. None group str Grouping variable for hierarchical/multilevel effects. None dpar str Distributional parameter (e.g. \"sigma\" or \"phi\" ). None resp str Response variable name for multivariate models. None nlpar str Nonlinear parameter name if using nonlinear formulas. None lb float Lower bound for truncated priors. None ub float Upper bound for truncated priors. None **kwargs Any Any additional keyword arguments supported by brms::prior_string() . These are forwarded unchanged. {} Returns: Type Description PriorSpec A typed prior specification object used by brmspy.fit() and brmspy.make_stancode() . Notes This function does not validate the prior expression string itself \u2014 validation occurs inside brms. Its purpose is to construct a structured, editor-friendly representation that seamlessly maps to rpy2 calls. Examples: Prior on the intercept :: p = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\") Prior on a coefficient :: p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\") Group-level (hierarchical) SD prior :: p = prior(\"exponential(2)\", class_=\"sd\", group=\"region\") Truncated prior :: p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0) Multiple priors passed to fit :: from brmspy import prior priors = [ prior(\"student_t(3, 0, 2)\", class_=\"b\", coef=\"zAge\"), prior(\"exponential(2)\", class_=\"sd\", group=\"patient\"), ] model = brms.fit(\"y ~ zAge + (1|patient)\", data=df, priors=priors)","title":"Types"},{"location":"api/types/#brmspy.types-classes","text":"","title":"Classes"},{"location":"api/types/#brmspy.types.PriorSpec","text":"Python representation of a brms prior specification. This dataclass provides a typed interface to brms::prior_string() arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the prior() factory function to create instances. Attributes: Name Type Description prior str Prior distribution as string (e.g., \"normal(0, 1)\", \"exponential(2)\") class_ ( str , optional ) Parameter class: \"b\" (fixed effects), \"sd\" (group SD), \"Intercept\", \"sigma\", \"cor\", etc. coef ( str , optional ) Specific coefficient name for class-level priors group ( str , optional ) Grouping variable for hierarchical effects dpar ( str , optional ) Distributional parameter (e.g., \"sigma\", \"phi\", \"zi\") resp ( str , optional ) Response variable for multivariate models nlpar ( str , optional ) Non-linear parameter name lb ( float , optional ) Lower bound for truncated priors ub ( float , optional ) Upper bound for truncated priors See Also prior : Factory function to create PriorSpec instances brms::prior_string : R documentation https://paulbuerkner.com/brms/reference/prior_string.html Examples: Create prior specifications (prefer using prior() function): from brmspy.types import PriorSpec # Fixed effect prior p1 = PriorSpec ( prior = \"normal(0, 1)\" , class_ = \"b\" ) # Group-level SD prior p2 = PriorSpec ( prior = \"exponential(2)\" , class_ = \"sd\" , group = \"patient\" ) # Coefficient-specific prior with bounds p3 = PriorSpec ( prior = \"normal(0, 1)\" , class_ = \"b\" , coef = \"age\" , lb = 0 # Truncated at zero )","title":"PriorSpec"},{"location":"api/types/#brmspy.types.PriorSpec-functions","text":"","title":"Functions"},{"location":"api/types/#brmspy.types.PriorSpec.to_brms_kwargs","text":"Convert PriorSpec to keyword arguments for brms::prior_string(). Maps Python dataclass fields to R function arguments, handling the class_ -> class parameter name conversion. Returns: Type Description dict Keyword arguments ready for brms::prior_string() Examples: from brmspy import prior p = prior ( \"normal(0, 1)\" , class_ = \"b\" , coef = \"age\" ) kwargs = p . to_brms_kwargs () print ( kwargs ) # {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}","title":"to_brms_kwargs"},{"location":"api/types/#brmspy.types.IDFit","text":"Bases: InferenceData Typed InferenceData for fitted brms models. Extends arviz.InferenceData with type hints for IDE autocomplete. Guarantees the presence of specific data groups returned by fit() . Attributes: Name Type Description posterior Dataset Posterior samples of model parameters posterior_predictive Dataset Posterior predictive samples (with observation noise) log_likelihood Dataset Log-likelihood values for each observation observed_data Dataset Original observed response data coords dict Coordinate mappings for dimensions dims dict Dimension specifications for variables See Also brmspy.brms.fit : Creates IDFit objects arviz.InferenceData : Base class documentation Examples: from brmspy import brms model = brms . fit ( \"y ~ x\" , data = df , chains = 4 ) # Type checking and autocomplete assert isinstance ( model . idata , IDFit ) print ( model . idata . posterior ) # IDE autocomplete works!","title":"IDFit"},{"location":"api/types/#brmspy.types.IDEpred","text":"Bases: InferenceData Typed InferenceData for posterior_epred results. Contains expected values E[Y|X] without observation noise. Attributes: Name Type Description posterior Dataset Expected value samples (no observation noise) See Also brmspy.brms.posterior_epred : Creates IDEpred objects","title":"IDEpred"},{"location":"api/types/#brmspy.types.IDPredict","text":"Bases: InferenceData Typed InferenceData for posterior_predict results. Contains posterior predictive samples with observation noise. Attributes: Name Type Description posterior_predictive Dataset Posterior predictive samples (includes observation noise) See Also brmspy.brms.posterior_predict : Creates IDPredict objects","title":"IDPredict"},{"location":"api/types/#brmspy.types.IDLinpred","text":"Bases: InferenceData Typed InferenceData for posterior_linpred results. Contains linear predictor values (before applying link function). Attributes: Name Type Description predictions Dataset Linear predictor samples See Also brmspy.brms.posterior_linpred : Creates IDLinpred objects","title":"IDLinpred"},{"location":"api/types/#brmspy.types.IDLogLik","text":"Bases: InferenceData Typed InferenceData for log_lik results. Contains log-likelihood values for model comparison. Attributes: Name Type Description log_likelihood Dataset Log-likelihood values for each observation See Also brmspy.brms.log_lik : Creates IDLogLik objects arviz.loo : LOO-CV using log-likelihood","title":"IDLogLik"},{"location":"api/types/#brmspy.types.GenericResult","text":"Generic result container with arviz and R objects. Attributes: Name Type Description idata InferenceData arviz InferenceData object r ListVector R object from brms","title":"GenericResult"},{"location":"api/types/#brmspy.types.FitResult","text":"Result from fit() function. Attributes: Name Type Description idata InferenceData arviz InferenceData with posterior, posterior_predictive, log_likelihood, and observed_data groups r ListVector brmsfit R object from brms::brm()","title":"FitResult"},{"location":"api/types/#brmspy.types.PosteriorEpredResult","text":"Result from posterior_epred() function. Attributes: Name Type Description idata InferenceData arviz InferenceData with expected values in 'posterior' group r ListVector R matrix from brms::posterior_epred()","title":"PosteriorEpredResult"},{"location":"api/types/#brmspy.types.PosteriorPredictResult","text":"Result from posterior_predict() function. Attributes: Name Type Description idata InferenceData arviz InferenceData with predictions in 'posterior_predictive' group r ListVector R matrix from brms::posterior_predict()","title":"PosteriorPredictResult"},{"location":"api/types/#brmspy.types.LogLikResult","text":"Result from log_lik() function. Attributes: Name Type Description idata IDLogLik arviz InferenceData with log-likelihood values r ListVector R matrix from brms::log_lik() See Also brmspy.brms.log_lik : Creates LogLikResult objects Examples: from brmspy import brms import arviz as az model = brms . fit ( \"y ~ x\" , data = df , chains = 4 ) loglik = brms . log_lik ( model ) # Use for model comparison loo = az . loo ( model . idata ) print ( loo )","title":"LogLikResult"},{"location":"api/types/#brmspy.types.PosteriorLinpredResult","text":"Result from posterior_linpred() function. Attributes: Name Type Description idata IDLinpred arviz InferenceData with linear predictor values r ListVector R matrix from brms::posterior_linpred() See Also brmspy.brms.posterior_linpred : Creates PosteriorLinpredResult objects Examples: from brmspy import brms model = brms . fit ( \"count ~ age\" , data = df , family = \"poisson\" , chains = 4 ) linpred = brms . posterior_linpred ( model ) # Linear predictor on log scale (for Poisson) print ( linpred . idata . predictions )","title":"PosteriorLinpredResult"},{"location":"api/types/#brmspy.types.FormulaResult","text":"Result from formula() function. Attributes: Name Type Description r ListVector R brmsformula object dict Dict Python dictionary representation of formula See Also brmspy.brms.formula : Creates FormulaResult objects Examples: from brmspy import brms # Create formula with options f = brms . formula ( \"y ~ x\" , decomp = \"QR\" ) # Use in fit() model = brms . fit ( f , data = df , chains = 4 )","title":"FormulaResult"},{"location":"api/types/#brmspy.types-functions","text":"","title":"Functions"},{"location":"api/types/#brmspy.types.prior","text":"Create a brms-style prior specification. This function mirrors the behavior of brms::prior_string() and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of prior_string() in brms. Parameters: Name Type Description Default prior str The prior definition as a string, exactly as brms expects it. Examples include :: \"normal(0, 1)\" \"student_t(3, 0, 1.5)\" \"exponential(2)\" \"lkj(2)\" required class_ str Parameter class (e.g. \"b\" , \"sd\" , \"Intercept\" ). This corresponds to class in brms. class cannot be used as a parameter in Python (reserved keyword), so class_ is used instead. None coef str Coefficient name for class-level effects. None group str Grouping variable for hierarchical/multilevel effects. None dpar str Distributional parameter (e.g. \"sigma\" or \"phi\" ). None resp str Response variable name for multivariate models. None nlpar str Nonlinear parameter name if using nonlinear formulas. None lb float Lower bound for truncated priors. None ub float Upper bound for truncated priors. None **kwargs Any Any additional keyword arguments supported by brms::prior_string() . These are forwarded unchanged. {} Returns: Type Description PriorSpec A typed prior specification object used by brmspy.fit() and brmspy.make_stancode() . Notes This function does not validate the prior expression string itself \u2014 validation occurs inside brms. Its purpose is to construct a structured, editor-friendly representation that seamlessly maps to rpy2 calls. Examples: Prior on the intercept :: p = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\") Prior on a coefficient :: p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\") Group-level (hierarchical) SD prior :: p = prior(\"exponential(2)\", class_=\"sd\", group=\"region\") Truncated prior :: p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0) Multiple priors passed to fit :: from brmspy import prior priors = [ prior(\"student_t(3, 0, 2)\", class_=\"b\", coef=\"zAge\"), prior(\"exponential(2)\", class_=\"sd\", group=\"patient\"), ] model = brms.fit(\"y ~ zAge + (1|patient)\", data=df, priors=priors)","title":"prior"},{"location":"binaries/build/","text":"Functions \u00b6 collect_runtime_metadata () \u00b6 Collect comprehensive R environment metadata for runtime bundle. Queries R via rpy2 to gather complete information about the current R installation, including R version, CmdStan installation, and full dependency closure of brms + cmdstanr with all package details. Returns: Type Description dict Metadata dictionary containing: - r_version : str - R version (e.g., \"4.3.1\") - cmdstan_path : str - Path to CmdStan installation - cmdstan_version : str - CmdStan version - packages : list of dict - Package information with fields: - Package : str - Package name - Version : str - Package version - LibPath : str - Installation library path - Priority : str - Package priority level Raises: Type Description RuntimeError If required R packages (jsonlite) cannot be installed If build-manifest.R script cannot be read Notes This function executes the build-manifest.R script which uses R's package dependency resolution to find the complete dependency closure. It ensures all transitive dependencies are included. Examples: metadata = collect_runtime_metadata () print ( f \"R version: { metadata [ 'r_version' ] } \" ) print ( f \"CmdStan: { metadata [ 'cmdstan_version' ] } \" ) print ( f \"Packages: { len ( metadata [ 'packages' ]) } \" ) # Check if brms is included pkg_names = [ p [ \"Package\" ] for p in metadata [ \"packages\" ]] assert \"brms\" in pkg_names stage_runtime_tree ( base_dir , metadata , runtime_version ) \u00b6 Create runtime directory structure and copy all required files. Builds the complete runtime directory tree by: 1. Creating fingerprint-specific directory structure 2. Copying all R packages to Rlib/ 3. Copying CmdStan installation to cmdstan/ 4. Generating manifest.json with checksums The resulting structure: base_dir/ {fingerprint}/ manifest.json Rlib/ {package1}/ {package2}/ ... cmdstan/ {cmdstan files} Parameters: Name Type Description Default base_dir Path Base directory for runtime tree required metadata dict Metadata from collect_runtime_metadata() containing: - packages : list - R package information - cmdstan_path : str - CmdStan location - r_version : str - cmdstan_version : str required runtime_version str Runtime schema version (e.g., \"0.1.0\") required Returns: Type Description Path Path to the runtime root directory (base_dir/fingerprint) Raises: Type Description RuntimeError If system_fingerprint() returns None If no package metadata provided If package directories don't exist If cmdstan_path doesn't exist Notes The fingerprint is determined by system_fingerprint() which includes: - OS (linux/macos/windows) - Architecture (x86_64/arm64) - R version (major.minor) The manifest.json includes a SHA256 hash for integrity verification. Examples: from pathlib import Path metadata = collect_runtime_metadata () base = Path ( \"./runtime_build\" ) runtime_root = stage_runtime_tree ( base , metadata , runtime_version = \"0.1.0\" ) print ( f \"Runtime staged at: { runtime_root } \" ) print ( f \"Manifest: { runtime_root / 'manifest.json' } \" ) print ( f \"R packages: { runtime_root / 'Rlib' } \" ) print ( f \"CmdStan: { runtime_root / 'cmdstan' } \" ) pack_runtime ( runtime_root , out_dir , runtime_version ) \u00b6 Create compressed tar archive from runtime directory. Packages the staged runtime directory into a distributable .tar.gz archive with standardized naming for platform/version identification. Archive naming format: brmspy-runtime-{runtime_version}-{fingerprint}.tar.gz For example: brmspy-runtime-0.1.0-linux-x86_64-r4.3.tar.gz Parameters: Name Type Description Default runtime_root Path Path to staged runtime directory (from stage_runtime_tree) required out_dir Path Output directory for archive file required runtime_version str Runtime schema version (e.g., \"0.1.0\") required Returns: Type Description Path Path to created .tar.gz archive file Notes The archive contains a top-level \"runtime/\" directory with all runtime files. This structure is expected by install_and_activate_runtime(). The fingerprint is extracted from runtime_root.name, which should match the fingerprint used in stage_runtime_tree(). Examples: from pathlib import Path runtime_root = Path ( \"./runtime_build/linux-x86_64-r4.3\" ) out_dir = Path ( \"./dist\" ) archive = pack_runtime ( runtime_root , out_dir , runtime_version = \"0.1.0\" ) print ( f \"Archive created: { archive } \" ) print ( f \"Size: { archive . stat () . st_size / 1024 / 1024 : .1f } MB\" ) main () \u00b6 CLI entry point for building brmspy prebuilt runtime bundles. Command-line tool that orchestrates the complete runtime build process: 1. Collect R environment metadata 2. Stage runtime directory tree 3. Pack into distributable archive Command-line Arguments --output-dir : str, default=\"runtime_build\" Directory where runtime tree and archive will be written --runtime-version : str, default=\"0.1.0\" Runtime schema version identifier (not pip version) Examples: Build with defaults: python -m brmspy.binaries.build Specify custom output directory and version: python -m brmspy.binaries.build --output-dir /tmp/runtime --runtime-version 0 .2.0 Notes Requires: - R with brms and cmdstanr installed - CmdStan compiled and configured - Write permissions to output directory The build process can take 5-10 minutes depending on the number of dependencies and disk speed. See Also collect_runtime_metadata : Gathers R environment info stage_runtime_tree : Creates runtime directory structure pack_runtime : Creates distributable archive","title":"Build"},{"location":"binaries/build/#brmspy.binaries.build-functions","text":"","title":"Functions"},{"location":"binaries/build/#brmspy.binaries.build.collect_runtime_metadata","text":"Collect comprehensive R environment metadata for runtime bundle. Queries R via rpy2 to gather complete information about the current R installation, including R version, CmdStan installation, and full dependency closure of brms + cmdstanr with all package details. Returns: Type Description dict Metadata dictionary containing: - r_version : str - R version (e.g., \"4.3.1\") - cmdstan_path : str - Path to CmdStan installation - cmdstan_version : str - CmdStan version - packages : list of dict - Package information with fields: - Package : str - Package name - Version : str - Package version - LibPath : str - Installation library path - Priority : str - Package priority level Raises: Type Description RuntimeError If required R packages (jsonlite) cannot be installed If build-manifest.R script cannot be read Notes This function executes the build-manifest.R script which uses R's package dependency resolution to find the complete dependency closure. It ensures all transitive dependencies are included. Examples: metadata = collect_runtime_metadata () print ( f \"R version: { metadata [ 'r_version' ] } \" ) print ( f \"CmdStan: { metadata [ 'cmdstan_version' ] } \" ) print ( f \"Packages: { len ( metadata [ 'packages' ]) } \" ) # Check if brms is included pkg_names = [ p [ \"Package\" ] for p in metadata [ \"packages\" ]] assert \"brms\" in pkg_names","title":"collect_runtime_metadata"},{"location":"binaries/build/#brmspy.binaries.build.stage_runtime_tree","text":"Create runtime directory structure and copy all required files. Builds the complete runtime directory tree by: 1. Creating fingerprint-specific directory structure 2. Copying all R packages to Rlib/ 3. Copying CmdStan installation to cmdstan/ 4. Generating manifest.json with checksums The resulting structure: base_dir/ {fingerprint}/ manifest.json Rlib/ {package1}/ {package2}/ ... cmdstan/ {cmdstan files} Parameters: Name Type Description Default base_dir Path Base directory for runtime tree required metadata dict Metadata from collect_runtime_metadata() containing: - packages : list - R package information - cmdstan_path : str - CmdStan location - r_version : str - cmdstan_version : str required runtime_version str Runtime schema version (e.g., \"0.1.0\") required Returns: Type Description Path Path to the runtime root directory (base_dir/fingerprint) Raises: Type Description RuntimeError If system_fingerprint() returns None If no package metadata provided If package directories don't exist If cmdstan_path doesn't exist Notes The fingerprint is determined by system_fingerprint() which includes: - OS (linux/macos/windows) - Architecture (x86_64/arm64) - R version (major.minor) The manifest.json includes a SHA256 hash for integrity verification. Examples: from pathlib import Path metadata = collect_runtime_metadata () base = Path ( \"./runtime_build\" ) runtime_root = stage_runtime_tree ( base , metadata , runtime_version = \"0.1.0\" ) print ( f \"Runtime staged at: { runtime_root } \" ) print ( f \"Manifest: { runtime_root / 'manifest.json' } \" ) print ( f \"R packages: { runtime_root / 'Rlib' } \" ) print ( f \"CmdStan: { runtime_root / 'cmdstan' } \" )","title":"stage_runtime_tree"},{"location":"binaries/build/#brmspy.binaries.build.pack_runtime","text":"Create compressed tar archive from runtime directory. Packages the staged runtime directory into a distributable .tar.gz archive with standardized naming for platform/version identification. Archive naming format: brmspy-runtime-{runtime_version}-{fingerprint}.tar.gz For example: brmspy-runtime-0.1.0-linux-x86_64-r4.3.tar.gz Parameters: Name Type Description Default runtime_root Path Path to staged runtime directory (from stage_runtime_tree) required out_dir Path Output directory for archive file required runtime_version str Runtime schema version (e.g., \"0.1.0\") required Returns: Type Description Path Path to created .tar.gz archive file Notes The archive contains a top-level \"runtime/\" directory with all runtime files. This structure is expected by install_and_activate_runtime(). The fingerprint is extracted from runtime_root.name, which should match the fingerprint used in stage_runtime_tree(). Examples: from pathlib import Path runtime_root = Path ( \"./runtime_build/linux-x86_64-r4.3\" ) out_dir = Path ( \"./dist\" ) archive = pack_runtime ( runtime_root , out_dir , runtime_version = \"0.1.0\" ) print ( f \"Archive created: { archive } \" ) print ( f \"Size: { archive . stat () . st_size / 1024 / 1024 : .1f } MB\" )","title":"pack_runtime"},{"location":"binaries/build/#brmspy.binaries.build.main","text":"CLI entry point for building brmspy prebuilt runtime bundles. Command-line tool that orchestrates the complete runtime build process: 1. Collect R environment metadata 2. Stage runtime directory tree 3. Pack into distributable archive Command-line Arguments --output-dir : str, default=\"runtime_build\" Directory where runtime tree and archive will be written --runtime-version : str, default=\"0.1.0\" Runtime schema version identifier (not pip version) Examples: Build with defaults: python -m brmspy.binaries.build Specify custom output directory and version: python -m brmspy.binaries.build --output-dir /tmp/runtime --runtime-version 0 .2.0 Notes Requires: - R with brms and cmdstanr installed - CmdStan compiled and configured - Write permissions to output directory The build process can take 5-10 minutes depending on the number of dependencies and disk speed. See Also collect_runtime_metadata : Gathers R environment info stage_runtime_tree : Creates runtime directory structure pack_runtime : Creates distributable archive","title":"main"},{"location":"binaries/env/","text":"Functions \u00b6 get_r_version_tuple () \u00b6 Get R version as tuple of integers. Queries the active R installation via rpy2 to retrieve version information. Returns None if R is not available or rpy2 cannot communicate with R. Returns: Type Description tuple of (int, int, int) or None (major, minor, patch) version numbers, or None if unavailable Examples: version = get_r_version_tuple () if version : major , minor , patch = version print ( f \"R { major } . { minor } . { patch } \" ) else : print ( \"R not available\" ) See Also r_available_and_supported : Check if R meets minimum requirements r_available_and_supported ( min_major = 4 , min_minor = 0 ) \u00b6 Check if R is available and meets minimum version requirements. Parameters: Name Type Description Default min_major int Minimum required R major version 4 min_minor int Minimum required R minor version 2 Returns: Type Description bool True if R is available and >= min_major.min_minor Examples: if r_available_and_supported (): print ( \"R 4.2+ is available\" ) # Check for R 4.3+ if r_available_and_supported ( min_major = 4 , min_minor = 3 ): print ( \"R 4.3+ is available\" ) See Also get_r_version_tuple : Get detailed R version extract_glibc_version ( ldd_output ) \u00b6 Parse glibc version from ldd command output. Extracts glibc version number from the output of ldd --version . Used on Linux to verify minimum glibc requirement for prebuilt binaries. Parameters: Name Type Description Default ldd_output str Output from ldd --version command required Returns: Type Description tuple of (int, int) or None (major, minor) version, or None if not found Examples: import subprocess out = subprocess . check_output ([ \"ldd\" , \"--version\" ], text = True ) version = extract_glibc_version ( out ) if version and version >= ( 2 , 27 ): print ( \"glibc 2.27+ available\" ) See Also linux_can_use_prebuilt : Uses this for Linux compatibility check parse_clang_version ( version_output ) \u00b6 Parse clang compiler version from command output. Extracts clang version number from the output of clang --version . Used on macOS to verify minimum compiler requirement. Parameters: Name Type Description Default version_output str Output from clang --version command required Returns: Type Description tuple of (int, int) or None (major, minor) version, or None if parsing fails Examples: import subprocess out = subprocess . check_output ([ \"clang\" , \"--version\" ], text = True ) version = parse_clang_version ( out ) if version and version >= ( 11 , 0 ): print ( \"clang 11+ available\" ) See Also macos_can_use_prebuilt : macOS compatibility check linux_can_use_prebuilt () \u00b6 Check if Linux system meets prebuilt binary requirements. Verifies that the Linux system has compatible toolchain versions required to use prebuilt brms runtime bundles. Checks glibc and g++ compiler versions. Returns: Type Description bool True if system meets all requirements: - glibc >= 2.27 (for binary compatibility) - g++ >= 9.0 (for C++17 Stan compilation) Notes Requirements for prebuilt Linux bundles: - glibc 2.27+: Ensures binary compatibility with precompiled Stan models - g++ 9+: Minimum compiler for C++17 features used by CmdStan Examples: from brmspy.binaries.env import linux_can_use_prebuilt if linux_can_use_prebuilt (): print ( \"System can use prebuilt Linux binaries\" ) else : print ( \"Must build from source\" ) See Also extract_glibc_version : Parse glibc version from ldd _parse_gxx_version : Parse g++ version toolchain_is_compatible : Master toolchain check for all platforms macos_can_use_prebuilt () \u00b6 Check if macOS system meets prebuilt binary requirements. Verifies that the macOS system has Xcode Command Line Tools and a compatible clang compiler version for using prebuilt brms bundles. Returns: Type Description bool True if system meets all requirements: - Xcode Command Line Tools installed - clang >= 11.0 (for C++17 Stan compilation) Notes Requirements for prebuilt macOS bundles: - Xcode CLT: Provides essential build tools and system headers - clang 11+: Minimum compiler for C++17 features used by CmdStan To install Xcode Command Line Tools: xcode-select --install Examples: from brmspy.binaries.env import macos_can_use_prebuilt if macos_can_use_prebuilt (): print ( \"System can use prebuilt macOS binaries\" ) else : print ( \"Install Xcode CLT or upgrade clang\" ) See Also parse_clang_version : Parse clang version from command output toolchain_is_compatible : Master toolchain check for all platforms windows_can_use_prebuilt () \u00b6 Check if Windows system meets prebuilt binary requirements. Verifies that the Windows system has Rtools with MinGW g++ compiler required for using prebuilt brms runtime bundles. Returns: Type Description bool True if system meets all requirements: - Rtools toolchain installed (MinGW g++ available) - g++ >= 9.0 (for C++17 Stan compilation) Notes Requirements for prebuilt Windows bundles: - Rtools 4.0+: Provides MinGW-w64 toolchain for Stan compilation - g++ 9+: Minimum compiler for C++17 features used by CmdStan Rtools can be downloaded from: https://cran.r-project.org/bin/windows/Rtools/ Examples: from brmspy.binaries.env import windows_can_use_prebuilt if windows_can_use_prebuilt (): print ( \"System can use prebuilt Windows binaries\" ) else : print ( \"Install Rtools 4.0+\" ) See Also parse_gxx_version : Parse g++ version from command output toolchain_is_compatible : Master toolchain check for all platforms supported_platform () \u00b6 Check if current platform is officially supported for prebuilt binaries. Validates that the operating system and architecture combination is one of the officially supported platforms for prebuilt brms bundles. Returns: Type Description bool True if platform is in the supported list Notes Currently supported platforms: - linux-x86_64: Linux on x86_64/AMD64 processors - macos-x86_64: macOS on Intel processors - macos-arm64: macOS on Apple Silicon (M1/M2/M3) - windows-x86_64: Windows on x86_64/AMD64 processors Unsupported combinations (e.g., linux-arm64, windows-arm64) will return False even if technically compatible. Examples: from brmspy.binaries.env import supported_platform if supported_platform(): print(\"Platform is supported for prebuilts\") # Further checks: toolchain, R version, etc. else: print(\"Platform not supported, must build from source\") See Also _normalized_os_arch : Get normalized platform identifiers can_use_prebuilt : Complete prebuilt eligibility check toolchain_is_compatible () \u00b6 Check if system toolchain is compatible with prebuilt binaries. Routes to the appropriate platform-specific toolchain verification function based on the detected operating system. Returns: Type Description bool True if system has compatible compiler toolchain for current OS Notes Platform-specific requirements: - Linux: glibc >= 2.27, g++ >= 9 - macOS: Xcode CLT installed, clang >= 11 - Windows: Rtools installed (MinGW g++ >= 9) This is a high-level check that delegates to OS-specific functions: - linux_can_use_prebuilt() for Linux - macos_can_use_prebuilt() for macOS - windows_can_use_prebuilt() for Windows Examples: from brmspy.binaries.env import toolchain_is_compatible if toolchain_is_compatible(): print(\"Toolchain is compatible\") else: print(\"Upgrade compiler or install build tools\") See Also linux_can_use_prebuilt : Linux toolchain check macos_can_use_prebuilt : macOS toolchain check windows_can_use_prebuilt : Windows toolchain check system_fingerprint () \u00b6 Generate system fingerprint for prebuilt bundle selection. Creates a unique identifier string combining OS, architecture, and R version to match against available prebuilt runtime bundles. Returns: Type Description str or None Fingerprint string in format '{os}-{arch}-r{major}.{minor}', or None if R version cannot be determined Notes The fingerprint format is: {os}-{arch}-r{major}.{minor} Example fingerprints: - 'linux-x86_64-r4.3' - 'macos-arm64-r4.4' - 'windows-x86_64-r4.2' This fingerprint is used to: 1. Select the correct prebuilt bundle for download 2. Verify bundle compatibility with current system 3. Cache bundles in system-specific directories Examples: from brmspy.binaries.env import system_fingerprint fp = system_fingerprint() if fp: print(f\"System fingerprint: {fp}\") # Use fingerprint to select bundle else: print(\"Cannot determine R version\") See Also _normalized_os_arch : Get OS and architecture get_r_version_tuple : Get R version prebuilt_available_for : Check bundle availability prebuilt_available_for ( fingerprint ) \u00b6 Check if prebuilt bundle exists for given system fingerprint. Verifies whether a prebuilt runtime bundle is available for the specified system fingerprint. Currently checks against a static set, but designed to support dynamic manifest/GitHub Releases lookup. Parameters: Name Type Description Default fingerprint str or None System fingerprint string (e.g., 'linux-x86_64-r4.3') from system_fingerprint() required Returns: Type Description bool True if prebuilt bundle exists for this fingerprint Notes The PREBUILT_FINGERPRINTS set contains all available bundle identifiers. This can be populated from: - Static manifest file in package - Remote JSON manifest from CDN/GitHub - GitHub Releases API Future enhancement: Dynamic manifest fetching to auto-discover new bundles without package updates. Examples: from brmspy.binaries.env import ( system_fingerprint, prebuilt_available_for ) fp = system_fingerprint() if fp and prebuilt_available_for(fp): print(f\"Prebuilt available for {fp}\") else: print(\"No prebuilt available, must build from source\") See Also system_fingerprint : Generate fingerprint for current system can_use_prebuilt : Complete eligibility check can_use_prebuilt () \u00b6 Master check for prebuilt binary eligibility. Comprehensive validation that system meets ALL requirements for using prebuilt brms runtime bundles. Acts as the primary gate for deciding whether to use prebuilts or build from source. Returns: Type Description bool True only if ALL conditions are met: - Platform is supported (OS-architecture combination) - R >= 4.2 is available and usable via rpy2 - System toolchain meets minimum requirements - Prebuilt bundle exists for this fingerprint (commented out) Notes This function performs checks in order of increasing cost: 1. supported_platform() : Quick OS/arch validation 2. r_available_and_supported() : Check R via rpy2 3. toolchain_is_compatible() : Verify compiler versions 4. prebuilt_available_for() : Check bundle availability (currently disabled) The prebuilt availability check is commented out to allow installation even when bundle registry is not yet populated. Examples: from brmspy.binaries.env import can_use_prebuilt if can_use_prebuilt (): print ( \"Using prebuilt binaries for fast installation\" ) # Proceed with prebuilt installation else : print ( \"Building from source\" ) # Proceed with source build # Diagnostic check with detailed feedback from brmspy.binaries.env import ( supported_platform , r_available_and_supported , toolchain_is_compatible , system_fingerprint , prebuilt_available_for ) print ( f \"Platform supported: { supported_platform () } \" ) print ( f \"R available: { r_available_and_supported () } \" ) print ( f \"Toolchain compatible: { toolchain_is_compatible () } \" ) fp = system_fingerprint () print ( f \"System fingerprint: { fp } \" ) print ( f \"Bundle available: { prebuilt_available_for ( fp ) } \" ) print ( f \"Can use prebuilt: { can_use_prebuilt () } \" ) See Also supported_platform : Check platform support r_available_and_supported : Check R availability toolchain_is_compatible : Check compiler compatibility system_fingerprint : Get system identifier prebuilt_available_for : Check bundle availability","title":"Env"},{"location":"binaries/env/#brmspy.binaries.env-functions","text":"","title":"Functions"},{"location":"binaries/env/#brmspy.binaries.env.get_r_version_tuple","text":"Get R version as tuple of integers. Queries the active R installation via rpy2 to retrieve version information. Returns None if R is not available or rpy2 cannot communicate with R. Returns: Type Description tuple of (int, int, int) or None (major, minor, patch) version numbers, or None if unavailable Examples: version = get_r_version_tuple () if version : major , minor , patch = version print ( f \"R { major } . { minor } . { patch } \" ) else : print ( \"R not available\" ) See Also r_available_and_supported : Check if R meets minimum requirements","title":"get_r_version_tuple"},{"location":"binaries/env/#brmspy.binaries.env.r_available_and_supported","text":"Check if R is available and meets minimum version requirements. Parameters: Name Type Description Default min_major int Minimum required R major version 4 min_minor int Minimum required R minor version 2 Returns: Type Description bool True if R is available and >= min_major.min_minor Examples: if r_available_and_supported (): print ( \"R 4.2+ is available\" ) # Check for R 4.3+ if r_available_and_supported ( min_major = 4 , min_minor = 3 ): print ( \"R 4.3+ is available\" ) See Also get_r_version_tuple : Get detailed R version","title":"r_available_and_supported"},{"location":"binaries/env/#brmspy.binaries.env.extract_glibc_version","text":"Parse glibc version from ldd command output. Extracts glibc version number from the output of ldd --version . Used on Linux to verify minimum glibc requirement for prebuilt binaries. Parameters: Name Type Description Default ldd_output str Output from ldd --version command required Returns: Type Description tuple of (int, int) or None (major, minor) version, or None if not found Examples: import subprocess out = subprocess . check_output ([ \"ldd\" , \"--version\" ], text = True ) version = extract_glibc_version ( out ) if version and version >= ( 2 , 27 ): print ( \"glibc 2.27+ available\" ) See Also linux_can_use_prebuilt : Uses this for Linux compatibility check","title":"extract_glibc_version"},{"location":"binaries/env/#brmspy.binaries.env.parse_clang_version","text":"Parse clang compiler version from command output. Extracts clang version number from the output of clang --version . Used on macOS to verify minimum compiler requirement. Parameters: Name Type Description Default version_output str Output from clang --version command required Returns: Type Description tuple of (int, int) or None (major, minor) version, or None if parsing fails Examples: import subprocess out = subprocess . check_output ([ \"clang\" , \"--version\" ], text = True ) version = parse_clang_version ( out ) if version and version >= ( 11 , 0 ): print ( \"clang 11+ available\" ) See Also macos_can_use_prebuilt : macOS compatibility check","title":"parse_clang_version"},{"location":"binaries/env/#brmspy.binaries.env.linux_can_use_prebuilt","text":"Check if Linux system meets prebuilt binary requirements. Verifies that the Linux system has compatible toolchain versions required to use prebuilt brms runtime bundles. Checks glibc and g++ compiler versions. Returns: Type Description bool True if system meets all requirements: - glibc >= 2.27 (for binary compatibility) - g++ >= 9.0 (for C++17 Stan compilation) Notes Requirements for prebuilt Linux bundles: - glibc 2.27+: Ensures binary compatibility with precompiled Stan models - g++ 9+: Minimum compiler for C++17 features used by CmdStan Examples: from brmspy.binaries.env import linux_can_use_prebuilt if linux_can_use_prebuilt (): print ( \"System can use prebuilt Linux binaries\" ) else : print ( \"Must build from source\" ) See Also extract_glibc_version : Parse glibc version from ldd _parse_gxx_version : Parse g++ version toolchain_is_compatible : Master toolchain check for all platforms","title":"linux_can_use_prebuilt"},{"location":"binaries/env/#brmspy.binaries.env.macos_can_use_prebuilt","text":"Check if macOS system meets prebuilt binary requirements. Verifies that the macOS system has Xcode Command Line Tools and a compatible clang compiler version for using prebuilt brms bundles. Returns: Type Description bool True if system meets all requirements: - Xcode Command Line Tools installed - clang >= 11.0 (for C++17 Stan compilation) Notes Requirements for prebuilt macOS bundles: - Xcode CLT: Provides essential build tools and system headers - clang 11+: Minimum compiler for C++17 features used by CmdStan To install Xcode Command Line Tools: xcode-select --install Examples: from brmspy.binaries.env import macos_can_use_prebuilt if macos_can_use_prebuilt (): print ( \"System can use prebuilt macOS binaries\" ) else : print ( \"Install Xcode CLT or upgrade clang\" ) See Also parse_clang_version : Parse clang version from command output toolchain_is_compatible : Master toolchain check for all platforms","title":"macos_can_use_prebuilt"},{"location":"binaries/env/#brmspy.binaries.env.windows_can_use_prebuilt","text":"Check if Windows system meets prebuilt binary requirements. Verifies that the Windows system has Rtools with MinGW g++ compiler required for using prebuilt brms runtime bundles. Returns: Type Description bool True if system meets all requirements: - Rtools toolchain installed (MinGW g++ available) - g++ >= 9.0 (for C++17 Stan compilation) Notes Requirements for prebuilt Windows bundles: - Rtools 4.0+: Provides MinGW-w64 toolchain for Stan compilation - g++ 9+: Minimum compiler for C++17 features used by CmdStan Rtools can be downloaded from: https://cran.r-project.org/bin/windows/Rtools/ Examples: from brmspy.binaries.env import windows_can_use_prebuilt if windows_can_use_prebuilt (): print ( \"System can use prebuilt Windows binaries\" ) else : print ( \"Install Rtools 4.0+\" ) See Also parse_gxx_version : Parse g++ version from command output toolchain_is_compatible : Master toolchain check for all platforms","title":"windows_can_use_prebuilt"},{"location":"binaries/env/#brmspy.binaries.env.supported_platform","text":"Check if current platform is officially supported for prebuilt binaries. Validates that the operating system and architecture combination is one of the officially supported platforms for prebuilt brms bundles. Returns: Type Description bool True if platform is in the supported list Notes Currently supported platforms: - linux-x86_64: Linux on x86_64/AMD64 processors - macos-x86_64: macOS on Intel processors - macos-arm64: macOS on Apple Silicon (M1/M2/M3) - windows-x86_64: Windows on x86_64/AMD64 processors Unsupported combinations (e.g., linux-arm64, windows-arm64) will return False even if technically compatible. Examples: from brmspy.binaries.env import supported_platform if supported_platform(): print(\"Platform is supported for prebuilts\") # Further checks: toolchain, R version, etc. else: print(\"Platform not supported, must build from source\") See Also _normalized_os_arch : Get normalized platform identifiers can_use_prebuilt : Complete prebuilt eligibility check","title":"supported_platform"},{"location":"binaries/env/#brmspy.binaries.env.toolchain_is_compatible","text":"Check if system toolchain is compatible with prebuilt binaries. Routes to the appropriate platform-specific toolchain verification function based on the detected operating system. Returns: Type Description bool True if system has compatible compiler toolchain for current OS Notes Platform-specific requirements: - Linux: glibc >= 2.27, g++ >= 9 - macOS: Xcode CLT installed, clang >= 11 - Windows: Rtools installed (MinGW g++ >= 9) This is a high-level check that delegates to OS-specific functions: - linux_can_use_prebuilt() for Linux - macos_can_use_prebuilt() for macOS - windows_can_use_prebuilt() for Windows Examples: from brmspy.binaries.env import toolchain_is_compatible if toolchain_is_compatible(): print(\"Toolchain is compatible\") else: print(\"Upgrade compiler or install build tools\") See Also linux_can_use_prebuilt : Linux toolchain check macos_can_use_prebuilt : macOS toolchain check windows_can_use_prebuilt : Windows toolchain check","title":"toolchain_is_compatible"},{"location":"binaries/env/#brmspy.binaries.env.system_fingerprint","text":"Generate system fingerprint for prebuilt bundle selection. Creates a unique identifier string combining OS, architecture, and R version to match against available prebuilt runtime bundles. Returns: Type Description str or None Fingerprint string in format '{os}-{arch}-r{major}.{minor}', or None if R version cannot be determined Notes The fingerprint format is: {os}-{arch}-r{major}.{minor} Example fingerprints: - 'linux-x86_64-r4.3' - 'macos-arm64-r4.4' - 'windows-x86_64-r4.2' This fingerprint is used to: 1. Select the correct prebuilt bundle for download 2. Verify bundle compatibility with current system 3. Cache bundles in system-specific directories Examples: from brmspy.binaries.env import system_fingerprint fp = system_fingerprint() if fp: print(f\"System fingerprint: {fp}\") # Use fingerprint to select bundle else: print(\"Cannot determine R version\") See Also _normalized_os_arch : Get OS and architecture get_r_version_tuple : Get R version prebuilt_available_for : Check bundle availability","title":"system_fingerprint"},{"location":"binaries/env/#brmspy.binaries.env.prebuilt_available_for","text":"Check if prebuilt bundle exists for given system fingerprint. Verifies whether a prebuilt runtime bundle is available for the specified system fingerprint. Currently checks against a static set, but designed to support dynamic manifest/GitHub Releases lookup. Parameters: Name Type Description Default fingerprint str or None System fingerprint string (e.g., 'linux-x86_64-r4.3') from system_fingerprint() required Returns: Type Description bool True if prebuilt bundle exists for this fingerprint Notes The PREBUILT_FINGERPRINTS set contains all available bundle identifiers. This can be populated from: - Static manifest file in package - Remote JSON manifest from CDN/GitHub - GitHub Releases API Future enhancement: Dynamic manifest fetching to auto-discover new bundles without package updates. Examples: from brmspy.binaries.env import ( system_fingerprint, prebuilt_available_for ) fp = system_fingerprint() if fp and prebuilt_available_for(fp): print(f\"Prebuilt available for {fp}\") else: print(\"No prebuilt available, must build from source\") See Also system_fingerprint : Generate fingerprint for current system can_use_prebuilt : Complete eligibility check","title":"prebuilt_available_for"},{"location":"binaries/env/#brmspy.binaries.env.can_use_prebuilt","text":"Master check for prebuilt binary eligibility. Comprehensive validation that system meets ALL requirements for using prebuilt brms runtime bundles. Acts as the primary gate for deciding whether to use prebuilts or build from source. Returns: Type Description bool True only if ALL conditions are met: - Platform is supported (OS-architecture combination) - R >= 4.2 is available and usable via rpy2 - System toolchain meets minimum requirements - Prebuilt bundle exists for this fingerprint (commented out) Notes This function performs checks in order of increasing cost: 1. supported_platform() : Quick OS/arch validation 2. r_available_and_supported() : Check R via rpy2 3. toolchain_is_compatible() : Verify compiler versions 4. prebuilt_available_for() : Check bundle availability (currently disabled) The prebuilt availability check is commented out to allow installation even when bundle registry is not yet populated. Examples: from brmspy.binaries.env import can_use_prebuilt if can_use_prebuilt (): print ( \"Using prebuilt binaries for fast installation\" ) # Proceed with prebuilt installation else : print ( \"Building from source\" ) # Proceed with source build # Diagnostic check with detailed feedback from brmspy.binaries.env import ( supported_platform , r_available_and_supported , toolchain_is_compatible , system_fingerprint , prebuilt_available_for ) print ( f \"Platform supported: { supported_platform () } \" ) print ( f \"R available: { r_available_and_supported () } \" ) print ( f \"Toolchain compatible: { toolchain_is_compatible () } \" ) fp = system_fingerprint () print ( f \"System fingerprint: { fp } \" ) print ( f \"Bundle available: { prebuilt_available_for ( fp ) } \" ) print ( f \"Can use prebuilt: { can_use_prebuilt () } \" ) See Also supported_platform : Check platform support r_available_and_supported : Check R availability toolchain_is_compatible : Check compiler compatibility system_fingerprint : Get system identifier prebuilt_available_for : Check bundle availability","title":"can_use_prebuilt"},{"location":"binaries/use/","text":"Functions \u00b6 activate_runtime ( runtime_root ) \u00b6 Activate a prebuilt brms runtime bundle in the current R session. Configures the embedded R session (via rpy2) to use libraries and CmdStan from a prebuilt runtime bundle. Updates R's library paths and sets cmdstanr's CmdStan path, then performs sanity checks. Parameters: Name Type Description Default runtime_root str or Path Path to runtime bundle root directory containing: - manifest.json: Bundle metadata and fingerprint - Rlib/: R package library with brms, cmdstanr, etc. - cmdstan/: CmdStan installation required Raises: Type Description RuntimeError If required directories/files are missing or validation fails Notes Important Limitations: This function reconfigures the running embedded R session but does NOT fully restart R (rpy2 cannot do that). For a truly clean environment: - Call this function BEFORE loading any R packages - Or restart the Python process after installation What this function does: Validates runtime bundle structure (manifest, Rlib, cmdstan directories) Optionally verifies system fingerprint matches bundle fingerprint Replaces R's .libPaths() with runtime Rlib directory Sets cmdstanr::set_cmdstan_path() to runtime cmdstan directory Performs sanity checks (brms and cmdstanr load successfully) Fingerprint Validation: If available, validates that the runtime bundle's fingerprint (from manifest.json) matches the current system fingerprint. This prevents incompatible bundles (e.g., Linux bundle on macOS) from being activated. Examples: from pathlib import Path from brmspy.binaries.use import activate_runtime # Activate a previously installed runtime runtime_path = Path . home () / \".brmspy\" / \"runtime\" / \"linux-x86_64-r4.3\" activate_runtime ( runtime_path ) # Now brms and cmdstanr use the prebuilt bundle from brmspy import fit result = fit ( \"y ~ x\" , data = { \"y\" : [ 1 , 2 , 3 ], \"x\" : [ 1 , 2 , 3 ]}) # Activate runtime before any R operations (recommended) import sys from brmspy.binaries.use import activate_runtime # Do this FIRST, before importing brmspy or using rpy2 activate_runtime ( \"/path/to/runtime\" ) # Now safe to use brmspy from brmspy import fit See Also install_and_activate_runtime : Download, install, and activate runtime brmspy.binaries.env.system_fingerprint : Get current system identifier install_and_activate_runtime ( url = None , bundle = None , runtime_version = '0.1.0' , base_dir = None , activate = True , expected_hash = None , require_attestation = True ) \u00b6 Download, install, and optionally activate a prebuilt brms runtime bundle. This is the high-level orchestration function. It: Resolves the source (URL \u2192 temp file, or local archive/dir) Determines the canonical runtime_root for this system+version Optionally reuses an existing runtime if the stored hash matches Installs from archive or directory into runtime_root Stores the expected hash (if provided) for fast future reuse Optionally activates the runtime in the current R session Parameters: Name Type Description Default url str URL to download runtime bundle archive (.tar.gz, .tar.bz2, etc.). Mutually exclusive with bundle . None bundle str or Path Local path to runtime bundle, either: - Archive file (.tar.gz, .tar.bz2, etc.) to extract, or - Directory containing an extracted runtime (with manifest.json). Mutually exclusive with url . None runtime_version str Logical runtime version used in the canonical runtime path {base_dir}/{system_fingerprint}-{runtime_version}. \"0.1.0\" base_dir str or Path Base directory for runtime installation. Default: ~/.brmspy/runtime/ None activate bool If True, call activate_runtime() after installation/reuse. True expected_hash str Attested hash (e.g. sha256 from GitHub release assets). If provided, the installer will: - Reuse an existing runtime only if its stored hash matches this value. - Store the hash into {runtime_root}/hash after (re)install. If NOT provided, but the binary is an official kaitumisuuringute-keskus/brmspy one, the expected_hash will be automatically fetched None require_attestation bool If True, expected_hash must be provided; otherwise a ValueError is raised. This lets callers enforce that only attested runtimes are used. True Returns: Type Description Path Path to the installed (or reused) runtime root directory.","title":"Use"},{"location":"binaries/use/#brmspy.binaries.use-functions","text":"","title":"Functions"},{"location":"binaries/use/#brmspy.binaries.use.activate_runtime","text":"Activate a prebuilt brms runtime bundle in the current R session. Configures the embedded R session (via rpy2) to use libraries and CmdStan from a prebuilt runtime bundle. Updates R's library paths and sets cmdstanr's CmdStan path, then performs sanity checks. Parameters: Name Type Description Default runtime_root str or Path Path to runtime bundle root directory containing: - manifest.json: Bundle metadata and fingerprint - Rlib/: R package library with brms, cmdstanr, etc. - cmdstan/: CmdStan installation required Raises: Type Description RuntimeError If required directories/files are missing or validation fails Notes Important Limitations: This function reconfigures the running embedded R session but does NOT fully restart R (rpy2 cannot do that). For a truly clean environment: - Call this function BEFORE loading any R packages - Or restart the Python process after installation What this function does: Validates runtime bundle structure (manifest, Rlib, cmdstan directories) Optionally verifies system fingerprint matches bundle fingerprint Replaces R's .libPaths() with runtime Rlib directory Sets cmdstanr::set_cmdstan_path() to runtime cmdstan directory Performs sanity checks (brms and cmdstanr load successfully) Fingerprint Validation: If available, validates that the runtime bundle's fingerprint (from manifest.json) matches the current system fingerprint. This prevents incompatible bundles (e.g., Linux bundle on macOS) from being activated. Examples: from pathlib import Path from brmspy.binaries.use import activate_runtime # Activate a previously installed runtime runtime_path = Path . home () / \".brmspy\" / \"runtime\" / \"linux-x86_64-r4.3\" activate_runtime ( runtime_path ) # Now brms and cmdstanr use the prebuilt bundle from brmspy import fit result = fit ( \"y ~ x\" , data = { \"y\" : [ 1 , 2 , 3 ], \"x\" : [ 1 , 2 , 3 ]}) # Activate runtime before any R operations (recommended) import sys from brmspy.binaries.use import activate_runtime # Do this FIRST, before importing brmspy or using rpy2 activate_runtime ( \"/path/to/runtime\" ) # Now safe to use brmspy from brmspy import fit See Also install_and_activate_runtime : Download, install, and activate runtime brmspy.binaries.env.system_fingerprint : Get current system identifier","title":"activate_runtime"},{"location":"binaries/use/#brmspy.binaries.use.install_and_activate_runtime","text":"Download, install, and optionally activate a prebuilt brms runtime bundle. This is the high-level orchestration function. It: Resolves the source (URL \u2192 temp file, or local archive/dir) Determines the canonical runtime_root for this system+version Optionally reuses an existing runtime if the stored hash matches Installs from archive or directory into runtime_root Stores the expected hash (if provided) for fast future reuse Optionally activates the runtime in the current R session Parameters: Name Type Description Default url str URL to download runtime bundle archive (.tar.gz, .tar.bz2, etc.). Mutually exclusive with bundle . None bundle str or Path Local path to runtime bundle, either: - Archive file (.tar.gz, .tar.bz2, etc.) to extract, or - Directory containing an extracted runtime (with manifest.json). Mutually exclusive with url . None runtime_version str Logical runtime version used in the canonical runtime path {base_dir}/{system_fingerprint}-{runtime_version}. \"0.1.0\" base_dir str or Path Base directory for runtime installation. Default: ~/.brmspy/runtime/ None activate bool If True, call activate_runtime() after installation/reuse. True expected_hash str Attested hash (e.g. sha256 from GitHub release assets). If provided, the installer will: - Reuse an existing runtime only if its stored hash matches this value. - Store the hash into {runtime_root}/hash after (re)install. If NOT provided, but the binary is an official kaitumisuuringute-keskus/brmspy one, the expected_hash will be automatically fetched None require_attestation bool If True, expected_hash must be provided; otherwise a ValueError is raised. This lets callers enforce that only attested runtimes are used. True Returns: Type Description Path Path to the installed (or reused) runtime root directory.","title":"install_and_activate_runtime"},{"location":"development/development/","text":"This guide covers the development infrastructure, build processes, and CI/CD architecture for brmspy. Quick Start \u00b6 Setup \u00b6 # Clone and setup git clone https://github.com/kaitumisuuringute-keskus/brmspy.git cd brmspy # Install with dev dependencies python -m venv .venv source .venv/bin/activate # or .venv\\Scripts\\activate on Windows pip install -e \".[all]\" # Install R dependencies python -c \"import brmspy; brmspy.install_brms()\" Project Architecture \u00b6 Directory Structure \u00b6 brmspy/ \u251c\u2500\u2500 brmspy/ # Main package \u2502 \u251c\u2500\u2500 brms.py # Core API (fit, predict, etc.) \u2502 \u251c\u2500\u2500 types.py # Type definitions \u2502 \u251c\u2500\u2500 install.py # R dependency installation \u2502 \u251c\u2500\u2500 binaries/ # Prebuilt runtime system \u2502 \u2502 \u251c\u2500\u2500 build.py # Create runtime bundles \u2502 \u2502 \u251c\u2500\u2500 env.py # Platform detection \u2502 \u2502 \u2514\u2500\u2500 use.py # Install runtimes \u2502 \u2514\u2500\u2500 helpers/ # Internal utilities \u2502 \u251c\u2500\u2500 conversion.py # Python \u2194 R \u2194 ArviZ \u2502 \u251c\u2500\u2500 priors.py # Prior builders \u2502 \u251c\u2500\u2500 rtools.py # Windows Rtools \u2502 \u2514\u2500\u2500 singleton.py # R package caching \u251c\u2500\u2500 .github/workflows/ # CI/CD pipelines \u251c\u2500\u2500 .runtime_builder/ # Docker for Linux builds \u251c\u2500\u2500 docs/ # mkdocs documentation \u2514\u2500\u2500 tests/ # Test suite Core Components \u00b6 brmspy/brms.py - High-level API for model fitting and predictions brmspy/types.py - Type definitions and result dataclasses brmspy/install.py - R dependency management brmspy/binaries/ - Prebuilt runtime bundle system brmspy/helpers/ - Internal conversion and utility functions Data Flow \u00b6 Python Code \u2193 brmspy.fit() [brms.py] \u2193 Type Conversions [helpers/conversion.py] \u2193 R brms via rpy2 \u2193 CmdStan MCMC Sampling \u2193 ArviZ InferenceData \u2193 Python Result Objects Runtime Binaries System \u00b6 The runtime system provides prebuilt bundles to skip lengthy R package compilation. System Fingerprint \u00b6 Each runtime is identified by: {os}-{arch}-r{major}.{minor} Examples: - linux-x86_64-r4.5 - darwin-arm64-r4.5 (macOS Apple Silicon) - windows-x86_64-r4.5 Components \u00b6 Platform Detection ( brmspy/binaries/env.py ): - Detect OS, architecture, R version - Generate system fingerprint - Check runtime compatibility Runtime Building ( brmspy/binaries/build.py ): - Bundle CmdStan binaries - Package R packages (cmdstanr, brms, posterior) - Include system libraries (Linux) - Create manifest with metadata Runtime Installation ( brmspy/binaries/use.py ): - Download from GitHub releases - Extract and activate runtime - Configure environment Bundle Structure \u00b6 brmspy-runtime-{fingerprint}-{version}.tar.gz \u251c\u2500\u2500 manifest.json # Metadata \u251c\u2500\u2500 cmdstan/ # Compiled CmdStan \u251c\u2500\u2500 Rlib # R libraries Usage \u00b6 import brmspy # Install prebuilt runtime (2-3 minutes vs 20-30 from source) brmspy . install_prebuilt ( version = \"0.1.0\" ) # Build custom runtime locally from brmspy.binaries.build import build_runtime_bundle build_runtime_bundle ( output_dir = \"dist/runtime\" ) CI/CD Pipelines \u00b6 All workflows in .github/workflows/ : 1. Python Test Matrix ( python-test-matrix.yml ) \u00b6 Trigger: Push/PR to master Purpose: Test Python 3.10, 3.12, 3.14 on Linux Workflow: 1. Build CmdStan once (cached) 2. Test matrix in parallel 3. Update coverage badge (3.12 only) Key Features: - Shared R/CmdStan cache - Parallel execution - Coverage reporting 2. R Dependencies Tests ( r-dependencies-tests.yml ) \u00b6 Trigger: Push/PR to master Purpose: Test on Linux, macOS, Windows Workflow: - Python 3.12 only - Tests marked with @pytest.mark.crossplatform - Fail-fast disabled 3. Documentation ( docs.yml ) \u00b6 Trigger: Push to master Purpose: Deploy docs to GitHub Pages Stack: - mkdocstrings for API docs - Auto-deploys to https://kaitumisuuringute-keskus.github.io/brmspy/ 4. PyPI Publish ( python-publish.yml ) \u00b6 Trigger: GitHub Release created Purpose: Publish to PyPI Workflow: 1. Run full test suite 2. Build: python -m build 3. Upload: twine upload dist/* Requirements: PYPI_USERNAME , PYPI_PASSWORD secrets 5. Runtime Publish ( runtime-publish.yml ) \u00b6 Trigger: Manual dispatch Purpose: Build prebuilt runtimes for all platforms Architecture: 1. Create GitHub Release (tag: runtime ) 2. Build runtimes in parallel (Linux in Docker, macOS/Windows native) 3. Upload to release with attestation Linux Build (Docker): - Pull : ghcr.io/.../brmspy-runtime-builder:ubuntu18-gcc9 - Install R 4.5.0 - Build runtime : python -m brmspy.binaries.build - Upload tarball macOS/Windows Build (Native): - Setup Python 3.12 + R 4.5 - Install dependencies - Build runtime - Upload tarball 6. Linux Runtime Builder ( build-linux-runtime-image.yml ) \u00b6 Trigger: Manual dispatch Purpose: Build Docker image for Linux runtime compilation Image: Ubuntu 18.04 + GCC 9 + Python 3.12 (for old glibc compatibility) Runtime Builder ( .runtime_builder/linux/ ) \u00b6 Dockerfile \u00b6 Creates build environment: - Base: Ubuntu 18.04 (glibc 2.27) - Toolchain: GCC 9, g++ 9, gfortran 9 - Python: 3.12.7 (compiled from source) - Dependencies: BLAS, LAPACK, V8, GLPK, graphics libs install_r.sh \u00b6 Smart R installation: 1. Try APT (fast) 2. Fallback to source compilation if version unavailable publish.sh \u00b6 Builds and pushes Docker image to GHCR: docker build -t ghcr.io/ { owner } /brmspy-runtime-builder: { tag } docker push ghcr.io/ { owner } /brmspy-runtime-builder: { tag } Testing \u00b6 Test Structure \u00b6 tests/ \u251c\u2500\u2500 conftest.py # Pytest fixtures \u251c\u2500\u2500 test_basic.py # Basic tests \u251c\u2500\u2500 test_integration.py # End-to-end tests \u251c\u2500\u2500 test_predictions.py # Prediction tests \u2514\u2500\u2500 test_crossplatform.py # Cross-platform tests Running Tests \u00b6 pytest tests/ -v # All tests pytest tests/ -v --cov = brmspy # With coverage pytest -m crossplatform # Cross-platform only pytest -n auto # Parallel (requires pytest-xdist) Test Markers \u00b6 @pytest . mark . crossplatform def test_basic_fit (): \"\"\"Runs on all platforms in CI\"\"\" pass Build and Release \u00b6 Version Management \u00b6 Update in: - pyproject.toml - settings.ini - brmspy/__init__.py Release Process \u00b6 Update versions and CHANGELOG.md Test: pytest Build: make build Create GitHub Release (tag: release-0... ) CI automatically tests and publishes to PyPI Building Runtimes \u00b6 Via GitHub Actions: 1. Go to Actions \u2192 runtime-publish 2. Run workflow with version and tag 3. Runtimes published to: releases/tag/runtime Locally: python -m brmspy.binaries.build --output-dir dist/runtime Documentation \u00b6 mkdocs Configuration \u00b6 File: mkdocs.yml site_name : brmspy theme : name : shadcn plugins : ... Docstring Style \u00b6 All docstrings use NumPy style with ```python code blocks (no .. code-block:: ): def example ( param : str ) -> dict : \"\"\" One-line summary. Detailed description. Parameters ---------- param : str Parameter description Returns ------- dict Return description Examples -------- Basic usage: ```python result = example(\"hello\") print(result) ``` \"\"\" return { \"param\" : param } Performance \u00b6 R Package Caching \u00b6 Singleton pattern in brmspy/helpers/singleton.py : from brmspy.helpers.singleton import get_r_package brms = get_r_package ( \"brms\" ) # First call: imports brms = get_r_package ( \"brms\" ) # Cached, instant Prebuilt Runtimes \u00b6 Method Installation Time From source 20-30 minutes Prebuilt runtime 20-60 seconds Troubleshooting \u00b6 R Package Installation Fails \u00b6 # Check R version (need 4.0+) R --version # Manual install R -e \"install.packages(c('cmdstanr', 'brms', 'posterior'))\" CmdStan Compilation Fails \u00b6 Linux: sudo apt-get install build-essential macOS: xcode-select --install Windows: import brmspy.helpers.rtools as rtools rtools . install_rtools () Runtime Incompatibility \u00b6 # Build local runtime from brmspy.binaries.build import build_runtime_bundle build_runtime_bundle ( output_dir = \"custom\" ) # Or install matching prebuilt brmspy . install_prebuilt () # Auto-detects platform Contributing \u00b6 Code Style \u00b6 Docstrings: NumPy style Type hints: Required for public APIs PR Process \u00b6 Fork and create feature branch Make changes and add tests Run: make format && make lint && make test Commit with conventional commits format Open PR with clear description Resources \u00b6 Documentation: https://kaitumisuuringute-keskus.github.io/brmspy/ Repository: https://github.com/kaitumisuuringute-keskus/brmspy Issues: https://github.com/kaitumisuuringute-keskus/brmspy/issues PyPI: https://pypi.org/project/brmspy/","title":"Development"},{"location":"development/development/#quick-start","text":"","title":"Quick Start"},{"location":"development/development/#setup","text":"# Clone and setup git clone https://github.com/kaitumisuuringute-keskus/brmspy.git cd brmspy # Install with dev dependencies python -m venv .venv source .venv/bin/activate # or .venv\\Scripts\\activate on Windows pip install -e \".[all]\" # Install R dependencies python -c \"import brmspy; brmspy.install_brms()\"","title":"Setup"},{"location":"development/development/#project-architecture","text":"","title":"Project Architecture"},{"location":"development/development/#directory-structure","text":"brmspy/ \u251c\u2500\u2500 brmspy/ # Main package \u2502 \u251c\u2500\u2500 brms.py # Core API (fit, predict, etc.) \u2502 \u251c\u2500\u2500 types.py # Type definitions \u2502 \u251c\u2500\u2500 install.py # R dependency installation \u2502 \u251c\u2500\u2500 binaries/ # Prebuilt runtime system \u2502 \u2502 \u251c\u2500\u2500 build.py # Create runtime bundles \u2502 \u2502 \u251c\u2500\u2500 env.py # Platform detection \u2502 \u2502 \u2514\u2500\u2500 use.py # Install runtimes \u2502 \u2514\u2500\u2500 helpers/ # Internal utilities \u2502 \u251c\u2500\u2500 conversion.py # Python \u2194 R \u2194 ArviZ \u2502 \u251c\u2500\u2500 priors.py # Prior builders \u2502 \u251c\u2500\u2500 rtools.py # Windows Rtools \u2502 \u2514\u2500\u2500 singleton.py # R package caching \u251c\u2500\u2500 .github/workflows/ # CI/CD pipelines \u251c\u2500\u2500 .runtime_builder/ # Docker for Linux builds \u251c\u2500\u2500 docs/ # mkdocs documentation \u2514\u2500\u2500 tests/ # Test suite","title":"Directory Structure"},{"location":"development/development/#core-components","text":"brmspy/brms.py - High-level API for model fitting and predictions brmspy/types.py - Type definitions and result dataclasses brmspy/install.py - R dependency management brmspy/binaries/ - Prebuilt runtime bundle system brmspy/helpers/ - Internal conversion and utility functions","title":"Core Components"},{"location":"development/development/#data-flow","text":"Python Code \u2193 brmspy.fit() [brms.py] \u2193 Type Conversions [helpers/conversion.py] \u2193 R brms via rpy2 \u2193 CmdStan MCMC Sampling \u2193 ArviZ InferenceData \u2193 Python Result Objects","title":"Data Flow"},{"location":"development/development/#runtime-binaries-system","text":"The runtime system provides prebuilt bundles to skip lengthy R package compilation.","title":"Runtime Binaries System"},{"location":"development/development/#system-fingerprint","text":"Each runtime is identified by: {os}-{arch}-r{major}.{minor} Examples: - linux-x86_64-r4.5 - darwin-arm64-r4.5 (macOS Apple Silicon) - windows-x86_64-r4.5","title":"System Fingerprint"},{"location":"development/development/#components","text":"Platform Detection ( brmspy/binaries/env.py ): - Detect OS, architecture, R version - Generate system fingerprint - Check runtime compatibility Runtime Building ( brmspy/binaries/build.py ): - Bundle CmdStan binaries - Package R packages (cmdstanr, brms, posterior) - Include system libraries (Linux) - Create manifest with metadata Runtime Installation ( brmspy/binaries/use.py ): - Download from GitHub releases - Extract and activate runtime - Configure environment","title":"Components"},{"location":"development/development/#bundle-structure","text":"brmspy-runtime-{fingerprint}-{version}.tar.gz \u251c\u2500\u2500 manifest.json # Metadata \u251c\u2500\u2500 cmdstan/ # Compiled CmdStan \u251c\u2500\u2500 Rlib # R libraries","title":"Bundle Structure"},{"location":"development/development/#usage","text":"import brmspy # Install prebuilt runtime (2-3 minutes vs 20-30 from source) brmspy . install_prebuilt ( version = \"0.1.0\" ) # Build custom runtime locally from brmspy.binaries.build import build_runtime_bundle build_runtime_bundle ( output_dir = \"dist/runtime\" )","title":"Usage"},{"location":"development/development/#cicd-pipelines","text":"All workflows in .github/workflows/ :","title":"CI/CD Pipelines"},{"location":"development/development/#1-python-test-matrix-python-test-matrixyml","text":"Trigger: Push/PR to master Purpose: Test Python 3.10, 3.12, 3.14 on Linux Workflow: 1. Build CmdStan once (cached) 2. Test matrix in parallel 3. Update coverage badge (3.12 only) Key Features: - Shared R/CmdStan cache - Parallel execution - Coverage reporting","title":"1. Python Test Matrix (python-test-matrix.yml)"},{"location":"development/development/#2-r-dependencies-tests-r-dependencies-testsyml","text":"Trigger: Push/PR to master Purpose: Test on Linux, macOS, Windows Workflow: - Python 3.12 only - Tests marked with @pytest.mark.crossplatform - Fail-fast disabled","title":"2. R Dependencies Tests (r-dependencies-tests.yml)"},{"location":"development/development/#3-documentation-docsyml","text":"Trigger: Push to master Purpose: Deploy docs to GitHub Pages Stack: - mkdocstrings for API docs - Auto-deploys to https://kaitumisuuringute-keskus.github.io/brmspy/","title":"3. Documentation (docs.yml)"},{"location":"development/development/#4-pypi-publish-python-publishyml","text":"Trigger: GitHub Release created Purpose: Publish to PyPI Workflow: 1. Run full test suite 2. Build: python -m build 3. Upload: twine upload dist/* Requirements: PYPI_USERNAME , PYPI_PASSWORD secrets","title":"4. PyPI Publish (python-publish.yml)"},{"location":"development/development/#5-runtime-publish-runtime-publishyml","text":"Trigger: Manual dispatch Purpose: Build prebuilt runtimes for all platforms Architecture: 1. Create GitHub Release (tag: runtime ) 2. Build runtimes in parallel (Linux in Docker, macOS/Windows native) 3. Upload to release with attestation Linux Build (Docker): - Pull : ghcr.io/.../brmspy-runtime-builder:ubuntu18-gcc9 - Install R 4.5.0 - Build runtime : python -m brmspy.binaries.build - Upload tarball macOS/Windows Build (Native): - Setup Python 3.12 + R 4.5 - Install dependencies - Build runtime - Upload tarball","title":"5. Runtime Publish (runtime-publish.yml)"},{"location":"development/development/#6-linux-runtime-builder-build-linux-runtime-imageyml","text":"Trigger: Manual dispatch Purpose: Build Docker image for Linux runtime compilation Image: Ubuntu 18.04 + GCC 9 + Python 3.12 (for old glibc compatibility)","title":"6. Linux Runtime Builder (build-linux-runtime-image.yml)"},{"location":"development/development/#runtime-builder-runtime_builderlinux","text":"","title":"Runtime Builder (.runtime_builder/linux/)"},{"location":"development/development/#dockerfile","text":"Creates build environment: - Base: Ubuntu 18.04 (glibc 2.27) - Toolchain: GCC 9, g++ 9, gfortran 9 - Python: 3.12.7 (compiled from source) - Dependencies: BLAS, LAPACK, V8, GLPK, graphics libs","title":"Dockerfile"},{"location":"development/development/#install_rsh","text":"Smart R installation: 1. Try APT (fast) 2. Fallback to source compilation if version unavailable","title":"install_r.sh"},{"location":"development/development/#publishsh","text":"Builds and pushes Docker image to GHCR: docker build -t ghcr.io/ { owner } /brmspy-runtime-builder: { tag } docker push ghcr.io/ { owner } /brmspy-runtime-builder: { tag }","title":"publish.sh"},{"location":"development/development/#testing","text":"","title":"Testing"},{"location":"development/development/#test-structure","text":"tests/ \u251c\u2500\u2500 conftest.py # Pytest fixtures \u251c\u2500\u2500 test_basic.py # Basic tests \u251c\u2500\u2500 test_integration.py # End-to-end tests \u251c\u2500\u2500 test_predictions.py # Prediction tests \u2514\u2500\u2500 test_crossplatform.py # Cross-platform tests","title":"Test Structure"},{"location":"development/development/#running-tests","text":"pytest tests/ -v # All tests pytest tests/ -v --cov = brmspy # With coverage pytest -m crossplatform # Cross-platform only pytest -n auto # Parallel (requires pytest-xdist)","title":"Running Tests"},{"location":"development/development/#test-markers","text":"@pytest . mark . crossplatform def test_basic_fit (): \"\"\"Runs on all platforms in CI\"\"\" pass","title":"Test Markers"},{"location":"development/development/#build-and-release","text":"","title":"Build and Release"},{"location":"development/development/#version-management","text":"Update in: - pyproject.toml - settings.ini - brmspy/__init__.py","title":"Version Management"},{"location":"development/development/#release-process","text":"Update versions and CHANGELOG.md Test: pytest Build: make build Create GitHub Release (tag: release-0... ) CI automatically tests and publishes to PyPI","title":"Release Process"},{"location":"development/development/#building-runtimes","text":"Via GitHub Actions: 1. Go to Actions \u2192 runtime-publish 2. Run workflow with version and tag 3. Runtimes published to: releases/tag/runtime Locally: python -m brmspy.binaries.build --output-dir dist/runtime","title":"Building Runtimes"},{"location":"development/development/#documentation","text":"","title":"Documentation"},{"location":"development/development/#mkdocs-configuration","text":"File: mkdocs.yml site_name : brmspy theme : name : shadcn plugins : ...","title":"mkdocs Configuration"},{"location":"development/development/#docstring-style","text":"All docstrings use NumPy style with ```python code blocks (no .. code-block:: ): def example ( param : str ) -> dict : \"\"\" One-line summary. Detailed description. Parameters ---------- param : str Parameter description Returns ------- dict Return description Examples -------- Basic usage: ```python result = example(\"hello\") print(result) ``` \"\"\" return { \"param\" : param }","title":"Docstring Style"},{"location":"development/development/#performance","text":"","title":"Performance"},{"location":"development/development/#r-package-caching","text":"Singleton pattern in brmspy/helpers/singleton.py : from brmspy.helpers.singleton import get_r_package brms = get_r_package ( \"brms\" ) # First call: imports brms = get_r_package ( \"brms\" ) # Cached, instant","title":"R Package Caching"},{"location":"development/development/#prebuilt-runtimes","text":"Method Installation Time From source 20-30 minutes Prebuilt runtime 20-60 seconds","title":"Prebuilt Runtimes"},{"location":"development/development/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"development/development/#r-package-installation-fails","text":"# Check R version (need 4.0+) R --version # Manual install R -e \"install.packages(c('cmdstanr', 'brms', 'posterior'))\"","title":"R Package Installation Fails"},{"location":"development/development/#cmdstan-compilation-fails","text":"Linux: sudo apt-get install build-essential macOS: xcode-select --install Windows: import brmspy.helpers.rtools as rtools rtools . install_rtools ()","title":"CmdStan Compilation Fails"},{"location":"development/development/#runtime-incompatibility","text":"# Build local runtime from brmspy.binaries.build import build_runtime_bundle build_runtime_bundle ( output_dir = \"custom\" ) # Or install matching prebuilt brmspy . install_prebuilt () # Auto-detects platform","title":"Runtime Incompatibility"},{"location":"development/development/#contributing","text":"","title":"Contributing"},{"location":"development/development/#code-style","text":"Docstrings: NumPy style Type hints: Required for public APIs","title":"Code Style"},{"location":"development/development/#pr-process","text":"Fork and create feature branch Make changes and add tests Run: make format && make lint && make test Commit with conventional commits format Open PR with clear description","title":"PR Process"},{"location":"development/development/#resources","text":"Documentation: https://kaitumisuuringute-keskus.github.io/brmspy/ Repository: https://github.com/kaitumisuuringute-keskus/brmspy Issues: https://github.com/kaitumisuuringute-keskus/brmspy/issues PyPI: https://pypi.org/project/brmspy/","title":"Resources"},{"location":"examples/advanced/","text":"Custom Sampling Parameters \u00b6 from brmspy import brms model = brms . fit ( formula = \"y ~ x + (1|group)\" , data = data , iter = 2000 , # Total iterations per chain warmup = 1000 , # Warmup iterations chains = 4 , # Number of chains cores = 4 , # Parallel cores thin = 1 , # Thinning seed = 123 , # Random seed control = { 'adapt_delta' : 0.95 } # Stan control parameters ) Multiple Prediction Types \u00b6 # Expected value (without observation noise) epred = brms . posterior_epred ( model , newdata = new_data ) # Posterior predictive (with observation noise) ypred = brms . posterior_predict ( model , newdata = new_data ) # Linear predictor linpred = brms . posterior_linpred ( model , newdata = new_data ) # Log likelihood loglik = brms . log_lik ( model , newdata = new_data ) Dual Python-R Workflow \u00b6 import arviz as az import rpy2.robjects as ro model = brms . fit ( formula = \"count ~ zAge + (1|patient)\" , data = data , family = \"poisson\" ) # Python analysis az . summary ( model . idata ) az . plot_trace ( model . idata ) # R analysis (if needed) ro . r ( 'summary' )( model . r ) ro . r ( 'plot' )( model . r ) ro . r ( 'loo' )( model . r ) # Leave-one-out cross-validation Different Families \u00b6 Gaussian (default) \u00b6 model = brms . fit ( formula = \"y ~ x\" , data = data , family = \"gaussian\" ) Poisson (count data) \u00b6 model = brms . fit ( formula = \"count ~ treatment + (1|subject)\" , data = data , family = \"poisson\" ) Binomial (binary outcomes) \u00b6 model = brms . fit ( formula = \"success | trials(n) ~ x\" , data = data , family = \"binomial\" ) Student-t (robust to outliers) \u00b6 model = brms . fit ( formula = \"y ~ x\" , data = data , family = \"student\" ) Complex Random Effects \u00b6 Nested Random Effects \u00b6 model = brms . fit ( formula = \"y ~ x + (1|country/region/city)\" , data = data ) Random Slopes \u00b6 model = brms . fit ( formula = \"y ~ x + (x|subject)\" , data = data ) Correlated Random Effects \u00b6 model = brms . fit ( formula = \"y ~ x + (x + z|subject)\" , data = data ) Working with Results \u00b6 Extract Posterior Samples \u00b6 # Get posterior as xarray Dataset posterior = model . idata . posterior # Extract specific parameter b_intercept = posterior [ 'b_Intercept' ] . values # Extract all coefficients coefficients = { var : posterior [ var ] . values for var in posterior . data_vars if var . startswith ( 'b_' ) } Model Comparison \u00b6 import arviz as az model1 = brms . fit ( formula = \"y ~ x\" , data = data ) model2 = brms . fit ( formula = \"y ~ x + z\" , data = data ) # Compare models comparison = az . compare ({ 'model1' : model1 . idata , 'model2' : model2 . idata }) print ( comparison ) Debugging \u00b6 Check Stan Code \u00b6 stan_code = brms . make_stancode ( formula = \"count ~ zAge + (1|patient)\" , data = data , priors = [], family = \"poisson\" ) print ( stan_code ) Compile Without Sampling \u00b6 ```python Just compile the model \u00b6 model = brms.fit( formula=\"y ~ x\", data=data, sample=False # Don't sample, just compile )","title":"Advanced Usage"},{"location":"examples/advanced/#custom-sampling-parameters","text":"from brmspy import brms model = brms . fit ( formula = \"y ~ x + (1|group)\" , data = data , iter = 2000 , # Total iterations per chain warmup = 1000 , # Warmup iterations chains = 4 , # Number of chains cores = 4 , # Parallel cores thin = 1 , # Thinning seed = 123 , # Random seed control = { 'adapt_delta' : 0.95 } # Stan control parameters )","title":"Custom Sampling Parameters"},{"location":"examples/advanced/#multiple-prediction-types","text":"# Expected value (without observation noise) epred = brms . posterior_epred ( model , newdata = new_data ) # Posterior predictive (with observation noise) ypred = brms . posterior_predict ( model , newdata = new_data ) # Linear predictor linpred = brms . posterior_linpred ( model , newdata = new_data ) # Log likelihood loglik = brms . log_lik ( model , newdata = new_data )","title":"Multiple Prediction Types"},{"location":"examples/advanced/#dual-python-r-workflow","text":"import arviz as az import rpy2.robjects as ro model = brms . fit ( formula = \"count ~ zAge + (1|patient)\" , data = data , family = \"poisson\" ) # Python analysis az . summary ( model . idata ) az . plot_trace ( model . idata ) # R analysis (if needed) ro . r ( 'summary' )( model . r ) ro . r ( 'plot' )( model . r ) ro . r ( 'loo' )( model . r ) # Leave-one-out cross-validation","title":"Dual Python-R Workflow"},{"location":"examples/advanced/#different-families","text":"","title":"Different Families"},{"location":"examples/advanced/#gaussian-default","text":"model = brms . fit ( formula = \"y ~ x\" , data = data , family = \"gaussian\" )","title":"Gaussian (default)"},{"location":"examples/advanced/#poisson-count-data","text":"model = brms . fit ( formula = \"count ~ treatment + (1|subject)\" , data = data , family = \"poisson\" )","title":"Poisson (count data)"},{"location":"examples/advanced/#binomial-binary-outcomes","text":"model = brms . fit ( formula = \"success | trials(n) ~ x\" , data = data , family = \"binomial\" )","title":"Binomial (binary outcomes)"},{"location":"examples/advanced/#student-t-robust-to-outliers","text":"model = brms . fit ( formula = \"y ~ x\" , data = data , family = \"student\" )","title":"Student-t (robust to outliers)"},{"location":"examples/advanced/#complex-random-effects","text":"","title":"Complex Random Effects"},{"location":"examples/advanced/#nested-random-effects","text":"model = brms . fit ( formula = \"y ~ x + (1|country/region/city)\" , data = data )","title":"Nested Random Effects"},{"location":"examples/advanced/#random-slopes","text":"model = brms . fit ( formula = \"y ~ x + (x|subject)\" , data = data )","title":"Random Slopes"},{"location":"examples/advanced/#correlated-random-effects","text":"model = brms . fit ( formula = \"y ~ x + (x + z|subject)\" , data = data )","title":"Correlated Random Effects"},{"location":"examples/advanced/#working-with-results","text":"","title":"Working with Results"},{"location":"examples/advanced/#extract-posterior-samples","text":"# Get posterior as xarray Dataset posterior = model . idata . posterior # Extract specific parameter b_intercept = posterior [ 'b_Intercept' ] . values # Extract all coefficients coefficients = { var : posterior [ var ] . values for var in posterior . data_vars if var . startswith ( 'b_' ) }","title":"Extract Posterior Samples"},{"location":"examples/advanced/#model-comparison","text":"import arviz as az model1 = brms . fit ( formula = \"y ~ x\" , data = data ) model2 = brms . fit ( formula = \"y ~ x + z\" , data = data ) # Compare models comparison = az . compare ({ 'model1' : model1 . idata , 'model2' : model2 . idata }) print ( comparison )","title":"Model Comparison"},{"location":"examples/advanced/#debugging","text":"","title":"Debugging"},{"location":"examples/advanced/#check-stan-code","text":"stan_code = brms . make_stancode ( formula = \"count ~ zAge + (1|patient)\" , data = data , priors = [], family = \"poisson\" ) print ( stan_code )","title":"Check Stan Code"},{"location":"examples/advanced/#compile-without-sampling","text":"```python","title":"Compile Without Sampling"},{"location":"examples/advanced/#just-compile-the-model","text":"model = brms.fit( formula=\"y ~ x\", data=data, sample=False # Don't sample, just compile )","title":"Just compile the model"},{"location":"examples/quickstart/","text":"Installation \u00b6 pip install brmspy First Time Setup \u00b6 Install brms and CmdStan: from brmspy import brms brms . install_brms () Basic Model \u00b6 from brmspy import brms , prior import arviz as az # Load example data epilepsy = brms . get_brms_data ( \"epilepsy\" ) # Fit model model = brms . fit ( formula = \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , family = \"poisson\" , priors = [ prior ( \"normal(0, 1)\" , \"b\" ), prior ( \"exponential(1)\" , \"sd\" , group = \"patient\" ), prior ( \"student_t(3, 0, 2.5)\" , \"Intercept\" ) ], chains = 4 , iter = 2000 ) # Analyze with arviz az . summary ( model . idata ) az . plot_posterior ( model . idata ) With Priors \u00b6 from brmspy import prior model = brms . fit ( formula = \"count ~ zAge + (1|patient)\" , data = epilepsy , family = \"poisson\" , priors = [ prior ( \"normal(0, 0.5)\" , class_ = \"b\" ), prior ( \"cauchy(0, 1)\" , class_ = \"sd\" ) ], chains = 4 ) Model Summary \u00b6 from brmspy import summary # Get summary as DataFrame summary_df = summary ( model ) print ( summary_df ) Predictions \u00b6 import pandas as pd # New data for predictions new_data = pd . DataFrame ({ 'zAge' : [ 0 , 0.5 , 1.0 ], 'zBase' : [ 0 , 0 , 0 ], 'Trt' : [ 0 , 0 , 0 ], 'patient' : [ 1 , 1 , 1 ] }) # Expected value predictions epred = brms . posterior_epred ( model , newdata = new_data ) # Posterior predictive samples ypred = brms . posterior_predict ( model , newdata = new_data ) Access R Object \u00b6 If you need direct R functionality: ```python import rpy2.robjects as ro Access R brmsfit object \u00b6 ro.r('summary')(model.r) ro.r('plot')(model.r)","title":"Quick Start"},{"location":"examples/quickstart/#installation","text":"pip install brmspy","title":"Installation"},{"location":"examples/quickstart/#first-time-setup","text":"Install brms and CmdStan: from brmspy import brms brms . install_brms ()","title":"First Time Setup"},{"location":"examples/quickstart/#basic-model","text":"from brmspy import brms , prior import arviz as az # Load example data epilepsy = brms . get_brms_data ( \"epilepsy\" ) # Fit model model = brms . fit ( formula = \"count ~ zAge + zBase * Trt + (1|patient)\" , data = epilepsy , family = \"poisson\" , priors = [ prior ( \"normal(0, 1)\" , \"b\" ), prior ( \"exponential(1)\" , \"sd\" , group = \"patient\" ), prior ( \"student_t(3, 0, 2.5)\" , \"Intercept\" ) ], chains = 4 , iter = 2000 ) # Analyze with arviz az . summary ( model . idata ) az . plot_posterior ( model . idata )","title":"Basic Model"},{"location":"examples/quickstart/#with-priors","text":"from brmspy import prior model = brms . fit ( formula = \"count ~ zAge + (1|patient)\" , data = epilepsy , family = \"poisson\" , priors = [ prior ( \"normal(0, 0.5)\" , class_ = \"b\" ), prior ( \"cauchy(0, 1)\" , class_ = \"sd\" ) ], chains = 4 )","title":"With Priors"},{"location":"examples/quickstart/#model-summary","text":"from brmspy import summary # Get summary as DataFrame summary_df = summary ( model ) print ( summary_df )","title":"Model Summary"},{"location":"examples/quickstart/#predictions","text":"import pandas as pd # New data for predictions new_data = pd . DataFrame ({ 'zAge' : [ 0 , 0.5 , 1.0 ], 'zBase' : [ 0 , 0 , 0 ], 'Trt' : [ 0 , 0 , 0 ], 'patient' : [ 1 , 1 , 1 ] }) # Expected value predictions epred = brms . posterior_epred ( model , newdata = new_data ) # Posterior predictive samples ypred = brms . posterior_predict ( model , newdata = new_data )","title":"Predictions"},{"location":"examples/quickstart/#access-r-object","text":"If you need direct R functionality: ```python import rpy2.robjects as ro","title":"Access R Object"},{"location":"examples/quickstart/#access-r-brmsfit-object","text":"ro.r('summary')(model.r) ro.r('plot')(model.r)","title":"Access R brmsfit object"},{"location":"helpers/conversion/","text":"Classes \u00b6 Functions \u00b6 brmsfit_to_idata ( brmsfit_obj , model_data = None ) \u00b6 Convert brmsfit R object to ArviZ InferenceData format. Comprehensive conversion that extracts all MCMC diagnostics, predictions, and observed data from a brms fitted model into ArviZ's InferenceData format. Handles proper chain/draw indexing and coordinates for ArviZ compatibility. Parameters: Name Type Description Default brmsfit_obj rpy2 R object (brmsfit) Fitted Bayesian model from R's brms::brm() function required model_data dict or DataFrame Additional model data (currently unused, reserved for future use) None Returns: Type Description InferenceData Complete InferenceData object containing: - posterior : Model parameters (\u03b2, \u03c3, etc.) with shape (chains, draws, ...) - posterior_predictive : Predicted outcomes y with observation noise - log_likelihood : Log-likelihood values for LOO-CV and model comparison - observed_data : Original response variable from training data - coords : Observation IDs and other coordinates - dims : Dimension labels for each variable Notes InferenceData Groups: Posterior : Parameter samples from MCMC Includes all model parameters (intercepts, slopes, sigmas, etc.) Shape: (n_chains, n_draws) for scalars, (n_chains, n_draws, ...) for arrays Extracted via posterior::as_draws_df() Posterior Predictive : Predictions including observation noise Generated via brms::posterior_predict() Useful for posterior predictive checks Shape: (n_chains, n_draws, n_obs) Log Likelihood : Pointwise log-likelihood values Generated via brms::log_lik() Required for LOO-CV and WAIC model comparison Shape: (n_chains, n_draws, n_obs) Observed Data : Original response variable Extracted from fit$data Uses first column (brms convention for response variable) Shape: (n_obs,) Reshaping Strategy: brms/rstan return flat arrays with shape (total_draws, ...) where total_draws = n_chains \u00d7 n_draws. This function reshapes to ArviZ's expected format (n_chains, n_draws, ...) by: 1. Tracking chain IDs from .chain column 2. Computing per-chain draw indices 3. Pivoting and reshaping to 3D arrays Examples: from brmspy import fit from brmspy.helpers.conversion import brmsfit_to_idata import arviz as az # Fit a model (returns InferenceData directly) result = fit ( \"y ~ x\" , data = pd . DataFrame ({ \"y\" : [ 1 , 2 , 3 ], \"x\" : [ 1 , 2 , 3 ]})) idata = result . idata # Or manually convert brmsfit object # brmsfit_r = ... # R brmsfit object # idata = brmsfit_to_idata(brmsfit_r) # Use ArviZ for diagnostics az . summary ( idata , var_names = [ \"b_Intercept\" , \"b_x\" ]) az . plot_trace ( idata ) az . plot_posterior ( idata , var_names = [ \"sigma\" ]) # Access different groups idata . posterior # Parameter samples idata . posterior_predictive # Predicted outcomes with noise idata . log_likelihood # For model comparison idata . observed_data # Original data # Model comparison with LOO-CV az . loo ( idata ) az . waic ( idata ) See Also brmspy.brms.fit : High-level fitting function (returns InferenceData) brms_epred_to_idata : Convert expected value predictions brms_predict_to_idata : Convert posterior predictions arviz.InferenceData : ArviZ's data structure documentation generic_pred_to_idata ( r_pred_obj , brmsfit_obj , newdata = None , var_name = 'pred' , az_name = 'posterior' ) \u00b6 Generic converter for brms prediction matrices to ArviZ InferenceData. Flexible conversion function that handles various brms prediction types (posterior_predict, posterior_epred, posterior_linpred, log_lik) and stores them in appropriate InferenceData groups with proper structure. Parameters: Name Type Description Default r_pred_obj rpy2 R matrix Prediction matrix from any brms prediction function Shape: (total_draws, n_observations) required brmsfit_obj rpy2 R object (brmsfit) Fitted model for extracting chain information required newdata DataFrame New data used for predictions. If provided, DataFrame index is used for observation coordinates None var_name str Name for the variable in the InferenceData dataset \"pred\" az_name str InferenceData group name. Common values: - \"posterior\": For expected values (epred) - \"posterior_predictive\": For predictions with noise (predict) - \"predictions\": For linear predictor (linpred) - \"log_likelihood\": For log-likelihood values \"posterior\" Returns: Type Description InferenceData InferenceData with single group containing reshaped predictions as xarray DataArray with proper coordinates and dimensions Notes InferenceData Group Selection: Different prediction types should use appropriate groups: - Expected values (epred): 'posterior' - deterministic E[Y|X] - Predictions (predict): 'posterior_predictive' - with observation noise - Linear predictor (linpred): 'predictions' - before link function - Log-likelihood: 'log_likelihood' - for model comparison Coordinates: If newdata is a DataFrame, uses its index as observation coordinates. This preserves meaningful labels (dates, IDs, etc.) in ArviZ plots. Examples: import pandas as pd from brmspy.helpers.conversion import generic_pred_to_idata # Assume we have fitted model and prediction matrix # r_epred = brms::posterior_epred(brmsfit, newdata=test_df) test_df = pd . DataFrame ({ 'x' : [ 1 , 2 , 3 ]}, index = [ 'A' , 'B' , 'C' ]) idata = generic_pred_to_idata ( r_pred_obj = r_epred , brmsfit_obj = brmsfit , newdata = test_df , var_name = \"expected_y\" , az_name = \"posterior\" ) # Access predictions print ( idata . posterior [ 'expected_y' ] . dims ) # ('chain', 'draw', 'obs_id') print ( idata . posterior [ 'expected_y' ] . coords [ 'obs_id' ]) # ['A', 'B', 'C'] See Also brms_epred_to_idata : Convenience wrapper for posterior_epred brms_predict_to_idata : Convenience wrapper for posterior_predict brms_linpred_to_idata : Convenience wrapper for posterior_linpred brms_log_lik_to_idata : Convenience wrapper for log_lik _reshape_r_prediction_to_arviz : Internal reshaping function brms_epred_to_idata ( r_epred_obj , brmsfit_obj , newdata = None , var_name = 'epred' ) \u00b6 Convert brms::posterior_epred result to ArviZ InferenceData. Convenience wrapper for converting expected value predictions (posterior_epred) to InferenceData format. Stores in 'posterior' group as deterministic expected values E[Y|X] without observation noise. Parameters: Name Type Description Default r_epred_obj rpy2 R matrix Result from brms::posterior_epred() required brmsfit_obj rpy2 R object (brmsfit) Fitted model required newdata DataFrame New data used for predictions None var_name str Variable name in InferenceData \"epred\" Returns: Type Description InferenceData InferenceData with 'posterior' group containing expected values Notes posterior_epred computes the expected value of the posterior predictive distribution (i.e., the mean outcome for given predictors): - For linear regression: E[Y|X] = \u03bc = X\u00b7\u03b2 - For Poisson regression: E[Y|X] = exp(X\u00b7\u03b2) - For logistic regression: E[Y|X] = logit\u207b\u00b9(X\u00b7\u03b2) This is stored in the 'posterior' group (not 'posterior_predictive') because it represents deterministic expected values, not noisy predictions. See Also brmspy.brms.posterior_epred : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_predict_to_idata : For predictions with observation noise brms_predict_to_idata ( r_predict_obj , brmsfit_obj , newdata = None , var_name = 'y' ) \u00b6 Convert brms::posterior_predict result to ArviZ InferenceData. Convenience wrapper for converting posterior predictions (posterior_predict) to InferenceData format. Stores in 'posterior_predictive' group as predictions including observation-level noise. Parameters: Name Type Description Default r_predict_obj rpy2 R matrix Result from brms::posterior_predict() required brmsfit_obj rpy2 R object (brmsfit) Fitted model required newdata DataFrame New data used for predictions None var_name str Variable name in InferenceData \"y\" Returns: Type Description InferenceData InferenceData with 'posterior_predictive' group containing predictions Notes posterior_predict generates predictions from the posterior predictive distribution, including observation-level noise: - For linear regression: Y ~ Normal(\u03bc, \u03c3) - For Poisson regression: Y ~ Poisson(\u03bb) - For logistic regression: Y ~ Bernoulli(p) These predictions include all sources of uncertainty (parameter and observation) and are useful for: - Posterior predictive checks - Generating realistic synthetic data - Assessing model fit to observed data See Also brmspy.brms.posterior_predict : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_epred_to_idata : For expected values without noise brms_linpred_to_idata ( r_linpred_obj , brmsfit_obj , newdata = None , var_name = 'linpred' ) \u00b6 Convert brms::posterior_linpred result to ArviZ InferenceData. Convenience wrapper for converting linear predictor values (posterior_linpred) to InferenceData format. Stores in 'predictions' group as linear predictor values before applying the link function. Parameters: Name Type Description Default r_linpred_obj rpy2 R matrix Result from brms::posterior_linpred() required brmsfit_obj rpy2 R object (brmsfit) Fitted model required newdata DataFrame New data used for predictions None var_name str Variable name in InferenceData \"linpred\" Returns: Type Description InferenceData InferenceData with 'predictions' group containing linear predictor Notes posterior_linpred returns the linear predictor \u03b7 = X\u00b7\u03b2 before applying the link function: - For linear regression: linpred = \u03bc (same as epred since link is identity) - For Poisson regression: linpred = log(\u03bb), epred = \u03bb - For logistic regression: linpred = logit(p), epred = p The linear predictor is useful for: - Understanding the scale of effects before transformation - Diagnosing model specification issues - Custom post-processing with different link functions See Also brmspy.brms.posterior_linpred : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_epred_to_idata : For expected values on response scale brms_log_lik_to_idata ( r_log_lik_obj , brmsfit_obj , newdata = None , var_name = 'log_lik' ) \u00b6 Convert brms::log_lik result to ArviZ InferenceData. Convenience wrapper for converting pointwise log-likelihood values (log_lik) to InferenceData format. Stores in 'log_likelihood' group for use in model comparison and diagnostics. Parameters: Name Type Description Default r_log_lik_obj rpy2 R matrix Result from brms::log_lik() required brmsfit_obj rpy2 R object (brmsfit) Fitted model required newdata DataFrame New data for log-likelihood calculation None var_name str Variable name in InferenceData \"log_lik\" Returns: Type Description InferenceData InferenceData with 'log_likelihood' group Notes log_lik computes pointwise log-likelihood values for each observation, which are essential for: LOO-CV : Leave-one-out cross-validation via az.loo() WAIC : Widely applicable information criterion via az.waic() Model Comparison : Compare multiple models with az.compare() Outlier Detection : Identify poorly fit observations Each MCMC draw \u00d7 observation gets a log-likelihood value, representing how well that parameter draw explains that specific observation. Examples: from brmspy import fit import arviz as az # Fit model (log_lik included automatically) result = fit ( \"y ~ x\" , data = { \"y\" : [ 1 , 2 , 3 ], \"x\" : [ 1 , 2 , 3 ]}) # Model comparison with LOO-CV loo_result = az . loo ( result . idata ) print ( loo_result ) # Compare multiple models model1_idata = fit ( \"y ~ x\" , data = data1 ) . idata model2_idata = fit ( \"y ~ x + x2\" , data = data2 ) . idata comparison = az . compare ({ \"model1\" : model1_idata , \"model2\" : model2_idata }) See Also brmspy.brms.log_lik : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function arviz.loo : Leave-one-out cross-validation arviz.waic : WAIC computation arviz.compare : Model comparison py_to_r ( obj ) \u00b6 Convert arbitrary Python objects to R objects via rpy2. Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts. Parameters: Name Type Description Default obj any Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types required Returns: Type Description rpy2 R object R representation of the Python object Notes Conversion Rules: None : \u2192 R NULL DataFrames : \u2192 R data.frame (via pandas2ri) Dictionaries : \u2192 R named list (ListVector), recursively converting values Lists of dicts : \u2192 R list with 1-based indexed names containing named lists Other lists/tuples : \u2192 R vectors or lists (via rpy2 default) NumPy arrays : \u2192 R vectors/matrices (via numpy2ri) Scalars : \u2192 R atomic values Recursive Conversion: Dictionary values are recursively converted, allowing nested structures: { 'a' : { 'b' : [ 1 , 2 , 3 ]}} \u2192 list ( a = list ( b = c ( 1 , 2 , 3 ))) List of Dicts: Lists containing only dicts are converted to R lists with 1-based indexing: [{ 'x' : 1 }, { 'x' : 2 }] \u2192 list ( \"1\" = list ( x = 1 ), \"2\" = list ( x = 2 )) Examples: from brmspy.helpers.conversion import py_to_r import numpy as np import pandas as pd # Scalars py_to_r ( 5 ) # R: 5 py_to_r ( \"hello\" ) # R: \"hello\" py_to_r ( None ) # R: NULL # Arrays py_to_r ( np . array ([ 1 , 2 , 3 ])) # R: c(1, 2, 3) # DataFrames df = pd . DataFrame ({ 'x' : [ 1 , 2 ], 'y' : [ 3 , 4 ]}) py_to_r ( df ) # R: data.frame(x = c(1, 2), y = c(3, 4)) See Also r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R r_to_py ( obj ) \u00b6 Convert R objects to Python objects via rpy2. Comprehensive converter that handles R lists (named/unnamed), vectors, formulas, and language objects. Provides sensible Python equivalents for all R types with special handling for edge cases. Parameters: Name Type Description Default obj rpy2 R object R object to convert to Python required Returns: Type Description any Python representation of the R object: - R NULL \u2192 None - Named list \u2192 dict (recursively) - Unnamed list \u2192 list (recursively) - Length-1 vector \u2192 scalar (int, float, str, bool) - Length-N vector \u2192 list of scalars - Formula/Language object \u2192 str (descriptive representation) - Other objects \u2192 default rpy2 conversion or str fallback Notes Conversion Rules: R NULL : \u2192 Python None Atomic vectors (numeric, character, logical): Length 1: \u2192 Python scalar (int, float, str, bool) Length >1: \u2192 Python list of scalars Named lists (ListVector with names): \u2192 Python dict, recursively Unnamed lists : \u2192 Python list, recursively Formulas (e.g., y ~ x ): \u2192 String representation Language objects (calls, expressions): \u2192 String representation Functions : \u2192 String representation Everything else : Try default rpy2 conversion, fallback to string Recursive Conversion: List elements and dictionary values are recursively converted: list ( a = list ( b = c ( 1 , 2 ))) \u2192 { 'a' : { 'b' : [ 1 , 2 ]}} Safe Fallback: R language objects, formulas, and functions are converted to descriptive strings rather than attempting complex conversions that might fail. Examples: from brmspy.helpers.conversion import r_to_py import rpy2.robjects as ro # R NULL r_to_py ( ro . NULL ) # None # Scalars r_to_py ( ro . IntVector ([ 5 ])) # 5 r_to_py ( ro . FloatVector ([ 3.14 ])) # 3.14 r_to_py ( ro . StrVector ([ \"hello\" ])) # \"hello\" # Vectors r_to_py ( ro . IntVector ([ 1 , 2 , 3 ])) # [1, 2, 3] See Also py_to_r : Convert Python objects to R brmspy.brms.summary : Returns Python-friendly summary dict kwargs_r ( kwargs ) \u00b6 Convert Python keyword arguments to R-compatible format. Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls. Parameters: Name Type Description Default kwargs dict or None Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.) required Returns: Type Description dict Dictionary with same keys but R-compatible values, or empty dict if None Notes This is a thin wrapper around py_to_r() that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2. Examples: from brmspy.helpers.conversion import kwargs_r import pandas as pd import numpy as np # Prepare kwargs for R function py_kwargs = { 'data' : pd . DataFrame ({ 'y' : [ 1 , 2 ], 'x' : [ 1 , 2 ]}), 'prior' : { 'b' : [ 0 , 1 ]}, 'chains' : 4 , 'iter' : 2000 } r_kwargs = kwargs_r ( py_kwargs ) # All values converted to R objects # Can now call: r_function(**r_kwargs) See Also py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R","title":"Conversion"},{"location":"helpers/conversion/#brmspy.helpers.conversion-classes","text":"","title":"Classes"},{"location":"helpers/conversion/#brmspy.helpers.conversion-functions","text":"","title":"Functions"},{"location":"helpers/conversion/#brmspy.helpers.conversion.brmsfit_to_idata","text":"Convert brmsfit R object to ArviZ InferenceData format. Comprehensive conversion that extracts all MCMC diagnostics, predictions, and observed data from a brms fitted model into ArviZ's InferenceData format. Handles proper chain/draw indexing and coordinates for ArviZ compatibility. Parameters: Name Type Description Default brmsfit_obj rpy2 R object (brmsfit) Fitted Bayesian model from R's brms::brm() function required model_data dict or DataFrame Additional model data (currently unused, reserved for future use) None Returns: Type Description InferenceData Complete InferenceData object containing: - posterior : Model parameters (\u03b2, \u03c3, etc.) with shape (chains, draws, ...) - posterior_predictive : Predicted outcomes y with observation noise - log_likelihood : Log-likelihood values for LOO-CV and model comparison - observed_data : Original response variable from training data - coords : Observation IDs and other coordinates - dims : Dimension labels for each variable Notes InferenceData Groups: Posterior : Parameter samples from MCMC Includes all model parameters (intercepts, slopes, sigmas, etc.) Shape: (n_chains, n_draws) for scalars, (n_chains, n_draws, ...) for arrays Extracted via posterior::as_draws_df() Posterior Predictive : Predictions including observation noise Generated via brms::posterior_predict() Useful for posterior predictive checks Shape: (n_chains, n_draws, n_obs) Log Likelihood : Pointwise log-likelihood values Generated via brms::log_lik() Required for LOO-CV and WAIC model comparison Shape: (n_chains, n_draws, n_obs) Observed Data : Original response variable Extracted from fit$data Uses first column (brms convention for response variable) Shape: (n_obs,) Reshaping Strategy: brms/rstan return flat arrays with shape (total_draws, ...) where total_draws = n_chains \u00d7 n_draws. This function reshapes to ArviZ's expected format (n_chains, n_draws, ...) by: 1. Tracking chain IDs from .chain column 2. Computing per-chain draw indices 3. Pivoting and reshaping to 3D arrays Examples: from brmspy import fit from brmspy.helpers.conversion import brmsfit_to_idata import arviz as az # Fit a model (returns InferenceData directly) result = fit ( \"y ~ x\" , data = pd . DataFrame ({ \"y\" : [ 1 , 2 , 3 ], \"x\" : [ 1 , 2 , 3 ]})) idata = result . idata # Or manually convert brmsfit object # brmsfit_r = ... # R brmsfit object # idata = brmsfit_to_idata(brmsfit_r) # Use ArviZ for diagnostics az . summary ( idata , var_names = [ \"b_Intercept\" , \"b_x\" ]) az . plot_trace ( idata ) az . plot_posterior ( idata , var_names = [ \"sigma\" ]) # Access different groups idata . posterior # Parameter samples idata . posterior_predictive # Predicted outcomes with noise idata . log_likelihood # For model comparison idata . observed_data # Original data # Model comparison with LOO-CV az . loo ( idata ) az . waic ( idata ) See Also brmspy.brms.fit : High-level fitting function (returns InferenceData) brms_epred_to_idata : Convert expected value predictions brms_predict_to_idata : Convert posterior predictions arviz.InferenceData : ArviZ's data structure documentation","title":"brmsfit_to_idata"},{"location":"helpers/conversion/#brmspy.helpers.conversion.generic_pred_to_idata","text":"Generic converter for brms prediction matrices to ArviZ InferenceData. Flexible conversion function that handles various brms prediction types (posterior_predict, posterior_epred, posterior_linpred, log_lik) and stores them in appropriate InferenceData groups with proper structure. Parameters: Name Type Description Default r_pred_obj rpy2 R matrix Prediction matrix from any brms prediction function Shape: (total_draws, n_observations) required brmsfit_obj rpy2 R object (brmsfit) Fitted model for extracting chain information required newdata DataFrame New data used for predictions. If provided, DataFrame index is used for observation coordinates None var_name str Name for the variable in the InferenceData dataset \"pred\" az_name str InferenceData group name. Common values: - \"posterior\": For expected values (epred) - \"posterior_predictive\": For predictions with noise (predict) - \"predictions\": For linear predictor (linpred) - \"log_likelihood\": For log-likelihood values \"posterior\" Returns: Type Description InferenceData InferenceData with single group containing reshaped predictions as xarray DataArray with proper coordinates and dimensions Notes InferenceData Group Selection: Different prediction types should use appropriate groups: - Expected values (epred): 'posterior' - deterministic E[Y|X] - Predictions (predict): 'posterior_predictive' - with observation noise - Linear predictor (linpred): 'predictions' - before link function - Log-likelihood: 'log_likelihood' - for model comparison Coordinates: If newdata is a DataFrame, uses its index as observation coordinates. This preserves meaningful labels (dates, IDs, etc.) in ArviZ plots. Examples: import pandas as pd from brmspy.helpers.conversion import generic_pred_to_idata # Assume we have fitted model and prediction matrix # r_epred = brms::posterior_epred(brmsfit, newdata=test_df) test_df = pd . DataFrame ({ 'x' : [ 1 , 2 , 3 ]}, index = [ 'A' , 'B' , 'C' ]) idata = generic_pred_to_idata ( r_pred_obj = r_epred , brmsfit_obj = brmsfit , newdata = test_df , var_name = \"expected_y\" , az_name = \"posterior\" ) # Access predictions print ( idata . posterior [ 'expected_y' ] . dims ) # ('chain', 'draw', 'obs_id') print ( idata . posterior [ 'expected_y' ] . coords [ 'obs_id' ]) # ['A', 'B', 'C'] See Also brms_epred_to_idata : Convenience wrapper for posterior_epred brms_predict_to_idata : Convenience wrapper for posterior_predict brms_linpred_to_idata : Convenience wrapper for posterior_linpred brms_log_lik_to_idata : Convenience wrapper for log_lik _reshape_r_prediction_to_arviz : Internal reshaping function","title":"generic_pred_to_idata"},{"location":"helpers/conversion/#brmspy.helpers.conversion.brms_epred_to_idata","text":"Convert brms::posterior_epred result to ArviZ InferenceData. Convenience wrapper for converting expected value predictions (posterior_epred) to InferenceData format. Stores in 'posterior' group as deterministic expected values E[Y|X] without observation noise. Parameters: Name Type Description Default r_epred_obj rpy2 R matrix Result from brms::posterior_epred() required brmsfit_obj rpy2 R object (brmsfit) Fitted model required newdata DataFrame New data used for predictions None var_name str Variable name in InferenceData \"epred\" Returns: Type Description InferenceData InferenceData with 'posterior' group containing expected values Notes posterior_epred computes the expected value of the posterior predictive distribution (i.e., the mean outcome for given predictors): - For linear regression: E[Y|X] = \u03bc = X\u00b7\u03b2 - For Poisson regression: E[Y|X] = exp(X\u00b7\u03b2) - For logistic regression: E[Y|X] = logit\u207b\u00b9(X\u00b7\u03b2) This is stored in the 'posterior' group (not 'posterior_predictive') because it represents deterministic expected values, not noisy predictions. See Also brmspy.brms.posterior_epred : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_predict_to_idata : For predictions with observation noise","title":"brms_epred_to_idata"},{"location":"helpers/conversion/#brmspy.helpers.conversion.brms_predict_to_idata","text":"Convert brms::posterior_predict result to ArviZ InferenceData. Convenience wrapper for converting posterior predictions (posterior_predict) to InferenceData format. Stores in 'posterior_predictive' group as predictions including observation-level noise. Parameters: Name Type Description Default r_predict_obj rpy2 R matrix Result from brms::posterior_predict() required brmsfit_obj rpy2 R object (brmsfit) Fitted model required newdata DataFrame New data used for predictions None var_name str Variable name in InferenceData \"y\" Returns: Type Description InferenceData InferenceData with 'posterior_predictive' group containing predictions Notes posterior_predict generates predictions from the posterior predictive distribution, including observation-level noise: - For linear regression: Y ~ Normal(\u03bc, \u03c3) - For Poisson regression: Y ~ Poisson(\u03bb) - For logistic regression: Y ~ Bernoulli(p) These predictions include all sources of uncertainty (parameter and observation) and are useful for: - Posterior predictive checks - Generating realistic synthetic data - Assessing model fit to observed data See Also brmspy.brms.posterior_predict : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_epred_to_idata : For expected values without noise","title":"brms_predict_to_idata"},{"location":"helpers/conversion/#brmspy.helpers.conversion.brms_linpred_to_idata","text":"Convert brms::posterior_linpred result to ArviZ InferenceData. Convenience wrapper for converting linear predictor values (posterior_linpred) to InferenceData format. Stores in 'predictions' group as linear predictor values before applying the link function. Parameters: Name Type Description Default r_linpred_obj rpy2 R matrix Result from brms::posterior_linpred() required brmsfit_obj rpy2 R object (brmsfit) Fitted model required newdata DataFrame New data used for predictions None var_name str Variable name in InferenceData \"linpred\" Returns: Type Description InferenceData InferenceData with 'predictions' group containing linear predictor Notes posterior_linpred returns the linear predictor \u03b7 = X\u00b7\u03b2 before applying the link function: - For linear regression: linpred = \u03bc (same as epred since link is identity) - For Poisson regression: linpred = log(\u03bb), epred = \u03bb - For logistic regression: linpred = logit(p), epred = p The linear predictor is useful for: - Understanding the scale of effects before transformation - Diagnosing model specification issues - Custom post-processing with different link functions See Also brmspy.brms.posterior_linpred : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_epred_to_idata : For expected values on response scale","title":"brms_linpred_to_idata"},{"location":"helpers/conversion/#brmspy.helpers.conversion.brms_log_lik_to_idata","text":"Convert brms::log_lik result to ArviZ InferenceData. Convenience wrapper for converting pointwise log-likelihood values (log_lik) to InferenceData format. Stores in 'log_likelihood' group for use in model comparison and diagnostics. Parameters: Name Type Description Default r_log_lik_obj rpy2 R matrix Result from brms::log_lik() required brmsfit_obj rpy2 R object (brmsfit) Fitted model required newdata DataFrame New data for log-likelihood calculation None var_name str Variable name in InferenceData \"log_lik\" Returns: Type Description InferenceData InferenceData with 'log_likelihood' group Notes log_lik computes pointwise log-likelihood values for each observation, which are essential for: LOO-CV : Leave-one-out cross-validation via az.loo() WAIC : Widely applicable information criterion via az.waic() Model Comparison : Compare multiple models with az.compare() Outlier Detection : Identify poorly fit observations Each MCMC draw \u00d7 observation gets a log-likelihood value, representing how well that parameter draw explains that specific observation. Examples: from brmspy import fit import arviz as az # Fit model (log_lik included automatically) result = fit ( \"y ~ x\" , data = { \"y\" : [ 1 , 2 , 3 ], \"x\" : [ 1 , 2 , 3 ]}) # Model comparison with LOO-CV loo_result = az . loo ( result . idata ) print ( loo_result ) # Compare multiple models model1_idata = fit ( \"y ~ x\" , data = data1 ) . idata model2_idata = fit ( \"y ~ x + x2\" , data = data2 ) . idata comparison = az . compare ({ \"model1\" : model1_idata , \"model2\" : model2_idata }) See Also brmspy.brms.log_lik : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function arviz.loo : Leave-one-out cross-validation arviz.waic : WAIC computation arviz.compare : Model comparison","title":"brms_log_lik_to_idata"},{"location":"helpers/conversion/#brmspy.helpers.conversion.py_to_r","text":"Convert arbitrary Python objects to R objects via rpy2. Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts. Parameters: Name Type Description Default obj any Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types required Returns: Type Description rpy2 R object R representation of the Python object Notes Conversion Rules: None : \u2192 R NULL DataFrames : \u2192 R data.frame (via pandas2ri) Dictionaries : \u2192 R named list (ListVector), recursively converting values Lists of dicts : \u2192 R list with 1-based indexed names containing named lists Other lists/tuples : \u2192 R vectors or lists (via rpy2 default) NumPy arrays : \u2192 R vectors/matrices (via numpy2ri) Scalars : \u2192 R atomic values Recursive Conversion: Dictionary values are recursively converted, allowing nested structures: { 'a' : { 'b' : [ 1 , 2 , 3 ]}} \u2192 list ( a = list ( b = c ( 1 , 2 , 3 ))) List of Dicts: Lists containing only dicts are converted to R lists with 1-based indexing: [{ 'x' : 1 }, { 'x' : 2 }] \u2192 list ( \"1\" = list ( x = 1 ), \"2\" = list ( x = 2 )) Examples: from brmspy.helpers.conversion import py_to_r import numpy as np import pandas as pd # Scalars py_to_r ( 5 ) # R: 5 py_to_r ( \"hello\" ) # R: \"hello\" py_to_r ( None ) # R: NULL # Arrays py_to_r ( np . array ([ 1 , 2 , 3 ])) # R: c(1, 2, 3) # DataFrames df = pd . DataFrame ({ 'x' : [ 1 , 2 ], 'y' : [ 3 , 4 ]}) py_to_r ( df ) # R: data.frame(x = c(1, 2), y = c(3, 4)) See Also r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R","title":"py_to_r"},{"location":"helpers/conversion/#brmspy.helpers.conversion.r_to_py","text":"Convert R objects to Python objects via rpy2. Comprehensive converter that handles R lists (named/unnamed), vectors, formulas, and language objects. Provides sensible Python equivalents for all R types with special handling for edge cases. Parameters: Name Type Description Default obj rpy2 R object R object to convert to Python required Returns: Type Description any Python representation of the R object: - R NULL \u2192 None - Named list \u2192 dict (recursively) - Unnamed list \u2192 list (recursively) - Length-1 vector \u2192 scalar (int, float, str, bool) - Length-N vector \u2192 list of scalars - Formula/Language object \u2192 str (descriptive representation) - Other objects \u2192 default rpy2 conversion or str fallback Notes Conversion Rules: R NULL : \u2192 Python None Atomic vectors (numeric, character, logical): Length 1: \u2192 Python scalar (int, float, str, bool) Length >1: \u2192 Python list of scalars Named lists (ListVector with names): \u2192 Python dict, recursively Unnamed lists : \u2192 Python list, recursively Formulas (e.g., y ~ x ): \u2192 String representation Language objects (calls, expressions): \u2192 String representation Functions : \u2192 String representation Everything else : Try default rpy2 conversion, fallback to string Recursive Conversion: List elements and dictionary values are recursively converted: list ( a = list ( b = c ( 1 , 2 ))) \u2192 { 'a' : { 'b' : [ 1 , 2 ]}} Safe Fallback: R language objects, formulas, and functions are converted to descriptive strings rather than attempting complex conversions that might fail. Examples: from brmspy.helpers.conversion import r_to_py import rpy2.robjects as ro # R NULL r_to_py ( ro . NULL ) # None # Scalars r_to_py ( ro . IntVector ([ 5 ])) # 5 r_to_py ( ro . FloatVector ([ 3.14 ])) # 3.14 r_to_py ( ro . StrVector ([ \"hello\" ])) # \"hello\" # Vectors r_to_py ( ro . IntVector ([ 1 , 2 , 3 ])) # [1, 2, 3] See Also py_to_r : Convert Python objects to R brmspy.brms.summary : Returns Python-friendly summary dict","title":"r_to_py"},{"location":"helpers/conversion/#brmspy.helpers.conversion.kwargs_r","text":"Convert Python keyword arguments to R-compatible format. Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls. Parameters: Name Type Description Default kwargs dict or None Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.) required Returns: Type Description dict Dictionary with same keys but R-compatible values, or empty dict if None Notes This is a thin wrapper around py_to_r() that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2. Examples: from brmspy.helpers.conversion import kwargs_r import pandas as pd import numpy as np # Prepare kwargs for R function py_kwargs = { 'data' : pd . DataFrame ({ 'y' : [ 1 , 2 ], 'x' : [ 1 , 2 ]}), 'prior' : { 'b' : [ 0 , 1 ]}, 'chains' : 4 , 'iter' : 2000 } r_kwargs = kwargs_r ( py_kwargs ) # All values converted to R objects # Can now call: r_function(**r_kwargs) See Also py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R","title":"kwargs_r"},{"location":"helpers/priors/","text":"Classes \u00b6","title":"Priors"},{"location":"helpers/priors/#brmspy.helpers.priors-classes","text":"","title":"Classes"},{"location":"helpers/rtools/","text":"Functions \u00b6 pick_rtools_for_r ( r_ver ) \u00b6 Select appropriate Rtools version tag for given R version. Maps R version to compatible Rtools major version. Rtools is required on Windows to compile Stan models and R packages with C++ code. Parameters: Name Type Description Default r_ver Version R version to match required Returns: Type Description str or None Rtools version tag ('40', '42', '43', '44', '45') or None if R version is too old (< 4.0.0) for automatic handling Notes R to Rtools Version Mapping: R 4.0.x - 4.1.x: Rtools 40 R 4.2.x: Rtools 42 R 4.3.x: Rtools 43 R 4.4.x: Rtools 44 R 4.5.x+: Rtools 44 R < 4.0.0: None (legacy, not supported) Rtools Purpose: Rtools provides MinGW-w64 compiler toolchain on Windows for: - Compiling Stan models (required by cmdstanr) - Building R packages from source - C++ compilation for brms/Stan Examples: from packaging.version import Version from brmspy.helpers.rtools import pick_rtools_for_r # R 4.3.2 needs Rtools 43 tag = pick_rtools_for_r ( Version ( \"4.3.2\" )) print ( tag ) # \"43\" # R 4.4.1 needs Rtools 44 tag = pick_rtools_for_r ( Version ( \"4.4.1\" )) print ( tag ) # \"44\" # Legacy R not supported tag = pick_rtools_for_r ( Version ( \"3.6.3\" )) print ( tag ) # None See Also _install_rtools_for_current_r : Automatically install matching Rtools _get_r_version : Get current R version References .. [1] Rtools download page: https://cran.r-project.org/bin/windows/Rtools/","title":"RTools (Windows)"},{"location":"helpers/rtools/#brmspy.helpers.rtools-functions","text":"","title":"Functions"},{"location":"helpers/rtools/#brmspy.helpers.rtools.pick_rtools_for_r","text":"Select appropriate Rtools version tag for given R version. Maps R version to compatible Rtools major version. Rtools is required on Windows to compile Stan models and R packages with C++ code. Parameters: Name Type Description Default r_ver Version R version to match required Returns: Type Description str or None Rtools version tag ('40', '42', '43', '44', '45') or None if R version is too old (< 4.0.0) for automatic handling Notes R to Rtools Version Mapping: R 4.0.x - 4.1.x: Rtools 40 R 4.2.x: Rtools 42 R 4.3.x: Rtools 43 R 4.4.x: Rtools 44 R 4.5.x+: Rtools 44 R < 4.0.0: None (legacy, not supported) Rtools Purpose: Rtools provides MinGW-w64 compiler toolchain on Windows for: - Compiling Stan models (required by cmdstanr) - Building R packages from source - C++ compilation for brms/Stan Examples: from packaging.version import Version from brmspy.helpers.rtools import pick_rtools_for_r # R 4.3.2 needs Rtools 43 tag = pick_rtools_for_r ( Version ( \"4.3.2\" )) print ( tag ) # \"43\" # R 4.4.1 needs Rtools 44 tag = pick_rtools_for_r ( Version ( \"4.4.1\" )) print ( tag ) # \"44\" # Legacy R not supported tag = pick_rtools_for_r ( Version ( \"3.6.3\" )) print ( tag ) # None See Also _install_rtools_for_current_r : Automatically install matching Rtools _get_r_version : Get current R version References .. [1] Rtools download page: https://cran.r-project.org/bin/windows/Rtools/","title":"pick_rtools_for_r"},{"location":"helpers/singleton/","text":"","title":"Singleton"}]}