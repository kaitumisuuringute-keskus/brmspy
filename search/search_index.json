{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"brmspy","text":"<p>Python-first access to R's brms  with proper parameter names, ArviZ support, and cmdstanr performance. The easiest way to run brms models from Python.</p> <p>This is an early development version of the library, use with caution.</p> <p>Github repo and issues</p> <p> </p> <p> </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install brmspy\n</code></pre> <p>First-time setup (installs brms, cmdstanr, and CmdStan in R):</p> <pre><code>from brmspy import brms\nbrms.install_brms() # requires R to be installed already\n</code></pre>"},{"location":"#prebuilt-runtimes-optional","title":"Prebuilt Runtimes (Optional)","text":"<p>For faster installation (~20-60 seconds vs 20-30 minutes), use prebuilt runtime bundles:</p> <pre><code>from brmspy import brms\nbrms.install_brms(use_prebuilt=True)\n</code></pre>"},{"location":"#windows-rtools","title":"Windows RTools","text":"<p>In case you don't have RTools installed, you can use the flag install_rtools = True. This is disabled by default, because the flag runs the full rtools installer and modifies system path.  Use with caution!</p> <pre><code>from brmspy import brms\nbrms.install_brms(\n    use_prebuilt=True,\n    install_rtools=True # works for both prebuilt and compiled binaries.\n)\n</code></pre>"},{"location":"#system-requirements","title":"System Requirements","text":"<p>Linux (x86_64): - glibc &gt;= 2.27 (Ubuntu 18.04+, Debian 10+, RHEL 8+) - g++ &gt;= 9.0 - R &gt;= 4.3</p> <p>macOS (Intel &amp; Apple Silicon): - Xcode Command Line Tools: <code>xcode-select --install</code> - clang &gt;= 11.0 - R &gt;= 4.2</p> <p>Windows (x86_64): - Rtools 4.0+ with MinGW toolchain - g++ &gt;= 9.0 - R &gt;= 4.5</p> <p>Download Rtools from: https://cran.r-project.org/bin/windows/Rtools/</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Proper parameter names: Returns <code>b_Intercept</code>, <code>b_zAge</code>, <code>sd_patient__Intercept</code> instead of generic names like <code>b_dim_0</code></li> <li>ArviZ integration: Returns <code>arviz.InferenceData</code> by default for Python workflow</li> <li>brms formula syntax: Full support for brms formula interface including random effects</li> <li>Dual access: Results include both <code>.idata</code> (arviz) and <code>.r</code> (brmsfit) attributes</li> <li>No reimplementation: Delegates all modeling logic to real brms. No Python-side reimplementation, no divergence from native behavior</li> <li>Prebuilt Binaries: Fast installation with precompiled runtimes (50x faster, ~25 seconds on Google Colab)</li> <li>Stays true to brms: Function names, parameters, and returned objects are designed to be as close as possible to brms</li> <li>Composable formula DSL: Build multivariate, non-linear, and distributional formulas by simply adding components together, identical to brms</li> </ul>"},{"location":"#examples","title":"Examples","text":""},{"location":"#1-quick-start","title":"1. Quick Start","text":"<p>Basic Bayesian regression with ArviZ diagnostics:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\n# Fit Poisson model with random effects\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\"count ~ zAge + (1|patient)\", data=epilepsy, family=\"poisson\")\n\n# Proper parameter names automatically!\nprint(az.summary(model.idata))\n#                  mean     sd  hdi_3%  hdi_97%  ...  r_hat\n# b_Intercept     1.234  0.123   1.012    1.456  ...   1.00\n# b_zAge          0.567  0.089   0.398    0.732  ...   1.00\n# sd_patient__... 0.345  0.067   0.223    0.467  ...   1.00\n</code></pre>"},{"location":"#2-multivariate-models-python-vs-r","title":"2. Multivariate Models (Python vs R)","text":"<p>Model multiple responses simultaneously with seamless ArviZ integration:</p> Python (brmspy)R (brms) <pre><code>from brmspy import brms, bf, set_rescor\nimport arviz as az\n\n# Fit multivariate model\nmv = brms.fit(\n    bf(\"mvbind(tarsus, back) ~ sex + (1|p|fosternest)\")\n    + set_rescor(True),\n    data=btdata\n)\n\n# ArviZ just works!\naz.loo(mv.idata, var_name=\"tarsus\")\naz.loo(mv.idata, var_name=\"back\")\naz.plot_ppc(mv.idata, var_names=[\"tarsus\"])\n</code></pre> <pre><code>library(brms)\nlibrary(loo)\n\n# Fit multivariate model\nfit &lt;- brm(\n  bf(mvbind(tarsus, back) ~ sex + (1|p|fosternest))\n  + set_rescor(TRUE),\n  data = BTdata\n)\n\n# Separate LOO for each response\nloo_tarsus &lt;- loo(fit, resp = \"tarsus\")\nloo_back &lt;- loo(fit, resp = \"back\")\n</code></pre>"},{"location":"#3-distributional-regression","title":"3. Distributional Regression","text":"<p>Model heteroscedasticity (variance depends on predictors):</p> <pre><code>from brmspy import bf\n\n# Model both mean AND variance\nmodel = brms.fit(\n    bf(\"reaction ~ days\", sigma = \"~ days\"),  # sigma varies with days!\n    data=sleep_data,\n    family=\"gaussian\"\n)\n\n# Extract distributional parameters\nprint(model.idata.posterior.data_vars)\n# b_Intercept, b_days, b_sigma_Intercept, b_sigma_days, ...\n</code></pre>"},{"location":"#4-complete-diagnostic-workflow-with-arviz","title":"4. Complete Diagnostic Workflow with ArviZ","text":"<p>Full model checking in ~10 lines:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nmodel = brms.fit(\"count ~ zAge * Trt + (1|patient)\", data=epilepsy, family=\"poisson\")\n\n# Check convergence\nassert az.rhat(model.idata).max() &lt; 1.01, \"Convergence issues!\"\nassert az.ess(model.idata).min() &gt; 400, \"Low effective sample size!\"\n\n# Posterior predictive check\naz.plot_ppc(model.idata, num_pp_samples=100)\n\n# Model comparison\nmodel2 = brms.fit(\"count ~ zAge + Trt + (1|patient)\", data=epilepsy, family=\"poisson\")\ncomparison = az.compare({\"interaction\": model.idata, \"additive\": model2.idata})\nprint(comparison)\n#              rank  loo    p_loo  d_loo  weight\n# interaction     0 -456.2   12.3    0.0    0.89\n# additive        1 -461.5   10.8    5.3    0.11\n</code></pre>"},{"location":"#5-advanced-formulas-splines-non-linear-effects","title":"5. Advanced Formulas: Splines &amp; Non-linear Effects","text":"<p>Smooth non-linear relationships with splines:</p> <pre><code>from brmspy import brms\n\n# Generalized additive model (GAM) with spline\nmodel = brms.fit(\n    \"y ~ s(x, bs='cr', k=10) + (1 + x | group)\",\n    data=data,\n    family=\"gaussian\"\n)\n\n# Polynomial regression\npoly_model = brms.fit(\n    \"y ~ poly(x, 3) + (1|group)\",\n    data=data\n)\n\n# Extract and visualize smooth effects\nconditional_effects = brms.call(\"conditional_effects\", model, \"x\")\n</code></pre>"},{"location":"#additional-features","title":"Additional Features","text":"<p>Custom Priors: <pre><code>from brmspy import prior\n\nmodel = brms.fit(\n    \"count ~ zAge + (1|patient)\",\n    data=epilepsy,\n    priors=[\n        prior(\"normal(0, 0.5)\", class_=\"b\"),\n        prior(\"exponential(1)\", class_=\"sd\", group=\"patient\")\n    ],\n    family=\"poisson\"\n)\n</code></pre></p> <p>Predictions: <pre><code>import pandas as pd\n\nnew_data = pd.DataFrame({\"zAge\": [-1, 0, 1], \"patient\": [999, 999, 999]})\n\n# Expected value (without observation noise)\nepred = brms.posterior_epred(model, newdata=new_data)\n\n# Posterior predictive (with noise)\nypred = brms.posterior_predict(model, newdata=new_data)\n\n# Access as InferenceData for ArviZ\naz.plot_violin(epred.idata)\n</code></pre></p>"},{"location":"#6-maximalist-example-kitchen-sink","title":"6. Maximalist Example: Kitchen Sink","text":"<p>Everything at once - multivariate responses, different families, distributional parameters, splines, and complete diagnostics:</p> <pre><code>from brmspy import brms, bf, lf, set_rescor, skew_normal, gaussian\nimport arviz as az\n\n# Load data\nbtdata = brms.get_data(\"BTdata\", package=\"MCMCglmm\")\n\nbf_tarsus = (\n    bf(\"tarsus ~ sex + (1|p|fosternest) + (1|q|dam)\") +\n    lf(\"sigma ~ 0 + sex\") +\n    skew_normal()\n)\n\nbf_back = (\n    bf(\"back ~ s(hatchdate) + (1|p|fosternest) + (1|q|dam)\") +\n    gaussian()\n)\n\nmodel = brms.fit(\n    bf_tarsus + bf_back + set_rescor(False),\n    data=btdata,\n    chains=2,\n    control={\"adapt_delta\": 0.95}\n)\n\n# ArviZ diagnostics work seamlessly\nfor response in [\"tarsus\", \"back\"]:\n    print(f\"\\n=== {response.upper()} ===\")\n\n    # Model comparison\n    loo = az.loo(model.idata, var_name=response)\n    print(f\"LOO: {loo.loo:.1f} \u00b1 {loo.loo_se:.1f}\")\n\n    # Posterior predictive check\n    az.plot_ppc(model.idata, var_names=[response])\n\n    # Parameter summaries\n    print(az.summary(\n        model.idata,\n        var_names=[f\"b_{response}\"],\n        filter_vars=\"like\"\n    ))\n\n# Visualize non-linear effect\nconditional = brms.call(\"conditional_effects\", model, \"hatchdate\", resp=\"back\")\n# Returns proper pandas DataFrame ready for plotting!\n</code></pre> <p>Output shows: - Proper parameter naming: <code>b_tarsus_Intercept</code>, <code>b_tarsus_sex</code>, <code>b_sigma_sex</code>, <code>sd_fosternest__tarsus_Intercept</code>, etc. - Separate posterior predictive for each response - Per-response LOO for model comparison - All parameters accessible via ArviZ</p>"},{"location":"#api-reference-partial","title":"API Reference (partial)","text":"<p>brmspy documentation</p> <p>brms documentation</p>"},{"location":"#setup-functions","title":"Setup Functions","text":"<p>It is NOT recommended to run installation functions when you have used the session.</p> <ul> <li><code>install_brms()</code> - Install brms, cmdstanr, and CmdStan from source or runtime</li> <li><code>install_runtime()</code> - Install latest runtime for OS</li> <li><code>activate_runtime()</code> - Activate existing prebuilt runtime</li> <li><code>deactivate_runtime()</code> - Deactivate current runtime</li> <li><code>get_brms_version()</code> - Get installed brms version</li> <li><code>find_local_runtime()</code> - checks if a runtime exists locally in standard directory and returns path if it does</li> </ul>"},{"location":"#data-functions","title":"Data Functions","text":"<ul> <li><code>get_brms_data()</code> - Load example datasets from brms</li> <li><code>get_data()</code> - Load example datasets from any package</li> <li><code>save_rds()</code> - Save brmsfit or another robject</li> <li><code>load_rds_fit()</code> - Load saved brmsfit object as FitResult (with idata)</li> <li><code>load_rds_raw()</code> - Load r object</li> </ul>"},{"location":"#model-functions","title":"Model Functions","text":"<ul> <li><code>bf</code>, <code>lg</code>, <code>nlf</code>, <code>acformula</code>, <code>set_rescor</code>, <code>set_mecor</code>, <code>set_nl</code> - formula functions</li> <li><code>brm()</code> - Fit Bayesian regression model</li> <li><code>add_criterion</code> - add loo, waic criterions to fit</li> <li><code>make_stancode()</code> - Generate Stan code for model</li> </ul>"},{"location":"#diagnostics-functions","title":"Diagnostics Functions","text":"<ul> <li><code>summary()</code> - Comprehensive model summary as SummaryResult dataclass</li> <li><code>fixef()</code> - Extract population-level (fixed) effects</li> <li><code>ranef()</code> - Extract group-level (random) effects as xarray</li> <li><code>posterior_summary()</code> - Summary statistics for all parameters</li> <li><code>prior_summary()</code> - Extract prior specifications used in model</li> <li><code>validate_newdata()</code> - Validate new data for predictions</li> <li>For loo, waic etc use arviz!</li> </ul>"},{"location":"#prior-functions","title":"Prior Functions","text":"<ul> <li><code>prior()</code> - Define a prior with same syntax as r-s <code>prior_string</code></li> <li><code>get_prior()</code> - Get pd.DataFrame describing default priors</li> <li><code>default_prior()</code> - Get pd.DataFrame describing default priors</li> </ul>"},{"location":"#families-functions","title":"Families Functions","text":"<ul> <li><code>family()</code> - Get family object of FitResult</li> <li><code>brmsfamily()</code> - Construct family object from kwargs</li> <li><code>gaussian()</code>, <code>...bernoulli()</code>, <code>...beta_binomial()</code>, etc - Wrappers around brmsfamily for faster family object construction</li> </ul>"},{"location":"#prediction-functions","title":"Prediction Functions","text":"<ul> <li><code>posterior_epred()</code> - Expected value predictions (without noise)</li> <li><code>posterior_predict()</code> - Posterior predictive samples (with noise)</li> <li><code>posterior_linpred()</code> - Linear predictor values</li> <li><code>log_lik()</code> - Log-likelihood values</li> </ul>"},{"location":"#generic-function-access","title":"Generic Function Access","text":"<ul> <li><code>call()</code> - Call any brms/R function by name with automatic type conversion</li> </ul>"},{"location":"#known-issues","title":"Known issues","text":"<ul> <li>Due to Windows' idiosyncrasies installing existing R packages (or cmdstanr) is NOT guaranteed to succeed in the same session if it has already been used. It is strongly recommended to restart your Python session before doing any installations when you have used it. This also means autoloading previously used prebuilt environment on windows is disabled, call activate() to load existing prebuilt runtime.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Python: 3.10-3.14</p> <p>R packages (auto-installed via <code>brms.install_brms()</code>): - brms &gt;= 2.20.0 - cmdstanr - posterior</p> <p>Python dependencies: - rpy2 &gt;= 3.5.0 - pandas &gt;= 1.3.0 - numpy &gt;= 1.20.0 - arviz (optional, for InferenceData)</p>"},{"location":"#development","title":"Development","text":"<pre><code>git clone https://github.com/kaitumisuuringute-keskus/brmspy.git\ncd brmspy\n./init-venv.sh\npytest tests/ -v\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<p>brmspy uses: - brms::brm() with cmdstanr backend for fitting (ensures proper parameter naming) - posterior R package for conversion to draws format - arviz for Python-native analysis and visualization - rpy2 for Python-R communication</p> <p>Previous versions used CmdStanPy directly, which resulted in generic parameter names. Current version calls brms directly to preserve brms' parameter renaming logic.</p>"},{"location":"#license","title":"License","text":"<p>Apache License 2.0</p>"},{"location":"#credits","title":"Credits","text":"<ul> <li>Current maintainer: Remi Sebastian Kits</li> <li>Original concept: Adam Haber</li> <li>Built on brms by Paul-Christian B\u00fcrkner</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>API Reference</li> <li>Examples</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#020-runtime-refactor-formula-dsl","title":"0.2.0 - Runtime Refactor &amp; Formula DSL","text":"<p>25.12.07</p>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Removed Diagnostics: Removed <code>loo</code>, <code>loo_compare</code>, and <code>add_criterion</code> due to frequent segfaults in embedded R mode. Users should rely on <code>arviz.loo</code> and <code>arviz.compare</code> using the <code>idata</code> property of the fit result.</li> <li>Installation API: Renamed <code>use_prebuilt_binaries</code> argument to <code>use_prebuilt</code> in <code>install_brms()</code>.</li> <li>Installation API now consists of: <code>install_brms</code>, <code>install_runtime</code>, <code>deactivate_runtime</code>, <code>activate_runtime</code>, <code>find_local_runtime</code>, <code>get_active_runtime</code>, <code>get_brms_version</code></li> <li>Deprecations: Renamed <code>fit</code> to <code>brm</code> and <code>formula</code> to <code>bf</code>. Previous names are still exported as aliases, but might be removed in a future version.</li> </ul>"},{"location":"changelog/#new-features","title":"New Features","text":"<ul> <li>Formula DSL: Implemented <code>bf</code>, <code>lf</code>, <code>nlf</code>, <code>acformula</code>, <code>set_rescor</code>, <code>set_mecor</code>, and <code>set_nl</code>. These objects support additive syntax (e.g., <code>bf(...) + set_rescor(True) + gaussian()</code>) mirroring native brms behavior.</li> <li>Generic Data Loader: Added <code>get_data()</code> to load datasets from any installed R package, complementing <code>get_brms_data()</code>.</li> <li>Runtime Status: Added <code>brmspy.runtime.status()</code> to programmatically inspect the current R environment, toolchain compatibility, and active runtime configuration.</li> <li>Families now in package root: Families can now be imported from package root, e.g <code>from brmspy import gaussian</code></li> </ul>"},{"location":"changelog/#runtime-installation","title":"Runtime &amp; Installation","text":"<ul> <li>Core Refactor: Completely re-architected <code>brmspy.runtime</code> into strict layers (<code>_config</code>, <code>_r_env</code>, <code>_platform</code>, <code>_install</code>, etc) to eliminate side effects during import and prevent circular dependencies.</li> <li>Atomic Activation: <code>activate_runtime()</code> now validates manifest integrity and system fingerprints before mutating the R environment, ensuring atomic success or rollback.</li> <li>Auto-Persistence: The last successfully activated runtime is automatically restored on module import via <code>runtime._autoload</code>, creating persistent sessions across restarts.</li> <li>Windows Toolchain: Modularized RTools detection logic to accurately map R versions to RTools versions (4.0\u20134.5) and handle path updates safely.</li> </ul>"},{"location":"changelog/#documentation-infrastructure","title":"Documentation &amp; Infrastructure","text":"<ul> <li>MkDocs Migration: Ported all documentation to MkDocs with the Material theme for better navigability and API references.</li> <li>Rendered notebooks: Added more notebook examples that are now rendered fully with links to running each in Google Colab.</li> <li>ArViz diagnostics examples: can now be found under API reference</li> <li>Test coverage: Test coverage for brms functions is now at 88% and for R environment and package management at 68%</li> </ul>"},{"location":"changelog/#0113-enhanced-diagnostics-type-safe-summaries","title":"0.1.13 - Enhanced Diagnostics &amp; Type-Safe Summaries","text":"<p>25.12.04</p>"},{"location":"changelog/#diagnostics","title":"Diagnostics","text":"<ul> <li><code>summary()</code> Rewrite: Returns <code>SummaryResult</code> dataclass with structured access to <code>fixed</code>, <code>spec_pars</code>, <code>random</code>, <code>prior</code>, and model metadata. Includes pretty-print support.</li> <li><code>fixef()</code>: Extract population-level effects as DataFrame. Supports <code>summary</code>, <code>robust</code>, <code>probs</code>, and <code>pars</code> arguments.</li> <li><code>ranef()</code>: Extract group-level effects as xarray DataArrays. Returns dict mapping grouping factors to arrays with configurable summary/raw modes.</li> <li><code>posterior_summary()</code>: Extract all model parameters (fixed, random, auxiliary) as DataFrame. Supports variable selection and regex patterns.</li> <li><code>prior_summary()</code>: Return DataFrame of prior specifications. Option to show all priors or only user-specified.</li> <li><code>loo()</code>: Compute LOO-CV using PSIS. Returns <code>LooResult</code> with elpd_loo, p_loo, looic, and Pareto k diagnostics.</li> <li><code>loo_compare()</code>: Compare multiple models via LOO-CV. Returns <code>LooCompareResult</code> ranked by performance with <code>elpd_diff</code> and standard errors.</li> <li><code>validate_newdata()</code>: Validate prediction data against fitted model requirements. Checks variables, factor levels, and grouping structure.</li> </ul>"},{"location":"changelog/#type-system","title":"Type System","text":"<ul> <li>DataFrame Detection: <code>r_to_py()</code> now correctly preserves row indexes, column names, and proper type conversion from R DataFrames.</li> <li><code>LooResult</code>/<code>LooCompareResult</code>: Added <code>__repr__()</code> for formatted notebook output.</li> </ul>"},{"location":"changelog/#generic-function-access","title":"Generic Function Access","text":"<ul> <li><code>call()</code>: Universal wrapper for calling any brms or R function by name with automatic type conversion.</li> <li><code>sanitised_name()</code>: Helper to convert Python-style names to valid R identifiers.</li> </ul>"},{"location":"changelog/#testing","title":"Testing","text":"<ul> <li>Added 14 tests covering all new diagnostics functions.</li> <li>Optimized test iterations (<code>iter=100, warmup=50</code>) for faster CI.</li> </ul>"},{"location":"changelog/#0112-rds-io-families-module-default-priors","title":"0.1.12 - RDS I/O, Families Module, Default Priors","text":"<p>25.12.03</p>"},{"location":"changelog/#new-features_1","title":"New Features","text":"<ul> <li><code>save_rds()</code>: Save <code>brmsfit</code> or generic R objects to RDS files.</li> <li><code>load_rds_fit()</code>: Load saved <code>brmsfit</code> objects, returning <code>FitResult</code> with attached <code>InferenceData</code>.</li> <li><code>load_rds_raw()</code>: Load arbitrary R objects from RDS files.</li> <li><code>brm</code> Alias: Added <code>brm</code> as alias for <code>fit</code>.</li> </ul>"},{"location":"changelog/#families","title":"Families","text":"<ul> <li>Added <code>brmspy.families</code> module with <code>brmsfamily()</code> and <code>family()</code> wrappers.</li> <li>Implemented keyword-argument wrappers for 40+ families: <code>student</code>, <code>bernoulli</code>, <code>beta_binomial</code>, <code>negbinomial</code>, <code>geometric</code>, <code>lognormal</code>, <code>shifted_lognormal</code>, <code>skew_normal</code>, <code>exponential</code>, <code>weibull</code>, <code>frechet</code>, <code>gen_extreme_value</code>, <code>exgaussian</code>, <code>wiener</code>, <code>Beta</code>, <code>dirichlet</code>, <code>logistic_normal</code>, <code>von_mises</code>, <code>asym_laplace</code>, <code>cox</code>, <code>hurdle_*</code>, <code>zero_inflated_*</code>, <code>categorical</code>, <code>multinomial</code>, <code>cumulative</code>, <code>sratio</code>, <code>cratio</code>, <code>acat</code>.</li> </ul>"},{"location":"changelog/#priors","title":"Priors","text":"<ul> <li><code>default_prior()</code>: Retrieve default priors for a model formula and dataset.</li> <li><code>get_prior()</code>: Inspect prior structure before fitting.</li> </ul>"},{"location":"changelog/#internal","title":"Internal","text":"<ul> <li>Reorganized brms wrappers into modular files under <code>brmspy/brms_functions/</code>.</li> <li>Added <code>RListVectorExtension</code> protocol for automatic R list extraction in type conversion.</li> </ul>"},{"location":"changelog/#0111-persistent-runtimes-logging","title":"0.1.11 - Persistent Runtimes &amp; Logging","text":"<p>25.12.01</p>"},{"location":"changelog/#new-features_2","title":"New Features","text":"<ul> <li>Persistent Runtimes: Activated runtime path saved to <code>~/.brmspy/config.json</code> and auto-loaded on import.</li> <li>Configurable Logging: Replaced print statements with centralized logger.</li> <li>Optimized Activation: Made aggressive unloading conditional for faster runtime activation.</li> </ul>"},{"location":"changelog/#0110-windows-stability-ci-improvements","title":"0.1.10 - Windows Stability &amp; CI Improvements","text":"<p>25.12.01</p>"},{"location":"changelog/#windows-support","title":"Windows Support","text":"<ul> <li>Implemented aggressive R package unloading (detach, unloadNamespace, DLL unload) to prevent file locking errors.</li> <li>Refined RTools detection; relaxed <code>g++</code> version requirements when valid RTools is detected.</li> <li>Changed <code>install_rtools</code> default to <code>False</code> in <code>install_brms()</code> to prevent unintended PATH modifications.</li> <li>Fixed PowerShell command syntax generation.</li> <li>Windows prebuilt binaries currently require R4.5.</li> </ul>"},{"location":"changelog/#build-ci","title":"Build &amp; CI","text":"<ul> <li>Expanded CI matrix: Windows, macOS, Ubuntu on Python 3.12.</li> <li>Optimized GitHub Actions caching for R libraries and CmdStan.</li> <li>Fixed artifact pruning logic in runtime builder workflows.</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Ensured <code>jsonlite</code> dependency is explicitly resolved during manifest generation.</li> <li>Fixed workflow path referencing and quoting issues.</li> </ul>"},{"location":"changelog/#019-prebuilt-runtimes-windows-toolchain","title":"0.1.9 - Prebuilt Runtimes &amp; Windows Toolchain","text":"<p>25.11.30</p>"},{"location":"changelog/#new-features_3","title":"New Features","text":"<ul> <li>Prebuilt Runtimes: Added <code>brmspy.binaries</code> subpackage for precompiled R environments with <code>brms</code> and <code>cmdstanr</code> (up to 50x faster install).</li> <li>Fast Installation: Added <code>use_prebuilt_binaries=True</code> argument to <code>install_brms()</code>.</li> <li>Windows Toolchain: Automatic Rtools (MinGW-w64) detection and installation in <code>install_brms()</code>.</li> </ul>"},{"location":"changelog/#enhancements","title":"Enhancements","text":"<ul> <li>Linux Binaries: Prioritize Posit Package Manager (P3M) binary repositories based on OS codename.</li> <li>Documentation: Added docstrings to all public and internal functions.</li> </ul>"},{"location":"changelog/#infrastructure","title":"Infrastructure","text":"<ul> <li>Added <code>.runtime_builder</code> Dockerfiles for reproducible Linux runtime environments.</li> </ul>"},{"location":"changelog/#018-rstan-support-version-pinning","title":"0.1.8 - RStan Support &amp; Version Pinning","text":"<p>25.11.29</p>"},{"location":"changelog/#new-features_4","title":"New Features","text":"<ul> <li>RStan Backend: Added <code>rstan</code> as alternative backend. <code>install_brms()</code> accepts <code>install_rstan</code> param; <code>fit()</code> accepts <code>backend=\"rstan\"</code>.</li> <li>Version Pinning: <code>install_brms()</code> supports pinning specific R package versions (e.g., <code>version=\"2.21.0\"</code>) via <code>remotes</code>.</li> </ul>"},{"location":"changelog/#platform-support","title":"Platform Support","text":"<ul> <li>Windows Toolchain: Automatic Rtools detection and setup in <code>install_brms()</code>.</li> <li>macOS/Windows Binaries: Fixed installation failures by defaulting to <code>type=\"both\"</code> instead of forcing source compilation.</li> </ul>"},{"location":"changelog/#infrastructure_1","title":"Infrastructure","text":"<ul> <li>Added cross-platform CI workflow (Windows, macOS, Ubuntu).</li> </ul>"},{"location":"changelog/#017-import-fixes","title":"0.1.7 - Import Fixes","text":"<p>25.11.29</p> <ul> <li>Fixed library refusing import when R dependencies are missing.</li> <li>R libraries now automatically imported after installation.</li> </ul>"},{"location":"changelog/#016-segfault-fix-stability","title":"0.1.6 - Segfault Fix &amp; Stability","text":"<p>25.11.29</p>"},{"location":"changelog/#core-stability","title":"Core Stability","text":"<ul> <li>Fixed segfault occurring when <code>fit()</code> was called inside <code>tqdm</code> loops or repeated call contexts.</li> <li>All R imports (<code>brms</code>, <code>cmdstanr</code>, <code>posterior</code>) now performed once at module import, never inside functions.</li> </ul>"},{"location":"changelog/#performance","title":"Performance","text":"<ul> <li>Repeated model fits now faster due to eliminated R namespace reloads.</li> <li>Reduced memory churn by removing redundant converter/namespace setup.</li> </ul>"},{"location":"changelog/#testing_1","title":"Testing","text":"<ul> <li>Added <code>test_fit_tqdm_segfault()</code> regression test.</li> </ul>"},{"location":"changelog/#015-priors-formula-helper-typed-arviz","title":"0.1.5 - Priors, Formula Helper, Typed ArviZ","text":"<p>25.11.28</p>"},{"location":"changelog/#api-types","title":"API &amp; Types","text":"<ul> <li><code>formula()</code>: Added helper for building reusable model formulas with kwargs support.</li> <li>Typed ArviZ Aliases: Added <code>IDFit</code>, <code>IDPredict</code>, <code>IDLinpred</code>, <code>IDLogLik</code>, <code>IDEpred</code> for different <code>InferenceData</code> shapes.</li> <li>Exported Types: <code>FitResult</code>, <code>PosteriorEpredResult</code>, <code>PosteriorPredictResult</code>, <code>PosteriorLinpredResult</code>, <code>LogLikResult</code>, <code>GenericResult</code> now in public API.</li> </ul>"},{"location":"changelog/#priors_1","title":"Priors","text":"<ul> <li><code>prior()</code> Helper: Now recommended way to specify priors instead of raw tuples.</li> <li>Improved internal prior-building logic for better mapping to <code>brms::set_prior()</code>.</li> <li>Supports <code>class_</code>, <code>coef</code>, <code>group</code>, <code>dpar</code> combinations.</li> </ul>"},{"location":"changelog/#internal_1","title":"Internal","text":"<ul> <li>Improved <code>fit()</code> kwargs parsing for more robust forwarding to <code>brms</code>/<code>cmdstanr</code>.</li> <li>Expanded test coverage for priors, <code>get_stancode</code>, <code>summary</code>, and fit-without-sampling paths.</li> </ul>"},{"location":"api/brms/","title":"Main Module","text":"<p>Main brms module with Pythonic API.</p>"},{"location":"api/brms/#brmspy.brms-classes","title":"Classes","text":""},{"location":"api/brms/#brmspy.brms.FitResult","title":"<code>FitResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from fit() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with posterior, posterior_predictive, log_likelihood, and observed_data groups</p> <code>r</code> <code>ListVector</code> <p>brmsfit R object from brms::brm()</p>"},{"location":"api/brms/#brmspy.brms.FormulaResult","title":"<code>FormulaResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from formula() function.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R brmsformula object</p> <code>dict</code> <code>Dict</code> <p>Python dictionary representation of formula</p> See Also <p>brmspy.brms.formula : Creates FormulaResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\n# Create formula with options\nf = brms.formula(\"y ~ x\", decomp=\"QR\")\n\n# Use in fit()\nmodel = brms.fit(f, data=df, chains=4)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.GenericResult","title":"<code>GenericResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Generic result container with arviz and R objects.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData object</p> <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/brms/#brmspy.brms.LogLikResult","title":"<code>LogLikResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from log_lik() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>IDLogLik</code> <p>arviz InferenceData with log-likelihood values</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::log_lik()</p> See Also <p>brmspy.brms.log_lik : Creates LogLikResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nmodel = brms.fit(\"y ~ x\", data=df, chains=4)\nloglik = brms.log_lik(model)\n\n# Use for model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.LooResult","title":"<code>LooResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p>"},{"location":"api/brms/#brmspy.brms.LooResult-functions","title":"Functions","text":""},{"location":"api/brms/#brmspy.brms.LooResult.__repr__","title":"<code>__repr__()</code>","text":"<p>Pretty print LOO-CV results.</p>"},{"location":"api/brms/#brmspy.brms.PosteriorEpredResult","title":"<code>PosteriorEpredResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from posterior_epred() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with expected values in 'posterior' group</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_epred()</p>"},{"location":"api/brms/#brmspy.brms.PosteriorLinpredResult","title":"<code>PosteriorLinpredResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from posterior_linpred() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>IDLinpred</code> <p>arviz InferenceData with linear predictor values</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_linpred()</p> See Also <p>brmspy.brms.posterior_linpred : Creates PosteriorLinpredResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.fit(\"count ~ age\", data=df, family=\"poisson\", chains=4)\nlinpred = brms.posterior_linpred(model)\n\n# Linear predictor on log scale (for Poisson)\nprint(linpred.idata.predictions)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.PosteriorPredictResult","title":"<code>PosteriorPredictResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from posterior_predict() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with predictions in 'posterior_predictive' group</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_predict()</p>"},{"location":"api/brms/#brmspy.brms.RListVectorExtension","title":"<code>RListVectorExtension</code>  <code>dataclass</code>","text":"<p>Generic result container with R objects.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/brms/#brmspy.brms.IDLinpred","title":"<code>IDLinpred</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_linpred results.</p> <p>Contains linear predictor values (before applying link function).</p> <p>Attributes:</p> Name Type Description <code>predictions</code> <code>Dataset</code> <p>Linear predictor samples</p> See Also <p>brmspy.brms.posterior_linpred : Creates IDLinpred objects</p>"},{"location":"api/brms/#brmspy.brms.IDEpred","title":"<code>IDEpred</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_epred results.</p> <p>Contains expected values E[Y|X] without observation noise.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Expected value samples (no observation noise)</p> See Also <p>brmspy.brms.posterior_epred : Creates IDEpred objects</p>"},{"location":"api/brms/#brmspy.brms.IDFit","title":"<code>IDFit</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for fitted brms models.</p> <p>Extends arviz.InferenceData with type hints for IDE autocomplete. Guarantees the presence of specific data groups returned by <code>fit()</code>.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Posterior samples of model parameters</p> <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (with observation noise)</p> <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation</p> <code>observed_data</code> <code>Dataset</code> <p>Original observed response data</p> <code>coords</code> <code>dict</code> <p>Coordinate mappings for dimensions</p> <code>dims</code> <code>dict</code> <p>Dimension specifications for variables</p> See Also <p>brmspy.brms.fit : Creates IDFit objects arviz.InferenceData : Base class documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\nmodel = brms.fit(\"y ~ x\", data=df, chains=4)\n\n# Type checking and autocomplete\nassert isinstance(model.idata, IDFit)\nprint(model.idata.posterior)  # IDE autocomplete works!\n</code></pre>"},{"location":"api/brms/#brmspy.brms.IDLogLik","title":"<code>IDLogLik</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for log_lik results.</p> <p>Contains log-likelihood values for model comparison.</p> <p>Attributes:</p> Name Type Description <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation</p> See Also <p>brmspy.brms.log_lik : Creates IDLogLik objects arviz.loo : LOO-CV using log-likelihood</p>"},{"location":"api/brms/#brmspy.brms.IDPredict","title":"<code>IDPredict</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_predict results.</p> <p>Contains posterior predictive samples with observation noise.</p> <p>Attributes:</p> Name Type Description <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (includes observation noise)</p> See Also <p>brmspy.brms.posterior_predict : Creates IDPredict objects</p>"},{"location":"api/brms/#brmspy.brms.PriorSpec","title":"<code>PriorSpec</code>  <code>dataclass</code>","text":"<p>Python representation of a brms prior specification.</p> <p>This dataclass provides a typed interface to brms::prior_string() arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the <code>prior()</code> factory function to create instances.</p> <p>Attributes:</p> Name Type Description <code>prior</code> <code>str</code> <p>Prior distribution as string (e.g., \"normal(0, 1)\", \"exponential(2)\")</p> <code>class_</code> <code>(str, optional)</code> <p>Parameter class: \"b\" (fixed effects), \"sd\" (group SD), \"Intercept\", \"sigma\", \"cor\", etc.</p> <code>coef</code> <code>(str, optional)</code> <p>Specific coefficient name for class-level priors</p> <code>group</code> <code>(str, optional)</code> <p>Grouping variable for hierarchical effects</p> <code>dpar</code> <code>(str, optional)</code> <p>Distributional parameter (e.g., \"sigma\", \"phi\", \"zi\")</p> <code>resp</code> <code>(str, optional)</code> <p>Response variable for multivariate models</p> <code>nlpar</code> <code>(str, optional)</code> <p>Non-linear parameter name</p> <code>lb</code> <code>(float, optional)</code> <p>Lower bound for truncated priors</p> <code>ub</code> <code>(float, optional)</code> <p>Upper bound for truncated priors</p> See Also <p>prior : Factory function to create PriorSpec instances brms::prior_string : R documentation     https://paulbuerkner.com/brms/reference/prior_string.html</p> <p>Examples:</p> <p>Create prior specifications (prefer using <code>prior()</code> function):</p> <pre><code>from brmspy.types import PriorSpec\n\n# Fixed effect prior\np1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n# Group-level SD prior\np2 = PriorSpec(\n    prior=\"exponential(2)\",\n    class_=\"sd\",\n    group=\"patient\"\n)\n\n# Coefficient-specific prior with bounds\np3 = PriorSpec(\n    prior=\"normal(0, 1)\",\n    class_=\"b\",\n    coef=\"age\",\n    lb=0  # Truncated at zero\n)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.PriorSpec-functions","title":"Functions","text":""},{"location":"api/brms/#brmspy.brms.PriorSpec.to_brms_kwargs","title":"<code>to_brms_kwargs()</code>","text":"<p>Convert PriorSpec to keyword arguments for brms::prior_string().</p> <p>Maps Python dataclass fields to R function arguments, handling the <code>class_</code> -&gt; <code>class</code> parameter name conversion.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keyword arguments ready for brms::prior_string()</p> <p>Examples:</p> <pre><code>from brmspy import prior\np = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\nkwargs = p.to_brms_kwargs()\nprint(kwargs)\n# {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n</code></pre>"},{"location":"api/brms/#brmspy.brms-functions","title":"Functions","text":""},{"location":"api/brms/#brmspy.brms.get_brms_data","title":"<code>get_brms_data(dataset_name, **kwargs)</code>","text":"<p>Load an example dataset from the R <code>brms</code> package.</p> <p>This is a convenience wrapper around :func:<code>get_data</code> that fixes <code>package=\"brms\"</code> and returns the dataset as a :class:<code>pandas.DataFrame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Name of the example dataset in the <code>brms</code> package (e.g. <code>\"epilepsy\"</code>, <code>\"kidney\"</code>, <code>\"inhaler\"</code>).</p> required <code>**kwargs</code> <p>Additional keyword arguments forwarded to :func:<code>get_data</code> and ultimately to R's <code>data()</code> function. These can be used to override defaults such as the target environment.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset as a pandas DataFrame with column names preserved.</p> See Also <p>get_data     Generic loader for datasets from arbitrary R packages. brms R reference     For a list of available example datasets and their structure.</p> <p>Examples:</p> <p>Load the epilepsy dataset::</p> <pre><code>from brmspy.runtime import get_brms_data\n\nepilepsy = get_brms_data(\"epilepsy\")\nprint(epilepsy.head())\n</code></pre> <p>Load the kidney dataset and inspect censoring::</p> <pre><code>kidney = get_brms_data(\"kidney\")\nprint(kidney.shape)\nprint(kidney[\"censored\"].value_counts())\n</code></pre>"},{"location":"api/brms/#brmspy.brms.read_rds_fit","title":"<code>read_rds_fit(file, **kwargs)</code>","text":"<p>Load saved brmsfit object as FitResult with arviz InferenceData.</p> <p>Reads a brmsfit object from an RDS file and converts it to a FitResult with both arviz InferenceData (.idata) and the raw R object (.r). This is the recommended way to load saved brms models for analysis and predictions in Python.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to RDS file containing saved brmsfit object</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to R's readRDS():</p> <ul> <li>refhook : function - Reference hook for deserialization</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Object with two attributes: - .idata : arviz.InferenceData with posterior samples and diagnostics - .r : R brmsfit object for use with brms functions</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If file doesn't exist or doesn't contain a valid brmsfit object</p> See Also <p>save_rds : Save brmsfit objects to RDS files read_rds_raw : Load as raw R object without conversion fit : Create brmsfit objects to save</p> <p>Examples:</p> <p>Basic loading and analysis:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\n# Load previously saved model\nmodel = brms.read_rds_fit(\"my_model.rds\")\n\n# Analyze with arviz\naz.summary(model.idata)\naz.plot_trace(model.idata)\n\n# Check diagnostics\nprint(az.rhat(model.idata))\n</code></pre> <p>Load and make predictions:</p> <pre><code>import pandas as pd\n\n# Load saved model\nmodel = brms.read_rds_fit(\"trained_model.rds\")\n\n# Create new data for predictions\nnewdata = pd.DataFrame({\n    'x': [1.0, 2.0, 3.0],\n    'group': ['A', 'B', 'A']\n})\n\n# Generate predictions\npredictions = brms.posterior_predict(model, newdata=newdata)\nprint(predictions.idata.posterior_predictive)\n</code></pre> <p>Load model for comparison:</p> <pre><code># Load multiple saved models\nmodel1 = brms.read_rds_fit(\"model1.rds\")\nmodel2 = brms.read_rds_fit(\"model2.rds\")\n\n# Compare with arviz\ncomparison = az.compare({\n    'model1': model1.idata,\n    'model2': model2.idata\n})\nprint(comparison)\n</code></pre> <p>Resume analysis from checkpoint:</p> <pre><code># Load model from checkpoint during long computation\ntry:\n    model = brms.read_rds_fit(\"checkpoint.rds\")\n    print(\"Loaded from checkpoint\")\nexcept:\n    # Checkpoint doesn't exist, fit from scratch\n    model = brms.fit(formula=\"y ~ x\", data=data, chains=4)\n    brms.save_rds(model, \"checkpoint.rds\")\n\n# Continue analysis\nsummary = brms.summary(model)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.read_rds_raw","title":"<code>read_rds_raw(file, **kwargs)</code>","text":"<p>Load R object from RDS file as raw ListVector.</p> <p>Reads an RDS file and returns the raw R object without any Python conversion or processing. Useful when you need direct access to the R object structure or want to inspect saved objects before full conversion.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to RDS file to load</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to R's readRDS():</p> <ul> <li>refhook : function - Reference hook for deserialization</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>ListVector</code> <p>Raw R ListVector object from the RDS file</p> See Also <p>read_rds_fit : Load as FitResult with arviz InferenceData save_rds : Save R objects to RDS files</p> <p>Examples:</p> <p>Load raw R object:</p> <pre><code>from brmspy import brms\n\n# Load raw brmsfit object\nraw_model = brms.read_rds_raw(\"model.rds\")\n\n# Access R object directly (for advanced users)\nprint(type(raw_model))  # rpy2.robjects.vectors.ListVector\n</code></pre> <p>Inspect object structure before conversion:</p> <pre><code># Load raw to check what's in the file\nraw_obj = brms.read_rds_raw(\"unknown_object.rds\")\n\n# Inspect R object attributes\nprint(raw_obj.names)\n\n# Then decide how to process it\nif \"fit\" in raw_obj.names:\n    # It's a brmsfit, convert properly\n    full_model = brms.read_rds_fit(\"unknown_object.rds\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.save_rds","title":"<code>save_rds(object, file, **kwargs)</code>","text":"<p>Save brmsfit object or R object to RDS file.</p> <p>Saves fitted brms models or other R objects to disk using R's saveRDS() function. This allows persisting models for later use, sharing fitted models, or creating model checkpoints during long computations.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Object to save. Can be: - FitResult from fit() - saves the underlying brmsfit R object - Any R ListVector object</p> required <code>file</code> <code>str</code> <p>File path where object will be saved. Typically uses .rds extension but not required</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to R's saveRDS():</p> <ul> <li>compress : bool or str - Compression method:     True (default), False, \"gzip\", \"bzip2\", \"xz\"</li> <li>version : int - RDS format version (2 or 3)</li> <li>ascii : bool - Use ASCII representation (default False)</li> <li>refhook : function - Reference hook for serialization (NOT tested)</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> See Also <p>read_rds_fit : Load saved brmsfit as FitResult read_rds_raw : Load saved object as raw R ListVector fit : Fit models that can be saved</p> <p>Examples:</p> <p>Save a fitted model:</p> <pre><code>from brmspy import brms\n\n# Fit model\nmodel = brms.fit(\n    formula=\"y ~ x + (1|group)\",\n    data=data,\n    family=\"gaussian\",\n    chains=4\n)\n\n# Save to file\nbrms.save_rds(model, \"my_model.rds\")\n</code></pre> <p>Save with compression options:</p> <pre><code># High compression for storage\nbrms.save_rds(model, \"model.rds\", compress=\"xz\")\n\n# No compression for faster saving\nbrms.save_rds(model, \"model.rds\", compress=False)\n</code></pre> <p>Save and later reload:</p> <pre><code># Save model\nbrms.save_rds(model, \"model.rds\")\n\n# Later session: reload model\nloaded_model = brms.read_rds_fit(\"model.rds\")\n\n# Use loaded model for predictions\npredictions = brms.posterior_predict(loaded_model, newdata=new_data)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.get_data","title":"<code>get_data(dataset_name, **kwargs)</code>","text":"<p>Load an R dataset and return it as a pandas DataFrame.</p> <p>This is a thin wrapper around R's <code>data()</code> that loads the object into the R global environment and converts it to a :class:<code>pandas.DataFrame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Name of the dataset as used in R (e.g. <code>\"BTdata\"</code>).</p> required <code>**kwargs</code> <p>Additional keyword arguments forwarded to R's <code>data()</code> function, for example <code>package=\"MCMCglmm\"</code> or other arguments supported by <code>utils::data()</code> in R.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset converted to a pandas DataFrame.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the dataset is not found in the R global environment after calling <code>data()</code>.</p> <code>RuntimeError</code> <p>If conversion from the R object to a pandas DataFrame fails.</p> See Also <p>get_brms_data     Convenience wrapper for datasets from the <code>brms</code> package.</p>"},{"location":"api/brms/#brmspy.brms.prior","title":"<code>prior(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None, **kwargs)</code>","text":"<p>Create a brms-style prior specification.</p> <p>This function mirrors the behavior of <code>brms::prior_string()</code> and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of <code>prior_string()</code> in brms.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>str</code> <p>The prior definition as a string, exactly as brms expects it. Examples include ::</p> <pre><code>\"normal(0, 1)\"\n\"student_t(3, 0, 1.5)\"\n\"exponential(2)\"\n\"lkj(2)\"\n</code></pre> required <code>class_</code> <code>str</code> <p>Parameter class (e.g. <code>\"b\"</code>, <code>\"sd\"</code>, <code>\"Intercept\"</code>). This corresponds to <code>class</code> in brms. <code>class</code> cannot be used as a parameter in Python (reserved keyword), so <code>class_</code> is used instead.</p> <code>None</code> <code>coef</code> <code>str</code> <p>Coefficient name for class-level effects.</p> <code>None</code> <code>group</code> <code>str</code> <p>Grouping variable for hierarchical/multilevel effects.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Distributional parameter (e.g. <code>\"sigma\"</code> or <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response variable name for multivariate models.</p> <code>None</code> <code>nlpar</code> <code>str</code> <p>Nonlinear parameter name if using nonlinear formulas.</p> <code>None</code> <code>lb</code> <code>float</code> <p>Lower bound for truncated priors.</p> <code>None</code> <code>ub</code> <code>float</code> <p>Upper bound for truncated priors.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Any additional keyword arguments supported by <code>brms::prior_string()</code>. These are forwarded unchanged.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriorSpec</code> <p>A typed prior specification object used by <code>brmspy.fit()</code> and <code>brmspy.make_stancode()</code>.</p> Notes <p>This function does not validate the prior expression string itself \u2014 validation occurs inside brms. Its purpose is to construct a structured, editor-friendly representation that seamlessly maps to rpy2 calls.</p> <p>Examples:</p> <p>Prior on the intercept ::</p> <pre><code>p = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\")\n</code></pre> <p>Prior on a coefficient ::</p> <pre><code>p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n</code></pre> <p>Group-level (hierarchical) SD prior ::</p> <pre><code>p = prior(\"exponential(2)\", class_=\"sd\", group=\"region\")\n</code></pre> <p>Truncated prior ::</p> <pre><code>p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0)\n</code></pre> <p>Multiple priors passed to <code>fit</code> ::</p> <pre><code>from brmspy import prior\npriors = [\n    prior(\"student_t(3, 0, 2)\", class_=\"b\", coef=\"zAge\"),\n    prior(\"exponential(2)\", class_=\"sd\", group=\"patient\"),\n]\nmodel = brms.fit(\"y ~ zAge + (1|patient)\", data=df, priors=priors)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.get_prior","title":"<code>get_prior(formula, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for all model parameters.</p> <p>Returns a DataFrame with default priors for each parameter class in the specified brms model. Useful for reviewing and customizing priors before fitting.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaResult</code> <p>Model formula (e.g., \"y ~ x + (1|group)\") or FormulaResult object</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\")</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row represents a parameter or parameter class that can have a custom prior.</p> See Also <p>default_prior : Generic function for getting default priors prior : Create custom prior specifications brms::get_prior : R documentation     https://paulbuerkner.com/brms/reference/get_prior.html</p> <p>Examples:</p> <p>Review default priors for a model:</p> <pre><code>from brmspy import brms\n\npriors = brms.get_prior(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\nprint(priors)\n#   prior       class    coef      group  ...\n#   student_t() Intercept  ...    ...     ...\n#   (flat)      b          zAge    ...    ...\n</code></pre> <p>Customize and use priors:</p> <pre><code>from brmspy import brms, prior\n\n# Get defaults\npriors_df = brms.get_prior(\"y ~ x\", data=df)\n\n# Create custom priors based on review\ncustom_priors = [\n    prior(\"normal(0, 0.5)\", class_=\"b\"),\n    prior(\"exponential(2)\", class_=\"sigma\")\n]\n\nmodel = brms.fit(\"y ~ x\", data=df, priors=custom_priors)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.default_prior","title":"<code>default_prior(object, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for brms model parameters (generic function).</p> <p>Generic function to retrieve default prior specifications for all parameters in a brms model. Accepts formula objects, brmsformula objects, or other model specification objects. This is the generic version of get_prior().</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>str, FormulaResult, or ListVector</code> <p>Model specification: formula string, brmsformula object, mvbrmsformula, or any object that can be coerced to these classes</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\"). Can be a list of families for multivariate models</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels, sparse)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row specifies a parameter class with its default prior. The 'prior' column is empty except for internal defaults.</p> See Also <p>get_prior : Convenience function with formula parameter prior : Create custom prior specifications brms::default_prior : R documentation     https://paulbuerkner.com/brms/reference/get_prior.html</p> <p>Examples:</p> <p>Get default priors for a Poisson model:</p> <pre><code>from brmspy import brms\n\npriors = brms.default_prior(\n    object=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\nprint(priors)\n</code></pre> <p>Use with formula object:</p> <pre><code>from brmspy import brms\n\nf = brms.formula(\"y ~ x + (1|group)\")\npriors = brms.default_prior(f, data=df, family=\"gaussian\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.brm","title":"<code>brm(formula, data, priors=None, family='gaussian', sample_prior='no', sample=True, backend='cmdstanr', formula_args=None, cores=2, **brm_args)</code>","text":"<p>Fit Bayesian regression model using brms.</p> <p>Uses brms with cmdstanr backend for proper parameter naming. Returns FitResult with .idata (arviz.InferenceData) and .r (brmsfit) attributes.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>brms formula: formula string, e.g \"y ~ x + (1|group)\" or FormulaResult from formula()</p> required <code>data</code> <code>dict or DataFrame</code> <p>Model data</p> required <code>priors</code> <code>list</code> <p>Prior specifications: [(\"normal(0,1)\", \"b\"), (\"cauchy(0,2)\", \"sd\")]</p> <code>[]</code> <code>family</code> <code>str</code> <p>Distribution family: \"gaussian\", \"poisson\", \"binomial\", etc.</p> <code>\"gaussian\"</code> <code>sample_prior</code> <code>str</code> <p>Sample from prior: \"no\", \"yes\", \"only\"</p> <code>\"no\"</code> <code>sample</code> <code>bool</code> <p>Whether to sample. If False, returns compiled model with empty=TRUE</p> <code>True</code> <code>backend</code> <code>str</code> <p>Stan backend: \"cmdstanr\" (recommended), \"rstan\"</p> <code>\"cmdstanr\"</code> <code>**brm_args</code> <p>Additional brms::brm() arguments: chains=4, iter=2000, warmup=1000, cores=4, seed=123, thin=1, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Object with .idata (arviz.InferenceData) and .r (brmsfit) attributes</p> See Also <p>brms::brm : R documentation     https://paulbuerkner.com/brms/reference/brm.html posterior_epred : Expected value predictions posterior_predict : Posterior predictive samples formula : Create formula object with options</p> Warnings <p><code>cores &lt;= 1</code> is unsafe in embedded R sessions. The single-process code path used by <code>brms::brm()</code> can crash the interpreter. Always use <code>cores &gt;= 2</code> to force parallel workers and avoid segfaults.</p> <p>Examples:</p> <p>Basic Poisson regression:</p> <p><pre><code>from brmspy import brms\nimport arviz as az\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    chains=4,\n    iter=2000\n)\n\naz.summary(model.idata)\n</code></pre> With custom priors:</p> <p><pre><code>from brmspy import prior\n\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    priors=[\n        prior(\"normal(0, 0.5)\", class_=\"b\"),\n        prior(\"exponential(2)\", class_=\"sd\", group=\"patient\")\n    ],\n    family=\"poisson\",\n    chains=4\n)\n</code></pre> Survival model with censoring:</p> <p><pre><code>kidney = brms.get_brms_data(\"kidney\")\n\nsurvival_model = brms.fit(\n    formula=\"time | cens(censored) ~ age + sex + disease + (1|patient)\",\n    data=kidney,\n    family=\"weibull\",\n    chains=4,\n    iter=4000,\n    warmup=2000,\n    cores=4,\n    seed=42\n)\n</code></pre> Gaussian model with distributional regression:</p> <pre><code>    # Model both mean and variance\n    model = brms.fit(\n        formula=brms.formula(\n            \"y ~ x\",\n            sigma ~ \"z\"  # Model heteroscedasticity\n        ),\n        data=data,\n        family=\"gaussian\",\n        chains=4\n    )\n</code></pre>"},{"location":"api/brms/#brmspy.brms.fit","title":"<code>fit(formula, data, priors=None, family='gaussian', sample_prior='no', sample=True, backend='cmdstanr', formula_args=None, cores=2, **brm_args)</code>","text":"<p>Fit Bayesian regression model using brms.</p> <p>Uses brms with cmdstanr backend for proper parameter naming. Returns FitResult with .idata (arviz.InferenceData) and .r (brmsfit) attributes.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>brms formula: formula string, e.g \"y ~ x + (1|group)\" or FormulaResult from formula()</p> required <code>data</code> <code>dict or DataFrame</code> <p>Model data</p> required <code>priors</code> <code>list</code> <p>Prior specifications: [(\"normal(0,1)\", \"b\"), (\"cauchy(0,2)\", \"sd\")]</p> <code>[]</code> <code>family</code> <code>str</code> <p>Distribution family: \"gaussian\", \"poisson\", \"binomial\", etc.</p> <code>\"gaussian\"</code> <code>sample_prior</code> <code>str</code> <p>Sample from prior: \"no\", \"yes\", \"only\"</p> <code>\"no\"</code> <code>sample</code> <code>bool</code> <p>Whether to sample. If False, returns compiled model with empty=TRUE</p> <code>True</code> <code>backend</code> <code>str</code> <p>Stan backend: \"cmdstanr\" (recommended), \"rstan\"</p> <code>\"cmdstanr\"</code> <code>**brm_args</code> <p>Additional brms::brm() arguments: chains=4, iter=2000, warmup=1000, cores=4, seed=123, thin=1, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Object with .idata (arviz.InferenceData) and .r (brmsfit) attributes</p> See Also <p>brms::brm : R documentation     https://paulbuerkner.com/brms/reference/brm.html posterior_epred : Expected value predictions posterior_predict : Posterior predictive samples formula : Create formula object with options</p> Warnings <p><code>cores &lt;= 1</code> is unsafe in embedded R sessions. The single-process code path used by <code>brms::brm()</code> can crash the interpreter. Always use <code>cores &gt;= 2</code> to force parallel workers and avoid segfaults.</p> <p>Examples:</p> <p>Basic Poisson regression:</p> <p><pre><code>from brmspy import brms\nimport arviz as az\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    chains=4,\n    iter=2000\n)\n\naz.summary(model.idata)\n</code></pre> With custom priors:</p> <p><pre><code>from brmspy import prior\n\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    priors=[\n        prior(\"normal(0, 0.5)\", class_=\"b\"),\n        prior(\"exponential(2)\", class_=\"sd\", group=\"patient\")\n    ],\n    family=\"poisson\",\n    chains=4\n)\n</code></pre> Survival model with censoring:</p> <p><pre><code>kidney = brms.get_brms_data(\"kidney\")\n\nsurvival_model = brms.fit(\n    formula=\"time | cens(censored) ~ age + sex + disease + (1|patient)\",\n    data=kidney,\n    family=\"weibull\",\n    chains=4,\n    iter=4000,\n    warmup=2000,\n    cores=4,\n    seed=42\n)\n</code></pre> Gaussian model with distributional regression:</p> <pre><code>    # Model both mean and variance\n    model = brms.fit(\n        formula=brms.formula(\n            \"y ~ x\",\n            sigma ~ \"z\"  # Model heteroscedasticity\n        ),\n        data=data,\n        family=\"gaussian\",\n        chains=4\n    )\n</code></pre>"},{"location":"api/brms/#brmspy.brms.summary","title":"<code>summary(model, **kwargs)</code>","text":"<p>Generate comprehensive summary statistics for fitted brms model.</p> <p>Returns a <code>SummaryResult</code> dataclass containing model information, parameter estimates, and diagnostic information. The SummaryResult object provides pretty printing via <code>str()</code> or <code>print()</code> and structured access to all components.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from <code>fit()</code></p> required <code>**kwargs</code> <p>Additional arguments passed to brms::summary(), such as: - probs: Quantiles for credible intervals, e.g., <code>probs=(0.025, 0.975)</code> - robust: Use robust estimates (median, MAD), default False</p> <code>{}</code> <p>Returns:</p> Type Description <code>SummaryResult</code> <p>A dataclass containing:</p> <ul> <li>formula (str): Model formula as string</li> <li>data_name (str): Name of the data object used</li> <li>group (str): Grouping structure information</li> <li>nobs (int): Number of observations</li> <li>ngrps (Dict[str, int]): Number of groups per grouping variable</li> <li>autocor (Optional[dict]): Autocorrelation structure if present</li> <li>prior (pd.DataFrame): Prior specifications used</li> <li>algorithm (str): Sampling algorithm (e.g., \"sampling\")</li> <li>sampler (str): Sampler specification (e.g., \"sample(hmc)\")</li> <li>total_ndraws (int): Total number of post-warmup draws</li> <li>chains (float): Number of chains</li> <li>iter (float): Iterations per chain</li> <li>warmup (float): Warmup iterations per chain</li> <li>thin (float): Thinning interval</li> <li>has_rhat (bool): Whether Rhat diagnostics are reported</li> <li>fixed (pd.DataFrame): Population-level (fixed) effects estimates</li> <li>spec_pars (pd.DataFrame): Family-specific parameters (e.g., sigma)</li> <li>cor_pars (pd.DataFrame): Correlation parameters if present</li> <li>random (dict): Group-level (random) effects by grouping variable</li> </ul> See Also <p>brms::summary.brmsfit : R documentation     https://paulbuerkner.com/brms/reference/summary.brmsfit.html</p> <p>Examples:</p> <p>Basic usage with pretty printing:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x\", data=data, chains=4)\nsummary = brmspy.summary(model)\n\n# Pretty print full summary\nprint(summary)\n</code></pre> <p>Access specific components:</p> <pre><code># Get population-level effects as DataFrame\nfixed_effects = summary.fixed\nprint(fixed_effects)\n\n# Get family-specific parameters (e.g., sigma)\nspec_params = summary.spec_pars\nprint(spec_params)\n\n# Access random effects (if present)\nrandom_effects = summary.random\nfor group_name, group_df in random_effects.items():\n    print(f\"Random effects for {group_name}:\")\n    print(group_df)\n\n# Check model metadata\nprint(f\"Formula: {summary.formula}\")\nprint(f\"Total draws: {summary.total_ndraws}\")\nprint(f\"Rhat reported: {summary.has_rhat}\")\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Use 90% credible intervals instead of default 95%\nsummary_90 = brmspy.summary(model, probs=(0.05, 0.95))\nprint(summary_90.fixed)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.fixef","title":"<code>fixef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, **kwargs)</code>","text":"<p>Extract population-level (fixed) effects estimates from a fitted brms model.</p> <p>Returns a pandas DataFrame containing estimates and uncertainty intervals for all population-level parameters (fixed effects). By default, returns summary statistics (mean, standard error, credible intervals). Can also return raw posterior samples when <code>summary=False</code>.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>summary</code> <code>bool</code> <p>If True, return summary statistics (mean/median, SE/MAD, credible intervals). If False, return matrix of posterior samples (iterations \u00d7 parameters).</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics. Only used when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>list of str</code> <p>Specific parameter names to extract. If None, returns all fixed effects. Useful for subsetting when you only need specific coefficients.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::fixef()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>When <code>summary=True</code> (default):     DataFrame with parameters as rows and columns for Estimate, Est.Error,     Q2.5, Q97.5 (or other quantiles specified in <code>probs</code>), and optionally     Rhat and Bulk_ESS/Tail_ESS diagnostics.</p> <p>When <code>summary=False</code>:     DataFrame with posterior samples where rows are iterations and columns     are parameters. Shape is (n_iterations \u00d7 n_parameters).</p> See Also <p>brms::fixef.brmsfit : R documentation     https://paulbuerkner.com/brms/reference/fixef.brmsfit.html summary() : Full model summary with all parameter types</p> <p>Examples:</p> <p>Basic usage with summary statistics:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=data, chains=4)\n\n# Get fixed effects summary\nfixed_effects = brmspy.fixef(model)\nprint(fixed_effects)\n#             Estimate  Est.Error      Q2.5     Q97.5\n# Intercept  10.234567   0.123456  9.992345  10.47689\n# x1          0.456789   0.098765  0.263456   0.65012\n# x2         -0.234567   0.087654 -0.406789  -0.06234\n</code></pre> <p>Get specific parameters only:</p> <pre><code># Extract only specific coefficients\nx1_x2_effects = brmspy.fixef(model, pars=[\"x1\", \"x2\"])\nprint(x1_x2_effects)\n</code></pre> <p>Use robust estimates (median and MAD):</p> <pre><code># Use median and MAD instead of mean and SD\nrobust_effects = brmspy.fixef(model, robust=True)\nprint(robust_effects)\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Get 90% credible intervals\neffects_90 = brmspy.fixef(model, probs=(0.05, 0.95))\nprint(effects_90)\n</code></pre> <p>Get raw posterior samples:</p> <pre><code># Get full posterior samples matrix\nsamples = brmspy.fixef(model, summary=False)\nprint(samples.shape)  # (n_iterations, n_parameters)\n\n# Can then compute custom statistics\nimport numpy as np\ncustom_quantile = np.percentile(samples[\"x1\"], 90)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.ranef","title":"<code>ranef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, groups=None, **kwargs)</code>","text":"<p>Extract group-level (random) effects as xarray DataArrays.</p> <p>This is a wrapper around <code>brms::ranef()</code>. For <code>summary=True</code> (default), each grouping factor is returned as a 3D array with dimensions <code>(\"group\", \"stat\", \"coef\")</code>. For <code>summary=False</code>, each factor is returned as <code>(\"draw\", \"group\", \"coef\")</code> with one slice per posterior draw.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model returned by :func:<code>brmspy.brms.fit</code> or an R <code>brmsfit</code> object / summary list.</p> required <code>summary</code> <code>bool</code> <p>If True, return posterior summaries for the group-level effects (means, errors, intervals). If False, return per-draw random effects.</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use robust summaries (median and MAD) instead of mean and SD. Passed through to <code>brms::ranef()</code> when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Central posterior interval probabilities, as in <code>brms::ranef()</code>. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>str or sequence of str</code> <p>Subset of group-level parameters to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>groups</code> <code>str or sequence of str</code> <p>Subset of grouping factors to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments forwarded to <code>brms::ranef()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, DataArray]</code> <p>Mapping from grouping-factor name (e.g. <code>\"patient\"</code>) to a <code>DataArray</code>:</p> <ul> <li><code>summary=True</code>: dims <code>(\"group\", \"stat\", \"coef\")</code>,   with <code>stat</code> typically containing   <code>[\"Estimate\", \"Est.Error\", \"Q2.5\", \"Q97.5\"]</code>.</li> <li><code>summary=False</code>: dims <code>(\"draw\", \"group\", \"coef\")</code>,   where <code>draw</code> indexes posterior samples.</li> </ul> <p>Examples:</p> <p>Compute summary random effects and inspect all coefficients for a single group level:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms import ranef\n\nfit = brms.fit(\"count ~ zAge + zBase * Trt + (1 + zBase + Trt | patient)\",\n               data=data, family=\"poisson\")\n\nre = ranef(fit)  # summary=True by default\npatient_re = re[\"patient\"].sel(group=\"1\", stat=\"Estimate\")\n</code></pre> <p>Extract per-draw random effects for downstream MCMC analysis:</p> <pre><code>re_draws = ranef(fit, summary=False)\npatient_draws = re_draws[\"patient\"]       # dims: (\"draw\", \"group\", \"coef\")\nfirst_draw = patient_draws.sel(draw=0)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.posterior_summary","title":"<code>posterior_summary(object, variable=None, probs=(0.025, 0.975), robust=False, **kwargs)</code>","text":"<p>Extract posterior summary statistics for all or selected model parameters.</p> <p>Provides a DataFrame with estimates, standard errors, and credible intervals for all parameters in a brms model, including fixed effects, random effects, and auxiliary parameters. More comprehensive than <code>fixef()</code> or <code>ranef()</code> as it covers all parameter types.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>variable</code> <code>str or list of str</code> <p>Specific variable name(s) to extract. If None, returns all parameters. Supports regex patterns for flexible selection.</p> <code>None</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals.</p> <code>(0.025, 0.975)</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments passed to brms::posterior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with parameters as rows and columns for Estimate, Est.Error, and quantiles (e.g., Q2.5, Q97.5). Includes all model parameters: population-level effects, group-level effects, and auxiliary parameters.</p> See Also <p>brms::posterior_summary : R documentation     https://paulbuerkner.com/brms/reference/posterior_summary.brmsfit.html <code>fixef()</code> : Extract only population-level effects <code>ranef()</code> : Extract only group-level effects</p> <p>Examples:</p> <p>Get summary for all parameters:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + (1|group)\", data=data, chains=4)\n\n# Get all parameter summaries\nall_params = brmspy.posterior_summary(model)\nprint(all_params)\n</code></pre> <p>Extract specific parameters:</p> <pre><code># Get summary for specific parameters\nintercept = brmspy.posterior_summary(model, variable=\"b_Intercept\")\nprint(intercept)\n\n# Multiple parameters\nfixed_only = brmspy.posterior_summary(model, variable=[\"b_Intercept\", \"b_x1\"])\nprint(fixed_only)\n</code></pre> <p>Custom credible intervals with robust estimates:</p> <pre><code># 90% intervals with median/MAD\nrobust_summary = brmspy.posterior_summary(\n    model,\n    probs=(0.05, 0.95),\n    robust=True\n)\nprint(robust_summary)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.prior_summary","title":"<code>prior_summary(object, all=True, **kwargs)</code>","text":"<p>Extract prior specifications used in a fitted brms model.</p> <p>Returns a DataFrame containing all prior distributions that were used (either explicitly set or defaults) when fitting the model. Useful for documenting model specifications and understanding which priors were applied.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>all</code> <code>bool</code> <p>If True, return all priors including default priors. If False, return only explicitly set priors.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to brms::prior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns describing prior specifications: - prior: Prior distribution formula - class: Parameter class (b, sd, Intercept, etc.) - coef: Specific coefficient (if applicable) - group: Grouping factor (if applicable) - resp: Response variable (for multivariate models) - dpar: Distributional parameter (if applicable) - nlpar: Non-linear parameter (if applicable) - lb/ub: Bounds for truncated priors - source: Origin of prior (default, user, etc.)</p> See Also <p>brms::prior_summary : R documentation     https://paulbuerkner.com/brms/reference/prior_summary.brmsfit.html <code>get_prior()</code> : Get prior structure before fitting <code>default_prior()</code> : Get default priors for a model</p> <p>Examples:</p> <p>Get all priors used in a model:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\n    \"y ~ x1 + (1|group)\",\n    data=data,\n    priors=[brmspy.prior(\"normal(0, 1)\", \"b\")],\n    chains=4\n)\n\n# Get all priors (including defaults)\npriors = brmspy.prior_summary(model)\nprint(priors)\n</code></pre> <p>Get only explicitly set priors:</p> <pre><code># Get only user-specified priors\nuser_priors = brmspy.prior_summary(model, all=False)\nprint(user_priors)\n</code></pre> <p>Compare with what would be used before fitting:</p> <pre><code># Before fitting - check default priors\ndefault_priors = brmspy.get_prior(\"y ~ x1\", data=data)\n\n# After fitting - see what was actually used\nused_priors = brmspy.prior_summary(model)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.validate_newdata","title":"<code>validate_newdata(newdata, object, re_formula=None, allow_new_levels=False, newdata2=None, resp=None, check_response=True, incl_autocor=True, group_vars=None, req_vars=None, **kwargs)</code>","text":"<p>Validate new data for predictions from a fitted brms model.</p> <p>Ensures that new data contains all required variables and has the correct structure for making predictions. Checks variable types, factor levels, grouping variables, and autocorrelation structures. This function is primarily used internally by prediction methods but can be called directly for debugging or validation purposes.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>DataFrame</code> <p>DataFrame containing new data to be validated against the model. Must include all predictor variables used in the model formula.</p> required <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>re_formula</code> <code>str</code> <p>Formula string specifying group-level effects to include in validation. If None (default), include all group-level effects. If NA, include no group-level effects.</p> <code>None</code> <code>allow_new_levels</code> <code>bool</code> <p>Whether to allow new levels of grouping variables not present in the original training data. If False, raises an error for new levels.</p> <code>False</code> <code>newdata2</code> <code>DataFrame</code> <p>Additional data that cannot be passed via <code>newdata</code>, such as objects used in autocorrelation structures or stanvars.</p> <code>None</code> <code>resp</code> <code>str or list of str</code> <p>Names of response variables to validate. If specified, validation is performed only for the specified responses (relevant for multivariate models).</p> <code>None</code> <code>check_response</code> <code>bool</code> <p>Whether to check if response variables are present in newdata. Set to False when making predictions where response is not needed.</p> <code>True</code> <code>incl_autocor</code> <code>bool</code> <p>Whether to include autocorrelation structures originally specified in the model. If True, validates autocorrelation-related variables.</p> <code>True</code> <code>group_vars</code> <code>list of str</code> <p>Names of specific grouping variables to validate. If None (default), validates all grouping variables present in the model.</p> <code>None</code> <code>req_vars</code> <code>list of str</code> <p>Names of specific variables required in newdata. If None (default), all variables from the original training data are required (unless excluded by other parameters).</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::validate_newdata()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Validated DataFrame based on newdata, potentially with added or modified columns to ensure compatibility with the model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If newdata is missing required variables</p> <code>ValueError</code> <p>If factor levels in newdata don't match those in training data (when allow_new_levels=False)</p> <code>ValueError</code> <p>If grouping variables have invalid structure</p> See Also <p>brms::validate_newdata : R documentation     https://paulbuerkner.com/brms/reference/validate_newdata.html <code>posterior_predict()</code> : Uses validate_newdata internally <code>posterior_epred()</code> : Uses validate_newdata internally</p> <p>Examples:</p> <p>Basic validation for prediction data:</p> <pre><code>import brmspy\nimport pandas as pd\n\n# Fit model\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=train_data, chains=4)\n\n# Prepare new data\nnew_data = pd.DataFrame({\n    'x1': [1.0, 2.0, 3.0],\n    'x2': [0.5, 1.0, 1.5]\n})\n\n# Validate before prediction\nvalidated_data = brmspy.validate_newdata(new_data, model)\nprint(validated_data)\n</code></pre> <p>Validate with group-level effects:</p> <pre><code># Model with random effects\nmodel = brmspy.fit(\"y ~ x + (1|group)\", data=train_data, chains=4)\n\n# New data with grouping variable\nnew_data = pd.DataFrame({\n    'x': [1.0, 2.0],\n    'group': ['A', 'B']  # Must match training data groups\n})\n\n# Validate - will error if groups A or B weren't in training\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    allow_new_levels=False\n)\n</code></pre> <p>Allow new levels for population-level predictions:</p> <pre><code># Allow new group levels (makes population-level predictions only)\nnew_data_with_new_groups = pd.DataFrame({\n    'x': [3.0, 4.0],\n    'group': ['C', 'D']  # New groups not in training\n})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data_with_new_groups,\n    model,\n    allow_new_levels=True\n)\n</code></pre> <p>Skip response variable checking:</p> <pre><code># When making predictions, response not needed\nnew_data = pd.DataFrame({'x1': [1.0, 2.0]})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    check_response=False\n)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.call","title":"<code>call(function, *args, **kwargs)</code>","text":"<p>Call any brms or R function by name with automatic type conversion.</p> <p>Generic wrapper for calling brms functions that don't have dedicated Python wrappers. Automatically converts Python arguments to R objects and R results back to Python. Tries <code>brms::function_name</code> first, then falls back to base R.</p> <p>This function is useful for: - Accessing newer brms functions not yet wrapped in brmspy - Calling brms utility functions without writing custom wrappers - Quick exploration of brms functionality from Python</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Name of the R function to call. Will be prefixed with 'brms::' if possible. Can also include namespace (e.g., \"stats::predict\").</p> required <code>*args</code> <p>Positional arguments passed to the R function. Automatically converted from Python to R types (FitResult \u2192 brmsfit, DataFrame \u2192 data.frame, etc.).</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments passed to the R function. Python parameter names are automatically converted to R conventions.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Result from R function, automatically converted to appropriate Python type (R data.frame \u2192 pandas DataFrame, R vector \u2192 numpy array, etc.).</p> See Also <p><code>py_to_r</code> : Python to R type conversion <code>r_to_py</code> : R to Python type conversion</p> <p>Examples:</p> <p>Call brms functions not yet wrapped:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms_functions.generic import call\n\nmodel = brms.fit(\"y ~ x\", data=data, chains=4)\n\n# Call brms::neff_ratio (not yet wrapped)\nneff = call(\"neff_ratio\", model)\nprint(neff)\n\n# Call brms::rhat (not yet wrapped)\nrhat = call(\"rhat\", model)\nprint(rhat)\n</code></pre> <p>Call with keyword arguments:</p> <pre><code># Call brms::hypothesis for testing hypotheses\nhypothesis_result = call(\n    \"hypothesis\",\n    model,\n    hypothesis=\"b_x1 &gt; 0\",\n    alpha=0.05\n)\nprint(hypothesis_result)\n</code></pre> <p>Access functions from other R packages:</p> <pre><code># Call functions with namespace\nresult = call(\"stats::AIC\", model)\nprint(result)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.bf","title":"<code>bf(formula, **formula_args)</code>","text":"<p>Set up a model formula for brms package.</p> <p>Allows defining (potentially non-linear) additive multilevel models for all parameters of the assumed response distribution.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>brms formula specification, e.g., \"y ~ x + (1|group)\"</p> required <code>**formula_args</code> <code>dict</code> <p>Additional brms::brmsformula() arguments:</p> <ul> <li>decomp : str     Decomposition method (e.g., \"QR\" for QR decomposition)</li> <li>center : bool     Whether to center predictors (default True)</li> <li>sparse : bool     Use sparse matrix representation</li> <li>nl : bool     Whether formula is non-linear</li> <li>loop : bool     Use loop-based Stan code</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object with .r (R brmsformula object) and .dict (Python dict) attributes</p> See Also <p>brms::brmsformula : R documentation     https://paulbuerkner.com/brms/reference/brmsformula.html fit : Fit model using formula</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>    from brmspy import brms\n    f = brms.bf(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>With QR decomposition for numerical stability:</p> <pre><code>f = brms.bf(\n    \"reaction ~ days + (days|subject)\",\n    decomp=\"QR\"\n)\n</code></pre> <p>Multivariate formula: <pre><code>    f = brms.bf(\n        \"mvbind(y1, y2) ~ x1 + x2\",\n        center=True\n    )\n</code></pre></p>"},{"location":"api/brms/#brmspy.brms.lf","title":"<code>lf(*formulas, flist=None, dpar=None, resp=None, center=None, cmc=None, sparse=None, decomp=None)</code>","text":"<p>Specify linear formulas for distributional / non-linear parameters.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str or FormulaResult</code> <p>One or more formulas (e.g. \"sigma ~ x\", \"nu ~ z\").</p> <code>()</code> <code>flist</code> <code>list</code> <p>Additional formulas passed as a list.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Name of the distributional parameter (e.g. \"sigma\").</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response name in multivariate models.</p> <code>None</code> <code>center</code> <code>optional</code> <p>Passed through to brms::lf().</p> <code>None</code> <code>cmc</code> <code>optional</code> <p>Passed through to brms::lf().</p> <code>None</code> <code>sparse</code> <code>optional</code> <p>Passed through to brms::lf().</p> <code>None</code> <code>decomp</code> <code>optional</code> <p>Passed through to brms::lf().</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object that can be added to a bf() formula via +.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = bf(\"y ~ 1\") + lf(\"sigma ~ x\", dpar=\"sigma\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.nlf","title":"<code>nlf(formula, *extra, flist=None, dpar=None, resp=None, loop=None)</code>","text":"<p>Specify non-linear formulas for distributional parameters.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>Non-linear formula, e.g. \"sigma ~ a * exp(b * x)\".</p> required <code>*extra</code> <code>str or FormulaResult</code> <p>Additional named parameters or formulas (rarely needed here; typically you use lf() for those).</p> <code>()</code> <code>flist</code> <code>list</code> <p>Additional formulas passed as a list.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Name of the distributional parameter.</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response name in multivariate models.</p> <code>None</code> <code>loop</code> <code>bool</code> <p>Whether to compute inside a loop (brms::nlf(loop=...)).</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object that can be added to a bf() formula via +.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = bf(\"y ~ 1\") + nlf(\"sigma ~ a * exp(b * x)\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.acformula","title":"<code>acformula(autocor, resp=None)</code>","text":"<p>Specify autocorrelation terms to add to a model.</p> <p>Parameters:</p> Name Type Description Default <code>autocor</code> <code>str</code> <p>One-sided formula with autocorrelation terms, e.g. \"~ arma(p = 1, q = 1)\".</p> required <code>resp</code> <code>str</code> <p>Response name in multivariate models.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object that can be added to a bf() formula via +.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = bf(\"y ~ x\") + acformula(\"~ arma(p = 1, q = 1)\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.set_rescor","title":"<code>set_rescor(rescor=True)</code>","text":"<p>Control residual correlations in multivariate models.</p> <p>Parameters:</p> Name Type Description Default <code>rescor</code> <code>bool</code> <p>Whether to model residual correlations.</p> <code>True</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object that can be added to a multivariate formula via +.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = bf(\"y1 ~ x\") + bf(\"y2 ~ z\") + set_rescor(True)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.set_mecor","title":"<code>set_mecor(mecor=True)</code>","text":"<p>Control correlations between latent me-terms.</p> <p>Parameters:</p> Name Type Description Default <code>mecor</code> <code>bool</code> <p>Whether to model correlations between me() latent variables.</p> <code>True</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object that can be added to a formula via +.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = bf(\"y ~ me(x, sdx)\") + set_mecor(True)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.set_nl","title":"<code>set_nl(dpar=None, resp=None)</code>","text":"<p>Mark a formula as non-linear (or parts of it).</p> <p>Parameters:</p> Name Type Description Default <code>dpar</code> <code>str</code> <p>Distributional parameter name (if only part of the model is non-linear).</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response name in multivariate models.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object that can be added to a formula via +.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = bf(\"y ~ a * inv_logit(x * b)\") + lf(\"a + b ~ z\") + set_nl()\n</code></pre>"},{"location":"api/brms/#brmspy.brms.formula","title":"<code>formula(formula, **formula_args)</code>","text":"<p>Set up a model formula for brms package.</p> <p>Allows defining (potentially non-linear) additive multilevel models for all parameters of the assumed response distribution.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>brms formula specification, e.g., \"y ~ x + (1|group)\"</p> required <code>**formula_args</code> <code>dict</code> <p>Additional brms::brmsformula() arguments:</p> <ul> <li>decomp : str     Decomposition method (e.g., \"QR\" for QR decomposition)</li> <li>center : bool     Whether to center predictors (default True)</li> <li>sparse : bool     Use sparse matrix representation</li> <li>nl : bool     Whether formula is non-linear</li> <li>loop : bool     Use loop-based Stan code</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object with .r (R brmsformula object) and .dict (Python dict) attributes</p> See Also <p>brms::brmsformula : R documentation     https://paulbuerkner.com/brms/reference/brmsformula.html fit : Fit model using formula</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>    from brmspy import brms\n    f = brms.bf(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>With QR decomposition for numerical stability:</p> <pre><code>f = brms.bf(\n    \"reaction ~ days + (days|subject)\",\n    decomp=\"QR\"\n)\n</code></pre> <p>Multivariate formula: <pre><code>    f = brms.bf(\n        \"mvbind(y1, y2) ~ x1 + x2\",\n        center=True\n    )\n</code></pre></p>"},{"location":"api/brms/#brmspy.brms.posterior_epred","title":"<code>posterior_epred(model, newdata, **kwargs)</code>","text":"<p>Compute expected value of posterior predictive distribution.</p> <p>Calls brms::posterior_epred() to get E[Y|data] without observation noise.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions</p> required <code>**kwargs</code> <p>Additional arguments to brms::posterior_epred()</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorEpredResult</code> <p>Object with .idata and .r attributes</p>"},{"location":"api/brms/#brmspy.brms.posterior_linpred","title":"<code>posterior_linpred(model, newdata=None, **kwargs)</code>","text":"<p>Compute linear predictor of the model.</p> <p>Returns samples of the linear predictor (before applying the link function). Useful for understanding the model's predictions on the linear scale.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments to brms::posterior_linpred():</p> <ul> <li>transform : bool - Apply inverse link function (default False)</li> <li>ndraws : int - Number of posterior draws</li> <li>summary : bool - Return summary statistics</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorLinpredResult</code> <p>Object with .idata (IDLinpred) and .r (R matrix) attributes</p> See Also <p>brms::posterior_linpred : R documentation     https://paulbuerkner.com/brms/reference/posterior_linpred.brmsfit.html posterior_epred : Expected values on response scale</p> <p>Examples:</p> <pre><code>    from brmspy import brms\n\n    epilepsy = brms.get_brms_data(\"epilepsy\")\n    model = brms.fit(\n        \"count ~ zAge + zBase * Trt + (1|patient)\",\n        data=epilepsy,\n        family=\"poisson\",\n        chains=4\n    )\n\n    # Linear predictor (log scale for Poisson)\n    linpred = brms.posterior_linpred(model)\n    print(linpred.idata.predictions)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.posterior_predict","title":"<code>posterior_predict(model, newdata=None, **kwargs)</code>","text":"<p>Generate posterior predictive samples with observation noise.</p> <p>Calls brms::posterior_predict() to get samples of Y_new|data.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to brms::posterior_predict()</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorPredictResult</code> <p>Object with .idata and .r attributes</p>"},{"location":"api/brms/#brmspy.brms.log_lik","title":"<code>log_lik(model, newdata=None, **kwargs)</code>","text":"<p>Compute log-likelihood values.</p> <p>Returns log p(y|theta) for each observation. Essential for model comparison via LOO-CV and WAIC.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments to brms::log_lik():</p> <ul> <li>ndraws : int - Number of posterior draws</li> <li>combine_chains : bool - Combine chains (default True)</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>LogLikResult</code> <p>Object with .idata (IDLogLik) and .r (R matrix) attributes</p> See Also <p>brms::log_lik : R documentation     https://paulbuerkner.com/brms/reference/log_lik.brmsfit.html arviz.loo : Leave-One-Out Cross-Validation arviz.waic : Widely Applicable Information Criterion</p> <p>Examples:</p> <p>Compute log-likelihood for model comparison:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    \"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    chains=4\n)\n\n# LOO-CV for model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre> <p>Compare multiple models: <pre><code>model1 = brms.fit(\"count ~ zAge + (1|patient)\", data=epilepsy, family=\"poisson\", chains=4)\nmodel2 = brms.fit(\"count ~ zAge + zBase + (1|patient)\", data=epilepsy, family=\"poisson\", chains=4)\n\ncomp = az.compare({'model1': model1.idata, 'model2': model2.idata})\nprint(comp)\n</code></pre></p>"},{"location":"api/brms/#brmspy.brms.make_stancode","title":"<code>make_stancode(formula, data, priors=None, family='poisson', sample_prior='no', formula_args=None)</code>","text":"<p>Generate Stan code using brms::make_stancode().</p> <p>Useful for inspecting the generated Stan model before fitting, understanding the model structure, or using the code with other Stan interfaces.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaResult</code> <p>brms formula specification</p> required <code>data</code> <code>DataFrame</code> <p>Model data</p> required <code>priors</code> <code>list of PriorSpec</code> <p>Prior specifications from prior() function</p> <code>None</code> <code>family</code> <code>str</code> <p>Distribution family (gaussian, poisson, binomial, etc.)</p> <code>\"poisson\"</code> <code>sample_prior</code> <code>str</code> <p>Whether to sample from prior: - \"no\": No prior samples - \"yes\": Include prior samples alongside posterior - \"only\": Sample from prior only (no data)</p> <code>\"no\"</code> <code>formula_args</code> <code>dict</code> <p>Additional arguments passed to formula()</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Complete Stan program code as string</p> See Also <p>brms::make_stancode : R documentation     https://paulbuerkner.com/brms/reference/make_stancode.html fit : Fit model instead of just generating code make_standata : Generate Stan data block</p> <p>Examples:</p> <p>Generate Stan code for simple model:</p> <pre><code>from brmspy import brms\nepilepsy = brms.get_brms_data(\"epilepsy\")\n\nstan_code = brms.make_stancode(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\n\nprint(stan_code[:500])  # Print first 500 characters\n</code></pre> <p>With custom priors:</p> <pre><code>    from brmspy import prior\n\n    stan_code = brms.make_stancode(\n        formula=\"count ~ zAge\",\n        data=epilepsy,\n        priors=[prior(\"normal(0, 1)\", class_=\"b\")],\n        family=\"poisson\"\n    )\n</code></pre> <p>For prior predictive checks (sample_prior=\"only\"):</p> <pre><code>stan_code = brms.make_stancode(\n    formula=\"count ~ zAge\",\n    data=epilepsy,\n    family=\"poisson\",\n    sample_prior=\"only\"\n)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.brmsfamily","title":"<code>brmsfamily(family, link=None, link_sigma='log', link_shape='log', link_nu='logm1', link_phi='log', link_kappa='log', link_beta='log', link_zi='logit', link_hu='logit', link_zoi='logit', link_coi='logit', link_disc='log', link_bs='log', link_ndt='log', link_bias='logit', link_xi='log1p', link_alpha='identity', link_quantile='logit', threshold='flexible', refcat=None, **kwargs)</code>","text":"<p>Family objects provide a convenient way to specify the details of the models used by many model fitting functions. The family functions presented here are for use with brms only and will not work with other model fitting functions such as glm or glmer. However, the standard family functions as described in family will work with brms.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <p>A character string naming the distribution family of the response variable to be used in the model. Currently, the following families are supported: gaussian, student, binomial, bernoulli, beta-binomial, poisson, negbinomial, geometric, Gamma, skew_normal, lognormal, shifted_lognormal, exgaussian, wiener, inverse.gaussian, exponential, weibull, frechet, Beta, dirichlet, von_mises, asym_laplace, gen_extreme_value, categorical, multinomial, cumulative, cratio, sratio, acat, hurdle_poisson, hurdle_negbinomial, hurdle_gamma, hurdle_lognormal, hurdle_cumulative, zero_inflated_binomial, zero_inflated_beta_binomial, zero_inflated_beta, zero_inflated_negbinomial, zero_inflated_poisson, and zero_one_inflated_beta.</p> required <code>link</code> <code>Optional[str]</code> <p>A specification for the model link function. This can be a name/expression or character string. See the 'Details' section for more information on link functions supported by each family.</p> <code>None</code> <code>link_sigma</code> <code>str</code> <p>Link of auxiliary parameter sigma if being predicted.</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link of auxiliary parameter shape if being predicted.</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link of auxiliary parameter nu if being predicted.</p> <code>'logm1'</code> <code>link_phi</code> <code>str</code> <p>Link of auxiliary parameter phi if being predicted.</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link of auxiliary parameter kappa if being predicted.</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link of auxiliary parameter beta if being predicted.</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link of auxiliary parameter zi if being predicted.</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link of auxiliary parameter hu if being predicted.</p> <code>'logit'</code> <code>link_zoi</code> <code>str</code> <p>Link of auxiliary parameter zoi if being predicted.</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link of auxiliary parameter coi if being predicted.</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link of auxiliary parameter disc if being predicted.</p> <code>'log'</code> <code>link_bs</code> <code>str</code> <p>Link of auxiliary parameter bs if being predicted.</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link of auxiliary parameter ndt if being predicted.</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link of auxiliary parameter bias if being predicted.</p> <code>'logit'</code> <code>link_xi</code> <code>str</code> <p>Link of auxiliary parameter xi if being predicted.</p> <code>'log1p'</code> <code>link_alpha</code> <code>str</code> <p>Link of auxiliary parameter alpha if being predicted.</p> <code>'identity'</code> <code>link_quantile</code> <code>str</code> <p>Link of auxiliary parameter quantile if being predicted.</p> <code>'logit'</code> <code>threshold</code> <code>str</code> <p>A character string indicating the type of thresholds (i.e. intercepts) used in an ordinal model. \"flexible\" provides the standard unstructured thresholds, \"equidistant\" restricts the distance between consecutive thresholds to the same value, and \"sum_to_zero\" ensures the thresholds sum to zero.</p> <code>'flexible'</code> <code>refcat</code> <code>Optional[str]</code> <p>Optional name of the reference response category used in categorical, multinomial, dirichlet and logistic_normal models. If NULL (the default), the first category is used as the reference. If NA, all categories will be predicted, which requires strong priors or carefully specified predictor terms in order to lead to an identified model.</p> <code>None</code> <code>bhaz</code> <p>Currently for experimental purposes only.</p> required"},{"location":"api/brms/#brmspy.brms.family","title":"<code>family(fit, **kwargs)</code>","text":"<p>Extract family object from a fitted model.</p> <p>Parameters:</p> Name Type Description Default <code>fit</code> <code>FitResult or ListVector</code> <p>Fitted brms model</p> required"},{"location":"api/brms/#brmspy.brms.student","title":"<code>student(link='identity', link_sigma='log', link_nu='logm1', **kwargs)</code>","text":"<p>Student's t distribution for robust regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for degrees of freedom parameter</p> <code>'logm1'</code>"},{"location":"api/brms/#brmspy.brms.bernoulli","title":"<code>bernoulli(link='logit', **kwargs)</code>","text":"<p>Bernoulli distribution for binary 0/1 outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.beta_binomial","title":"<code>beta_binomial(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta-binomial distribution for overdispersed binomial data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.negbinomial","title":"<code>negbinomial(link='log', link_shape='log', **kwargs)</code>","text":"<p>Negative binomial distribution for overdispersed count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.geometric","title":"<code>geometric(link='log', **kwargs)</code>","text":"<p>Geometric distribution for count data (negative binomial with shape=1).</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.lognormal","title":"<code>lognormal(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Lognormal distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean on log scale</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.shifted_lognormal","title":"<code>shifted_lognormal(link='identity', link_sigma='log', link_ndt='log', **kwargs)</code>","text":"<p>Shifted lognormal distribution with non-decision time parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.skew_normal","title":"<code>skew_normal(link='identity', link_sigma='log', link_alpha='identity', **kwargs)</code>","text":"<p>Skew normal distribution for asymmetric continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_alpha</code> <code>str</code> <p>Link function for skewness parameter</p> <code>'identity'</code>"},{"location":"api/brms/#brmspy.brms.exponential","title":"<code>exponential(link='log', **kwargs)</code>","text":"<p>Exponential distribution for time-to-event data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.weibull","title":"<code>weibull(link='log', link_shape='log', **kwargs)</code>","text":"<p>Weibull distribution for survival and reliability analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.frechet","title":"<code>frechet(link='log', link_nu='logm1', **kwargs)</code>","text":"<p>Frechet distribution for extreme value analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'logm1'</code>"},{"location":"api/brms/#brmspy.brms.gen_extreme_value","title":"<code>gen_extreme_value(link='identity', link_sigma='log', link_xi='log1p', **kwargs)</code>","text":"<p>Generalized extreme value distribution for extreme events.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location parameter</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_xi</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log1p'</code>"},{"location":"api/brms/#brmspy.brms.exgaussian","title":"<code>exgaussian(link='identity', link_sigma='log', link_beta='log', **kwargs)</code>","text":"<p>Ex-Gaussian distribution for reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for Gaussian SD parameter</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link function for exponential rate parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.wiener","title":"<code>wiener(link='identity', link_bs='log', link_ndt='log', link_bias='logit', **kwargs)</code>","text":"<p>Wiener diffusion model for two-choice reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for drift rate</p> <code>'identity'</code> <code>link_bs</code> <code>str</code> <p>Link function for boundary separation</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link function for initial bias</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.Beta","title":"<code>Beta(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta distribution for data between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.xbeta","title":"<code>xbeta(link='logit', link_phi='log', link_kappa='log', **kwargs)</code>","text":"<p>Extended beta distribution with additional shape parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link function for kappa shape parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.dirichlet","title":"<code>dirichlet(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms/#brmspy.brms.logistic_normal","title":"<code>logistic_normal(link='identity', link_sigma='log', refcat=None, **kwargs)</code>","text":"<p>Logistic-normal distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms/#brmspy.brms.von_mises","title":"<code>von_mises(link='tan_half', link_kappa='log', **kwargs)</code>","text":"<p>Von Mises distribution for circular/directional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean direction</p> <code>'tan_half'</code> <code>link_kappa</code> <code>str</code> <p>Link function for concentration parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.asym_laplace","title":"<code>asym_laplace(link='identity', link_sigma='log', link_quantile='logit', **kwargs)</code>","text":"<p>Asymmetric Laplace distribution for quantile regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_quantile</code> <code>str</code> <p>Link function for the quantile parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.cox","title":"<code>cox(link='log', **kwargs)</code>","text":"<p>Cox proportional hazards model for survival data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the hazard rate</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.hurdle_poisson","title":"<code>hurdle_poisson(link='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Poisson distribution for zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.hurdle_negbinomial","title":"<code>hurdle_negbinomial(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle negative binomial for overdispersed zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.hurdle_gamma","title":"<code>hurdle_gamma(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Gamma distribution for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.hurdle_lognormal","title":"<code>hurdle_lognormal(link='identity', link_sigma='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle lognormal for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.hurdle_cumulative","title":"<code>hurdle_cumulative(link='logit', link_hu='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Hurdle cumulative for zero-inflated ordinal data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the ordinal response</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms/#brmspy.brms.zero_inflated_beta","title":"<code>zero_inflated_beta(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta for data between 0 and 1 with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.zero_one_inflated_beta","title":"<code>zero_one_inflated_beta(link='logit', link_phi='log', link_zoi='logit', link_coi='logit', **kwargs)</code>","text":"<p>Zero-one-inflated beta for data between 0 and 1 with excess zeros and ones.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zoi</code> <code>str</code> <p>Link function for zero-or-one inflation parameter</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link function for conditional one inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.zero_inflated_poisson","title":"<code>zero_inflated_poisson(link='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated Poisson for count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.zero_inflated_negbinomial","title":"<code>zero_inflated_negbinomial(link='log', link_shape='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated negative binomial for overdispersed count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.zero_inflated_binomial","title":"<code>zero_inflated_binomial(link='logit', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated binomial for binary count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.zero_inflated_beta_binomial","title":"<code>zero_inflated_beta_binomial(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta-binomial for overdispersed binomial data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.categorical","title":"<code>categorical(link='logit', refcat=None, **kwargs)</code>","text":"<p>Categorical distribution for unordered multi-category outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms/#brmspy.brms.multinomial","title":"<code>multinomial(link='logit', refcat=None, **kwargs)</code>","text":"<p>Multinomial distribution for count data across multiple categories.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms/#brmspy.brms.dirichlet_multinomial","title":"<code>dirichlet_multinomial(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet-multinomial for overdispersed categorical count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms/#brmspy.brms.cumulative","title":"<code>cumulative(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Cumulative (proportional odds) model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for cumulative probabilities</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms/#brmspy.brms.sratio","title":"<code>sratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Sequential (stopping) ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for sequential ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms/#brmspy.brms.cratio","title":"<code>cratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Continuation ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for continuation ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms/#brmspy.brms.acat","title":"<code>acat(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Adjacent category model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for adjacent category ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms/#brmspy.brms.gaussian","title":"<code>gaussian(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Gaussian (normal) distribution for continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the standard deviation</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.poisson","title":"<code>poisson(link='log', **kwargs)</code>","text":"<p>Poisson distribution for count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.binomial","title":"<code>binomial(link='logit', **kwargs)</code>","text":"<p>Binomial distribution for binary count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.Gamma","title":"<code>Gamma(link='log', link_shape='log', **kwargs)</code>","text":"<p>Gamma distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.inverse_gaussian","title":"<code>inverse_gaussian(link='1/mu^2', link_shape='log', **kwargs)</code>","text":"<p>Inverse Gaussian distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'1/mu^2'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.install_brms","title":"<code>install_brms(*, use_prebuilt=False, install_rtools=False, brms_version=None, cmdstanr_version=None, install_rstan=True, install_cmdstanr=True, rstan_version=None, activate=True, **kwargs)</code>","text":"<p>Install brms R package, optionally cmdstanr and CmdStan compiler, or rstan.</p> <p>WINDOWS WARNING: DO NOT run this if you have </p> <p>Parameters:</p> Name Type Description Default <code>brms_version</code> <code>str</code> <p>brms version: \"latest\", \"2.23.0\", or \"&gt;= 2.20.0\"</p> <code>\"latest\"</code> <code>repo</code> <code>str | None</code> <p>Extra CRAN repository URL</p> <code>None</code> <code>install_cmdstanr</code> <code>bool</code> <p>Whether to install cmdstanr and build CmdStan compiler</p> <code>True</code> <code>install_rstan</code> <code>bool</code> <p>Whether to install rstan (alternative to cmdstanr)</p> <code>False</code> <code>cmdstanr_version</code> <code>str</code> <p>cmdstanr version: \"latest\", \"0.8.1\", or \"&gt;= 0.8.0\"</p> <code>\"latest\"</code> <code>rstan_version</code> <code>str</code> <p>rstan version: \"latest\", \"2.32.6\", or \"&gt;= 2.32.0\"</p> <code>\"latest\"</code> <code>use_prebuilt</code> <code>bool</code> <p>Uses fully prebuilt binaries for cmdstanr and brms and their dependencies.  Ignores system R libraries and uses the latest brms and cmdstanr available  for your system. Requires R&gt;=4 and might not be compatible with some older systems or missing toolchains. Can reduce setup time by 50x.</p> <code>False</code> <code>install_rtools</code> <code>bool</code> <p>Installs RTools (windows only) if they cant be found.  WARNING: Modifies system path and runs the full rtools installer.  Use with caution!</p> <code>False</code> <p>Examples:</p> <p>Basic installation:</p> <p><pre><code>from brmspy import brms\nbrms.install_brms()\n</code></pre> Install specific version:</p> <pre><code>brms.install_brms(brms_version=\"2.23.0\")\n</code></pre> <p>Use rstan instead of cmdstanr:</p> <pre><code>brms.install_brms(install_cmdstanr=False, install_rstan=True)\n</code></pre> <p>Fast installation with prebuilt binaries: ```python brms.install_brms(use_prebuilt=True)</p>"},{"location":"api/brms/#brmspy.brms.get_brms_version","title":"<code>get_brms_version()</code>","text":"<p>Get installed brms R package version.</p> <p>Returns:</p> Type Description <code>str</code> <p>Version object or None</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If brms is not installed</p> <p>Examples:</p> <pre><code>from brmspy import brms\nversion = brms.get_brms_version()\nprint(f\"brms version: {version}\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.install_runtime","title":"<code>install_runtime(install_rtools=False)</code>","text":"<p>Install prebuilt brmspy runtime bundle for fast setup.</p> <p>Downloads and activates a precompiled runtime containing: - R packages (brms, cmdstanr, dependencies) - Compiled CmdStan binary - Complete environment ready for immediate use</p> <p>This reduces setup time from ~30 minutes to ~1 minute by avoiding compilation. Available for specific platform/R version combinations.</p> <p>This function reconfigures the running embedded R session to use an isolated  library environment from downloaded binaries. It does not mix or break the  default library tree already installed in the system.</p> <p>Parameters:</p> Name Type Description Default <code>install_rtools</code> <code>bool</code> <p>Installs RTools (windows only) if they cant be found.  WARNING: Modifies system path and runs the full rtools installer.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Path if installation succeeded, None otherwise</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If prebuilt binaries not available for this platform</p> Notes <p>Platform Support: Prebuilt binaries are available for: - Linux: x86_64, glibc &gt;= 2.27, g++ &gt;= 9 - macOS: x86_64 and arm64, clang &gt;= 11 - Windows: x86_64 with Rtools</p> <p>R Version: Runtime includes all R packages, so they must match your R installation's major.minor version (e.g., R 4.3.x).</p> <p>System Fingerprint: Runtime is selected based on: - Operating system (linux/macos/windows) - CPU architecture (x86_64/arm64) - R version (major.minor)</p> <p>Example: <code>linux-x86_64-r4.3</code></p> See Also <p>install_brms : Main installation function</p>"},{"location":"api/brms/#brmspy.brms.deactivate_runtime","title":"<code>deactivate_runtime()</code>","text":"<p>Deactivate current runtime and restore original R environment.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no runtime is currently active.</p> Notes <p>Side effects of deactivation:</p> <ul> <li>Unloads brms/cmdstanr/rstan if loaded</li> <li>Restores original .libPaths()</li> <li>Restores original cmdstan path</li> <li>Clears active_runtime from config</li> <li>Invalidates cached R package singletons</li> </ul>"},{"location":"api/brms/#brmspy.brms.activate_runtime","title":"<code>activate_runtime(runtime_path=None)</code>","text":"<p>Activate a runtime by mutating R environment.</p> <p>Parameters:</p> Name Type Description Default <code>runtime_path</code> <code>Path or str or None</code> <p>Path to runtime directory. If None, uses last active runtime from config.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If runtime_path is None and no config exists.</p> <code>FileNotFoundError</code> <p>If runtime directory doesn't exist.</p> <code>RuntimeError</code> <p>If runtime structure is invalid or activation fails.</p> Notes <p>Side effects of activation:</p> <ul> <li>Stores original R environment for later restoration</li> <li>Unloads brms/cmdstanr/rstan if loaded</li> <li>Sets R .libPaths() to runtime's Rlib/</li> <li>Sets cmdstanr path to runtime's cmdstan/</li> <li>Saves runtime_path to ~/.brmspy/config.json</li> <li>Invalidates cached R package singletons</li> </ul>"},{"location":"api/brms/#brmspy.brms.get_active_runtime","title":"<code>get_active_runtime()</code>","text":"<p>Get path to currently active prebuilt runtime.</p> <p>Returns:</p> Type Description <code>Path or None</code> <p>Path to active runtime directory, or None if not configured</p> Notes <p>Returns None if: - No runtime configured in config file - Config file doesn't exist - Config file is corrupted</p> <p>Examples:</p> <pre><code>from brmspy import get_active_runtime\n\nruntime_path = get_active_runtime()\nif runtime_path and runtime_path.exists():\n    print(f\"Active runtime: {runtime_path}\")\nelse:\n    print(\"No active runtime configured\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.find_local_runtime","title":"<code>find_local_runtime()</code>","text":"<p>Find an installed runtime matching the current system fingerprint.</p> <p>Uses <code>system_fingerprint()</code> to compute the current system identity and searches the local runtime store for a matching runtime directory.</p> <p>Returns:</p> Type Description <code>Path or None</code> <p>Path to the matching runtime root directory if found, otherwise <code>None</code>.</p> Notes <p>This function is a pure lookup: it does not install, activate, or modify any runtime state.</p>"},{"location":"api/diagnostics-arviz/","title":"Diagnostics with ArviZ","text":"<p>This guide covers how to use ArviZ for comprehensive diagnostics with brmspy models. All fitted models return <code>arviz.InferenceData</code> objects by default, enabling seamless integration with ArviZ's extensive diagnostic toolkit.</p> <p>Key Feature: brmspy's InferenceData outputs are in the correct format for both univariate and multivariate models, so any ArviZ analysis function works directly without additional conversion or configuration.</p>"},{"location":"api/diagnostics-arviz/#inferencedata-structure","title":"InferenceData Structure","text":"<p>Each fitted model's <code>.idata</code> attribute contains:</p> <ul> <li>posterior: Parameter samples (population-level effects, group-level effects, etc.)   All parameters retain brms naming conventions (e.g., <code>b_Intercept</code>, <code>b_zAge</code>, <code>sd_patient__Intercept</code>)</li> <li>posterior_predictive: Posterior predictive samples for each response variable</li> <li>log_likelihood: Pointwise log-likelihood values for model comparison (LOO, WAIC)</li> <li>observed_data: Original response variable values</li> <li>coords: Coordinate labels (chain, draw, obs_id) for indexing</li> </ul>"},{"location":"api/diagnostics-arviz/#basic-diagnostics-with-arviz","title":"Basic Diagnostics with ArviZ","text":""},{"location":"api/diagnostics-arviz/#summary-statistics","title":"Summary Statistics","text":"<p>Use <code>az.summary()</code> to get posterior estimates with convergence diagnostics:</p> <pre><code>import brmspy\nimport arviz as az\n\n# Fit model\nmodel = brmspy.fit(\"count ~ zAge + (1|patient)\", data=data, family=\"poisson\")\n\n# Get summary with Rhat and ESS\nsummary = az.summary(model.idata)\nprint(summary)\n#                mean     sd  hdi_3%  hdi_97%  mcse_mean  mcse_sd  ess_bulk  ess_tail  r_hat\n# b_Intercept   1.234  0.123   1.012    1.456      0.002    0.001    3421.0    3012.0   1.00\n# b_zAge        0.567  0.089   0.398    0.732      0.001    0.001    4123.0    3456.0   1.00\n# ...\n</code></pre>"},{"location":"api/diagnostics-arviz/#convergence-diagnostics","title":"Convergence Diagnostics","text":"<p>Check for convergence issues:</p> <pre><code># Rhat values (should be &lt; 1.01)\nrhat = az.rhat(model.idata)\nprint(f\"Max Rhat: {rhat.max().values}\")\n\n# Effective sample size\ness_bulk = az.ess(model.idata, method=\"bulk\")\ness_tail = az.ess(model.idata, method=\"tail\")\nprint(f\"Min bulk ESS: {ess_bulk.min().values}\")\n</code></pre>"},{"location":"api/diagnostics-arviz/#trace-plots","title":"Trace Plots","text":"<p>Visualize MCMC chains:</p> <pre><code># All parameters\naz.plot_trace(model.idata)\n\n# Specific parameters only\naz.plot_trace(model.idata, var_names=[\"b_Intercept\", \"b_zAge\"])\n</code></pre>"},{"location":"api/diagnostics-arviz/#posterior-predictive-checks","title":"Posterior Predictive Checks","text":""},{"location":"api/diagnostics-arviz/#univariate-models","title":"Univariate Models","text":"<p>Use <code>az.plot_ppc()</code> to assess model fit:</p> <pre><code># Basic posterior predictive check\naz.plot_ppc(model.idata)\n\n# With specific number of samples\naz.plot_ppc(model.idata, num_pp_samples=100)\n\n# Different plot types\naz.plot_ppc(model.idata, kind=\"cumulative\")\naz.plot_ppc(model.idata, kind=\"scatter\")\n</code></pre>"},{"location":"api/diagnostics-arviz/#multivariate-models","title":"Multivariate Models","text":"<p>For multivariate models with multiple response variables, specify which response to check using the <code>var_names</code> parameter:</p> <pre><code># Fit multivariate model\nfrom brmspy import bf, set_rescor\n\nmv_model = brmspy.fit(\n    bf(\"mvbind(tarsus, back) ~ sex + (1|p|fosternest)\") + set_rescor(True),\n    data=data\n)\n\n# Check each response separately\naz.plot_ppc(mv_model.idata, var_names=[\"tarsus\"])\naz.plot_ppc(mv_model.idata, var_names=[\"back\"])\n</code></pre>"},{"location":"api/diagnostics-arviz/#model-comparison","title":"Model Comparison","text":""},{"location":"api/diagnostics-arviz/#leave-one-out-cross-validation-loo","title":"Leave-One-Out Cross-Validation (LOO)","text":"<p>Compute LOO information criterion for model comparison:</p> <pre><code># Univariate model\nloo_result = az.loo(model.idata)\nprint(loo_result)\n# Computed from 4000 posterior samples and 100 observations log-likelihood matrix.\n#          Estimate       SE\n# elpd_loo   -234.5      8.2\n# p_loo         12.3      1.1\n# looic        469.0     16.4\n\n# Multivariate model - specify response variable\nloo_tarsus = az.loo(mv_model.idata, var_name=\"tarsus\")\nloo_back = az.loo(mv_model.idata, var_name=\"back\")\n</code></pre>"},{"location":"api/diagnostics-arviz/#waic-widely-applicable-information-criterion","title":"WAIC (Widely Applicable Information Criterion)","text":"<p>Alternative to LOO for model comparison:</p> <pre><code>waic_result = az.waic(model.idata)\nprint(waic_result)\n\n# For multivariate models\nwaic_tarsus = az.waic(mv_model.idata, var_name=\"tarsus\")\n</code></pre>"},{"location":"api/diagnostics-arviz/#comparing-multiple-models","title":"Comparing Multiple Models","text":"<p>Use <code>az.compare()</code> to compare multiple models:</p> <pre><code># Fit competing models\nmodel1 = brmspy.fit(\"y ~ x1\", data=data)\nmodel2 = brmspy.fit(\"y ~ x1 + x2\", data=data)\nmodel3 = brmspy.fit(\"y ~ x1 * x2\", data=data)\n\n# Compare with LOO\ncomparison = az.compare({\n    \"model1\": model1.idata,\n    \"model2\": model2.idata,\n    \"model3\": model3.idata\n}, ic=\"loo\")\n\nprint(comparison)\n#         rank  loo    p_loo   d_loo   weight    se   dse  warning  loo_scale\n# model3     0 -234.5   12.3    0.0    0.72    8.2   0.0    False        log\n# model2     1 -237.8   10.1    3.3    0.24    8.0   2.1    False        log\n# model1     2 -245.2    8.9   10.7    0.04    7.8   4.5    False        log\n\n# Visualize comparison\naz.plot_compare(comparison)\n</code></pre>"},{"location":"api/diagnostics-arviz/#multivariate-model-comparison","title":"Multivariate Model Comparison","text":"<p>For multivariate models, compare each response separately:</p> <pre><code># Fit two multivariate models\nmv_model1 = brmspy.fit(\n    bf(\"mvbind(tarsus, back) ~ sex + (1|p|fosternest)\") + set_rescor(True),\n    data=data\n)\n\nmv_model2 = brmspy.fit(\n    bf(\"mvbind(tarsus, back) ~ sex + hatchdate + (1|p|fosternest)\") + set_rescor(True),\n    data=data\n)\n\n# Compare for 'back' response\ncomparison_back = az.compare(\n    {\"model1\": mv_model1.idata, \"model2\": mv_model2.idata},\n    ic=\"loo\",\n    var_name=\"back\"\n)\nprint(comparison_back)\n\n# Compare for 'tarsus' response\ncomparison_tarsus = az.compare(\n    {\"model1\": mv_model1.idata, \"model2\": mv_model2.idata},\n    ic=\"loo\",\n    var_name=\"tarsus\"\n)\n</code></pre>"},{"location":"api/diagnostics-arviz/#advanced-visualizations","title":"Advanced Visualizations","text":""},{"location":"api/diagnostics-arviz/#posterior-distributions","title":"Posterior Distributions","text":"<p>Visualize parameter posteriors:</p> <pre><code># Forest plot\naz.plot_forest(model.idata, var_names=[\"b\"])\n\n# Posterior densities\naz.plot_posterior(model.idata, var_names=[\"b_Intercept\", \"b_zAge\"])\n\n# With reference values\naz.plot_posterior(\n    model.idata,\n    var_names=[\"b_zAge\"],\n    ref_val=0,  # Add reference line at 0\n    hdi_prob=0.95\n)\n</code></pre>"},{"location":"api/diagnostics-arviz/#pairwise-relationships","title":"Pairwise Relationships","text":"<p>Examine parameter correlations:</p> <pre><code># Pair plot for selected parameters\naz.plot_pair(\n    model.idata,\n    var_names=[\"b_Intercept\", \"b_zAge\"],\n    kind=\"hexbin\"\n)\n\n# Include divergences (if any)\naz.plot_pair(\n    model.idata,\n    var_names=[\"b\"],\n    divergences=True\n)\n</code></pre>"},{"location":"api/diagnostics-arviz/#energy-plots","title":"Energy Plots","text":"<p>Diagnose sampling issues:</p> <pre><code>az.plot_energy(model.idata)\n</code></pre>"},{"location":"api/diagnostics-arviz/#complete-diagnostic-workflow","title":"Complete Diagnostic Workflow","text":"<p>Here's a complete example showing the full diagnostic workflow:</p> <pre><code>from brmspy import brms\nimport arviz as az\nimport matplotlib.pyplot as plt\n\n# Fit model\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    \"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    chains=4,\n    iter=2000\n)\n\n# 1. Check convergence\nprint(az.summary(model.idata))\nassert all(az.rhat(model.idata) &lt; 1.01), \"Convergence issues detected\"\n\n# 2. Visualize chains\naz.plot_trace(model.idata, var_names=[\"b\"])\nplt.tight_layout()\nplt.show()\n\n# 3. Posterior predictive check\naz.plot_ppc(model.idata, num_pp_samples=100)\nplt.show()\n\n# 4. Model comparison\nloo = az.loo(model.idata)\nprint(f\"LOO: {loo.loo:.1f} \u00b1 {loo.loo_se:.1f}\")\n\n# 5. Examine specific parameters\naz.plot_posterior(\n    model.idata,\n    var_names=[\"b_zAge\", \"b_Trt\"],\n    ref_val=0\n)\nplt.show()\n</code></pre>"},{"location":"api/diagnostics-arviz/#notes","title":"Notes","text":""},{"location":"api/diagnostics-arviz/#parameter-naming","title":"Parameter Naming","text":"<p>brmspy preserves brms parameter naming conventions:</p> <ul> <li>Population-level effects: <code>b_Intercept</code>, <code>b_variable_name</code></li> <li>Group-level standard deviations: <code>sd_group__effect</code></li> <li>Correlations: <code>cor_group__effect1__effect2</code></li> <li>Family-specific parameters: <code>sigma</code>, <code>nu</code>, <code>shape</code>, etc.</li> </ul>"},{"location":"api/diagnostics-arviz/#multivariate-models_1","title":"Multivariate Models","text":"<p>When working with multivariate models, remember to specify the <code>var_name</code> parameter in ArviZ functions that operate on response variables (e.g., <code>az.loo()</code>, <code>az.waic()</code>, <code>az.plot_ppc()</code>).</p>"},{"location":"api/diagnostics-arviz/#performance","title":"Performance","text":"<p>For large models or datasets, LOO computation can be slow. Consider using <code>az.loo(..., pointwise=False)</code> or WAIC as alternatives.</p>"},{"location":"api/diagnostics-arviz/#see-also","title":"See Also","text":"<ul> <li>arviz.summary - Posterior summary statistics</li> <li>arviz.loo - Leave-one-out cross-validation</li> <li>arviz.waic - WAIC information criterion</li> <li>arviz.compare - Compare multiple models</li> <li>arviz.plot_ppc - Posterior predictive checks</li> <li>arviz.plot_trace - MCMC trace plots</li> <li>ArviZ Documentation - Complete ArviZ API reference</li> </ul>"},{"location":"api/install/","title":"Install","text":""},{"location":"api/install/#brmspy.runtime-classes","title":"Classes","text":""},{"location":"api/install/#brmspy.runtime.RuntimeStatus","title":"<code>RuntimeStatus</code>  <code>dataclass</code>","text":"<p>Immutable snapshot of current runtime state.</p>"},{"location":"api/install/#brmspy.runtime.RuntimeManifest","title":"<code>RuntimeManifest</code>  <code>dataclass</code>","text":"<p>Runtime bundle manifest (from manifest.json).</p>"},{"location":"api/install/#brmspy.runtime.SystemInfo","title":"<code>SystemInfo</code>  <code>dataclass</code>","text":"<p>Immutable system environment snapshot.</p>"},{"location":"api/install/#brmspy.runtime-functions","title":"Functions","text":""},{"location":"api/install/#brmspy.runtime.install_runtime","title":"<code>install_runtime(install_rtools=False)</code>","text":"<p>Install prebuilt brmspy runtime bundle for fast setup.</p> <p>Downloads and activates a precompiled runtime containing: - R packages (brms, cmdstanr, dependencies) - Compiled CmdStan binary - Complete environment ready for immediate use</p> <p>This reduces setup time from ~30 minutes to ~1 minute by avoiding compilation. Available for specific platform/R version combinations.</p> <p>This function reconfigures the running embedded R session to use an isolated  library environment from downloaded binaries. It does not mix or break the  default library tree already installed in the system.</p> <p>Parameters:</p> Name Type Description Default <code>install_rtools</code> <code>bool</code> <p>Installs RTools (windows only) if they cant be found.  WARNING: Modifies system path and runs the full rtools installer.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Path if installation succeeded, None otherwise</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If prebuilt binaries not available for this platform</p> Notes <p>Platform Support: Prebuilt binaries are available for: - Linux: x86_64, glibc &gt;= 2.27, g++ &gt;= 9 - macOS: x86_64 and arm64, clang &gt;= 11 - Windows: x86_64 with Rtools</p> <p>R Version: Runtime includes all R packages, so they must match your R installation's major.minor version (e.g., R 4.3.x).</p> <p>System Fingerprint: Runtime is selected based on: - Operating system (linux/macos/windows) - CPU architecture (x86_64/arm64) - R version (major.minor)</p> <p>Example: <code>linux-x86_64-r4.3</code></p> See Also <p>install_brms : Main installation function</p>"},{"location":"api/install/#brmspy.runtime.get_brms_version","title":"<code>get_brms_version()</code>","text":"<p>Get installed brms R package version.</p> <p>Returns:</p> Type Description <code>str</code> <p>Version object or None</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If brms is not installed</p> <p>Examples:</p> <pre><code>from brmspy import brms\nversion = brms.get_brms_version()\nprint(f\"brms version: {version}\")\n</code></pre>"},{"location":"api/install/#brmspy.runtime.get_active_runtime","title":"<code>get_active_runtime()</code>","text":"<p>Get path to currently active prebuilt runtime.</p> <p>Returns:</p> Type Description <code>Path or None</code> <p>Path to active runtime directory, or None if not configured</p> Notes <p>Returns None if: - No runtime configured in config file - Config file doesn't exist - Config file is corrupted</p> <p>Examples:</p> <pre><code>from brmspy import get_active_runtime\n\nruntime_path = get_active_runtime()\nif runtime_path and runtime_path.exists():\n    print(f\"Active runtime: {runtime_path}\")\nelse:\n    print(\"No active runtime configured\")\n</code></pre>"},{"location":"api/install/#brmspy.runtime.install_brms","title":"<code>install_brms(*, use_prebuilt=False, install_rtools=False, brms_version=None, cmdstanr_version=None, install_rstan=True, install_cmdstanr=True, rstan_version=None, activate=True, **kwargs)</code>","text":"<p>Install brms R package, optionally cmdstanr and CmdStan compiler, or rstan.</p> <p>WINDOWS WARNING: DO NOT run this if you have </p> <p>Parameters:</p> Name Type Description Default <code>brms_version</code> <code>str</code> <p>brms version: \"latest\", \"2.23.0\", or \"&gt;= 2.20.0\"</p> <code>\"latest\"</code> <code>repo</code> <code>str | None</code> <p>Extra CRAN repository URL</p> <code>None</code> <code>install_cmdstanr</code> <code>bool</code> <p>Whether to install cmdstanr and build CmdStan compiler</p> <code>True</code> <code>install_rstan</code> <code>bool</code> <p>Whether to install rstan (alternative to cmdstanr)</p> <code>False</code> <code>cmdstanr_version</code> <code>str</code> <p>cmdstanr version: \"latest\", \"0.8.1\", or \"&gt;= 0.8.0\"</p> <code>\"latest\"</code> <code>rstan_version</code> <code>str</code> <p>rstan version: \"latest\", \"2.32.6\", or \"&gt;= 2.32.0\"</p> <code>\"latest\"</code> <code>use_prebuilt</code> <code>bool</code> <p>Uses fully prebuilt binaries for cmdstanr and brms and their dependencies.  Ignores system R libraries and uses the latest brms and cmdstanr available  for your system. Requires R&gt;=4 and might not be compatible with some older systems or missing toolchains. Can reduce setup time by 50x.</p> <code>False</code> <code>install_rtools</code> <code>bool</code> <p>Installs RTools (windows only) if they cant be found.  WARNING: Modifies system path and runs the full rtools installer.  Use with caution!</p> <code>False</code> <p>Examples:</p> <p>Basic installation:</p> <p><pre><code>from brmspy import brms\nbrms.install_brms()\n</code></pre> Install specific version:</p> <pre><code>brms.install_brms(brms_version=\"2.23.0\")\n</code></pre> <p>Use rstan instead of cmdstanr:</p> <pre><code>brms.install_brms(install_cmdstanr=False, install_rstan=True)\n</code></pre> <p>Fast installation with prebuilt binaries: ```python brms.install_brms(use_prebuilt=True)</p>"},{"location":"api/install/#brmspy.runtime.activate_runtime","title":"<code>activate_runtime(runtime_path=None)</code>","text":"<p>Activate a runtime by mutating R environment.</p> <p>Parameters:</p> Name Type Description Default <code>runtime_path</code> <code>Path or str or None</code> <p>Path to runtime directory. If None, uses last active runtime from config.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If runtime_path is None and no config exists.</p> <code>FileNotFoundError</code> <p>If runtime directory doesn't exist.</p> <code>RuntimeError</code> <p>If runtime structure is invalid or activation fails.</p> Notes <p>Side effects of activation:</p> <ul> <li>Stores original R environment for later restoration</li> <li>Unloads brms/cmdstanr/rstan if loaded</li> <li>Sets R .libPaths() to runtime's Rlib/</li> <li>Sets cmdstanr path to runtime's cmdstan/</li> <li>Saves runtime_path to ~/.brmspy/config.json</li> <li>Invalidates cached R package singletons</li> </ul>"},{"location":"api/install/#brmspy.runtime.deactivate_runtime","title":"<code>deactivate_runtime()</code>","text":"<p>Deactivate current runtime and restore original R environment.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no runtime is currently active.</p> Notes <p>Side effects of deactivation:</p> <ul> <li>Unloads brms/cmdstanr/rstan if loaded</li> <li>Restores original .libPaths()</li> <li>Restores original cmdstan path</li> <li>Clears active_runtime from config</li> <li>Invalidates cached R package singletons</li> </ul>"},{"location":"api/install/#brmspy.runtime.status","title":"<code>status()</code>","text":"<p>Query current runtime status without side effects.</p> <p>Returns:</p> Type Description <code>RuntimeStatus</code> <p>Dataclass with comprehensive state information including:</p> <ul> <li>Active runtime path and activation state</li> <li>System fingerprint and toolchain info</li> <li>Prebuilt compatibility and availability</li> <li>Installed brms/cmdstanr/rstan versions</li> </ul>"},{"location":"api/install/#brmspy.runtime.find_local_runtime","title":"<code>find_local_runtime()</code>","text":"<p>Find an installed runtime matching the current system fingerprint.</p> <p>Uses <code>system_fingerprint()</code> to compute the current system identity and searches the local runtime store for a matching runtime directory.</p> <p>Returns:</p> Type Description <code>Path or None</code> <p>Path to the matching runtime root directory if found, otherwise <code>None</code>.</p> Notes <p>This function is a pure lookup: it does not install, activate, or modify any runtime state.</p>"},{"location":"api/types/","title":"Types","text":"<p>Result types for brmspy functions.</p>"},{"location":"api/types/#brmspy.types-classes","title":"Classes","text":""},{"location":"api/types/#brmspy.types.PriorSpec","title":"<code>PriorSpec</code>  <code>dataclass</code>","text":"<p>Python representation of a brms prior specification.</p> <p>This dataclass provides a typed interface to brms::prior_string() arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the <code>prior()</code> factory function to create instances.</p> <p>Attributes:</p> Name Type Description <code>prior</code> <code>str</code> <p>Prior distribution as string (e.g., \"normal(0, 1)\", \"exponential(2)\")</p> <code>class_</code> <code>(str, optional)</code> <p>Parameter class: \"b\" (fixed effects), \"sd\" (group SD), \"Intercept\", \"sigma\", \"cor\", etc.</p> <code>coef</code> <code>(str, optional)</code> <p>Specific coefficient name for class-level priors</p> <code>group</code> <code>(str, optional)</code> <p>Grouping variable for hierarchical effects</p> <code>dpar</code> <code>(str, optional)</code> <p>Distributional parameter (e.g., \"sigma\", \"phi\", \"zi\")</p> <code>resp</code> <code>(str, optional)</code> <p>Response variable for multivariate models</p> <code>nlpar</code> <code>(str, optional)</code> <p>Non-linear parameter name</p> <code>lb</code> <code>(float, optional)</code> <p>Lower bound for truncated priors</p> <code>ub</code> <code>(float, optional)</code> <p>Upper bound for truncated priors</p> See Also <p>prior : Factory function to create PriorSpec instances brms::prior_string : R documentation     https://paulbuerkner.com/brms/reference/prior_string.html</p> <p>Examples:</p> <p>Create prior specifications (prefer using <code>prior()</code> function):</p> <pre><code>from brmspy.types import PriorSpec\n\n# Fixed effect prior\np1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n# Group-level SD prior\np2 = PriorSpec(\n    prior=\"exponential(2)\",\n    class_=\"sd\",\n    group=\"patient\"\n)\n\n# Coefficient-specific prior with bounds\np3 = PriorSpec(\n    prior=\"normal(0, 1)\",\n    class_=\"b\",\n    coef=\"age\",\n    lb=0  # Truncated at zero\n)\n</code></pre>"},{"location":"api/types/#brmspy.types.PriorSpec-functions","title":"Functions","text":""},{"location":"api/types/#brmspy.types.PriorSpec.to_brms_kwargs","title":"<code>to_brms_kwargs()</code>","text":"<p>Convert PriorSpec to keyword arguments for brms::prior_string().</p> <p>Maps Python dataclass fields to R function arguments, handling the <code>class_</code> -&gt; <code>class</code> parameter name conversion.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keyword arguments ready for brms::prior_string()</p> <p>Examples:</p> <pre><code>from brmspy import prior\np = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\nkwargs = p.to_brms_kwargs()\nprint(kwargs)\n# {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n</code></pre>"},{"location":"api/types/#brmspy.types.IDFit","title":"<code>IDFit</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for fitted brms models.</p> <p>Extends arviz.InferenceData with type hints for IDE autocomplete. Guarantees the presence of specific data groups returned by <code>fit()</code>.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Posterior samples of model parameters</p> <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (with observation noise)</p> <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation</p> <code>observed_data</code> <code>Dataset</code> <p>Original observed response data</p> <code>coords</code> <code>dict</code> <p>Coordinate mappings for dimensions</p> <code>dims</code> <code>dict</code> <p>Dimension specifications for variables</p> See Also <p>brmspy.brms.fit : Creates IDFit objects arviz.InferenceData : Base class documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\nmodel = brms.fit(\"y ~ x\", data=df, chains=4)\n\n# Type checking and autocomplete\nassert isinstance(model.idata, IDFit)\nprint(model.idata.posterior)  # IDE autocomplete works!\n</code></pre>"},{"location":"api/types/#brmspy.types.IDEpred","title":"<code>IDEpred</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_epred results.</p> <p>Contains expected values E[Y|X] without observation noise.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Expected value samples (no observation noise)</p> See Also <p>brmspy.brms.posterior_epred : Creates IDEpred objects</p>"},{"location":"api/types/#brmspy.types.IDPredict","title":"<code>IDPredict</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_predict results.</p> <p>Contains posterior predictive samples with observation noise.</p> <p>Attributes:</p> Name Type Description <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (includes observation noise)</p> See Also <p>brmspy.brms.posterior_predict : Creates IDPredict objects</p>"},{"location":"api/types/#brmspy.types.IDLinpred","title":"<code>IDLinpred</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_linpred results.</p> <p>Contains linear predictor values (before applying link function).</p> <p>Attributes:</p> Name Type Description <code>predictions</code> <code>Dataset</code> <p>Linear predictor samples</p> See Also <p>brmspy.brms.posterior_linpred : Creates IDLinpred objects</p>"},{"location":"api/types/#brmspy.types.IDLogLik","title":"<code>IDLogLik</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for log_lik results.</p> <p>Contains log-likelihood values for model comparison.</p> <p>Attributes:</p> Name Type Description <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation</p> See Also <p>brmspy.brms.log_lik : Creates IDLogLik objects arviz.loo : LOO-CV using log-likelihood</p>"},{"location":"api/types/#brmspy.types.RListVectorExtension","title":"<code>RListVectorExtension</code>  <code>dataclass</code>","text":"<p>Generic result container with R objects.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/types/#brmspy.types.GenericResult","title":"<code>GenericResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Generic result container with arviz and R objects.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData object</p> <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/types/#brmspy.types.FitResult","title":"<code>FitResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from fit() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with posterior, posterior_predictive, log_likelihood, and observed_data groups</p> <code>r</code> <code>ListVector</code> <p>brmsfit R object from brms::brm()</p>"},{"location":"api/types/#brmspy.types.PosteriorEpredResult","title":"<code>PosteriorEpredResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from posterior_epred() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with expected values in 'posterior' group</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_epred()</p>"},{"location":"api/types/#brmspy.types.PosteriorPredictResult","title":"<code>PosteriorPredictResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from posterior_predict() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with predictions in 'posterior_predictive' group</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_predict()</p>"},{"location":"api/types/#brmspy.types.LogLikResult","title":"<code>LogLikResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from log_lik() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>IDLogLik</code> <p>arviz InferenceData with log-likelihood values</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::log_lik()</p> See Also <p>brmspy.brms.log_lik : Creates LogLikResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nmodel = brms.fit(\"y ~ x\", data=df, chains=4)\nloglik = brms.log_lik(model)\n\n# Use for model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre>"},{"location":"api/types/#brmspy.types.PosteriorLinpredResult","title":"<code>PosteriorLinpredResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from posterior_linpred() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>IDLinpred</code> <p>arviz InferenceData with linear predictor values</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_linpred()</p> See Also <p>brmspy.brms.posterior_linpred : Creates PosteriorLinpredResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.fit(\"count ~ age\", data=df, family=\"poisson\", chains=4)\nlinpred = brms.posterior_linpred(model)\n\n# Linear predictor on log scale (for Poisson)\nprint(linpred.idata.predictions)\n</code></pre>"},{"location":"api/types/#brmspy.types.FormulaResult","title":"<code>FormulaResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from formula() function.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R brmsformula object</p> <code>dict</code> <code>Dict</code> <p>Python dictionary representation of formula</p> See Also <p>brmspy.brms.formula : Creates FormulaResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\n# Create formula with options\nf = brms.formula(\"y ~ x\", decomp=\"QR\")\n\n# Use in fit()\nmodel = brms.fit(f, data=df, chains=4)\n</code></pre>"},{"location":"api/types/#brmspy.types.LooResult","title":"<code>LooResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p>"},{"location":"api/types/#brmspy.types.LooResult-functions","title":"Functions","text":""},{"location":"api/types/#brmspy.types.LooResult.__repr__","title":"<code>__repr__()</code>","text":"<p>Pretty print LOO-CV results.</p>"},{"location":"api/brms_functions/brm/","title":"brm","text":""},{"location":"api/brms_functions/brm/#brmspy.brms_functions.brm-classes","title":"Classes","text":""},{"location":"api/brms_functions/brm/#brmspy.brms_functions.brm-functions","title":"Functions","text":""},{"location":"api/brms_functions/brm/#brmspy.brms_functions.brm.brm","title":"<code>brm(formula, data, priors=None, family='gaussian', sample_prior='no', sample=True, backend='cmdstanr', formula_args=None, cores=2, **brm_args)</code>","text":"<p>Fit Bayesian regression model using brms.</p> <p>Uses brms with cmdstanr backend for proper parameter naming. Returns FitResult with .idata (arviz.InferenceData) and .r (brmsfit) attributes.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>brms formula: formula string, e.g \"y ~ x + (1|group)\" or FormulaResult from formula()</p> required <code>data</code> <code>dict or DataFrame</code> <p>Model data</p> required <code>priors</code> <code>list</code> <p>Prior specifications: [(\"normal(0,1)\", \"b\"), (\"cauchy(0,2)\", \"sd\")]</p> <code>[]</code> <code>family</code> <code>str</code> <p>Distribution family: \"gaussian\", \"poisson\", \"binomial\", etc.</p> <code>\"gaussian\"</code> <code>sample_prior</code> <code>str</code> <p>Sample from prior: \"no\", \"yes\", \"only\"</p> <code>\"no\"</code> <code>sample</code> <code>bool</code> <p>Whether to sample. If False, returns compiled model with empty=TRUE</p> <code>True</code> <code>backend</code> <code>str</code> <p>Stan backend: \"cmdstanr\" (recommended), \"rstan\"</p> <code>\"cmdstanr\"</code> <code>**brm_args</code> <p>Additional brms::brm() arguments: chains=4, iter=2000, warmup=1000, cores=4, seed=123, thin=1, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Object with .idata (arviz.InferenceData) and .r (brmsfit) attributes</p> See Also <p>brms::brm : R documentation     https://paulbuerkner.com/brms/reference/brm.html posterior_epred : Expected value predictions posterior_predict : Posterior predictive samples formula : Create formula object with options</p> Warnings <p><code>cores &lt;= 1</code> is unsafe in embedded R sessions. The single-process code path used by <code>brms::brm()</code> can crash the interpreter. Always use <code>cores &gt;= 2</code> to force parallel workers and avoid segfaults.</p> <p>Examples:</p> <p>Basic Poisson regression:</p> <p><pre><code>from brmspy import brms\nimport arviz as az\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    chains=4,\n    iter=2000\n)\n\naz.summary(model.idata)\n</code></pre> With custom priors:</p> <p><pre><code>from brmspy import prior\n\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    priors=[\n        prior(\"normal(0, 0.5)\", class_=\"b\"),\n        prior(\"exponential(2)\", class_=\"sd\", group=\"patient\")\n    ],\n    family=\"poisson\",\n    chains=4\n)\n</code></pre> Survival model with censoring:</p> <p><pre><code>kidney = brms.get_brms_data(\"kidney\")\n\nsurvival_model = brms.fit(\n    formula=\"time | cens(censored) ~ age + sex + disease + (1|patient)\",\n    data=kidney,\n    family=\"weibull\",\n    chains=4,\n    iter=4000,\n    warmup=2000,\n    cores=4,\n    seed=42\n)\n</code></pre> Gaussian model with distributional regression:</p> <pre><code>    # Model both mean and variance\n    model = brms.fit(\n        formula=brms.formula(\n            \"y ~ x\",\n            sigma ~ \"z\"  # Model heteroscedasticity\n        ),\n        data=data,\n        family=\"gaussian\",\n        chains=4\n    )\n</code></pre>"},{"location":"api/brms_functions/diagnostics/","title":"diagnostics","text":"<p>Diagnostic functions for brms models with ArviZ integration.</p> <p>This module provides diagnostic functions for analyzing fitted brms models. All fitted models return <code>arviz.InferenceData</code> objects by default through the <code>.idata</code> attribute, enabling seamless integration with ArviZ's diagnostic toolkit.</p> ArviZ Integration <p>brmspy models work directly with ArviZ functions without conversion:</p> <ul> <li>Summary &amp; Convergence: <code>az.summary()</code>, <code>az.rhat()</code>, <code>az.ess()</code></li> <li>Visualization: <code>az.plot_trace()</code>, <code>az.plot_posterior()</code>, <code>az.plot_pair()</code></li> <li>Model Comparison: <code>az.loo()</code>, <code>az.waic()</code>, <code>az.compare()</code></li> <li>Predictive Checks: <code>az.plot_ppc()</code></li> </ul> <p>For multivariate models, use the <code>var_name</code> parameter in ArviZ functions to specify which response variable to analyze (e.g., <code>az.loo(model.idata, var_name=\"y1\")</code>).</p> Quick Example <pre><code>import brmspy\nimport arviz as az\n\n# Fit model\nmodel = brmspy.fit(\"count ~ zAge + (1|patient)\", data=data, family=\"poisson\")\n\n# Diagnostics\nprint(az.summary(model.idata))  # Parameter estimates with Rhat, ESS\naz.plot_trace(model.idata)       # MCMC trace plots\naz.plot_ppc(model.idata)         # Posterior predictive check\n\n# Model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre> See Also <p>Diagnostics with ArviZ : Complete guide with examples     https://kaitumisuuringute-keskus.github.io/brmspy/api/diagnostics-arviz/</p> Notes <p>The InferenceData structure contains:</p> <ul> <li>posterior: All parameter samples with brms naming (e.g., <code>b_Intercept</code>, <code>sd_patient__Intercept</code>)</li> <li>posterior_predictive: Posterior predictive samples for each response</li> <li>log_likelihood: Pointwise log-likelihood for LOO/WAIC</li> <li>observed_data: Original response values</li> </ul>"},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics-classes","title":"Classes","text":""},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics-functions","title":"Functions","text":""},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.summary","title":"<code>summary(model, **kwargs)</code>","text":"<p>Generate comprehensive summary statistics for fitted brms model.</p> <p>Returns a <code>SummaryResult</code> dataclass containing model information, parameter estimates, and diagnostic information. The SummaryResult object provides pretty printing via <code>str()</code> or <code>print()</code> and structured access to all components.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from <code>fit()</code></p> required <code>**kwargs</code> <p>Additional arguments passed to brms::summary(), such as: - probs: Quantiles for credible intervals, e.g., <code>probs=(0.025, 0.975)</code> - robust: Use robust estimates (median, MAD), default False</p> <code>{}</code> <p>Returns:</p> Type Description <code>SummaryResult</code> <p>A dataclass containing:</p> <ul> <li>formula (str): Model formula as string</li> <li>data_name (str): Name of the data object used</li> <li>group (str): Grouping structure information</li> <li>nobs (int): Number of observations</li> <li>ngrps (Dict[str, int]): Number of groups per grouping variable</li> <li>autocor (Optional[dict]): Autocorrelation structure if present</li> <li>prior (pd.DataFrame): Prior specifications used</li> <li>algorithm (str): Sampling algorithm (e.g., \"sampling\")</li> <li>sampler (str): Sampler specification (e.g., \"sample(hmc)\")</li> <li>total_ndraws (int): Total number of post-warmup draws</li> <li>chains (float): Number of chains</li> <li>iter (float): Iterations per chain</li> <li>warmup (float): Warmup iterations per chain</li> <li>thin (float): Thinning interval</li> <li>has_rhat (bool): Whether Rhat diagnostics are reported</li> <li>fixed (pd.DataFrame): Population-level (fixed) effects estimates</li> <li>spec_pars (pd.DataFrame): Family-specific parameters (e.g., sigma)</li> <li>cor_pars (pd.DataFrame): Correlation parameters if present</li> <li>random (dict): Group-level (random) effects by grouping variable</li> </ul> See Also <p>brms::summary.brmsfit : R documentation     https://paulbuerkner.com/brms/reference/summary.brmsfit.html</p> <p>Examples:</p> <p>Basic usage with pretty printing:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x\", data=data, chains=4)\nsummary = brmspy.summary(model)\n\n# Pretty print full summary\nprint(summary)\n</code></pre> <p>Access specific components:</p> <pre><code># Get population-level effects as DataFrame\nfixed_effects = summary.fixed\nprint(fixed_effects)\n\n# Get family-specific parameters (e.g., sigma)\nspec_params = summary.spec_pars\nprint(spec_params)\n\n# Access random effects (if present)\nrandom_effects = summary.random\nfor group_name, group_df in random_effects.items():\n    print(f\"Random effects for {group_name}:\")\n    print(group_df)\n\n# Check model metadata\nprint(f\"Formula: {summary.formula}\")\nprint(f\"Total draws: {summary.total_ndraws}\")\nprint(f\"Rhat reported: {summary.has_rhat}\")\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Use 90% credible intervals instead of default 95%\nsummary_90 = brmspy.summary(model, probs=(0.05, 0.95))\nprint(summary_90.fixed)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.fixef","title":"<code>fixef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, **kwargs)</code>","text":"<p>Extract population-level (fixed) effects estimates from a fitted brms model.</p> <p>Returns a pandas DataFrame containing estimates and uncertainty intervals for all population-level parameters (fixed effects). By default, returns summary statistics (mean, standard error, credible intervals). Can also return raw posterior samples when <code>summary=False</code>.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>summary</code> <code>bool</code> <p>If True, return summary statistics (mean/median, SE/MAD, credible intervals). If False, return matrix of posterior samples (iterations \u00d7 parameters).</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics. Only used when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>list of str</code> <p>Specific parameter names to extract. If None, returns all fixed effects. Useful for subsetting when you only need specific coefficients.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::fixef()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>When <code>summary=True</code> (default):     DataFrame with parameters as rows and columns for Estimate, Est.Error,     Q2.5, Q97.5 (or other quantiles specified in <code>probs</code>), and optionally     Rhat and Bulk_ESS/Tail_ESS diagnostics.</p> <p>When <code>summary=False</code>:     DataFrame with posterior samples where rows are iterations and columns     are parameters. Shape is (n_iterations \u00d7 n_parameters).</p> See Also <p>brms::fixef.brmsfit : R documentation     https://paulbuerkner.com/brms/reference/fixef.brmsfit.html summary() : Full model summary with all parameter types</p> <p>Examples:</p> <p>Basic usage with summary statistics:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=data, chains=4)\n\n# Get fixed effects summary\nfixed_effects = brmspy.fixef(model)\nprint(fixed_effects)\n#             Estimate  Est.Error      Q2.5     Q97.5\n# Intercept  10.234567   0.123456  9.992345  10.47689\n# x1          0.456789   0.098765  0.263456   0.65012\n# x2         -0.234567   0.087654 -0.406789  -0.06234\n</code></pre> <p>Get specific parameters only:</p> <pre><code># Extract only specific coefficients\nx1_x2_effects = brmspy.fixef(model, pars=[\"x1\", \"x2\"])\nprint(x1_x2_effects)\n</code></pre> <p>Use robust estimates (median and MAD):</p> <pre><code># Use median and MAD instead of mean and SD\nrobust_effects = brmspy.fixef(model, robust=True)\nprint(robust_effects)\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Get 90% credible intervals\neffects_90 = brmspy.fixef(model, probs=(0.05, 0.95))\nprint(effects_90)\n</code></pre> <p>Get raw posterior samples:</p> <pre><code># Get full posterior samples matrix\nsamples = brmspy.fixef(model, summary=False)\nprint(samples.shape)  # (n_iterations, n_parameters)\n\n# Can then compute custom statistics\nimport numpy as np\ncustom_quantile = np.percentile(samples[\"x1\"], 90)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.ranef","title":"<code>ranef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, groups=None, **kwargs)</code>","text":"<p>Extract group-level (random) effects as xarray DataArrays.</p> <p>This is a wrapper around <code>brms::ranef()</code>. For <code>summary=True</code> (default), each grouping factor is returned as a 3D array with dimensions <code>(\"group\", \"stat\", \"coef\")</code>. For <code>summary=False</code>, each factor is returned as <code>(\"draw\", \"group\", \"coef\")</code> with one slice per posterior draw.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model returned by :func:<code>brmspy.brms.fit</code> or an R <code>brmsfit</code> object / summary list.</p> required <code>summary</code> <code>bool</code> <p>If True, return posterior summaries for the group-level effects (means, errors, intervals). If False, return per-draw random effects.</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use robust summaries (median and MAD) instead of mean and SD. Passed through to <code>brms::ranef()</code> when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Central posterior interval probabilities, as in <code>brms::ranef()</code>. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>str or sequence of str</code> <p>Subset of group-level parameters to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>groups</code> <code>str or sequence of str</code> <p>Subset of grouping factors to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments forwarded to <code>brms::ranef()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, DataArray]</code> <p>Mapping from grouping-factor name (e.g. <code>\"patient\"</code>) to a <code>DataArray</code>:</p> <ul> <li><code>summary=True</code>: dims <code>(\"group\", \"stat\", \"coef\")</code>,   with <code>stat</code> typically containing   <code>[\"Estimate\", \"Est.Error\", \"Q2.5\", \"Q97.5\"]</code>.</li> <li><code>summary=False</code>: dims <code>(\"draw\", \"group\", \"coef\")</code>,   where <code>draw</code> indexes posterior samples.</li> </ul> <p>Examples:</p> <p>Compute summary random effects and inspect all coefficients for a single group level:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms import ranef\n\nfit = brms.fit(\"count ~ zAge + zBase * Trt + (1 + zBase + Trt | patient)\",\n               data=data, family=\"poisson\")\n\nre = ranef(fit)  # summary=True by default\npatient_re = re[\"patient\"].sel(group=\"1\", stat=\"Estimate\")\n</code></pre> <p>Extract per-draw random effects for downstream MCMC analysis:</p> <pre><code>re_draws = ranef(fit, summary=False)\npatient_draws = re_draws[\"patient\"]       # dims: (\"draw\", \"group\", \"coef\")\nfirst_draw = patient_draws.sel(draw=0)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.posterior_summary","title":"<code>posterior_summary(object, variable=None, probs=(0.025, 0.975), robust=False, **kwargs)</code>","text":"<p>Extract posterior summary statistics for all or selected model parameters.</p> <p>Provides a DataFrame with estimates, standard errors, and credible intervals for all parameters in a brms model, including fixed effects, random effects, and auxiliary parameters. More comprehensive than <code>fixef()</code> or <code>ranef()</code> as it covers all parameter types.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>variable</code> <code>str or list of str</code> <p>Specific variable name(s) to extract. If None, returns all parameters. Supports regex patterns for flexible selection.</p> <code>None</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals.</p> <code>(0.025, 0.975)</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments passed to brms::posterior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with parameters as rows and columns for Estimate, Est.Error, and quantiles (e.g., Q2.5, Q97.5). Includes all model parameters: population-level effects, group-level effects, and auxiliary parameters.</p> See Also <p>brms::posterior_summary : R documentation     https://paulbuerkner.com/brms/reference/posterior_summary.brmsfit.html <code>fixef()</code> : Extract only population-level effects <code>ranef()</code> : Extract only group-level effects</p> <p>Examples:</p> <p>Get summary for all parameters:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + (1|group)\", data=data, chains=4)\n\n# Get all parameter summaries\nall_params = brmspy.posterior_summary(model)\nprint(all_params)\n</code></pre> <p>Extract specific parameters:</p> <pre><code># Get summary for specific parameters\nintercept = brmspy.posterior_summary(model, variable=\"b_Intercept\")\nprint(intercept)\n\n# Multiple parameters\nfixed_only = brmspy.posterior_summary(model, variable=[\"b_Intercept\", \"b_x1\"])\nprint(fixed_only)\n</code></pre> <p>Custom credible intervals with robust estimates:</p> <pre><code># 90% intervals with median/MAD\nrobust_summary = brmspy.posterior_summary(\n    model,\n    probs=(0.05, 0.95),\n    robust=True\n)\nprint(robust_summary)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.prior_summary","title":"<code>prior_summary(object, all=True, **kwargs)</code>","text":"<p>Extract prior specifications used in a fitted brms model.</p> <p>Returns a DataFrame containing all prior distributions that were used (either explicitly set or defaults) when fitting the model. Useful for documenting model specifications and understanding which priors were applied.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>all</code> <code>bool</code> <p>If True, return all priors including default priors. If False, return only explicitly set priors.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to brms::prior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns describing prior specifications: - prior: Prior distribution formula - class: Parameter class (b, sd, Intercept, etc.) - coef: Specific coefficient (if applicable) - group: Grouping factor (if applicable) - resp: Response variable (for multivariate models) - dpar: Distributional parameter (if applicable) - nlpar: Non-linear parameter (if applicable) - lb/ub: Bounds for truncated priors - source: Origin of prior (default, user, etc.)</p> See Also <p>brms::prior_summary : R documentation     https://paulbuerkner.com/brms/reference/prior_summary.brmsfit.html <code>get_prior()</code> : Get prior structure before fitting <code>default_prior()</code> : Get default priors for a model</p> <p>Examples:</p> <p>Get all priors used in a model:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\n    \"y ~ x1 + (1|group)\",\n    data=data,\n    priors=[brmspy.prior(\"normal(0, 1)\", \"b\")],\n    chains=4\n)\n\n# Get all priors (including defaults)\npriors = brmspy.prior_summary(model)\nprint(priors)\n</code></pre> <p>Get only explicitly set priors:</p> <pre><code># Get only user-specified priors\nuser_priors = brmspy.prior_summary(model, all=False)\nprint(user_priors)\n</code></pre> <p>Compare with what would be used before fitting:</p> <pre><code># Before fitting - check default priors\ndefault_priors = brmspy.get_prior(\"y ~ x1\", data=data)\n\n# After fitting - see what was actually used\nused_priors = brmspy.prior_summary(model)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.validate_newdata","title":"<code>validate_newdata(newdata, object, re_formula=None, allow_new_levels=False, newdata2=None, resp=None, check_response=True, incl_autocor=True, group_vars=None, req_vars=None, **kwargs)</code>","text":"<p>Validate new data for predictions from a fitted brms model.</p> <p>Ensures that new data contains all required variables and has the correct structure for making predictions. Checks variable types, factor levels, grouping variables, and autocorrelation structures. This function is primarily used internally by prediction methods but can be called directly for debugging or validation purposes.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>DataFrame</code> <p>DataFrame containing new data to be validated against the model. Must include all predictor variables used in the model formula.</p> required <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>re_formula</code> <code>str</code> <p>Formula string specifying group-level effects to include in validation. If None (default), include all group-level effects. If NA, include no group-level effects.</p> <code>None</code> <code>allow_new_levels</code> <code>bool</code> <p>Whether to allow new levels of grouping variables not present in the original training data. If False, raises an error for new levels.</p> <code>False</code> <code>newdata2</code> <code>DataFrame</code> <p>Additional data that cannot be passed via <code>newdata</code>, such as objects used in autocorrelation structures or stanvars.</p> <code>None</code> <code>resp</code> <code>str or list of str</code> <p>Names of response variables to validate. If specified, validation is performed only for the specified responses (relevant for multivariate models).</p> <code>None</code> <code>check_response</code> <code>bool</code> <p>Whether to check if response variables are present in newdata. Set to False when making predictions where response is not needed.</p> <code>True</code> <code>incl_autocor</code> <code>bool</code> <p>Whether to include autocorrelation structures originally specified in the model. If True, validates autocorrelation-related variables.</p> <code>True</code> <code>group_vars</code> <code>list of str</code> <p>Names of specific grouping variables to validate. If None (default), validates all grouping variables present in the model.</p> <code>None</code> <code>req_vars</code> <code>list of str</code> <p>Names of specific variables required in newdata. If None (default), all variables from the original training data are required (unless excluded by other parameters).</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::validate_newdata()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Validated DataFrame based on newdata, potentially with added or modified columns to ensure compatibility with the model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If newdata is missing required variables</p> <code>ValueError</code> <p>If factor levels in newdata don't match those in training data (when allow_new_levels=False)</p> <code>ValueError</code> <p>If grouping variables have invalid structure</p> See Also <p>brms::validate_newdata : R documentation     https://paulbuerkner.com/brms/reference/validate_newdata.html <code>posterior_predict()</code> : Uses validate_newdata internally <code>posterior_epred()</code> : Uses validate_newdata internally</p> <p>Examples:</p> <p>Basic validation for prediction data:</p> <pre><code>import brmspy\nimport pandas as pd\n\n# Fit model\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=train_data, chains=4)\n\n# Prepare new data\nnew_data = pd.DataFrame({\n    'x1': [1.0, 2.0, 3.0],\n    'x2': [0.5, 1.0, 1.5]\n})\n\n# Validate before prediction\nvalidated_data = brmspy.validate_newdata(new_data, model)\nprint(validated_data)\n</code></pre> <p>Validate with group-level effects:</p> <pre><code># Model with random effects\nmodel = brmspy.fit(\"y ~ x + (1|group)\", data=train_data, chains=4)\n\n# New data with grouping variable\nnew_data = pd.DataFrame({\n    'x': [1.0, 2.0],\n    'group': ['A', 'B']  # Must match training data groups\n})\n\n# Validate - will error if groups A or B weren't in training\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    allow_new_levels=False\n)\n</code></pre> <p>Allow new levels for population-level predictions:</p> <pre><code># Allow new group levels (makes population-level predictions only)\nnew_data_with_new_groups = pd.DataFrame({\n    'x': [3.0, 4.0],\n    'group': ['C', 'D']  # New groups not in training\n})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data_with_new_groups,\n    model,\n    allow_new_levels=True\n)\n</code></pre> <p>Skip response variable checking:</p> <pre><code># When making predictions, response not needed\nnew_data = pd.DataFrame({'x1': [1.0, 2.0]})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    check_response=False\n)\n</code></pre>"},{"location":"api/brms_functions/families/","title":"families","text":"<p>Reference: https://paulbuerkner.com/brms/reference/brmsfamily.html</p> <p>family()</p>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families-classes","title":"Classes","text":""},{"location":"api/brms_functions/families/#brmspy.brms_functions.families-functions","title":"Functions","text":""},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.brmsfamily","title":"<code>brmsfamily(family, link=None, link_sigma='log', link_shape='log', link_nu='logm1', link_phi='log', link_kappa='log', link_beta='log', link_zi='logit', link_hu='logit', link_zoi='logit', link_coi='logit', link_disc='log', link_bs='log', link_ndt='log', link_bias='logit', link_xi='log1p', link_alpha='identity', link_quantile='logit', threshold='flexible', refcat=None, **kwargs)</code>","text":"<p>Family objects provide a convenient way to specify the details of the models used by many model fitting functions. The family functions presented here are for use with brms only and will not work with other model fitting functions such as glm or glmer. However, the standard family functions as described in family will work with brms.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <p>A character string naming the distribution family of the response variable to be used in the model. Currently, the following families are supported: gaussian, student, binomial, bernoulli, beta-binomial, poisson, negbinomial, geometric, Gamma, skew_normal, lognormal, shifted_lognormal, exgaussian, wiener, inverse.gaussian, exponential, weibull, frechet, Beta, dirichlet, von_mises, asym_laplace, gen_extreme_value, categorical, multinomial, cumulative, cratio, sratio, acat, hurdle_poisson, hurdle_negbinomial, hurdle_gamma, hurdle_lognormal, hurdle_cumulative, zero_inflated_binomial, zero_inflated_beta_binomial, zero_inflated_beta, zero_inflated_negbinomial, zero_inflated_poisson, and zero_one_inflated_beta.</p> required <code>link</code> <code>Optional[str]</code> <p>A specification for the model link function. This can be a name/expression or character string. See the 'Details' section for more information on link functions supported by each family.</p> <code>None</code> <code>link_sigma</code> <code>str</code> <p>Link of auxiliary parameter sigma if being predicted.</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link of auxiliary parameter shape if being predicted.</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link of auxiliary parameter nu if being predicted.</p> <code>'logm1'</code> <code>link_phi</code> <code>str</code> <p>Link of auxiliary parameter phi if being predicted.</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link of auxiliary parameter kappa if being predicted.</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link of auxiliary parameter beta if being predicted.</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link of auxiliary parameter zi if being predicted.</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link of auxiliary parameter hu if being predicted.</p> <code>'logit'</code> <code>link_zoi</code> <code>str</code> <p>Link of auxiliary parameter zoi if being predicted.</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link of auxiliary parameter coi if being predicted.</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link of auxiliary parameter disc if being predicted.</p> <code>'log'</code> <code>link_bs</code> <code>str</code> <p>Link of auxiliary parameter bs if being predicted.</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link of auxiliary parameter ndt if being predicted.</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link of auxiliary parameter bias if being predicted.</p> <code>'logit'</code> <code>link_xi</code> <code>str</code> <p>Link of auxiliary parameter xi if being predicted.</p> <code>'log1p'</code> <code>link_alpha</code> <code>str</code> <p>Link of auxiliary parameter alpha if being predicted.</p> <code>'identity'</code> <code>link_quantile</code> <code>str</code> <p>Link of auxiliary parameter quantile if being predicted.</p> <code>'logit'</code> <code>threshold</code> <code>str</code> <p>A character string indicating the type of thresholds (i.e. intercepts) used in an ordinal model. \"flexible\" provides the standard unstructured thresholds, \"equidistant\" restricts the distance between consecutive thresholds to the same value, and \"sum_to_zero\" ensures the thresholds sum to zero.</p> <code>'flexible'</code> <code>refcat</code> <code>Optional[str]</code> <p>Optional name of the reference response category used in categorical, multinomial, dirichlet and logistic_normal models. If NULL (the default), the first category is used as the reference. If NA, all categories will be predicted, which requires strong priors or carefully specified predictor terms in order to lead to an identified model.</p> <code>None</code> <code>bhaz</code> <p>Currently for experimental purposes only.</p> required"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.family","title":"<code>family(fit, **kwargs)</code>","text":"<p>Extract family object from a fitted model.</p> <p>Parameters:</p> Name Type Description Default <code>fit</code> <code>FitResult or ListVector</code> <p>Fitted brms model</p> required"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.student","title":"<code>student(link='identity', link_sigma='log', link_nu='logm1', **kwargs)</code>","text":"<p>Student's t distribution for robust regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for degrees of freedom parameter</p> <code>'logm1'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.bernoulli","title":"<code>bernoulli(link='logit', **kwargs)</code>","text":"<p>Bernoulli distribution for binary 0/1 outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.beta_binomial","title":"<code>beta_binomial(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta-binomial distribution for overdispersed binomial data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.negbinomial","title":"<code>negbinomial(link='log', link_shape='log', **kwargs)</code>","text":"<p>Negative binomial distribution for overdispersed count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.geometric","title":"<code>geometric(link='log', **kwargs)</code>","text":"<p>Geometric distribution for count data (negative binomial with shape=1).</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.lognormal","title":"<code>lognormal(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Lognormal distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean on log scale</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.shifted_lognormal","title":"<code>shifted_lognormal(link='identity', link_sigma='log', link_ndt='log', **kwargs)</code>","text":"<p>Shifted lognormal distribution with non-decision time parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.skew_normal","title":"<code>skew_normal(link='identity', link_sigma='log', link_alpha='identity', **kwargs)</code>","text":"<p>Skew normal distribution for asymmetric continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_alpha</code> <code>str</code> <p>Link function for skewness parameter</p> <code>'identity'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.exponential","title":"<code>exponential(link='log', **kwargs)</code>","text":"<p>Exponential distribution for time-to-event data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.weibull","title":"<code>weibull(link='log', link_shape='log', **kwargs)</code>","text":"<p>Weibull distribution for survival and reliability analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.frechet","title":"<code>frechet(link='log', link_nu='logm1', **kwargs)</code>","text":"<p>Frechet distribution for extreme value analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'logm1'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.gen_extreme_value","title":"<code>gen_extreme_value(link='identity', link_sigma='log', link_xi='log1p', **kwargs)</code>","text":"<p>Generalized extreme value distribution for extreme events.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location parameter</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_xi</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log1p'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.exgaussian","title":"<code>exgaussian(link='identity', link_sigma='log', link_beta='log', **kwargs)</code>","text":"<p>Ex-Gaussian distribution for reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for Gaussian SD parameter</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link function for exponential rate parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.wiener","title":"<code>wiener(link='identity', link_bs='log', link_ndt='log', link_bias='logit', **kwargs)</code>","text":"<p>Wiener diffusion model for two-choice reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for drift rate</p> <code>'identity'</code> <code>link_bs</code> <code>str</code> <p>Link function for boundary separation</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link function for initial bias</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.Beta","title":"<code>Beta(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta distribution for data between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.xbeta","title":"<code>xbeta(link='logit', link_phi='log', link_kappa='log', **kwargs)</code>","text":"<p>Extended beta distribution with additional shape parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link function for kappa shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.dirichlet","title":"<code>dirichlet(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.logistic_normal","title":"<code>logistic_normal(link='identity', link_sigma='log', refcat=None, **kwargs)</code>","text":"<p>Logistic-normal distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.von_mises","title":"<code>von_mises(link='tan_half', link_kappa='log', **kwargs)</code>","text":"<p>Von Mises distribution for circular/directional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean direction</p> <code>'tan_half'</code> <code>link_kappa</code> <code>str</code> <p>Link function for concentration parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.asym_laplace","title":"<code>asym_laplace(link='identity', link_sigma='log', link_quantile='logit', **kwargs)</code>","text":"<p>Asymmetric Laplace distribution for quantile regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_quantile</code> <code>str</code> <p>Link function for the quantile parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.cox","title":"<code>cox(link='log', **kwargs)</code>","text":"<p>Cox proportional hazards model for survival data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the hazard rate</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.hurdle_poisson","title":"<code>hurdle_poisson(link='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Poisson distribution for zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.hurdle_negbinomial","title":"<code>hurdle_negbinomial(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle negative binomial for overdispersed zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.hurdle_gamma","title":"<code>hurdle_gamma(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Gamma distribution for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.hurdle_lognormal","title":"<code>hurdle_lognormal(link='identity', link_sigma='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle lognormal for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.hurdle_cumulative","title":"<code>hurdle_cumulative(link='logit', link_hu='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Hurdle cumulative for zero-inflated ordinal data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the ordinal response</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.zero_inflated_beta","title":"<code>zero_inflated_beta(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta for data between 0 and 1 with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.zero_one_inflated_beta","title":"<code>zero_one_inflated_beta(link='logit', link_phi='log', link_zoi='logit', link_coi='logit', **kwargs)</code>","text":"<p>Zero-one-inflated beta for data between 0 and 1 with excess zeros and ones.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zoi</code> <code>str</code> <p>Link function for zero-or-one inflation parameter</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link function for conditional one inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.zero_inflated_poisson","title":"<code>zero_inflated_poisson(link='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated Poisson for count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.zero_inflated_negbinomial","title":"<code>zero_inflated_negbinomial(link='log', link_shape='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated negative binomial for overdispersed count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.zero_inflated_binomial","title":"<code>zero_inflated_binomial(link='logit', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated binomial for binary count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.zero_inflated_beta_binomial","title":"<code>zero_inflated_beta_binomial(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta-binomial for overdispersed binomial data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.categorical","title":"<code>categorical(link='logit', refcat=None, **kwargs)</code>","text":"<p>Categorical distribution for unordered multi-category outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.multinomial","title":"<code>multinomial(link='logit', refcat=None, **kwargs)</code>","text":"<p>Multinomial distribution for count data across multiple categories.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.dirichlet_multinomial","title":"<code>dirichlet_multinomial(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet-multinomial for overdispersed categorical count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.cumulative","title":"<code>cumulative(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Cumulative (proportional odds) model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for cumulative probabilities</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.sratio","title":"<code>sratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Sequential (stopping) ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for sequential ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.cratio","title":"<code>cratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Continuation ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for continuation ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.acat","title":"<code>acat(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Adjacent category model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for adjacent category ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.gaussian","title":"<code>gaussian(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Gaussian (normal) distribution for continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the standard deviation</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.poisson","title":"<code>poisson(link='log', **kwargs)</code>","text":"<p>Poisson distribution for count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.binomial","title":"<code>binomial(link='logit', **kwargs)</code>","text":"<p>Binomial distribution for binary count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.Gamma","title":"<code>Gamma(link='log', link_shape='log', **kwargs)</code>","text":"<p>Gamma distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.inverse_gaussian","title":"<code>inverse_gaussian(link='1/mu^2', link_shape='log', **kwargs)</code>","text":"<p>Inverse Gaussian distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'1/mu^2'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/formula/","title":"formula","text":""},{"location":"api/brms_functions/formula/#brmspy.brms_functions.formula-classes","title":"Classes","text":""},{"location":"api/brms_functions/formula/#brmspy.brms_functions.formula-functions","title":"Functions","text":""},{"location":"api/brms_functions/formula/#brmspy.brms_functions.formula.bf","title":"<code>bf(formula, **formula_args)</code>","text":"<p>Set up a model formula for brms package.</p> <p>Allows defining (potentially non-linear) additive multilevel models for all parameters of the assumed response distribution.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>brms formula specification, e.g., \"y ~ x + (1|group)\"</p> required <code>**formula_args</code> <code>dict</code> <p>Additional brms::brmsformula() arguments:</p> <ul> <li>decomp : str     Decomposition method (e.g., \"QR\" for QR decomposition)</li> <li>center : bool     Whether to center predictors (default True)</li> <li>sparse : bool     Use sparse matrix representation</li> <li>nl : bool     Whether formula is non-linear</li> <li>loop : bool     Use loop-based Stan code</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object with .r (R brmsformula object) and .dict (Python dict) attributes</p> See Also <p>brms::brmsformula : R documentation     https://paulbuerkner.com/brms/reference/brmsformula.html fit : Fit model using formula</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>    from brmspy import brms\n    f = brms.bf(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>With QR decomposition for numerical stability:</p> <pre><code>f = brms.bf(\n    \"reaction ~ days + (days|subject)\",\n    decomp=\"QR\"\n)\n</code></pre> <p>Multivariate formula: <pre><code>    f = brms.bf(\n        \"mvbind(y1, y2) ~ x1 + x2\",\n        center=True\n    )\n</code></pre></p>"},{"location":"api/brms_functions/formula/#brmspy.brms_functions.formula.lf","title":"<code>lf(*formulas, flist=None, dpar=None, resp=None, center=None, cmc=None, sparse=None, decomp=None)</code>","text":"<p>Specify linear formulas for distributional / non-linear parameters.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str or FormulaResult</code> <p>One or more formulas (e.g. \"sigma ~ x\", \"nu ~ z\").</p> <code>()</code> <code>flist</code> <code>list</code> <p>Additional formulas passed as a list.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Name of the distributional parameter (e.g. \"sigma\").</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response name in multivariate models.</p> <code>None</code> <code>center</code> <code>optional</code> <p>Passed through to brms::lf().</p> <code>None</code> <code>cmc</code> <code>optional</code> <p>Passed through to brms::lf().</p> <code>None</code> <code>sparse</code> <code>optional</code> <p>Passed through to brms::lf().</p> <code>None</code> <code>decomp</code> <code>optional</code> <p>Passed through to brms::lf().</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object that can be added to a bf() formula via +.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = bf(\"y ~ 1\") + lf(\"sigma ~ x\", dpar=\"sigma\")\n</code></pre>"},{"location":"api/brms_functions/formula/#brmspy.brms_functions.formula.nlf","title":"<code>nlf(formula, *extra, flist=None, dpar=None, resp=None, loop=None)</code>","text":"<p>Specify non-linear formulas for distributional parameters.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>Non-linear formula, e.g. \"sigma ~ a * exp(b * x)\".</p> required <code>*extra</code> <code>str or FormulaResult</code> <p>Additional named parameters or formulas (rarely needed here; typically you use lf() for those).</p> <code>()</code> <code>flist</code> <code>list</code> <p>Additional formulas passed as a list.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Name of the distributional parameter.</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response name in multivariate models.</p> <code>None</code> <code>loop</code> <code>bool</code> <p>Whether to compute inside a loop (brms::nlf(loop=...)).</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object that can be added to a bf() formula via +.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = bf(\"y ~ 1\") + nlf(\"sigma ~ a * exp(b * x)\")\n</code></pre>"},{"location":"api/brms_functions/formula/#brmspy.brms_functions.formula.acformula","title":"<code>acformula(autocor, resp=None)</code>","text":"<p>Specify autocorrelation terms to add to a model.</p> <p>Parameters:</p> Name Type Description Default <code>autocor</code> <code>str</code> <p>One-sided formula with autocorrelation terms, e.g. \"~ arma(p = 1, q = 1)\".</p> required <code>resp</code> <code>str</code> <p>Response name in multivariate models.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object that can be added to a bf() formula via +.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = bf(\"y ~ x\") + acformula(\"~ arma(p = 1, q = 1)\")\n</code></pre>"},{"location":"api/brms_functions/formula/#brmspy.brms_functions.formula.set_rescor","title":"<code>set_rescor(rescor=True)</code>","text":"<p>Control residual correlations in multivariate models.</p> <p>Parameters:</p> Name Type Description Default <code>rescor</code> <code>bool</code> <p>Whether to model residual correlations.</p> <code>True</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object that can be added to a multivariate formula via +.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = bf(\"y1 ~ x\") + bf(\"y2 ~ z\") + set_rescor(True)\n</code></pre>"},{"location":"api/brms_functions/formula/#brmspy.brms_functions.formula.set_mecor","title":"<code>set_mecor(mecor=True)</code>","text":"<p>Control correlations between latent me-terms.</p> <p>Parameters:</p> Name Type Description Default <code>mecor</code> <code>bool</code> <p>Whether to model correlations between me() latent variables.</p> <code>True</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object that can be added to a formula via +.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = bf(\"y ~ me(x, sdx)\") + set_mecor(True)\n</code></pre>"},{"location":"api/brms_functions/formula/#brmspy.brms_functions.formula.set_nl","title":"<code>set_nl(dpar=None, resp=None)</code>","text":"<p>Mark a formula as non-linear (or parts of it).</p> <p>Parameters:</p> Name Type Description Default <code>dpar</code> <code>str</code> <p>Distributional parameter name (if only part of the model is non-linear).</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response name in multivariate models.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object that can be added to a formula via +.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = bf(\"y ~ a * inv_logit(x * b)\") + lf(\"a + b ~ z\") + set_nl()\n</code></pre>"},{"location":"api/brms_functions/generic/","title":"generic","text":""},{"location":"api/brms_functions/generic/#brmspy.brms_functions.generic-functions","title":"Functions","text":""},{"location":"api/brms_functions/generic/#brmspy.brms_functions.generic.sanitised_name","title":"<code>sanitised_name(function)</code>","text":"<p>Sanitize a function name for safe R execution.</p> <p>Converts Python-style function names to valid R identifiers by: - Replacing invalid characters with underscores - Ensuring the name doesn't start with a number - Preserving namespace separators (::)</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Function name to sanitize</p> required <p>Returns:</p> Type Description <code>str</code> <p>Sanitized function name safe for R execution</p> <p>Examples:</p> <pre><code>from brmspy.brms_functions.generic import sanitised_name\n\n# Basic sanitization\nprint(sanitised_name(\"my-function\"))  # \"my_function\"\nprint(sanitised_name(\"123func\"))       # \"_123func\"\n\n# Preserves namespace\nprint(sanitised_name(\"brms::loo\"))     # \"brms::loo\"\n</code></pre>"},{"location":"api/brms_functions/generic/#brmspy.brms_functions.generic.call","title":"<code>call(function, *args, **kwargs)</code>","text":"<p>Call any brms or R function by name with automatic type conversion.</p> <p>Generic wrapper for calling brms functions that don't have dedicated Python wrappers. Automatically converts Python arguments to R objects and R results back to Python. Tries <code>brms::function_name</code> first, then falls back to base R.</p> <p>This function is useful for: - Accessing newer brms functions not yet wrapped in brmspy - Calling brms utility functions without writing custom wrappers - Quick exploration of brms functionality from Python</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Name of the R function to call. Will be prefixed with 'brms::' if possible. Can also include namespace (e.g., \"stats::predict\").</p> required <code>*args</code> <p>Positional arguments passed to the R function. Automatically converted from Python to R types (FitResult \u2192 brmsfit, DataFrame \u2192 data.frame, etc.).</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments passed to the R function. Python parameter names are automatically converted to R conventions.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Result from R function, automatically converted to appropriate Python type (R data.frame \u2192 pandas DataFrame, R vector \u2192 numpy array, etc.).</p> See Also <p><code>py_to_r</code> : Python to R type conversion <code>r_to_py</code> : R to Python type conversion</p> <p>Examples:</p> <p>Call brms functions not yet wrapped:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms_functions.generic import call\n\nmodel = brms.fit(\"y ~ x\", data=data, chains=4)\n\n# Call brms::neff_ratio (not yet wrapped)\nneff = call(\"neff_ratio\", model)\nprint(neff)\n\n# Call brms::rhat (not yet wrapped)\nrhat = call(\"rhat\", model)\nprint(rhat)\n</code></pre> <p>Call with keyword arguments:</p> <pre><code># Call brms::hypothesis for testing hypotheses\nhypothesis_result = call(\n    \"hypothesis\",\n    model,\n    hypothesis=\"b_x1 &gt; 0\",\n    alpha=0.05\n)\nprint(hypothesis_result)\n</code></pre> <p>Access functions from other R packages:</p> <pre><code># Call functions with namespace\nresult = call(\"stats::AIC\", model)\nprint(result)\n</code></pre>"},{"location":"api/brms_functions/io/","title":"io","text":""},{"location":"api/brms_functions/io/#brmspy.brms_functions.io-classes","title":"Classes","text":""},{"location":"api/brms_functions/io/#brmspy.brms_functions.io-functions","title":"Functions","text":""},{"location":"api/brms_functions/io/#brmspy.brms_functions.io.get_data","title":"<code>get_data(dataset_name, **kwargs)</code>","text":"<p>Load an R dataset and return it as a pandas DataFrame.</p> <p>This is a thin wrapper around R's <code>data()</code> that loads the object into the R global environment and converts it to a :class:<code>pandas.DataFrame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Name of the dataset as used in R (e.g. <code>\"BTdata\"</code>).</p> required <code>**kwargs</code> <p>Additional keyword arguments forwarded to R's <code>data()</code> function, for example <code>package=\"MCMCglmm\"</code> or other arguments supported by <code>utils::data()</code> in R.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset converted to a pandas DataFrame.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the dataset is not found in the R global environment after calling <code>data()</code>.</p> <code>RuntimeError</code> <p>If conversion from the R object to a pandas DataFrame fails.</p> See Also <p>get_brms_data     Convenience wrapper for datasets from the <code>brms</code> package.</p>"},{"location":"api/brms_functions/io/#brmspy.brms_functions.io.get_brms_data","title":"<code>get_brms_data(dataset_name, **kwargs)</code>","text":"<p>Load an example dataset from the R <code>brms</code> package.</p> <p>This is a convenience wrapper around :func:<code>get_data</code> that fixes <code>package=\"brms\"</code> and returns the dataset as a :class:<code>pandas.DataFrame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Name of the example dataset in the <code>brms</code> package (e.g. <code>\"epilepsy\"</code>, <code>\"kidney\"</code>, <code>\"inhaler\"</code>).</p> required <code>**kwargs</code> <p>Additional keyword arguments forwarded to :func:<code>get_data</code> and ultimately to R's <code>data()</code> function. These can be used to override defaults such as the target environment.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset as a pandas DataFrame with column names preserved.</p> See Also <p>get_data     Generic loader for datasets from arbitrary R packages. brms R reference     For a list of available example datasets and their structure.</p> <p>Examples:</p> <p>Load the epilepsy dataset::</p> <pre><code>from brmspy.runtime import get_brms_data\n\nepilepsy = get_brms_data(\"epilepsy\")\nprint(epilepsy.head())\n</code></pre> <p>Load the kidney dataset and inspect censoring::</p> <pre><code>kidney = get_brms_data(\"kidney\")\nprint(kidney.shape)\nprint(kidney[\"censored\"].value_counts())\n</code></pre>"},{"location":"api/brms_functions/io/#brmspy.brms_functions.io.save_rds","title":"<code>save_rds(object, file, **kwargs)</code>","text":"<p>Save brmsfit object or R object to RDS file.</p> <p>Saves fitted brms models or other R objects to disk using R's saveRDS() function. This allows persisting models for later use, sharing fitted models, or creating model checkpoints during long computations.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Object to save. Can be: - FitResult from fit() - saves the underlying brmsfit R object - Any R ListVector object</p> required <code>file</code> <code>str</code> <p>File path where object will be saved. Typically uses .rds extension but not required</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to R's saveRDS():</p> <ul> <li>compress : bool or str - Compression method:     True (default), False, \"gzip\", \"bzip2\", \"xz\"</li> <li>version : int - RDS format version (2 or 3)</li> <li>ascii : bool - Use ASCII representation (default False)</li> <li>refhook : function - Reference hook for serialization (NOT tested)</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> See Also <p>read_rds_fit : Load saved brmsfit as FitResult read_rds_raw : Load saved object as raw R ListVector fit : Fit models that can be saved</p> <p>Examples:</p> <p>Save a fitted model:</p> <pre><code>from brmspy import brms\n\n# Fit model\nmodel = brms.fit(\n    formula=\"y ~ x + (1|group)\",\n    data=data,\n    family=\"gaussian\",\n    chains=4\n)\n\n# Save to file\nbrms.save_rds(model, \"my_model.rds\")\n</code></pre> <p>Save with compression options:</p> <pre><code># High compression for storage\nbrms.save_rds(model, \"model.rds\", compress=\"xz\")\n\n# No compression for faster saving\nbrms.save_rds(model, \"model.rds\", compress=False)\n</code></pre> <p>Save and later reload:</p> <pre><code># Save model\nbrms.save_rds(model, \"model.rds\")\n\n# Later session: reload model\nloaded_model = brms.read_rds_fit(\"model.rds\")\n\n# Use loaded model for predictions\npredictions = brms.posterior_predict(loaded_model, newdata=new_data)\n</code></pre>"},{"location":"api/brms_functions/io/#brmspy.brms_functions.io.read_rds_raw","title":"<code>read_rds_raw(file, **kwargs)</code>","text":"<p>Load R object from RDS file as raw ListVector.</p> <p>Reads an RDS file and returns the raw R object without any Python conversion or processing. Useful when you need direct access to the R object structure or want to inspect saved objects before full conversion.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to RDS file to load</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to R's readRDS():</p> <ul> <li>refhook : function - Reference hook for deserialization</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>ListVector</code> <p>Raw R ListVector object from the RDS file</p> See Also <p>read_rds_fit : Load as FitResult with arviz InferenceData save_rds : Save R objects to RDS files</p> <p>Examples:</p> <p>Load raw R object:</p> <pre><code>from brmspy import brms\n\n# Load raw brmsfit object\nraw_model = brms.read_rds_raw(\"model.rds\")\n\n# Access R object directly (for advanced users)\nprint(type(raw_model))  # rpy2.robjects.vectors.ListVector\n</code></pre> <p>Inspect object structure before conversion:</p> <pre><code># Load raw to check what's in the file\nraw_obj = brms.read_rds_raw(\"unknown_object.rds\")\n\n# Inspect R object attributes\nprint(raw_obj.names)\n\n# Then decide how to process it\nif \"fit\" in raw_obj.names:\n    # It's a brmsfit, convert properly\n    full_model = brms.read_rds_fit(\"unknown_object.rds\")\n</code></pre>"},{"location":"api/brms_functions/io/#brmspy.brms_functions.io.read_rds_fit","title":"<code>read_rds_fit(file, **kwargs)</code>","text":"<p>Load saved brmsfit object as FitResult with arviz InferenceData.</p> <p>Reads a brmsfit object from an RDS file and converts it to a FitResult with both arviz InferenceData (.idata) and the raw R object (.r). This is the recommended way to load saved brms models for analysis and predictions in Python.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to RDS file containing saved brmsfit object</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to R's readRDS():</p> <ul> <li>refhook : function - Reference hook for deserialization</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Object with two attributes: - .idata : arviz.InferenceData with posterior samples and diagnostics - .r : R brmsfit object for use with brms functions</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If file doesn't exist or doesn't contain a valid brmsfit object</p> See Also <p>save_rds : Save brmsfit objects to RDS files read_rds_raw : Load as raw R object without conversion fit : Create brmsfit objects to save</p> <p>Examples:</p> <p>Basic loading and analysis:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\n# Load previously saved model\nmodel = brms.read_rds_fit(\"my_model.rds\")\n\n# Analyze with arviz\naz.summary(model.idata)\naz.plot_trace(model.idata)\n\n# Check diagnostics\nprint(az.rhat(model.idata))\n</code></pre> <p>Load and make predictions:</p> <pre><code>import pandas as pd\n\n# Load saved model\nmodel = brms.read_rds_fit(\"trained_model.rds\")\n\n# Create new data for predictions\nnewdata = pd.DataFrame({\n    'x': [1.0, 2.0, 3.0],\n    'group': ['A', 'B', 'A']\n})\n\n# Generate predictions\npredictions = brms.posterior_predict(model, newdata=newdata)\nprint(predictions.idata.posterior_predictive)\n</code></pre> <p>Load model for comparison:</p> <pre><code># Load multiple saved models\nmodel1 = brms.read_rds_fit(\"model1.rds\")\nmodel2 = brms.read_rds_fit(\"model2.rds\")\n\n# Compare with arviz\ncomparison = az.compare({\n    'model1': model1.idata,\n    'model2': model2.idata\n})\nprint(comparison)\n</code></pre> <p>Resume analysis from checkpoint:</p> <pre><code># Load model from checkpoint during long computation\ntry:\n    model = brms.read_rds_fit(\"checkpoint.rds\")\n    print(\"Loaded from checkpoint\")\nexcept:\n    # Checkpoint doesn't exist, fit from scratch\n    model = brms.fit(formula=\"y ~ x\", data=data, chains=4)\n    brms.save_rds(model, \"checkpoint.rds\")\n\n# Continue analysis\nsummary = brms.summary(model)\n</code></pre>"},{"location":"api/brms_functions/prediction/","title":"prediction","text":""},{"location":"api/brms_functions/prediction/#brmspy.brms_functions.prediction-classes","title":"Classes","text":""},{"location":"api/brms_functions/prediction/#brmspy.brms_functions.prediction-functions","title":"Functions","text":""},{"location":"api/brms_functions/prediction/#brmspy.brms_functions.prediction.posterior_epred","title":"<code>posterior_epred(model, newdata, **kwargs)</code>","text":"<p>Compute expected value of posterior predictive distribution.</p> <p>Calls brms::posterior_epred() to get E[Y|data] without observation noise.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions</p> required <code>**kwargs</code> <p>Additional arguments to brms::posterior_epred()</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorEpredResult</code> <p>Object with .idata and .r attributes</p>"},{"location":"api/brms_functions/prediction/#brmspy.brms_functions.prediction.posterior_predict","title":"<code>posterior_predict(model, newdata=None, **kwargs)</code>","text":"<p>Generate posterior predictive samples with observation noise.</p> <p>Calls brms::posterior_predict() to get samples of Y_new|data.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to brms::posterior_predict()</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorPredictResult</code> <p>Object with .idata and .r attributes</p>"},{"location":"api/brms_functions/prediction/#brmspy.brms_functions.prediction.posterior_linpred","title":"<code>posterior_linpred(model, newdata=None, **kwargs)</code>","text":"<p>Compute linear predictor of the model.</p> <p>Returns samples of the linear predictor (before applying the link function). Useful for understanding the model's predictions on the linear scale.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments to brms::posterior_linpred():</p> <ul> <li>transform : bool - Apply inverse link function (default False)</li> <li>ndraws : int - Number of posterior draws</li> <li>summary : bool - Return summary statistics</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorLinpredResult</code> <p>Object with .idata (IDLinpred) and .r (R matrix) attributes</p> See Also <p>brms::posterior_linpred : R documentation     https://paulbuerkner.com/brms/reference/posterior_linpred.brmsfit.html posterior_epred : Expected values on response scale</p> <p>Examples:</p> <pre><code>    from brmspy import brms\n\n    epilepsy = brms.get_brms_data(\"epilepsy\")\n    model = brms.fit(\n        \"count ~ zAge + zBase * Trt + (1|patient)\",\n        data=epilepsy,\n        family=\"poisson\",\n        chains=4\n    )\n\n    # Linear predictor (log scale for Poisson)\n    linpred = brms.posterior_linpred(model)\n    print(linpred.idata.predictions)\n</code></pre>"},{"location":"api/brms_functions/prediction/#brmspy.brms_functions.prediction.log_lik","title":"<code>log_lik(model, newdata=None, **kwargs)</code>","text":"<p>Compute log-likelihood values.</p> <p>Returns log p(y|theta) for each observation. Essential for model comparison via LOO-CV and WAIC.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments to brms::log_lik():</p> <ul> <li>ndraws : int - Number of posterior draws</li> <li>combine_chains : bool - Combine chains (default True)</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>LogLikResult</code> <p>Object with .idata (IDLogLik) and .r (R matrix) attributes</p> See Also <p>brms::log_lik : R documentation     https://paulbuerkner.com/brms/reference/log_lik.brmsfit.html arviz.loo : Leave-One-Out Cross-Validation arviz.waic : Widely Applicable Information Criterion</p> <p>Examples:</p> <p>Compute log-likelihood for model comparison:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    \"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    chains=4\n)\n\n# LOO-CV for model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre> <p>Compare multiple models: <pre><code>model1 = brms.fit(\"count ~ zAge + (1|patient)\", data=epilepsy, family=\"poisson\", chains=4)\nmodel2 = brms.fit(\"count ~ zAge + zBase + (1|patient)\", data=epilepsy, family=\"poisson\", chains=4)\n\ncomp = az.compare({'model1': model1.idata, 'model2': model2.idata})\nprint(comp)\n</code></pre></p>"},{"location":"api/brms_functions/prior/","title":"prior","text":""},{"location":"api/brms_functions/prior/#brmspy.brms_functions.prior-classes","title":"Classes","text":""},{"location":"api/brms_functions/prior/#brmspy.brms_functions.prior-functions","title":"Functions","text":""},{"location":"api/brms_functions/prior/#brmspy.brms_functions.prior.prior","title":"<code>prior(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None, **kwargs)</code>","text":"<p>Create a brms-style prior specification.</p> <p>This function mirrors the behavior of <code>brms::prior_string()</code> and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of <code>prior_string()</code> in brms.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>str</code> <p>The prior definition as a string, exactly as brms expects it. Examples include ::</p> <pre><code>\"normal(0, 1)\"\n\"student_t(3, 0, 1.5)\"\n\"exponential(2)\"\n\"lkj(2)\"\n</code></pre> required <code>class_</code> <code>str</code> <p>Parameter class (e.g. <code>\"b\"</code>, <code>\"sd\"</code>, <code>\"Intercept\"</code>). This corresponds to <code>class</code> in brms. <code>class</code> cannot be used as a parameter in Python (reserved keyword), so <code>class_</code> is used instead.</p> <code>None</code> <code>coef</code> <code>str</code> <p>Coefficient name for class-level effects.</p> <code>None</code> <code>group</code> <code>str</code> <p>Grouping variable for hierarchical/multilevel effects.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Distributional parameter (e.g. <code>\"sigma\"</code> or <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response variable name for multivariate models.</p> <code>None</code> <code>nlpar</code> <code>str</code> <p>Nonlinear parameter name if using nonlinear formulas.</p> <code>None</code> <code>lb</code> <code>float</code> <p>Lower bound for truncated priors.</p> <code>None</code> <code>ub</code> <code>float</code> <p>Upper bound for truncated priors.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Any additional keyword arguments supported by <code>brms::prior_string()</code>. These are forwarded unchanged.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriorSpec</code> <p>A typed prior specification object used by <code>brmspy.fit()</code> and <code>brmspy.make_stancode()</code>.</p> Notes <p>This function does not validate the prior expression string itself \u2014 validation occurs inside brms. Its purpose is to construct a structured, editor-friendly representation that seamlessly maps to rpy2 calls.</p> <p>Examples:</p> <p>Prior on the intercept ::</p> <pre><code>p = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\")\n</code></pre> <p>Prior on a coefficient ::</p> <pre><code>p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n</code></pre> <p>Group-level (hierarchical) SD prior ::</p> <pre><code>p = prior(\"exponential(2)\", class_=\"sd\", group=\"region\")\n</code></pre> <p>Truncated prior ::</p> <pre><code>p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0)\n</code></pre> <p>Multiple priors passed to <code>fit</code> ::</p> <pre><code>from brmspy import prior\npriors = [\n    prior(\"student_t(3, 0, 2)\", class_=\"b\", coef=\"zAge\"),\n    prior(\"exponential(2)\", class_=\"sd\", group=\"patient\"),\n]\nmodel = brms.fit(\"y ~ zAge + (1|patient)\", data=df, priors=priors)\n</code></pre>"},{"location":"api/brms_functions/prior/#brmspy.brms_functions.prior.get_prior","title":"<code>get_prior(formula, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for all model parameters.</p> <p>Returns a DataFrame with default priors for each parameter class in the specified brms model. Useful for reviewing and customizing priors before fitting.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaResult</code> <p>Model formula (e.g., \"y ~ x + (1|group)\") or FormulaResult object</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\")</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row represents a parameter or parameter class that can have a custom prior.</p> See Also <p>default_prior : Generic function for getting default priors prior : Create custom prior specifications brms::get_prior : R documentation     https://paulbuerkner.com/brms/reference/get_prior.html</p> <p>Examples:</p> <p>Review default priors for a model:</p> <pre><code>from brmspy import brms\n\npriors = brms.get_prior(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\nprint(priors)\n#   prior       class    coef      group  ...\n#   student_t() Intercept  ...    ...     ...\n#   (flat)      b          zAge    ...    ...\n</code></pre> <p>Customize and use priors:</p> <pre><code>from brmspy import brms, prior\n\n# Get defaults\npriors_df = brms.get_prior(\"y ~ x\", data=df)\n\n# Create custom priors based on review\ncustom_priors = [\n    prior(\"normal(0, 0.5)\", class_=\"b\"),\n    prior(\"exponential(2)\", class_=\"sigma\")\n]\n\nmodel = brms.fit(\"y ~ x\", data=df, priors=custom_priors)\n</code></pre>"},{"location":"api/brms_functions/prior/#brmspy.brms_functions.prior.default_prior","title":"<code>default_prior(object, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for brms model parameters (generic function).</p> <p>Generic function to retrieve default prior specifications for all parameters in a brms model. Accepts formula objects, brmsformula objects, or other model specification objects. This is the generic version of get_prior().</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>str, FormulaResult, or ListVector</code> <p>Model specification: formula string, brmsformula object, mvbrmsformula, or any object that can be coerced to these classes</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\"). Can be a list of families for multivariate models</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels, sparse)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row specifies a parameter class with its default prior. The 'prior' column is empty except for internal defaults.</p> See Also <p>get_prior : Convenience function with formula parameter prior : Create custom prior specifications brms::default_prior : R documentation     https://paulbuerkner.com/brms/reference/get_prior.html</p> <p>Examples:</p> <p>Get default priors for a Poisson model:</p> <pre><code>from brmspy import brms\n\npriors = brms.default_prior(\n    object=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\nprint(priors)\n</code></pre> <p>Use with formula object:</p> <pre><code>from brmspy import brms\n\nf = brms.formula(\"y ~ x + (1|group)\")\npriors = brms.default_prior(f, data=df, family=\"gaussian\")\n</code></pre>"},{"location":"api/brms_functions/stan/","title":"stan","text":""},{"location":"api/brms_functions/stan/#brmspy.brms_functions.stan-classes","title":"Classes","text":""},{"location":"api/brms_functions/stan/#brmspy.brms_functions.stan-functions","title":"Functions","text":""},{"location":"api/brms_functions/stan/#brmspy.brms_functions.stan.make_stancode","title":"<code>make_stancode(formula, data, priors=None, family='poisson', sample_prior='no', formula_args=None)</code>","text":"<p>Generate Stan code using brms::make_stancode().</p> <p>Useful for inspecting the generated Stan model before fitting, understanding the model structure, or using the code with other Stan interfaces.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaResult</code> <p>brms formula specification</p> required <code>data</code> <code>DataFrame</code> <p>Model data</p> required <code>priors</code> <code>list of PriorSpec</code> <p>Prior specifications from prior() function</p> <code>None</code> <code>family</code> <code>str</code> <p>Distribution family (gaussian, poisson, binomial, etc.)</p> <code>\"poisson\"</code> <code>sample_prior</code> <code>str</code> <p>Whether to sample from prior: - \"no\": No prior samples - \"yes\": Include prior samples alongside posterior - \"only\": Sample from prior only (no data)</p> <code>\"no\"</code> <code>formula_args</code> <code>dict</code> <p>Additional arguments passed to formula()</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Complete Stan program code as string</p> See Also <p>brms::make_stancode : R documentation     https://paulbuerkner.com/brms/reference/make_stancode.html fit : Fit model instead of just generating code make_standata : Generate Stan data block</p> <p>Examples:</p> <p>Generate Stan code for simple model:</p> <pre><code>from brmspy import brms\nepilepsy = brms.get_brms_data(\"epilepsy\")\n\nstan_code = brms.make_stancode(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\n\nprint(stan_code[:500])  # Print first 500 characters\n</code></pre> <p>With custom priors:</p> <pre><code>    from brmspy import prior\n\n    stan_code = brms.make_stancode(\n        formula=\"count ~ zAge\",\n        data=epilepsy,\n        priors=[prior(\"normal(0, 1)\", class_=\"b\")],\n        family=\"poisson\"\n    )\n</code></pre> <p>For prior predictive checks (sample_prior=\"only\"):</p> <pre><code>stan_code = brms.make_stancode(\n    formula=\"count ~ zAge\",\n    data=epilepsy,\n    family=\"poisson\",\n    sample_prior=\"only\"\n)\n</code></pre>"},{"location":"api/helpers/conversion/","title":"Conversion","text":""},{"location":"api/helpers/conversion/#brmspy.helpers.conversion-classes","title":"Classes","text":""},{"location":"api/helpers/conversion/#brmspy.helpers.conversion-functions","title":"Functions","text":""},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.brmsfit_to_idata","title":"<code>brmsfit_to_idata(brmsfit_obj, model_data=None)</code>","text":"<p>Convert brmsfit -&gt; ArviZ InferenceData (uni- and multivariate).</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.generic_pred_to_idata","title":"<code>generic_pred_to_idata(r_pred_obj, brmsfit_obj, newdata=None, var_name='pred', az_name='posterior')</code>","text":"<p>Generic converter for brms prediction matrices to ArviZ InferenceData.</p> <p>Flexible conversion function that handles various brms prediction types (posterior_predict, posterior_epred, posterior_linpred, log_lik) and stores them in appropriate InferenceData groups with proper structure.</p> <p>Parameters:</p> Name Type Description Default <code>r_pred_obj</code> <code>rpy2 R matrix</code> <p>Prediction matrix from any brms prediction function Shape: (total_draws, n_observations)</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model for extracting chain information</p> required <code>newdata</code> <code>DataFrame</code> <p>New data used for predictions. If provided, DataFrame index is used for observation coordinates</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Name for the variable in the InferenceData dataset</p> <code>\"pred\"</code> <code>az_name</code> <code>str</code> <p>InferenceData group name. Common values: - \"posterior\": For expected values (epred) - \"posterior_predictive\": For predictions with noise (predict) - \"predictions\": For linear predictor (linpred) - \"log_likelihood\": For log-likelihood values</p> <code>\"posterior\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with single group containing reshaped predictions as xarray DataArray with proper coordinates and dimensions</p> Notes <p>InferenceData Group Selection:</p> <p>Different prediction types should use appropriate groups: - Expected values (epred): 'posterior' - deterministic E[Y|X] - Predictions (predict): 'posterior_predictive' - with observation noise - Linear predictor (linpred): 'predictions' - before link function - Log-likelihood: 'log_likelihood' - for model comparison</p> <p>Coordinates:</p> <p>If newdata is a DataFrame, uses its index as observation coordinates. This preserves meaningful labels (dates, IDs, etc.) in ArviZ plots.</p> <p>Examples:</p> <pre><code>import pandas as pd\nfrom brmspy.helpers.conversion import generic_pred_to_idata\n\n# Assume we have fitted model and prediction matrix\n# r_epred = brms::posterior_epred(brmsfit, newdata=test_df)\n\ntest_df = pd.DataFrame({'x': [1, 2, 3]}, index=['A', 'B', 'C'])\n\nidata = generic_pred_to_idata(\n    r_pred_obj=r_epred,\n    brmsfit_obj=brmsfit,\n    newdata=test_df,\n    var_name=\"expected_y\",\n    az_name=\"posterior\"\n)\n\n# Access predictions\nprint(idata.posterior['expected_y'].dims)  # ('chain', 'draw', 'obs_id')\nprint(idata.posterior['expected_y'].coords['obs_id'])  # ['A', 'B', 'C']\n</code></pre> See Also <p>brms_epred_to_idata : Convenience wrapper for posterior_epred brms_predict_to_idata : Convenience wrapper for posterior_predict brms_linpred_to_idata : Convenience wrapper for posterior_linpred brms_log_lik_to_idata : Convenience wrapper for log_lik _reshape_r_prediction_to_arviz : Internal reshaping function</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.brms_epred_to_idata","title":"<code>brms_epred_to_idata(r_epred_obj, brmsfit_obj, newdata=None, var_name='epred')</code>","text":"<p>Convert brms::posterior_epred result to ArviZ InferenceData.</p> <p>Convenience wrapper for converting expected value predictions (posterior_epred) to InferenceData format. Stores in 'posterior' group as deterministic expected values E[Y|X] without observation noise.</p> <p>Parameters:</p> Name Type Description Default <code>r_epred_obj</code> <code>rpy2 R matrix</code> <p>Result from brms::posterior_epred()</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model</p> required <code>newdata</code> <code>DataFrame</code> <p>New data used for predictions</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Variable name in InferenceData</p> <code>\"epred\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with 'posterior' group containing expected values</p> Notes <p>posterior_epred computes the expected value of the posterior predictive distribution (i.e., the mean outcome for given predictors): - For linear regression: E[Y|X] = \u03bc = X\u00b7\u03b2 - For Poisson regression: E[Y|X] = exp(X\u00b7\u03b2) - For logistic regression: E[Y|X] = logit\u207b\u00b9(X\u00b7\u03b2)</p> <p>This is stored in the 'posterior' group (not 'posterior_predictive') because it represents deterministic expected values, not noisy predictions.</p> See Also <p>brmspy.brms.posterior_epred : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_predict_to_idata : For predictions with observation noise</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.brms_predict_to_idata","title":"<code>brms_predict_to_idata(r_predict_obj, brmsfit_obj, newdata=None, var_name='y')</code>","text":"<p>Convert brms::posterior_predict result to ArviZ InferenceData.</p> <p>Convenience wrapper for converting posterior predictions (posterior_predict) to InferenceData format. Stores in 'posterior_predictive' group as predictions including observation-level noise.</p> <p>Parameters:</p> Name Type Description Default <code>r_predict_obj</code> <code>rpy2 R matrix</code> <p>Result from brms::posterior_predict()</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model</p> required <code>newdata</code> <code>DataFrame</code> <p>New data used for predictions</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Variable name in InferenceData</p> <code>\"y\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with 'posterior_predictive' group containing predictions</p> Notes <p>posterior_predict generates predictions from the posterior predictive distribution, including observation-level noise: - For linear regression: Y ~ Normal(\u03bc, \u03c3) - For Poisson regression: Y ~ Poisson(\u03bb) - For logistic regression: Y ~ Bernoulli(p)</p> <p>These predictions include all sources of uncertainty (parameter and observation) and are useful for: - Posterior predictive checks - Generating realistic synthetic data - Assessing model fit to observed data</p> See Also <p>brmspy.brms.posterior_predict : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_epred_to_idata : For expected values without noise</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.brms_linpred_to_idata","title":"<code>brms_linpred_to_idata(r_linpred_obj, brmsfit_obj, newdata=None, var_name='linpred')</code>","text":"<p>Convert brms::posterior_linpred result to ArviZ InferenceData.</p> <p>Convenience wrapper for converting linear predictor values (posterior_linpred) to InferenceData format. Stores in 'predictions' group as linear predictor values before applying the link function.</p> <p>Parameters:</p> Name Type Description Default <code>r_linpred_obj</code> <code>rpy2 R matrix</code> <p>Result from brms::posterior_linpred()</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model</p> required <code>newdata</code> <code>DataFrame</code> <p>New data used for predictions</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Variable name in InferenceData</p> <code>\"linpred\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with 'predictions' group containing linear predictor</p> Notes <p>posterior_linpred returns the linear predictor \u03b7 = X\u00b7\u03b2 before applying the link function: - For linear regression: linpred = \u03bc (same as epred since link is identity) - For Poisson regression: linpred = log(\u03bb), epred = \u03bb - For logistic regression: linpred = logit(p), epred = p</p> <p>The linear predictor is useful for: - Understanding the scale of effects before transformation - Diagnosing model specification issues - Custom post-processing with different link functions</p> See Also <p>brmspy.brms.posterior_linpred : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_epred_to_idata : For expected values on response scale</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.brms_log_lik_to_idata","title":"<code>brms_log_lik_to_idata(r_log_lik_obj, brmsfit_obj, newdata=None, var_name='log_lik')</code>","text":"<p>Convert brms::log_lik result to ArviZ InferenceData.</p> <p>Convenience wrapper for converting pointwise log-likelihood values (log_lik) to InferenceData format. Stores in 'log_likelihood' group for use in model comparison and diagnostics.</p> <p>Parameters:</p> Name Type Description Default <code>r_log_lik_obj</code> <code>rpy2 R matrix</code> <p>Result from brms::log_lik()</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model</p> required <code>newdata</code> <code>DataFrame</code> <p>New data for log-likelihood calculation</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Variable name in InferenceData</p> <code>\"log_lik\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with 'log_likelihood' group</p> Notes <p>log_lik computes pointwise log-likelihood values for each observation, which are essential for:</p> <ul> <li>LOO-CV: Leave-one-out cross-validation via <code>az.loo()</code></li> <li>WAIC: Widely applicable information criterion via <code>az.waic()</code></li> <li>Model Comparison: Compare multiple models with <code>az.compare()</code></li> <li>Outlier Detection: Identify poorly fit observations</li> </ul> <p>Each MCMC draw \u00d7 observation gets a log-likelihood value, representing how well that parameter draw explains that specific observation.</p> <p>Examples:</p> <pre><code>from brmspy import fit\nimport arviz as az\n\n# Fit model (log_lik included automatically)\nresult = fit(\"y ~ x\", data={\"y\": [1, 2, 3], \"x\": [1, 2, 3]})\n\n# Model comparison with LOO-CV\nloo_result = az.loo(result.idata)\nprint(loo_result)\n\n# Compare multiple models\nmodel1_idata = fit(\"y ~ x\", data=data1).idata\nmodel2_idata = fit(\"y ~ x + x2\", data=data2).idata\ncomparison = az.compare({\"model1\": model1_idata, \"model2\": model2_idata})\n</code></pre> See Also <p>brmspy.brms.log_lik : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function arviz.loo : Leave-one-out cross-validation arviz.waic : WAIC computation arviz.compare : Model comparison</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.r_to_py","title":"<code>r_to_py(obj)</code>","text":"<p>Convert R objects to Python objects via rpy2.</p> <p>Comprehensive converter that handles R lists (named/unnamed), vectors, formulas, and language objects. Provides sensible Python equivalents for all R types with special handling for edge cases.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>rpy2 R object</code> <p>R object to convert to Python</p> required <p>Returns:</p> Type Description <code>any</code> <p>Python representation of the R object: - R NULL \u2192 None - Named list \u2192 dict (recursively) - Unnamed list \u2192 list (recursively) - Length-1 vector \u2192 scalar (int, float, str, bool) - Length-N vector \u2192 list of scalars - Formula/Language object \u2192 str (descriptive representation) - Other objects \u2192 default rpy2 conversion or str fallback</p> Notes <p>Conversion Rules:</p> <ol> <li>R NULL: \u2192 Python None</li> <li>Atomic vectors (numeric, character, logical):</li> <li>Length 1: \u2192 Python scalar (int, float, str, bool)</li> <li>Length &gt;1: \u2192 Python list of scalars</li> <li>Named lists (ListVector with names): \u2192 Python dict, recursively</li> <li>Unnamed lists: \u2192 Python list, recursively</li> <li>Formulas (e.g., <code>y ~ x</code>): \u2192 String representation</li> <li>Language objects (calls, expressions): \u2192 String representation</li> <li>Functions: \u2192 String representation</li> <li>Everything else: Try default rpy2 conversion, fallback to string</li> </ol> <p>Recursive Conversion:</p> <p>List elements and dictionary values are recursively converted: <pre><code>list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n</code></pre></p> <p>Safe Fallback:</p> <p>R language objects, formulas, and functions are converted to descriptive strings rather than attempting complex conversions that might fail.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import r_to_py\nimport rpy2.robjects as ro\n\n# R NULL\nr_to_py(ro.NULL)  # None\n\n# Scalars\nr_to_py(ro.IntVector([5]))    # 5\nr_to_py(ro.FloatVector([3.14]))  # 3.14\nr_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n# Vectors\nr_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n</code></pre> See Also <p>py_to_r : Convert Python objects to R brmspy.brms.summary : Returns Python-friendly summary dict</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.kwargs_r","title":"<code>kwargs_r(kwargs)</code>","text":"<p>Convert Python keyword arguments to R-compatible format.</p> <p>Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict or None</code> <p>Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with same keys but R-compatible values, or empty dict if None</p> Notes <p>This is a thin wrapper around <code>py_to_r()</code> that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import kwargs_r\nimport pandas as pd\nimport numpy as np\n\n# Prepare kwargs for R function\npy_kwargs = {\n    'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n    'prior': {'b': [0, 1]},\n    'chains': 4,\n    'iter': 2000\n}\n\nr_kwargs = kwargs_r(py_kwargs)\n# All values converted to R objects\n# Can now call: r_function(**r_kwargs)\n</code></pre> See Also <p>py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R</p>"},{"location":"api/helpers/priors/","title":"Priors","text":""},{"location":"api/helpers/priors/#brmspy.helpers.priors-classes","title":"Classes","text":""},{"location":"api/helpers/priors/#brmspy.helpers.priors-functions","title":"Functions","text":""},{"location":"development/development/","title":"Development Guide","text":"<p>This guide covers the development infrastructure, build processes, and CI/CD architecture for brmspy.</p>"},{"location":"development/development/#quick-start","title":"Quick Start","text":""},{"location":"development/development/#setup","title":"Setup","text":"<pre><code># Clone and setup\ngit clone https://github.com/kaitumisuuringute-keskus/brmspy.git\ncd brmspy\n\n# Install with dev dependencies\npython -m venv .venv\nsource .venv/bin/activate  # or .venv\\Scripts\\activate on Windows\npip install -e \".[all]\"\n\n# Install R dependencies (fast with prebuilt runtime)\npython -c \"import brmspy; brmspy.install_brms(use_prebuilt=True)\"\n\n# Or traditional installation from source (~30 minutes)\n# python -c \"import brmspy; brmspy.install_brms()\"\n</code></pre>"},{"location":"development/development/#project-architecture","title":"Project Architecture","text":""},{"location":"development/development/#directory-structure","title":"Directory Structure","text":"<pre><code>brmspy/\n\u251c\u2500\u2500 brmspy/                    # Main package\n\u2502   \u251c\u2500\u2500 brms.py               # Core API exports\n\u2502   \u251c\u2500\u2500 types.py              # Type definitions and result dataclasses\n\u2502   \u251c\u2500\u2500 brms_functions/       # Modular brms function wrappers\n\u2502   \u2502   \u251c\u2500\u2500 brm.py            # Model fitting (fit, brm)\n\u2502   \u2502   \u251c\u2500\u2500 diagnostics.py    # Model diagnostics (summary, loo, etc.)\n\u2502   \u2502   \u251c\u2500\u2500 families.py       # Family specifications\n\u2502   \u2502   \u251c\u2500\u2500 formula.py        # Formula construction\n\u2502   \u2502   \u251c\u2500\u2500 generic.py        # Generic function caller\n\u2502   \u2502   \u251c\u2500\u2500 io.py             # Data I/O (save_rds, read_rds, etc.)\n\u2502   \u2502   \u251c\u2500\u2500 prediction.py     # Predictions (posterior_predict, etc.)\n\u2502   \u2502   \u251c\u2500\u2500 prior.py          # Prior specifications\n\u2502   \u2502   \u2514\u2500\u2500 stan.py           # Stan code generation\n\u2502   \u251c\u2500\u2500 runtime/              # Runtime management system (layered architecture)\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py       # Public API: install(), activate(), deactivate(), status()\n\u2502   \u2502   \u251c\u2500\u2500 _types.py         # Foundation: RuntimeStatus, RuntimeManifest, SystemInfo\n\u2502   \u2502   \u251c\u2500\u2500 _platform.py      # Foundation: Platform detection, fingerprinting\n\u2502   \u2502   \u251c\u2500\u2500 _manifest.py      # Foundation: Manifest reading\n\u2502   \u2502   \u251c\u2500\u2500 _r_packages.py    # R Layer: Package operations\n\u2502   \u2502   \u251c\u2500\u2500 _r_env.py         # R Layer: Environment management\n\u2502   \u2502   \u251c\u2500\u2500 _config.py        # Disk Layer: Config management (~/.brmspy/config.json)\n\u2502   \u2502   \u251c\u2500\u2500 _storage.py       # Disk Layer: Runtime storage (~/.brmspy/runtime/)\n\u2502   \u2502   \u251c\u2500\u2500 _download.py      # Disk Layer: Download utilities\n\u2502   \u2502   \u251c\u2500\u2500 _github.py        # Disk Layer: GitHub API integration\n\u2502   \u2502   \u251c\u2500\u2500 _rtools.py        # Disk Layer: Windows Rtools installation\n\u2502   \u2502   \u251c\u2500\u2500 _state.py         # Orchestration: State management (env snapshots)\n\u2502   \u2502   \u251c\u2500\u2500 _activation.py    # Orchestration: Runtime activation/deactivation\n\u2502   \u2502   \u2514\u2500\u2500 _install.py       # Orchestration: Installation logic\n\u2502   \u2514\u2500\u2500 helpers/              # Internal utilities\n\u2502       \u251c\u2500\u2500 conversion.py     # Python \u2194 R \u2194 ArviZ\n\u2502       \u251c\u2500\u2500 log.py            # Logging utilities\n\u2502       \u251c\u2500\u2500 priors.py         # Prior builders\n\u2502       \u251c\u2500\u2500 robject_iter.py   # R object iteration\n\u2502       \u251c\u2500\u2500 rtools.py         # Rtools utilities (legacy)\n\u2502       \u2514\u2500\u2500 singleton.py      # R package caching\n\u251c\u2500\u2500 .github/workflows/        # CI/CD pipelines\n\u251c\u2500\u2500 .runtime_builder/         # Docker for Linux builds\n\u251c\u2500\u2500 docs/                     # mkdocs documentation\n\u2514\u2500\u2500 tests/                    # Test suite\n</code></pre>"},{"location":"development/development/#core-components","title":"Core Components","text":"<p>brmspy/brms.py - Main module that exports all public functions brmspy/types.py - Type definitions and result dataclasses (FitResult, SummaryResult, LooResult, etc.) brmspy/brms_functions/ - Modular organization of brms function wrappers:   - brm.py - Model fitting functions   - diagnostics.py - 8 diagnostic functions (summary, fixef, ranef, loo, loo_compare, validate_newdata, etc.)   - prediction.py - Prediction functions (posterior_predict, posterior_epred, posterior_linpred, log_lik)   - prior.py - Prior specification functions   - families.py - Family specifications and wrappers   - formula.py - Formula construction helpers   - generic.py - Generic function caller for unwrapped brms functions   - io.py - Data I/O functions   - stan.py - Stan code generation</p> <p>brmspy/runtime/ - Runtime management system with layered architecture (see below) brmspy/helpers/ - Internal conversion and utility functions</p>"},{"location":"development/development/#data-flow","title":"Data Flow","text":"<pre><code>Python Code\n    \u2193\nbrmspy.fit() [brms.py]\n    \u2193\nType Conversions [helpers/conversion.py]\n    \u2193\nR brms via rpy2\n    \u2193\nCmdStan MCMC Sampling\n    \u2193\nArviZ InferenceData\n    \u2193\nPython Result Objects\n</code></pre>"},{"location":"development/development/#runtime-system-architecture","title":"Runtime System Architecture","text":"<p>The runtime system provides prebuilt bundles to skip lengthy R package compilation. The new architecture uses a layered design pattern with strict separation of concerns.</p>"},{"location":"development/development/#layered-architecture","title":"Layered Architecture","text":"<p>The runtime system is organized into 4 layers, each with specific responsibilities:</p>"},{"location":"development/development/#1-foundation-layer-no-dependencies","title":"1. Foundation Layer (No Dependencies)","text":"<p>Pure functions for system information and data structures.</p> <ul> <li><code>_types.py</code> - Type definitions: <code>RuntimeStatus</code>, <code>RuntimeManifest</code>, <code>SystemInfo</code></li> <li><code>_platform.py</code> - Platform detection, system fingerprinting, compatibility checks</li> <li><code>_manifest.py</code> - Manifest file reading and validation</li> </ul>"},{"location":"development/development/#2-r-layer-depends-on-foundation","title":"2. R Layer (Depends on Foundation)","text":"<p>R package operations and environment management.</p> <ul> <li><code>_r_packages.py</code> - Install/unload R packages, build CmdStan</li> <li><code>_r_env.py</code> - Manage R environment variables, GitHub token forwarding</li> </ul>"},{"location":"development/development/#3-disk-layer-depends-on-foundation","title":"3. Disk Layer (Depends on Foundation)","text":"<p>File system operations and external integrations.</p> <ul> <li><code>_config.py</code> - Persistent config at <code>~/.brmspy/config.json</code></li> <li><code>_storage.py</code> - Runtime storage at <code>~/.brmspy/runtime/</code></li> <li><code>_download.py</code> - Download and hash verification utilities</li> <li><code>_github.py</code> - GitHub API for release discovery</li> <li><code>_rtools.py</code> - Windows Rtools installation</li> </ul>"},{"location":"development/development/#4-orchestration-layer-depends-on-all-lower-layers","title":"4. Orchestration Layer (Depends on All Lower Layers)","text":"<p>High-level workflows coordinating multiple components.</p> <ul> <li><code>_state.py</code> - Environment snapshot/restore for activation</li> <li><code>_activation.py</code> - Runtime activation/deactivation logic</li> <li><code>_install.py</code> - Installation orchestration (traditional + prebuilt)</li> </ul>"},{"location":"development/development/#public-api-__init__py","title":"Public API (<code>__init__.py</code>)","text":"<p>Four clean functions for users:</p> <pre><code>from brmspy import runtime\n\n# Install R packages traditionally (~30 min) or prebuilt (~1 min)\nruntime.install(use_prebuilt=True)\n\n# Activate a specific runtime\nruntime.activate(runtime_path)\n\n# Deactivate and restore original environment\nruntime.deactivate()\n\n# Query current state\nstatus = runtime.status()\nprint(status.system.fingerprint)  # e.g., 'linux-x86_64-r4.5'\n</code></pre>"},{"location":"development/development/#system-fingerprint","title":"System Fingerprint","text":"<p>Each runtime is identified by: <code>{os}-{arch}-r{major}.{minor}</code></p> <p>Examples: - <code>linux-x86_64-r4.5</code> - <code>macos-arm64-r4.5</code> (Apple Silicon) - <code>windows-x86_64-r4.5</code></p> <p>Generated by <code>_platform.system_fingerprint()</code></p>"},{"location":"development/development/#bundle-structure","title":"Bundle Structure","text":"<pre><code>brmspy-runtime-{fingerprint}-{version}.tar.gz\n\u251c\u2500\u2500 manifest.json              # Metadata (fingerprint, versions, build info)\n\u251c\u2500\u2500 cmdstan/                   # Compiled CmdStan binaries\n\u2514\u2500\u2500 Rlib/                      # R libraries (brms, cmdstanr, dependencies)\n</code></pre> <p>Installed to: <code>~/.brmspy/runtime/{fingerprint}-{version}/</code></p>"},{"location":"development/development/#usage-examples","title":"Usage Examples","text":"<pre><code>import brmspy\n\n# Fast installation with prebuilt runtime (~1 minute)\nbrmspy.install_brms(use_prebuilt=True)\n\n# Traditional installation (~30 minutes)\nbrmspy.install_brms()\n\n# Check current runtime status\nstatus = brmspy.runtime.status()\nprint(f\"Active: {status.active_runtime}\")\nprint(f\"System: {status.system.fingerprint}\")\nprint(f\"Can use prebuilt: {status.can_use_prebuilt}\")\n\n# Manual activation/deactivation\nbrmspy.runtime.activate(\"/path/to/runtime\")\nbrmspy.runtime.deactivate()\n</code></pre> <p>Note: Runtime building is handled internally by CI/CD. Users should use <code>install(use_prebuilt=True)</code> rather than building locally.</p>"},{"location":"development/development/#cicd-pipelines","title":"CI/CD Pipelines","text":"<p>All workflows in <code>.github/workflows/</code>:</p>"},{"location":"development/development/#1-python-test-matrix-python-test-matrixyml","title":"1. Python Test Matrix (<code>python-test-matrix.yml</code>)","text":"<p>Trigger: Push/PR to master Purpose: Test Python 3.10, 3.12, 3.14 on Linux</p> <p>Workflow: 1. Build CmdStan once (cached) 2. Test matrix in parallel 3. Update coverage badge (3.12 only)</p> <p>Key Features: - Shared R/CmdStan cache - Parallel execution - Coverage reporting</p>"},{"location":"development/development/#2-r-dependencies-tests-r-dependencies-testsyml","title":"2. R Dependencies Tests (<code>r-dependencies-tests.yml</code>)","text":"<p>Trigger: Push/PR to master Purpose: Test on Linux, macOS, Windows</p> <p>Workflow: - Python 3.12 only - Tests marked with <code>@pytest.mark.rdeps</code> - Fail-fast disabled</p>"},{"location":"development/development/#3-documentation-docsyml","title":"3. Documentation (<code>docs.yml</code>)","text":"<p>Trigger: Push to master Purpose: Deploy docs to GitHub Pages</p> <p>Stack: - mkdocstrings for API docs - Auto-deploys to https://kaitumisuuringute-keskus.github.io/brmspy/</p>"},{"location":"development/development/#4-pypi-publish-python-publishyml","title":"4. PyPI Publish (<code>python-publish.yml</code>)","text":"<p>Trigger: GitHub Release created Purpose: Publish to PyPI</p> <p>Workflow: 1. Run full test suite 2. Build: <code>python -m build</code> 3. Upload: <code>twine upload dist/*</code></p> <p>Requirements: <code>PYPI_USERNAME</code>, <code>PYPI_PASSWORD</code> secrets</p>"},{"location":"development/development/#5-runtime-publish-runtime-publishyml","title":"5. Runtime Publish (<code>runtime-publish.yml</code>)","text":"<p>Trigger: Manual dispatch Purpose: Build prebuilt runtimes for all platforms</p> <p>Architecture: 1. Create GitHub Release (tag: <code>runtime</code>) 2. Build runtimes in parallel (Linux in Docker, macOS/Windows native) 3. Upload to release with attestation</p> <p>Linux Build (Docker): <pre><code>- Pull: ghcr.io/.../brmspy-runtime-builder:ubuntu18-gcc9\n- Install R 4.5.0\n- Build runtime using internal build script\n- Upload tarball\n</code></pre></p> <p>macOS/Windows Build (Native): <pre><code>- Setup Python 3.12 + R 4.5\n- Install dependencies\n- Build runtime using internal build script\n- Upload tarball\n</code></pre></p> <p>Note: Runtime building uses internal tooling. The public API for users is <code>brmspy.runtime.install(use_prebuilt=True)</code>.</p>"},{"location":"development/development/#6-linux-runtime-builder-build-linux-runtime-imageyml","title":"6. Linux Runtime Builder (<code>build-linux-runtime-image.yml</code>)","text":"<p>Trigger: Manual dispatch Purpose: Build Docker image for Linux runtime compilation</p> <p>Image: Ubuntu 18.04 + GCC 9 + Python 3.12 (for old glibc compatibility)</p>"},{"location":"development/development/#runtime-builder-runtime_builderlinux","title":"Runtime Builder (<code>.runtime_builder/linux/</code>)","text":""},{"location":"development/development/#dockerfile","title":"Dockerfile","text":"<p>Creates build environment: - Base: Ubuntu 18.04 (glibc 2.27) - Toolchain: GCC 9, g++ 9, gfortran 9 - Python: 3.12.7 (compiled from source) - Dependencies: BLAS, LAPACK, V8, GLPK, graphics libs</p>"},{"location":"development/development/#install_rsh","title":"install_r.sh","text":"<p>Smart R installation: 1. Try APT (fast) 2. Fallback to source compilation if version unavailable</p>"},{"location":"development/development/#publishsh","title":"publish.sh","text":"<p>Builds and pushes Docker image to GHCR: <pre><code>docker build -t ghcr.io/{owner}/brmspy-runtime-builder:{tag}\ndocker push ghcr.io/{owner}/brmspy-runtime-builder:{tag}\n</code></pre></p>"},{"location":"development/development/#testing","title":"Testing","text":""},{"location":"development/development/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py                      # Pytest fixtures (sample_dataframe, etc.)\n\u251c\u2500\u2500 test_basic.py                    # Basic functionality tests\n\u251c\u2500\u2500 test_diagnostics.py              # Diagnostics functions tests (14 tests)\n\u251c\u2500\u2500 test_families.py                 # Family specifications tests\n\u251c\u2500\u2500 test_generic.py                  # Generic function caller tests\n\u251c\u2500\u2500 test_integration.py              # End-to-end integration tests\n\u251c\u2500\u2500 test_io.py                       # I/O functions tests\n\u251c\u2500\u2500 test_predictions.py              # Prediction functions tests\n\u251c\u2500\u2500 test_priors.py                   # Prior specification tests\n\u251c\u2500\u2500 test_conversion.py               # Type conversion tests\n\u251c\u2500\u2500 test_log.py                      # Logging utility tests\n\u251c\u2500\u2500 test_rdeps_1_install.py          # Runtime installation tests (marked @pytest.mark.rdeps)\n\u251c\u2500\u2500 test_rdeps_build.py              # Runtime building tests\n\u251c\u2500\u2500 test_rdeps_config.py             # Config management tests\n\u251c\u2500\u2500 test_rdeps_github.py             # GitHub API tests\n\u251c\u2500\u2500 test_rdeps_install_extended.py   # Extended installation tests\n\u251c\u2500\u2500 test_runtime_r_env.py            # R environment management tests\n\u2514\u2500\u2500 test_runtime_storage.py          # Runtime storage tests\n</code></pre> <p>Test Coverage: - 14 diagnostics tests covering summary, fixef, ranef, posterior_summary, prior_summary, loo, loo_compare, validate_newdata - 2 generic function tests for call() wrapper - All tests use <code>iter=100, warmup=50</code> for fast CI execution - Tests marked with <code>@pytest.mark.slow</code> and <code>@pytest.mark.requires_brms</code></p>"},{"location":"development/development/#running-tests","title":"Running Tests","text":"<pre><code>pytest tests/ -v                    # All tests\npytest tests/ -v --cov=brmspy      # With coverage\npytest -m rdeps                    # DESTRUCTIVE rdeps tests\npytest -n auto                     # Parallel (requires pytest-xdist)\n</code></pre>"},{"location":"development/development/#test-markers","title":"Test Markers","text":"<pre><code>@pytest.mark.rdeps\ndef test_basic_fit():\n    \"\"\"Runs on all platforms in CI\"\"\"\n    pass\n</code></pre>"},{"location":"development/development/#build-and-release","title":"Build and Release","text":""},{"location":"development/development/#version-management","title":"Version Management","text":"<p>Update in: - <code>pyproject.toml</code> - <code>settings.ini</code> - <code>brmspy/__init__.py</code></p>"},{"location":"development/development/#release-process","title":"Release Process","text":"<ol> <li>Update versions and CHANGELOG.md</li> <li>Test: <code>pytest</code></li> <li>Build: <code>make build</code></li> <li>Create GitHub Release (tag: <code>release-0...</code>)</li> <li>CI automatically tests and publishes to PyPI</li> </ol>"},{"location":"development/development/#building-runtimes","title":"Building Runtimes","text":"<p>Via GitHub Actions (Recommended): 1. Go to Actions \u2192 runtime-publish 2. Run workflow with version and tag 3. Runtimes published to: <code>releases/tag/runtime</code></p> <p>Local Development: Runtime building for local development uses internal scripts not exposed in the public API. For testing, use:</p> <pre><code># Install from source for testing\nimport brmspy\nbrmspy.install_brms()  # Traditional installation\n\n# Or test with prebuilt from GitHub\nbrmspy.install_brms(use_prebuilt=True)\n</code></pre>"},{"location":"development/development/#documentation","title":"Documentation","text":""},{"location":"development/development/#mkdocs-configuration","title":"mkdocs Configuration","text":"<p>File: <code>mkdocs.yml</code></p> <pre><code>site_name: brmspy\ntheme:\n  name: shadcn\nplugins:\n  ...\n</code></pre>"},{"location":"development/development/#docstring-style","title":"Docstring Style","text":"<p>All docstrings use NumPy style with <code>```python</code> code blocks (no <code>.. code-block::</code>):</p> <pre><code>def example(param: str) -&gt; dict:\n    \"\"\"\n    One-line summary.\n\n    Detailed description.\n\n    Parameters\n    ----------\n    param : str\n        Parameter description\n\n    Returns\n    -------\n    dict\n        Return description\n\n    Examples\n    --------\n    Basic usage:\n\n    ```python\n    result = example(\"hello\")\n    print(result)\n    ```\n    \"\"\"\n    return {\"param\": param}\n</code></pre>"},{"location":"development/development/#performance","title":"Performance","text":""},{"location":"development/development/#r-package-caching","title":"R Package Caching","text":"<p>Singleton pattern in <code>brmspy/helpers/singleton.py</code>:</p> <pre><code>from brmspy.helpers.singleton import get_r_package\n\nbrms = get_r_package(\"brms\")  # First call: imports\nbrms = get_r_package(\"brms\")  # Cached, instant\n</code></pre>"},{"location":"development/development/#prebuilt-runtimes","title":"Prebuilt Runtimes","text":"Method Installation Time From source 20-30 minutes Prebuilt runtime 20-60 seconds"},{"location":"development/development/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/development/#r-package-installation-fails","title":"R Package Installation Fails","text":"<pre><code># Check R version (need 4.0+)\nR --version\n\n# Manual install\nR -e \"install.packages(c('cmdstanr', 'brms', 'posterior'))\"\n</code></pre>"},{"location":"development/development/#cmdstan-compilation-fails","title":"CmdStan Compilation Fails","text":"<p>Linux: <pre><code>sudo apt-get install build-essential\n</code></pre></p> <p>macOS: <pre><code>xcode-select --install\n</code></pre></p> <p>Windows: <pre><code>import brmspy\n# Automatically installs Rtools if needed\nbrmspy.install_brms(install_rtools=True)\n</code></pre></p> <p>Or manually via the runtime API: <pre><code>from brmspy.runtime import _rtools\n_rtools.ensure_installed()  # Internal API\n</code></pre></p>"},{"location":"development/development/#runtime-incompatibility","title":"Runtime Incompatibility","text":"<pre><code># Check compatibility\nfrom brmspy import runtime\nstatus = runtime.status()\nprint(f\"Can use prebuilt: {status.can_use_prebuilt}\")\nprint(f\"Issues: {status.compatibility_issues}\")\n\n# Install matching prebuilt (auto-detects platform)\nimport brmspy\nbrmspy.install_brms(use_prebuilt=True)\n\n# Or install from source\nbrmspy.install_brms()  # Traditional installation\n</code></pre>"},{"location":"development/development/#contributing","title":"Contributing","text":""},{"location":"development/development/#code-style","title":"Code Style","text":"<ul> <li>Docstrings: NumPy style</li> <li>Type hints: Required for public APIs</li> </ul>"},{"location":"development/development/#pr-process","title":"PR Process","text":"<ol> <li>Fork and create feature branch</li> <li>Make changes and add tests</li> <li>Run: <code>make format &amp;&amp; make lint &amp;&amp; make test</code></li> <li>Commit with conventional commits format</li> <li>Open PR with clear description</li> </ol>"},{"location":"development/development/#resources","title":"Resources","text":"<ul> <li>Documentation: https://kaitumisuuringute-keskus.github.io/brmspy/</li> <li>Repository: https://github.com/kaitumisuuringute-keskus/brmspy</li> <li>Issues: https://github.com/kaitumisuuringute-keskus/brmspy/issues</li> <li>PyPI: https://pypi.org/project/brmspy/</li> </ul>"},{"location":"examples/brmspy-estimating-multivariate-models/","title":"brmspy - Estimating Multivariate Models","text":"In\u00a0[1]: Copied! <pre>import os\nimport sys\n\nimport sys, os # for running from repo\nsys.path.insert(0, os.path.abspath(\"../../\"))\n\ntry: from brmspy import brms; import seaborn;\nexcept ImportError:\n    %pip install -q brmspy seaborn\n    from brmspy import brms\n\nfrom brmspy import bf, set_rescor, lf\n\nimport pandas as pd\nimport arviz as az\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set_style(\"darkgrid\")\n#brms.install_runtime()\nbrms.install_rpackage(\"MCMCglmm\")\n</pre>  import os import sys  import sys, os # for running from repo sys.path.insert(0, os.path.abspath(\"../../\"))  try: from brmspy import brms; import seaborn; except ImportError:     %pip install -q brmspy seaborn     from brmspy import brms  from brmspy import bf, set_rescor, lf  import pandas as pd import arviz as az import numpy as np import matplotlib.pyplot as plt import seaborn as sns  sns.set_style(\"darkgrid\") #brms.install_runtime() brms.install_rpackage(\"MCMCglmm\") <pre>R callback write-console: Error in loadNamespace(x) : there is no package called \u2018cmdstanr\u2019\n  \nR callback write-console: CmdStan path set to: /Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0/cmdstan\n  \n[brmspy] MCMCglmm 2.36 already installed.\n</pre> In\u00a0[2]: Copied! <pre>df = brms.get_data(\"BTdata\", package = \"MCMCglmm\")\ndf.head()\n</pre> df = brms.get_data(\"BTdata\", package = \"MCMCglmm\") df.head() Out[2]: tarsus back animal dam fosternest hatchdate sex 1 -1.892297 1.146421 207 56 74 -0.687402 1 2 1.136110 -0.759652 219 57 72 -0.687402 2 3 0.984689 0.144937 395 61 16 -0.427981 2 4 0.379008 0.255585 46 38 4 -1.465664 2 5 -0.075253 -0.300699 38 43 12 -1.465664 1 In\u00a0[3]: Copied! <pre>bform1 = bf(\"\"\"\nmvbind(tarsus, back) ~\n    sex + \n    hatchdate + \n    (1|p|fosternest) + \n    (1|q|dam)\n\"\"\") + set_rescor(rescor=True)\n\nfit1 = brms.brm(bform1, data = df, chains = 2, cores = 2, silent = 2, refresh = 0)\n</pre> bform1 = bf(\"\"\" mvbind(tarsus, back) ~     sex +      hatchdate +      (1|p|fosternest) +      (1|q|dam) \"\"\") + set_rescor(rescor=True)  fit1 = brms.brm(bform1, data = df, chains = 2, cores = 2, silent = 2, refresh = 0) <pre>[brmspy] Fitting model with brms (backend: cmdstanr)...\n</pre> <pre> \\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\r</pre> <p>As can be seen in the model code, we have used mvbind notation to tell brms that both tarsus and back are separate response variables. The term (1|p|fosternest) indicates a varying intercept over fosternest. By writing |p| in between we indicate that all varying effects of fosternest should be modeled as correlated. This makes sense since we actually have two model parts, one for tarsus and one for back. The indicator p is arbitrary and can be replaced by other symbols that comes into your mind (for details about the multilevel syntax of brms, see help(\"brmsformula\") and vignette(\"brms_multilevel\")). Similarly, the term (1|q|dam) indicates correlated varying effects of the genetic mother of the chicks. Alternatively, we could have also modeled the genetic similarities through pedigrees and corresponding relatedness matrices, but this is not the focus of this vignette (please see vignette(\"brms_phylogenetics\")). The model results are readily summarized via</p> In\u00a0[4]: Copied! <pre>for var in fit1.idata.posterior_predictive.data_vars:\n    print(var)\n    print(az.loo(fit1.idata, var_name=var))\n    print(\"\\n\")\n</pre> for var in fit1.idata.posterior_predictive.data_vars:     print(var)     print(az.loo(fit1.idata, var_name=var))     print(\"\\n\") <pre>tarsus\n</pre> <pre>/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.70 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n</pre> <pre>Computed from 2000 posterior samples and 828 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo -1037.00    26.33\np_loo      100.21        -\n\nThere has been a warning during the calculation. Please check the results.\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.70]   (good)      826   99.8%\n   (0.70, 1]   (bad)         2    0.2%\n   (1, Inf)   (very bad)    0    0.0%\n\n\n\nback\nComputed from 2000 posterior samples and 828 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo -1128.30    19.51\np_loo       73.65        -\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.70]   (good)      828  100.0%\n   (0.70, 1]   (bad)         0    0.0%\n   (1, Inf)   (very bad)    0    0.0%\n\n\n\n</pre> In\u00a0[5]: Copied! <pre>brms.summary(fit1)\n</pre> brms.summary(fit1) Out[5]: <pre> Family: MV(gaussian, gaussian) \n  Links: mu = identity\n         mu = identity \nFormula: tarsus ~ sex + hatchdate + (1 | p | fosternest) + (1 | q | dam) \n         back ~ sex + hatchdate + (1 | p | fosternest) + (1 | q | dam) \n   Data: structure(list(tarsus = c(-1.89229718155107, 1.136 (Number of observations: 828) \n  Draws: 2 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 2000\n\nMultilevel Hyperparameters:\n~dam (Number of levels: 106) \n                                     Estimate Est.Error l-95% CI u-95% CI Rhat\nsd(tarsus_Intercept)                     0.47      0.05     0.37     0.57 1.00\nsd(back_Intercept)                       0.24      0.07     0.10     0.38 1.00\ncor(tarsus_Intercept,back_Intercept)    -0.55      0.22    -0.94    -0.09 1.00\n                                     Bulk_ESS Tail_ESS\nsd(tarsus_Intercept)                     1051     1241\nsd(back_Intercept)                        308      763\ncor(tarsus_Intercept,back_Intercept)      561      620\n\n~fosternest (Number of levels: 104) \n                                     Estimate Est.Error l-95% CI u-95% CI Rhat\nsd(tarsus_Intercept)                     0.31      0.06     0.20     0.42 1.00\nsd(back_Intercept)                       0.35      0.06     0.24     0.46 1.00\ncor(tarsus_Intercept,back_Intercept)     0.67      0.20     0.22     0.97 1.00\n                                     Bulk_ESS Tail_ESS\nsd(tarsus_Intercept)                      684     1076\nsd(back_Intercept)                        439      912\ncor(tarsus_Intercept,back_Intercept)      341      619\n\nRegression Coefficients:\n                 Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\ntarsus_Intercept    -0.80      0.10    -0.99    -0.60 1.00     2429     1724\nback_Intercept      -0.06      0.10    -0.26     0.14 1.00     2684     1376\ntarsus_sex           0.49      0.05     0.39     0.59 1.00     4291     1308\ntarsus_hatchdate    -0.08      0.06    -0.19     0.04 1.00     1523     1408\nback_sex             0.04      0.06    -0.08     0.15 1.00     3311     1215\nback_hatchdate      -0.09      0.05    -0.19     0.01 1.00     2280     1178\n\nFurther Distributional Parameters:\n             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma_tarsus     0.79      0.02     0.75     0.84 1.00     2154     1318\nsigma_back       0.90      0.02     0.86     0.95 1.00     2331     1227\n\nResidual Correlations: \n                    Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nrescor(tarsus,back)    -0.06      0.04    -0.14     0.02 1.00     2762     1432\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).</pre> <p>The summary output of multivariate models closely resembles those of univariate models, except that the parameters now have the corresponding response variable as prefix. Across dams, tarsus length and back color seem to be negatively correlated, while across fosternests the opposite is true. This indicates differential effects of genetic and environmental factors on these two characteristics. Further, the small residual correlation rescor(tarsus, back) on the bottom of the output indicates that there is little unmodeled dependency between tarsus length and back color. Although not necessary at this point, we have already computed and stored the LOO information criterion of fit1, which we will use for model comparisons. Next, let\u2019s take a look at some posterior-predictive checks, which give us a first impression of the model fit.</p> In\u00a0[6]: Copied! <pre>az.plot_ppc(fit1.idata, var_names=['tarsus'])\n</pre> az.plot_ppc(fit1.idata, var_names=['tarsus']) Out[6]: <pre>&lt;Axes: xlabel='tarsus'&gt;</pre> In\u00a0[7]: Copied! <pre>az.plot_ppc(fit1.idata, var_names=[\"back\"])\n</pre> az.plot_ppc(fit1.idata, var_names=[\"back\"]) Out[7]: <pre>&lt;Axes: xlabel='back'&gt;</pre> <p>This looks pretty solid, but we notice a slight unmodeled left skewness in the distribution of tarsus. We will come back to this later on. Next, we want to investigate how much variation in the response variables can be explained by our model and we use a Bayesian generalization of the \ud835\udc452 coefficient.</p> In\u00a0[8]: Copied! <pre>brms.call(\"bayes_R2\", fit1)\n</pre> brms.call(\"bayes_R2\", fit1) Out[8]: Estimate Est.Error Q2.5 Q97.5 R2tarsus 0.378385 0.025264 0.326799 0.425129 R2back 0.196298 0.026960 0.141394 0.250162 <p>Clearly, there is much variation in both animal characteristics that we can not explain, but apparently we can explain more of the variation in tarsus length than in back color.</p> In\u00a0[9]: Copied! <pre>bf_tarsus = bf(\"tarsus ~ sex + (1|p|fosternest) + (1|q|dam)\")\nbf_back = bf(\"back ~ hatchdate + (1|p|fosternest) + (1|q|dam)\")\n\nfit2 = brms.brm(bf_tarsus + bf_back + set_rescor(True), data = df, chains = 2, cores = 2, silent = 2, refresh = 0)\n</pre> bf_tarsus = bf(\"tarsus ~ sex + (1|p|fosternest) + (1|q|dam)\") bf_back = bf(\"back ~ hatchdate + (1|p|fosternest) + (1|q|dam)\")  fit2 = brms.brm(bf_tarsus + bf_back + set_rescor(True), data = df, chains = 2, cores = 2, silent = 2, refresh = 0) <pre>[brmspy] Fitting model with brms (backend: cmdstanr)...\n</pre> <p>Note that we have literally added the two model parts via the + operator, which is in this case equivalent to writing mvbf(bf_tarsus, bf_back). See help(\"brmsformula\") and help(\"mvbrmsformula\") for more details about this syntax. Again, we summarize the model first.</p> In\u00a0[10]: Copied! <pre>for var in fit2.idata.posterior_predictive.data_vars:\n    print(var)\n    print(az.loo(fit2.idata, var_name=var))\n    print(\"\\n\")\n</pre> for var in fit2.idata.posterior_predictive.data_vars:     print(var)     print(az.loo(fit2.idata, var_name=var))     print(\"\\n\") <pre>tarsus\n</pre> <pre>/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.70 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n</pre> <pre>Computed from 2000 posterior samples and 828 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo -1035.99    26.24\np_loo       99.67        -\n\nThere has been a warning during the calculation. Please check the results.\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.70]   (good)      827   99.9%\n   (0.70, 1]   (bad)         1    0.1%\n   (1, Inf)   (very bad)    0    0.0%\n\n\n\nback\nComputed from 2000 posterior samples and 828 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo -1126.33    19.48\np_loo       72.99        -\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.70]   (good)      828  100.0%\n   (0.70, 1]   (bad)         0    0.0%\n   (1, Inf)   (very bad)    0    0.0%\n\n\n\n</pre> In\u00a0[11]: Copied! <pre>brms.summary(fit2)\n</pre> brms.summary(fit2) Out[11]: <pre> Family: MV(gaussian, gaussian) \n  Links: mu = identity\n         mu = identity \nFormula: tarsus ~ sex + (1 | p | fosternest) + (1 | q | dam) \n         back ~ hatchdate + (1 | p | fosternest) + (1 | q | dam) \n   Data: structure(list(tarsus = c(-1.89229718155107, 1.136 (Number of observations: 828) \n  Draws: 2 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 2000\n\nMultilevel Hyperparameters:\n~dam (Number of levels: 106) \n                                     Estimate Est.Error l-95% CI u-95% CI Rhat\nsd(tarsus_Intercept)                     0.47      0.05     0.38     0.58 1.00\nsd(back_Intercept)                       0.25      0.08     0.09     0.39 1.01\ncor(tarsus_Intercept,back_Intercept)    -0.52      0.23    -0.93    -0.06 1.00\n                                     Bulk_ESS Tail_ESS\nsd(tarsus_Intercept)                      628     1394\nsd(back_Intercept)                        377      687\ncor(tarsus_Intercept,back_Intercept)      482      683\n\n~fosternest (Number of levels: 104) \n                                     Estimate Est.Error l-95% CI u-95% CI Rhat\nsd(tarsus_Intercept)                     0.31      0.05     0.21     0.42 1.00\nsd(back_Intercept)                       0.35      0.06     0.23     0.47 1.00\ncor(tarsus_Intercept,back_Intercept)     0.65      0.20     0.21     0.96 1.00\n                                     Bulk_ESS Tail_ESS\nsd(tarsus_Intercept)                      753     1052\nsd(back_Intercept)                        500      667\ncor(tarsus_Intercept,back_Intercept)      255      536\n\nRegression Coefficients:\n                 Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\ntarsus_Intercept    -0.80      0.10    -1.01    -0.60 1.00     1866     1572\nback_Intercept      -0.00      0.05    -0.11     0.10 1.00     1651     1612\ntarsus_sex           0.49      0.05     0.39     0.58 1.00     3138     1403\nback_hatchdate      -0.08      0.05    -0.18     0.02 1.00     1963     1664\n\nFurther Distributional Parameters:\n             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma_tarsus     0.79      0.02     0.75     0.84 1.00     2046     1610\nsigma_back       0.90      0.03     0.85     0.95 1.00     1731     1203\n\nResidual Correlations: \n                    Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nrescor(tarsus,back)    -0.06      0.04    -0.14     0.01 1.00     2399     1478\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).</pre> <p>Let\u2019s find out, how model fit changed due to excluding certain effects from the initial model:</p> In\u00a0[12]: Copied! <pre>var = \"back\"\nloo1 = az.loo(fit1.idata, var_name=var)\nloo2 = az.loo(fit2.idata, var_name=var)\ncmp = az.compare({\"m1\": fit1.idata, \"m2\": fit2.idata}, ic=\"loo\", var_name=var)\ncmp\n</pre> var = \"back\" loo1 = az.loo(fit1.idata, var_name=var) loo2 = az.loo(fit2.idata, var_name=var) cmp = az.compare({\"m1\": fit1.idata, \"m2\": fit2.idata}, ic=\"loo\", var_name=var) cmp Out[12]: rank elpd_loo p_loo elpd_diff weight se dse warning scale m1 0 -30.367550 60.744969 0.000000 1.0 10.249669 0.00000 False log m2 1 -1126.327534 72.989176 1095.959985 0.0 19.482218 22.70914 False log <p>Apparently, there is no noteworthy difference in the model fit. Accordingly, we do not really need to model sex and hatchdate for both response variables, but there is also no harm in including them (so I would probably just include them).</p> <p>To give you a glimpse of the capabilities of brms\u2019 multivariate syntax, we change our model in various directions at the same time. Remember the slight left skewness of tarsus, which we will now model by using the skew_normal family instead of the gaussian family. Since we do not have a multivariate normal (or student-t) model, anymore, estimating residual correlations is no longer possible. We make this explicit using the set_rescor function. Further, we investigate if the relationship of back and hatchdate is really linear as previously assumed by fitting a non-linear spline of hatchdate. On top of it, we model separate residual variances of tarsus for male and female chicks.</p> In\u00a0[13]: Copied! <pre>from brmspy import skew_normal, gaussian\n</pre> from brmspy import skew_normal, gaussian In\u00a0[14]: Copied! <pre>bf_tarsus = bf(\"tarsus ~ sex + (1|p|fosternest) + (1|q|dam)\") + lf(\"sigma ~ 0 + sex\") + skew_normal()\nbf_back = bf(\"back ~ s(hatchdate) + (1|p|fosternest) + (1|q|dam)\") + gaussian()\n\nfit3 = brms.brm(\n  bf_tarsus + bf_back + set_rescor(False),\n  data = df, chains = 2, cores = 2,\n  control = {\"adapt_delta\": 0.95},\n  silent = 2, refresh = 0\n)\n</pre>  bf_tarsus = bf(\"tarsus ~ sex + (1|p|fosternest) + (1|q|dam)\") + lf(\"sigma ~ 0 + sex\") + skew_normal() bf_back = bf(\"back ~ s(hatchdate) + (1|p|fosternest) + (1|q|dam)\") + gaussian()  fit3 = brms.brm(   bf_tarsus + bf_back + set_rescor(False),   data = df, chains = 2, cores = 2,   control = {\"adapt_delta\": 0.95},   silent = 2, refresh = 0 ) <pre>[brmspy] Fitting model with brms (backend: cmdstanr)...\n</pre> <pre> \\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\r</pre> <pre>R callback write-console: Warning: 3 of 2000 (0.0%) transitions ended with a divergence.\nSee https://mc-stan.org/misc/warnings for details.\n\n  \n</pre> <p>Again, we summarize the model and look at some posterior-predictive checks.</p> In\u00a0[15]: Copied! <pre>for var in fit3.idata.posterior_predictive.data_vars:\n    print(var)\n    print(az.loo(fit3.idata, var_name=var))\n    print(\"\\n\")\n</pre> for var in fit3.idata.posterior_predictive.data_vars:     print(var)     print(az.loo(fit3.idata, var_name=var))     print(\"\\n\") <pre>tarsus\n</pre> <pre>/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.70 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n</pre> <pre>Computed from 2000 posterior samples and 828 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo -1049.76    25.55\np_loo       95.05        -\n\nThere has been a warning during the calculation. Please check the results.\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.70]   (good)      826   99.8%\n   (0.70, 1]   (bad)         1    0.1%\n   (1, Inf)   (very bad)    1    0.1%\n\n\n\nback\nComputed from 2000 posterior samples and 828 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo -1125.37    19.54\np_loo       70.02        -\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.70]   (good)      828  100.0%\n   (0.70, 1]   (bad)         0    0.0%\n   (1, Inf)   (very bad)    0    0.0%\n\n\n\n</pre> In\u00a0[16]: Copied! <pre>brms.summary(fit3)\n</pre> brms.summary(fit3) <pre>R callback write-console: In addition:   \nR callback write-console: Warning message:\n  \nR callback write-console: There were 3 divergent transitions after warmup. Increasing adapt_delta above 0.95 may help. See http://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup \n  \n</pre> Out[16]: <pre> Family: MV(skew_normal, gaussian) \n  Links: mu = identity; sigma = log\n         mu = identity \nFormula: tarsus ~ sex + (1 | p | fosternest) + (1 | q | dam) \n         sigma ~ 0 + sex\n         back ~ s(hatchdate) + (1 | p | fosternest) + (1 | q | dam) \n   Data: structure(list(tarsus = c(-1.89229718155107, 1.136 (Number of observations: 828) \n  Draws: 2 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 2000\n\nSmoothing Spline Hyperparameters:\n                       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS\nsds(back_shatchdate_1)     2.23      1.13     0.54     4.92 1.00      538\n                       Tail_ESS\nsds(back_shatchdate_1)      646\n\nMultilevel Hyperparameters:\n~dam (Number of levels: 106) \n                                     Estimate Est.Error l-95% CI u-95% CI Rhat\nsd(tarsus_Intercept)                     0.46      0.05     0.36     0.56 1.01\nsd(back_Intercept)                       0.23      0.07     0.09     0.36 1.01\ncor(tarsus_Intercept,back_Intercept)    -0.54      0.24    -0.96    -0.06 1.02\n                                     Bulk_ESS Tail_ESS\nsd(tarsus_Intercept)                      616     1097\nsd(back_Intercept)                        237      427\ncor(tarsus_Intercept,back_Intercept)      317      454\n\n~fosternest (Number of levels: 104) \n                                     Estimate Est.Error l-95% CI u-95% CI Rhat\nsd(tarsus_Intercept)                     0.30      0.06     0.19     0.42 1.01\nsd(back_Intercept)                       0.31      0.06     0.20     0.42 1.00\ncor(tarsus_Intercept,back_Intercept)     0.62      0.24     0.11     0.98 1.01\n                                     Bulk_ESS Tail_ESS\nsd(tarsus_Intercept)                      394      521\nsd(back_Intercept)                        312      554\ncor(tarsus_Intercept,back_Intercept)      146      255\n\nRegression Coefficients:\n                  Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\ntarsus_Intercept     -0.76      0.11    -0.98    -0.54 1.00      992     1493\nback_Intercept        0.00      0.05    -0.10     0.10 1.00      873     1317\ntarsus_sex            0.46      0.06     0.35     0.57 1.00     1540     1376\nsigma_tarsus_sex     -0.11      0.02    -0.14    -0.08 1.00     1291     1257\nback_shatchdate_1     0.08      3.36    -5.75     7.36 1.00      663     1019\n\nFurther Distributional Parameters:\n             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma_back       0.90      0.02     0.85     0.95 1.00     1302     1459\nalpha_tarsus    -0.91      0.64    -1.82     0.64 1.00      750     1247\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).</pre> <p>We see that the (log) residual standard deviation of tarsus is somewhat larger for chicks whose sex could not be identified as compared to male or female chicks. Further, we see from the negative alpha (skewness) parameter of tarsus that the residuals are indeed slightly left-skewed. Lastly, running</p> In\u00a0[17]: Copied! <pre>result = brms.call(\"conditional_effects\", fit3, \"hatchdate\", resp=\"back\")\ndf_result = result['back.back_hatchdate']\n\ndf_plot = df_result.sort_values(\"hatchdate\")\n\nfig, ax = plt.subplots()\n\nax.plot(\n    df_plot[\"hatchdate\"],\n    df_plot[\"estimate__\"],\n    color=\"blue\"\n)\n\nax.fill_between(\n    df_plot[\"hatchdate\"],\n    df_plot[\"lower__\"],\n    df_plot[\"upper__\"],\n    alpha=0.3,\n    color=\"blue\"\n)\n\nax.set_xlabel(\"hatchdate\")\nax.set_ylabel(\"back\")\nax.set_title(\"Conditional effect of hatchdate on back\")\n\nplt.show()\n</pre> result = brms.call(\"conditional_effects\", fit3, \"hatchdate\", resp=\"back\") df_result = result['back.back_hatchdate']  df_plot = df_result.sort_values(\"hatchdate\")  fig, ax = plt.subplots()  ax.plot(     df_plot[\"hatchdate\"],     df_plot[\"estimate__\"],     color=\"blue\" )  ax.fill_between(     df_plot[\"hatchdate\"],     df_plot[\"lower__\"],     df_plot[\"upper__\"],     alpha=0.3,     color=\"blue\" )  ax.set_xlabel(\"hatchdate\") ax.set_ylabel(\"back\") ax.set_title(\"Conditional effect of hatchdate on back\")  plt.show() <p>reveals a non-linear relationship of hatchdate on the back color, which seems to change in waves over the course of the hatch dates.</p> <p>There are many more modeling options for multivariate models, which are not discussed in this vignette. Examples include autocorrelation structures, Gaussian processes, or explicit non-linear predictors (e.g., see help(\"brmsformula\") or vignette(\"brms_multilevel\")). In fact, nearly all the flexibility of univariate models is retained in multivariate models.</p>"},{"location":"examples/brmspy-estimating-multivariate-models/#brmspy-estimating-multivariate-models","title":"brmspy - Estimating Multivariate Models\u00b6","text":"<p>Example adapted from: HERE</p>"},{"location":"examples/brmspy-estimating-multivariate-models/#introduction","title":"Introduction\u00b6","text":"<p>In the present example, we want to discuss how to specify multivariate multilevel models using brms. We call a model multivariate if it contains multiple response variables, each being predicted by its own set of predictors. Consider an example from biology. Hadfield, Nutall, Osorio, and Owens (2007) analyzed data of the Eurasian blue tit (https://en.wikipedia.org/wiki/Eurasian_blue_tit). They predicted the tarsus length as well as the back color of chicks. Half of the brood were put into another fosternest, while the other half stayed in the fosternest of their own dam. This allows to separate genetic from environmental factors. Additionally, we have information about the hatchdate and sex of the chicks (the latter being known for 94% of the animals).</p>"},{"location":"examples/brmspy-estimating-multivariate-models/#basic-multivariate-models","title":"Basic Multivariate Models\u00b6","text":"<p>We begin with a relatively simple multivariate normal model.</p>"},{"location":"examples/brmspy-estimating-multivariate-models/#more-complex-multivariate-models","title":"More Complex Multivariate Models\u00b6","text":"<p>Now, suppose we only want to control for sex in tarsus but not in back and vice versa for hatchdate. Not that this is particular reasonable for the present example, but it allows us to illustrate how to specify different formulas for different response variables. We can no longer use mvbind syntax and so we have to use a more verbose approach:</p>"},{"location":"examples/brmspy-estimating-multivariate-models/#references","title":"References\u00b6","text":"<p>Hadfield JD, Nutall A, Osorio D, Owens IPF (2007). Testing the phenotypic gambit: phenotypic, genetic and environmental correlations of colour. Journal of Evolutionary Biology, 20(2), 549-557.</p>"},{"location":"examples/brmspy-google-colab/","title":"brmspy - google colab","text":"In\u00a0[1]: Copied! <pre>try: from brmspy import brms\nexcept ImportError:\n    %pip install -q brmspy\n    from brmspy import brms\n</pre> try: from brmspy import brms except ImportError:     %pip install -q brmspy     from brmspy import brms <pre>[brmspy][WARNING] brmspy: brms and other required libraries are not installed. Please call brmspy.install_brms()\n</pre> In\u00a0[3]: Copied! <pre>brms.install_brms(use_prebuilt=True)\n</pre> brms.install_brms(use_prebuilt=True) <pre>R callback write-console: CmdStan path set to: /Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0/cmdstan\n  \n</pre> In\u00a0[\u00a0]: Copied! <pre>epilepsy = brms.get_brms_data(\"epilepsy\")\nformula = \"count ~ zAge + zBase * Trt + (1|patient)\"\nfamily = \"poisson\"\nbrms.default_prior(formula, data=epilepsy, family=family)\n</pre> epilepsy = brms.get_brms_data(\"epilepsy\") formula = \"count ~ zAge + zBase * Trt + (1|patient)\" family = \"poisson\" brms.default_prior(formula, data=epilepsy, family=family) Out[\u00a0]: prior class coef group resp dpar nlpar lb ub tag source 1 b default 2 b Base default 3 b count default 4 b obs10 default 5 b obs100 default ... ... ... ... ... ... ... ... ... ... ... ... 299 b visit3 default 300 b visit4 default 301 b zAge default 302 b zBase default 303 student_t(3, 3.3, 2.5) Intercept default <p>303 rows \u00d7 11 columns</p> In\u00a0[6]: Copied! <pre>model = brms.fit(\n    formula=formula,\n    data=epilepsy,\n    family=family,\n    warmup=500,\n    iter=1000,\n    chains=4\n)\nidata = model.idata\n</pre>  model = brms.fit(     formula=formula,     data=epilepsy,     family=family,     warmup=500,     iter=1000,     chains=4 ) idata = model.idata <pre>[brmspy][&lt;cell line: 0&gt;] Fitting model with brms (backend: cmdstanr)...\nWARNING:rpy2.rinterface_lib.callbacks:R[write to console]: Compiling Stan program...\n\n</pre> <pre></pre> <pre>WARNING:rpy2.rinterface_lib.callbacks:R[write to console]: Start sampling\n\n</pre> <pre>Running MCMC with 4 sequential chains...\n\nChain 1 Iteration:   1 / 1000 [  0%]  (Warmup) \nChain 1 Iteration: 100 / 1000 [ 10%]  (Warmup) \nChain 1 Iteration: 200 / 1000 [ 20%]  (Warmup) \nChain 1 Iteration: 300 / 1000 [ 30%]  (Warmup) \nChain 1 Iteration: 400 / 1000 [ 40%]  (Warmup) \nChain 1 Iteration: 500 / 1000 [ 50%]  (Warmup) \nChain 1 Iteration: 501 / 1000 [ 50%]  (Sampling) \nChain 1 Iteration: 600 / 1000 [ 60%]  (Sampling) \nChain 1 Iteration: 700 / 1000 [ 70%]  (Sampling) \nChain 1 Iteration: 800 / 1000 [ 80%]  (Sampling) \nChain 1 Iteration: 900 / 1000 [ 90%]  (Sampling) \nChain 1 Iteration: 1000 / 1000 [100%]  (Sampling) \nChain 1 finished in 2.8 seconds.\nChain 2 Iteration:   1 / 1000 [  0%]  (Warmup) \nChain 2 Iteration: 100 / 1000 [ 10%]  (Warmup) \nChain 2 Iteration: 200 / 1000 [ 20%]  (Warmup) \nChain 2 Iteration: 300 / 1000 [ 30%]  (Warmup) \nChain 2 Iteration: 400 / 1000 [ 40%]  (Warmup) \nChain 2 Iteration: 500 / 1000 [ 50%]  (Warmup) \nChain 2 Iteration: 501 / 1000 [ 50%]  (Sampling) \nChain 2 Iteration: 600 / 1000 [ 60%]  (Sampling) \nChain 2 Iteration: 700 / 1000 [ 70%]  (Sampling) \nChain 2 Iteration: 800 / 1000 [ 80%]  (Sampling) \nChain 2 Iteration: 900 / 1000 [ 90%]  (Sampling) \nChain 2 Iteration: 1000 / 1000 [100%]  (Sampling) \nChain 2 finished in 2.7 seconds.\nChain 3 Iteration:   1 / 1000 [  0%]  (Warmup) \nChain 3 Iteration: 100 / 1000 [ 10%]  (Warmup) \nChain 3 Iteration: 200 / 1000 [ 20%]  (Warmup) \nChain 3 Iteration: 300 / 1000 [ 30%]  (Warmup) \nChain 3 Iteration: 400 / 1000 [ 40%]  (Warmup) \nChain 3 Iteration: 500 / 1000 [ 50%]  (Warmup) \nChain 3 Iteration: 501 / 1000 [ 50%]  (Sampling) \nChain 3 Iteration: 600 / 1000 [ 60%]  (Sampling) \nChain 3 Iteration: 700 / 1000 [ 70%]  (Sampling) \nChain 3 Iteration: 800 / 1000 [ 80%]  (Sampling) \nChain 3 Iteration: 900 / 1000 [ 90%]  (Sampling) \nChain 3 Iteration: 1000 / 1000 [100%]  (Sampling) \nChain 3 finished in 5.4 seconds.\nChain 4 Iteration:   1 / 1000 [  0%]  (Warmup) \nChain 4 Iteration: 100 / 1000 [ 10%]  (Warmup) \nChain 4 Iteration: 200 / 1000 [ 20%]  (Warmup) \nChain 4 Iteration: 300 / 1000 [ 30%]  (Warmup) \nChain 4 Iteration: 400 / 1000 [ 40%]  (Warmup) \nChain 4 Iteration: 500 / 1000 [ 50%]  (Warmup) \nChain 4 Iteration: 501 / 1000 [ 50%]  (Sampling) \nChain 4 Iteration: 600 / 1000 [ 60%]  (Sampling) \nChain 4 Iteration: 700 / 1000 [ 70%]  (Sampling) \nChain 4 Iteration: 800 / 1000 [ 80%]  (Sampling) \nChain 4 Iteration: 900 / 1000 [ 90%]  (Sampling) \nChain 4 Iteration: 1000 / 1000 [100%]  (Sampling) \nChain 4 finished in 2.9 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 3.5 seconds.\nTotal execution time: 14.5 seconds.\n\n</pre> In\u00a0[7]: Copied! <pre>brms.save_rds(model, \"epilepsy_fixed_effects.rds\")\n# load later using: model = brms.load_rds_fit(\"epilepsy_fixed_effects.rds\")\n</pre> brms.save_rds(model, \"epilepsy_fixed_effects.rds\") # load later using: model = brms.load_rds_fit(\"epilepsy_fixed_effects.rds\") In\u00a0[8]: Copied! <pre>import arviz as az\nsummary = az.summary(\n    idata,\n    hdi_prob=0.95,\n    kind=\"stats\",\n    round_to=3\n)\n\nprint(\"Posterior Summary\")\nprint(\"=\"*60)\nprint(summary)\n</pre> import arviz as az summary = az.summary(     idata,     hdi_prob=0.95,     kind=\"stats\",     round_to=3 )  print(\"Posterior Summary\") print(\"=\"*60) print(summary) <pre>Posterior Summary\n============================================================\n                         mean     sd  hdi_2.5%  hdi_97.5%\nIntercept               1.631  0.085     1.473      1.808\nb_Intercept             1.777  0.130     1.535      2.049\nb_Trt1                 -0.279  0.178    -0.630      0.079\nb_zAge                  0.099  0.090    -0.067      0.286\nb_zBase                 0.706  0.122     0.492      0.968\n...                       ...    ...       ...        ...\nr_patient[6,Intercept]  0.011  0.230    -0.424      0.440\nr_patient[7,Intercept] -0.200  0.288    -0.712      0.425\nr_patient[8,Intercept]  0.581  0.254     0.119      1.105\nr_patient[9,Intercept] -0.013  0.261    -0.521      0.508\nsd_patient__Intercept   0.588  0.072     0.458      0.731\n\n[68 rows x 4 columns]\n</pre> In\u00a0[9]: Copied! <pre>import matplotlib.pyplot as plt\nimport seaborn as sns\n\nfig = az.plot_posterior(\n    idata,\n    var_names=['b_Intercept', 'b_zAge', 'b_zBase', 'b_Trt1', 'b_zBase:Trt1'],\n    figsize=(12, 8),\n    textsize=10\n)\nplt.suptitle('Posterior Distributions - Fixed Effects', y=1.02, fontsize=14, fontweight='bold')\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt import seaborn as sns  fig = az.plot_posterior(     idata,     var_names=['b_Intercept', 'b_zAge', 'b_zBase', 'b_Trt1', 'b_zBase:Trt1'],     figsize=(12, 8),     textsize=10 ) plt.suptitle('Posterior Distributions - Fixed Effects', y=1.02, fontsize=14, fontweight='bold') plt.tight_layout() plt.show()  In\u00a0[9]: Copied! <pre>\n</pre>"},{"location":"examples/brmspy-google-colab/#brmspy-google-colab","title":"brmspy - google colab\u00b6","text":""},{"location":"examples/brmspy-vi-sampling/","title":"brmspy - Variational Inference","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nimport sys\n\nimport sys, os # for running from repo\nsys.path.insert(0, os.path.abspath(\"..\"))\n\ntry: from brmspy import brms\nexcept ImportError:\n    %pip install -q brmspy\n    from brmspy import brms\n\nfrom brmspy import bf, set_rescor, lf\nimport pandas as pd\nimport arviz as az\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set_style(\"darkgrid\")\n#brms.install_runtime()\n</pre>  import os import sys  import sys, os # for running from repo sys.path.insert(0, os.path.abspath(\"..\"))  try: from brmspy import brms except ImportError:     %pip install -q brmspy     from brmspy import brms  from brmspy import bf, set_rescor, lf import pandas as pd import arviz as az import numpy as np import matplotlib.pyplot as plt import seaborn as sns  sns.set_style(\"darkgrid\") #brms.install_runtime() <pre>R callback write-console: Error in loadNamespace(x) : there is no package called \u2018cmdstanr\u2019\n  \nR callback write-console: CmdStan path set to: /Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.1.0/cmdstan\n  \n</pre> In\u00a0[2]: Copied! <pre>df = brms.get_brms_data(\"epilepsy\")\n</pre> df = brms.get_brms_data(\"epilepsy\") In\u00a0[6]: Copied! <pre>model = brms.brm(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    family=\"negbinomial\", \n    data=df,\n    \n    # 1. ALGORITHM\n    algorithm=\"meanfield\",\n    \n    # 2. OPTIMIZATION LOOP\n    iter=30000,\n    eta=0.1,\n    adapt_engaged=True,\n    \n    # 3. GRADIENT ESTIMATION (Reducing Noise)\n    grad_samples=5,\n    elbo_samples=100,\n    \n    # 4. CONVERGENCE CRITERIA\n    eval_elbo=200,\n    tol_rel_obj=0.0001,\n    \n    seed=42,\n\n    refresh=0, silent=2\n)\n</pre> model = brms.brm(     formula=\"count ~ zAge + zBase * Trt + (1|patient)\",     family=\"negbinomial\",      data=df,          # 1. ALGORITHM     algorithm=\"meanfield\",          # 2. OPTIMIZATION LOOP     iter=30000,     eta=0.1,     adapt_engaged=True,          # 3. GRADIENT ESTIMATION (Reducing Noise)     grad_samples=5,     elbo_samples=100,          # 4. CONVERGENCE CRITERIA     eval_elbo=200,     tol_rel_obj=0.0001,          seed=42,      refresh=0, silent=2 ) <pre>[brmspy] Fitting model with brms (backend: cmdstanr)...\n</pre> <pre>------------------------------------------------------------ \nEXPERIMENTAL ALGORITHM: \n  This procedure has not been thoroughly tested and may be unstable \n  or buggy. The interface is subject to change. \n------------------------------------------------------------ \nGradient evaluation took 6.6e-05 seconds \n1000 transitions using 10 leapfrog steps per transition would take 0.66 seconds. \nAdjust your expectations accordingly! \nBegin eta adaptation. \nIteration:   1 / 250 [  0%]  (Adaptation) \nIteration:  50 / 250 [ 20%]  (Adaptation) \nIteration: 100 / 250 [ 40%]  (Adaptation) \nIteration: 150 / 250 [ 60%]  (Adaptation) \nIteration: 200 / 250 [ 80%]  (Adaptation) \nSuccess! Found best value [eta = 1] earlier than expected. \nBegin stochastic gradient ascent. \n  iter             ELBO   delta_ELBO_mean   delta_ELBO_med   notes  \n   200         -652.394             1.000            1.000 \n   400         -652.970             0.500            1.000 \n   600         -650.120             0.335            0.004 \n   800         -652.771             0.252            0.004 \n  1000         -650.305             0.203            0.004 \n  1200         -649.219             0.169            0.004 \n  1400         -651.298             0.145            0.004 \n  1600         -650.483             0.127            0.004 \n  1800         -652.597             0.114            0.003 \n  2000         -650.026             0.103            0.004 \n  2200         -650.406             0.093            0.003 \n  2400         -650.830             0.086            0.003 \n  2600         -650.437             0.079            0.003 \n  2800         -648.942             0.074            0.003 \n  3000         -650.946             0.069            0.003 \n  3200         -650.071             0.002            0.002 \n  3400         -649.236             0.002            0.002 \n  3600         -651.772             0.002            0.002 \n  3800         -650.013             0.002            0.002 \n  4000         -649.779             0.002            0.002 \n  4200         -650.599             0.002            0.001 \n  4400         -649.986             0.002            0.001 \n  4600         -649.596             0.002            0.001 \n  4800         -650.784             0.002            0.001 \n  5000         -651.083             0.001            0.001 \n  5200         -648.887             0.002            0.001 \n  5400         -649.172             0.002            0.001 \n  5600         -649.446             0.002            0.001 \n  5800         -648.973             0.002            0.001 \n  6000         -648.896             0.001            0.001 \n  6200         -649.314             0.001            0.001 \n  6400         -649.089             0.001            0.001 \n  6600         -649.375             0.001            0.001 \n  6800         -649.641             0.001            0.000 \n  7000         -649.083             0.001            0.001 \n  7200         -648.838             0.001            0.000 \n  7400         -648.887             0.001            0.000 \n  7600         -648.659             0.001            0.000 \n  7800         -648.117             0.001            0.000 \n  8000         -650.031             0.001            0.000 \n  8200         -649.920             0.001            0.000 \n  8400         -649.288             0.001            0.000 \n  8600         -648.947             0.001            0.000 \n  8800         -647.518             0.001            0.000 \n  9000         -649.226             0.001            0.001 \n  9200         -650.370             0.001            0.001 \n  9400         -648.902             0.001            0.001 \n  9600         -648.854             0.001            0.001 \n  9800         -650.103             0.001            0.001 \n  10000         -649.133             0.001            0.001 \n  10200         -648.926             0.001            0.001 \n  10400         -648.198             0.001            0.001 \n  10600         -650.328             0.002            0.001 \n  10800         -648.939             0.002            0.002 \n  11000         -649.499             0.001            0.001 \n  11200         -648.618             0.002            0.001 \n  11400         -648.918             0.001            0.001 \n  11600         -648.060             0.002            0.001 \n  11800         -649.188             0.002            0.001 \n  12000         -649.402             0.001            0.001 \n  12200         -649.857             0.001            0.001 \n  12400         -650.381             0.001            0.001 \n  12600         -649.190             0.001            0.001 \n  12800         -649.261             0.001            0.001 \n  13000         -649.857             0.001            0.001 \n  13200         -649.480             0.001            0.001 \n  13400         -648.946             0.001            0.001 \n  13600         -647.745             0.001            0.001 \n  13800         -649.635             0.001            0.001 \n  14000         -649.332             0.001            0.001 \n  14200         -649.666             0.001            0.001 \n  14400         -649.317             0.001            0.001 \n  14600         -649.858             0.001            0.001 \n  14800         -649.478             0.001            0.001 \n  15000         -650.213             0.001            0.001 \n  15200         -649.809             0.001            0.001 \n  15400         -649.419             0.001            0.001 \n  15600         -650.002             0.001            0.001 \n  15800         -647.672             0.001            0.001 \n  16000         -649.595             0.001            0.001 \n  16200         -649.908             0.001            0.001 \n  16400         -650.165             0.001            0.001 \n  16600         -649.076             0.001            0.001 \n  16800         -649.755             0.001            0.001 \n  17000         -649.846             0.001            0.001 \n  17200         -648.930             0.001            0.001 \n  17400         -649.366             0.001            0.001 \n  17600         -649.002             0.001            0.001 \n  17800         -650.382             0.001            0.001 \n  18000         -650.079             0.001            0.001 \n  18200         -650.501             0.001            0.001 \n  18400         -648.699             0.001            0.001 \n  18600         -647.671             0.001            0.001 \n  18800         -649.414             0.001            0.001 \n  19000         -648.623             0.001            0.001 \n  19200         -649.478             0.001            0.001 \n  19400         -649.675             0.001            0.001 \n  19600         -648.411             0.001            0.001 \n  19800         -648.159             0.001            0.001 \n  20000         -649.112             0.001            0.001 \n  20200         -649.459             0.001            0.001 \n  20400         -647.534             0.001            0.001 \n  20600         -649.228             0.002            0.001 \n  20800         -649.454             0.001            0.001 \n  21000         -649.684             0.001            0.001 \n  21200         -648.718             0.001            0.001 \n  21400         -650.052             0.001            0.001 \n  21600         -649.061             0.001            0.001 \n  21800         -649.027             0.001            0.001 \n  22000         -649.068             0.001            0.001 \n  22200         -648.792             0.001            0.001 \n  22400         -649.876             0.001            0.001 \n  22600         -649.991             0.001            0.001 \n  22800         -649.223             0.001            0.001 \n  23000         -649.077             0.001            0.001 \n  23200         -648.953             0.001            0.000 \n  23400         -649.894             0.001            0.000 \n  23600         -648.379             0.001            0.000 \n  23800         -648.999             0.001            0.001 \n  24000         -650.932             0.001            0.001 \n  24200         -648.653             0.001            0.001 \n  24400         -649.225             0.001            0.001 \n  24600         -649.829             0.001            0.001 \n  24800         -649.086             0.001            0.001 \n  25000         -648.186             0.001            0.001 \n  25200         -649.377             0.001            0.001 \n  25400         -647.628             0.001            0.001 \n  25600         -649.409             0.002            0.001 \n  25800         -649.125             0.002            0.001 \n  26000         -648.632             0.002            0.001 \n  26200         -648.135             0.002            0.001 \n  26400         -649.139             0.002            0.001 \n  26600         -649.310             0.002            0.001 \n  26800         -649.611             0.001            0.001 \n  27000         -648.477             0.001            0.001 \n  27200         -650.008             0.001            0.001 \n  27400         -648.483             0.001            0.001 \n  27600         -648.559             0.001            0.001 \n  27800         -649.814             0.001            0.002 \n  28000         -648.641             0.001            0.002 \n  28200         -649.483             0.001            0.002 \n  28400         -648.510             0.001            0.002 \n  28600         -649.441             0.001            0.001 \n  28800         -649.177             0.001            0.001 \n  29000         -649.217             0.001            0.001 \n  29200         -649.179             0.001            0.001 \n  29400         -648.250             0.001            0.001 \n  29600         -649.271             0.001            0.001 \n  29800         -648.726             0.001            0.001 \n  30000         -649.375             0.001            0.001 \nInformational Message: The maximum number of iterations is reached! The algorithm may not have converged. \nThis variational approximation is not guaranteed to be meaningful. \nDrawing a sample of size 1000 from the approximate posterior...  \nCOMPLETED. \nFinished in  3.5 seconds.\n</pre> In\u00a0[7]: Copied! <pre>loo_res = az.loo(model.idata, pointwise=True)\nprint(loo_res)\n\n# Visualize the k-hats\naz.plot_khat(loo_res)\nplt.show()\n</pre> loo_res = az.loo(model.idata, pointwise=True) print(loo_res)  # Visualize the k-hats az.plot_khat(loo_res) plt.show() <pre>Computed from 1000 posterior samples and 236 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo  -623.39    17.86\np_loo       45.52        -\n\nThere has been a warning during the calculation. Please check the results.\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.67]   (good)      227   96.2%\n   (0.67, 1]   (bad)         7    3.0%\n   (1, Inf)   (very bad)    2    0.8%\n\n</pre> <pre>/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.67 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n</pre> In\u00a0[8]: Copied! <pre>az.plot_ppc(model.idata, num_pp_samples=100)\nplt.title(\"Posterior Predictive Check\")\nplt.xlim(0, 100)\nplt.show()\n</pre> az.plot_ppc(model.idata, num_pp_samples=100) plt.title(\"Posterior Predictive Check\") plt.xlim(0, 100) plt.show() In\u00a0[9]: Copied! <pre>pred = brms.posterior_predict(model)\n</pre> pred = brms.posterior_predict(model) In\u00a0[\u00a0]: Copied! <pre>summary = brms.summary(model)\nsummary\n</pre> summary = brms.summary(model) summary <pre>[brmspy][iterate_robject_to_dataclass][WARNING] Type of param 'iter' &lt;class 'int'&gt; does not match expected '&lt;class 'float'&gt;'\n</pre> <pre>           Estimate  Est.Error  l-95% CI  u-95% CI  Rhat  Bulk_ESS  Tail_ESS\nIntercept      2.04       0.12      1.81      2.29  1.00   1113.57   1022.38\nzAge           0.10       0.04      0.02      0.18  1.00   1163.52    979.43\nzBase          0.65       0.03      0.58      0.71  1.00    926.45    907.70\nTrt           -0.25       0.07     -0.40     -0.10  1.00   1065.05    980.16\nzBase:Trt      0.04       0.02      0.00      0.08  1.00    948.40    940.45\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/brmspy-vi-sampling/#brmspy-variational-inference","title":"brmspy - Variational Inference\u00b6","text":""}]}