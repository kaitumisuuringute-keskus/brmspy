{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"brmspy","text":"<p>Python-first access to R's brms  with proper parameter names, ArviZ support, and cmdstanr performance. The easiest way to run brms models from Python.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Proper parameter names: Returns <code>b_Intercept</code>, <code>b_zAge</code>, <code>sd_patient__Intercept</code> instead of generic names like <code>b_dim_0</code></li> <li>arviz integration: Returns <code>arviz.InferenceData</code> by default for Python workflow</li> <li>brms formula syntax: Full support for brms formula interface including random effects</li> <li>Dual access: Results include both <code>.idata</code> (arviz) and <code>.r</code> (brmsfit or other) attributes</li> <li>Prebuilt Binaries: Fast installation with precompiled runtimes containing brms and cmstanr (50x faster, 25 seconds on Google Colab)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install brmspy\n</code></pre> <p>First-time setup (installs brms, cmdstanr, and CmdStan in R):</p> <pre><code>from brmspy import brms\nbrms.install_brms() # requires R to be installed already\n</code></pre>"},{"location":"#prebuilt-runtimes-optional","title":"Prebuilt Runtimes (Optional)","text":"<p>For faster installation (~20-60 seconds vs 20-30 minutes), use prebuilt runtime bundles:</p> <pre><code>from brmspy import brms\nbrms.install_brms(use_prebuilt_binaries=True)\n</code></pre>"},{"location":"#windows-rtools","title":"Windows RTools","text":"<p>In case you don't have RTools installed, you can use the flag install_rtools = True. This is disabled by default, because the flag runs the full rtools installer and modifies system path.  Use with caution!</p> <pre><code>from brmspy import brms\nbrms.install_brms(\n    use_prebuilt_binaries=True,\n    install_rtools=True # works for both prebuilt and compiled binaries.\n)\n</code></pre>"},{"location":"#system-requirements","title":"System Requirements","text":"<p>R &gt;= 4.0</p> <p>Linux (x86_64): - glibc &gt;= 2.27 (Ubuntu 18.04+, Debian 10+, RHEL 8+) - g++ &gt;= 9.0</p> <p>macOS (Intel &amp; Apple Silicon): - Xcode Command Line Tools: <code>xcode-select --install</code> - clang &gt;= 11.0</p> <p>Windows (x86_64): - Rtools 4.0+ with MinGW toolchain - g++ &gt;= 9.0</p> <p>Download Rtools from: https://cran.r-project.org/bin/windows/Rtools/</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from brmspy import brms, prior\nimport arviz as az\n\n# Load data\nepilepsy = brms.get_brms_data(\"epilepsy\")\n\n# Fit model\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    priors=[\n        prior(\"normal(0, 1)\", \"b\"),\n        prior(\"exponential(1)\", \"sd\", group=\"patient\"),\n        prior(\"student_t(3, 0, 2.5)\", \"Intercept\")\n    ],\n    family=\"poisson\",\n    chains=4,\n    iter=2000\n)\n\n# Analyze\naz.summary(model.idata)\naz.plot_posterior(model.idata)\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.10-3.14</li> <li>R with brms &gt;= 2.20.0, cmdstanr, and posterior packages</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>API Reference</li> <li>Examples</li> </ul>"},{"location":"api/brms/","title":"Main Module","text":""},{"location":"api/brms/#brmspy.brms-classes","title":"Classes","text":""},{"location":"api/brms/#brmspy.brms.FitResult","title":"<code>FitResult</code>  <code>dataclass</code>","text":"<p>Result from fit() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with posterior, posterior_predictive, log_likelihood, and observed_data groups</p> <code>r</code> <code>ListVector</code> <p>brmsfit R object from brms::brm()</p>"},{"location":"api/brms/#brmspy.brms.FormulaResult","title":"<code>FormulaResult</code>  <code>dataclass</code>","text":"<p>Result from formula() function.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R brmsformula object</p> <code>dict</code> <code>Dict</code> <p>Python dictionary representation of formula</p> See Also <p>brmspy.brms.formula : Creates FormulaResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\n# Create formula with options\nf = brms.formula(\"y ~ x\", decomp=\"QR\")\n\n# Use in fit()\nmodel = brms.fit(f, data=df, chains=4)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.GenericResult","title":"<code>GenericResult</code>  <code>dataclass</code>","text":"<p>Generic result container with arviz and R objects.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData object</p> <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/brms/#brmspy.brms.LogLikResult","title":"<code>LogLikResult</code>  <code>dataclass</code>","text":"<p>Result from log_lik() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>IDLogLik</code> <p>arviz InferenceData with log-likelihood values</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::log_lik()</p> See Also <p>brmspy.brms.log_lik : Creates LogLikResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nmodel = brms.fit(\"y ~ x\", data=df, chains=4)\nloglik = brms.log_lik(model)\n\n# Use for model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.PosteriorEpredResult","title":"<code>PosteriorEpredResult</code>  <code>dataclass</code>","text":"<p>Result from posterior_epred() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with expected values in 'posterior' group</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_epred()</p>"},{"location":"api/brms/#brmspy.brms.PosteriorLinpredResult","title":"<code>PosteriorLinpredResult</code>  <code>dataclass</code>","text":"<p>Result from posterior_linpred() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>IDLinpred</code> <p>arviz InferenceData with linear predictor values</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_linpred()</p> See Also <p>brmspy.brms.posterior_linpred : Creates PosteriorLinpredResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.fit(\"count ~ age\", data=df, family=\"poisson\", chains=4)\nlinpred = brms.posterior_linpred(model)\n\n# Linear predictor on log scale (for Poisson)\nprint(linpred.idata.predictions)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.PosteriorPredictResult","title":"<code>PosteriorPredictResult</code>  <code>dataclass</code>","text":"<p>Result from posterior_predict() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with predictions in 'posterior_predictive' group</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_predict()</p>"},{"location":"api/brms/#brmspy.brms-functions","title":"Functions","text":""},{"location":"api/brms/#brmspy.brms.prior","title":"<code>prior(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None, **kwargs)</code>","text":"<p>Create a brms-style prior specification.</p> <p>This function mirrors the behavior of <code>brms::prior_string()</code> and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of <code>prior_string()</code> in brms.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>str</code> <p>The prior definition as a string, exactly as brms expects it. Examples include ::</p> <pre><code>\"normal(0, 1)\"\n\"student_t(3, 0, 1.5)\"\n\"exponential(2)\"\n\"lkj(2)\"\n</code></pre> required <code>class_</code> <code>str</code> <p>Parameter class (e.g. <code>\"b\"</code>, <code>\"sd\"</code>, <code>\"Intercept\"</code>). This corresponds to <code>class</code> in brms. <code>class</code> cannot be used as a parameter in Python (reserved keyword), so <code>class_</code> is used instead.</p> <code>None</code> <code>coef</code> <code>str</code> <p>Coefficient name for class-level effects.</p> <code>None</code> <code>group</code> <code>str</code> <p>Grouping variable for hierarchical/multilevel effects.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Distributional parameter (e.g. <code>\"sigma\"</code> or <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response variable name for multivariate models.</p> <code>None</code> <code>nlpar</code> <code>str</code> <p>Nonlinear parameter name if using nonlinear formulas.</p> <code>None</code> <code>lb</code> <code>float</code> <p>Lower bound for truncated priors.</p> <code>None</code> <code>ub</code> <code>float</code> <p>Upper bound for truncated priors.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Any additional keyword arguments supported by <code>brms::prior_string()</code>. These are forwarded unchanged.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriorSpec</code> <p>A typed prior specification object used by <code>brmspy.fit()</code> and <code>brmspy.make_stancode()</code>.</p> Notes <p>This function does not validate the prior expression string itself \u2014 validation occurs inside brms. Its purpose is to construct a structured, editor-friendly representation that seamlessly maps to rpy2 calls.</p> <p>Examples:</p> <p>Prior on the intercept ::</p> <pre><code>p = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\")\n</code></pre> <p>Prior on a coefficient ::</p> <pre><code>p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n</code></pre> <p>Group-level (hierarchical) SD prior ::</p> <pre><code>p = prior(\"exponential(2)\", class_=\"sd\", group=\"region\")\n</code></pre> <p>Truncated prior ::</p> <pre><code>p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0)\n</code></pre> <p>Multiple priors passed to <code>fit</code> ::</p> <pre><code>from brmspy import prior\npriors = [\n    prior(\"student_t(3, 0, 2)\", class_=\"b\", coef=\"zAge\"),\n    prior(\"exponential(2)\", class_=\"sd\", group=\"patient\"),\n]\nmodel = brms.fit(\"y ~ zAge + (1|patient)\", data=df, priors=priors)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.install_brms","title":"<code>install_brms(brms_version='latest', repo=None, install_cmdstanr=True, install_rstan=False, cmdstanr_version='latest', rstan_version='latest', use_prebuilt_binaries=False, install_rtools=False)</code>","text":"<p>Install brms R package, optionally cmdstanr and CmdStan compiler, or rstan.</p> <p>Parameters:</p> Name Type Description Default <code>brms_version</code> <code>str</code> <p>brms version: \"latest\", \"2.23.0\", or \"&gt;= 2.20.0\"</p> <code>\"latest\"</code> <code>repo</code> <code>str | None</code> <p>Extra CRAN repository URL</p> <code>None</code> <code>install_cmdstanr</code> <code>bool</code> <p>Whether to install cmdstanr and build CmdStan compiler</p> <code>True</code> <code>install_rstan</code> <code>bool</code> <p>Whether to install rstan (alternative to cmdstanr)</p> <code>False</code> <code>cmdstanr_version</code> <code>str</code> <p>cmdstanr version: \"latest\", \"0.8.1\", or \"&gt;= 0.8.0\"</p> <code>\"latest\"</code> <code>rstan_version</code> <code>str</code> <p>rstan version: \"latest\", \"2.32.6\", or \"&gt;= 2.32.0\"</p> <code>\"latest\"</code> <code>use_prebuilt_binaries</code> <code>bool</code> <p>Uses fully prebuilt binaries for cmdstanr and brms and their dependencies.  Ignores system R libraries and uses the latest brms and cmdstanr available  for your system. Requires R&gt;=4 and might not be compatible with some older systems or missing toolchains. Can reduce setup time by 50x.</p> <code>False</code> <code>install_rtools</code> <code>bool</code> <p>Installs RTools (windows only) if they cant be found.  WARNING: Modifies system path and runs the full rtools installer.  Use with caution!</p> <code>False</code> <p>Examples:</p> <p>Basic installation:</p> <p><pre><code>from brmspy import brms\nbrms.install_brms()\n</code></pre> Install specific version:</p> <pre><code>brms.install_brms(brms_version=\"2.23.0\")\n</code></pre> <p>Use rstan instead of cmdstanr:</p> <pre><code>brms.install_brms(install_cmdstanr=False, install_rstan=True)\n</code></pre> <p>Fast installation with prebuilt binaries: <pre><code>brms.install_brms(use_prebuilt_binaries=True)\n</code></pre></p>"},{"location":"api/brms/#brmspy.brms.get_brms_version","title":"<code>get_brms_version()</code>","text":"<p>Get installed brms R package version.</p> <p>Returns:</p> Type Description <code>str</code> <p>Version string (e.g., \"2.23.0\")</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If brms is not installed</p> <p>Examples:</p> <pre><code>from brmspy import brms\nversion = brms.get_brms_version()\nprint(f\"brms version: {version}\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.get_brms_data","title":"<code>get_brms_data(dataset_name)</code>","text":"<p>Load example dataset from brms package.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Dataset name. Available datasets include: - 'epilepsy': Epileptic seizure counts - 'kidney': Kidney infection data with censoring - 'inhaler': Inhaler usage study - 'btdata': British Telecom share price data - And many more from brms package</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset as pandas DataFrame with column names preserved</p> See Also <p>brms::brmsdata : R documentation for available datasets     https://paulbuerkner.com/brms/reference/index.html#data</p> <p>Examples:</p> <p>Load epilepsy dataset:</p> <pre><code>from brmspy import brms\nepilepsy = brms.get_brms_data(\"epilepsy\")\nprint(epilepsy.head())\nprint(epilepsy.columns)\n</code></pre> <p>Load kidney dataset with censoring:</p> <pre><code>kidney = brms.get_brms_data(\"kidney\")\nprint(f\"Shape: {kidney.shape}\")\nprint(f\"Censored observations: {kidney['censored'].sum()}\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.make_stancode","title":"<code>make_stancode(formula, data, priors=None, family='poisson', sample_prior='no', formula_args=None)</code>","text":"<p>Generate Stan code using brms::make_stancode().</p> <p>Useful for inspecting the generated Stan model before fitting, understanding the model structure, or using the code with other Stan interfaces.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaResult</code> <p>brms formula specification</p> required <code>data</code> <code>DataFrame</code> <p>Model data</p> required <code>priors</code> <code>list of PriorSpec</code> <p>Prior specifications from prior() function</p> <code>None</code> <code>family</code> <code>str</code> <p>Distribution family (gaussian, poisson, binomial, etc.)</p> <code>\"poisson\"</code> <code>sample_prior</code> <code>str</code> <p>Whether to sample from prior: - \"no\": No prior samples - \"yes\": Include prior samples alongside posterior - \"only\": Sample from prior only (no data)</p> <code>\"no\"</code> <code>formula_args</code> <code>dict</code> <p>Additional arguments passed to formula()</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Complete Stan program code as string</p> See Also <p>brms::make_stancode : R documentation     https://paulbuerkner.com/brms/reference/make_stancode.html fit : Fit model instead of just generating code make_standata : Generate Stan data block</p> <p>Examples:</p> <p>Generate Stan code for simple model:</p> <pre><code>from brmspy import brms\nepilepsy = brms.get_brms_data(\"epilepsy\")\n\nstan_code = brms.make_stancode(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\n\nprint(stan_code[:500])  # Print first 500 characters\n</code></pre> <p>With custom priors:</p> <pre><code>    from brmspy import prior\n\n    stan_code = brms.make_stancode(\n        formula=\"count ~ zAge\",\n        data=epilepsy,\n        priors=[prior(\"normal(0, 1)\", class_=\"b\")],\n        family=\"poisson\"\n    )\n</code></pre> <p>For prior predictive checks (sample_prior=\"only\"):</p> <pre><code>stan_code = brms.make_stancode(\n    formula=\"count ~ zAge\",\n    data=epilepsy,\n    family=\"poisson\",\n    sample_prior=\"only\"\n)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.formula","title":"<code>formula(formula, **formula_args)</code>","text":"<p>Set up a model formula for brms package.</p> <p>Allows defining (potentially non-linear) additive multilevel models for all parameters of the assumed response distribution.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>brms formula specification, e.g., \"y ~ x + (1|group)\"</p> required <code>**formula_args</code> <code>dict</code> <p>Additional brms::brmsformula() arguments:</p> <ul> <li>decomp : str     Decomposition method (e.g., \"QR\" for QR decomposition)</li> <li>center : bool     Whether to center predictors (default True)</li> <li>sparse : bool     Use sparse matrix representation</li> <li>nl : bool     Whether formula is non-linear</li> <li>loop : bool     Use loop-based Stan code</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object with .r (R brmsformula object) and .dict (Python dict) attributes</p> See Also <p>brms::brmsformula : R documentation     https://paulbuerkner.com/brms/reference/brmsformula.html fit : Fit model using formula</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>    from brmspy import brms\n    f = brms.formula(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>With QR decomposition for numerical stability:</p> <pre><code>f = brms.formula(\n    \"reaction ~ days + (days|subject)\",\n    decomp=\"QR\"\n)\n</code></pre> <p>Multivariate formula: <pre><code>    f = brms.formula(\n        \"mvbind(y1, y2) ~ x1 + x2\",\n        center=True\n    )\n</code></pre></p>"},{"location":"api/brms/#brmspy.brms.fit","title":"<code>fit(formula, data, priors=None, family='gaussian', sample_prior='no', sample=True, backend='cmdstanr', formula_args=None, **brm_args)</code>","text":"<p>Fit Bayesian regression model using brms.</p> <p>Uses brms with cmdstanr backend for proper parameter naming. Returns FitResult with .idata (arviz.InferenceData) and .r (brmsfit) attributes.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>brms formula: formula string, e.g \"y ~ x + (1|group)\" or FormulaResult from formula()</p> required <code>data</code> <code>dict or DataFrame</code> <p>Model data</p> required <code>priors</code> <code>list</code> <p>Prior specifications: [(\"normal(0,1)\", \"b\"), (\"cauchy(0,2)\", \"sd\")]</p> <code>[]</code> <code>family</code> <code>str</code> <p>Distribution family: \"gaussian\", \"poisson\", \"binomial\", etc.</p> <code>\"gaussian\"</code> <code>sample_prior</code> <code>str</code> <p>Sample from prior: \"no\", \"yes\", \"only\"</p> <code>\"no\"</code> <code>sample</code> <code>bool</code> <p>Whether to sample. If False, returns compiled model with empty=TRUE</p> <code>True</code> <code>backend</code> <code>str</code> <p>Stan backend: \"cmdstanr\" (recommended), \"rstan\"</p> <code>\"cmdstanr\"</code> <code>**brm_args</code> <p>Additional brms::brm() arguments: chains=4, iter=2000, warmup=1000, cores=4, seed=123, thin=1, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Object with .idata (arviz.InferenceData) and .r (brmsfit) attributes</p> See Also <p>brms::brm : R documentation     https://paulbuerkner.com/brms/reference/brm.html posterior_epred : Expected value predictions posterior_predict : Posterior predictive samples formula : Create formula object with options</p> <p>Examples:</p> <p>Basic Poisson regression:</p> <p><pre><code>from brmspy import brms\nimport arviz as az\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    chains=4,\n    iter=2000\n)\n\naz.summary(model.idata)\n</code></pre> With custom priors:</p> <p><pre><code>from brmspy import prior\n\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    priors=[\n        prior(\"normal(0, 0.5)\", class_=\"b\"),\n        prior(\"exponential(2)\", class_=\"sd\", group=\"patient\")\n    ],\n    family=\"poisson\",\n    chains=4\n)\n</code></pre> Survival model with censoring:</p> <p><pre><code>kidney = brms.get_brms_data(\"kidney\")\n\nsurvival_model = brms.fit(\n    formula=\"time | cens(censored) ~ age + sex + disease + (1|patient)\",\n    data=kidney,\n    family=\"weibull\",\n    chains=4,\n    iter=4000,\n    warmup=2000,\n    cores=4,\n    seed=42\n)\n</code></pre> Gaussian model with distributional regression:</p> <pre><code>    # Model both mean and variance\n    model = brms.fit(\n        formula=brms.formula(\n            \"y ~ x\",\n            sigma ~ \"z\"  # Model heteroscedasticity\n        ),\n        data=data,\n        family=\"gaussian\",\n        chains=4\n    )\n</code></pre>"},{"location":"api/brms/#brmspy.brms.posterior_epred","title":"<code>posterior_epred(model, newdata, **kwargs)</code>","text":"<p>Compute expected value of posterior predictive distribution.</p> <p>Calls brms::posterior_epred() to get E[Y|data] without observation noise.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions</p> required <code>**kwargs</code> <p>Additional arguments to brms::posterior_epred()</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorEpredResult</code> <p>Object with .idata and .r attributes</p>"},{"location":"api/brms/#brmspy.brms.posterior_predict","title":"<code>posterior_predict(model, newdata=None, **kwargs)</code>","text":"<p>Generate posterior predictive samples with observation noise.</p> <p>Calls brms::posterior_predict() to get samples of Y_new|data.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to brms::posterior_predict()</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorPredictResult</code> <p>Object with .idata and .r attributes</p>"},{"location":"api/brms/#brmspy.brms.posterior_linpred","title":"<code>posterior_linpred(model, newdata=None, **kwargs)</code>","text":"<p>Compute linear predictor of the model.</p> <p>Returns samples of the linear predictor (before applying the link function). Useful for understanding the model's predictions on the linear scale.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments to brms::posterior_linpred():</p> <ul> <li>transform : bool - Apply inverse link function (default False)</li> <li>ndraws : int - Number of posterior draws</li> <li>summary : bool - Return summary statistics</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorLinpredResult</code> <p>Object with .idata (IDLinpred) and .r (R matrix) attributes</p> See Also <p>brms::posterior_linpred : R documentation     https://paulbuerkner.com/brms/reference/posterior_linpred.brmsfit.html posterior_epred : Expected values on response scale</p> <p>Examples:</p> <pre><code>    from brmspy import brms\n\n    epilepsy = brms.get_brms_data(\"epilepsy\")\n    model = brms.fit(\n        \"count ~ zAge + zBase * Trt + (1|patient)\",\n        data=epilepsy,\n        family=\"poisson\",\n        chains=4\n    )\n\n    # Linear predictor (log scale for Poisson)\n    linpred = brms.posterior_linpred(model)\n    print(linpred.idata.predictions)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.log_lik","title":"<code>log_lik(model, newdata=None, **kwargs)</code>","text":"<p>Compute log-likelihood values.</p> <p>Returns log p(y|theta) for each observation. Essential for model comparison via LOO-CV and WAIC.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments to brms::log_lik():</p> <ul> <li>ndraws : int - Number of posterior draws</li> <li>combine_chains : bool - Combine chains (default True)</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>LogLikResult</code> <p>Object with .idata (IDLogLik) and .r (R matrix) attributes</p> See Also <p>brms::log_lik : R documentation     https://paulbuerkner.com/brms/reference/log_lik.brmsfit.html arviz.loo : Leave-One-Out Cross-Validation arviz.waic : Widely Applicable Information Criterion</p> <p>Examples:</p> <p>Compute log-likelihood for model comparison:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    \"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    chains=4\n)\n\n# LOO-CV for model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre> <p>Compare multiple models: <pre><code>model1 = brms.fit(\"count ~ zAge + (1|patient)\", data=epilepsy, family=\"poisson\", chains=4)\nmodel2 = brms.fit(\"count ~ zAge + zBase + (1|patient)\", data=epilepsy, family=\"poisson\", chains=4)\n\ncomp = az.compare({'model1': model1.idata, 'model2': model2.idata})\nprint(comp)\n</code></pre></p>"},{"location":"api/brms/#brmspy.brms.summary","title":"<code>summary(model, **kwargs)</code>","text":"<p>Generate summary statistics for fitted model.</p> <p>Calls R's summary() function on brmsfit object and converts to pandas DataFrame.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>**kwargs</code> <p>Additional arguments to summary(), e.g., probs=c(0.025, 0.975)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Summary statistics with columns for Estimate, Est.Error, and credible intervals</p> See Also <p>brms::summary.brmsfit : R documentation     https://paulbuerkner.com/brms/reference/summary.brmsfit.html</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.fit(\"y ~ x\", data=data, chains=4)\nsummary_df = brms.summary(model)\nprint(summary_df)\n</code></pre>"},{"location":"api/install/","title":"Install","text":""},{"location":"api/install/#brmspy.install-functions","title":"Functions","text":""},{"location":"api/install/#brmspy.install.install_prebuilt","title":"<code>install_prebuilt(runtime_version='0.1.0', url=None, bundle=None, install_rtools=False)</code>","text":"<p>Install prebuilt brmspy runtime bundle for fast setup.</p> <p>Downloads and activates a precompiled runtime containing: - R packages (brms, cmdstanr, dependencies) - Compiled CmdStan binary - Complete environment ready for immediate use</p> <p>This reduces setup time from ~30 minutes to ~1 minute by avoiding compilation. Available for specific platform/R version combinations.</p> <p>This function reconfigures the running embedded R session to use an isolated  library environment from downloaded binaries. It does not mix or break the  default library tree already installed in the system.</p> <p>Parameters:</p> Name Type Description Default <code>runtime_version</code> <code>str</code> <p>Runtime schema version (not pip version)</p> <code>\"0.1.0\"</code> <code>url</code> <code>str</code> <p>Custom URL for runtime bundle. If None, uses GitHub releases</p> <code>None</code> <code>bundle</code> <code>str</code> <p>Local path to runtime bundle (.tar.gz or directory)</p> <code>None</code> <code>install_rtools</code> <code>bool</code> <p>Installs RTools (windows only) if they cant be found.  WARNING: Modifies system path and runs the full rtools installer.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if installation succeeded, False otherwise</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If prebuilt binaries not available for this platform</p> Notes <p>Platform Support: Prebuilt binaries are available for: - Linux: x86_64, glibc &gt;= 2.27, g++ &gt;= 9 - macOS: x86_64 and arm64, clang &gt;= 11 - Windows: x86_64 with Rtools</p> <p>R Version: Runtime includes all R packages, so they must match your R installation's major.minor version (e.g., R 4.3.x).</p> <p>System Fingerprint: Runtime is selected based on: - Operating system (linux/macos/windows) - CPU architecture (x86_64/arm64) - R version (major.minor)</p> <p>Example: <code>linux-x86_64-r4.3</code></p> See Also <p>install_brms : Main installation function brmspy.binaries.install_and_activate_runtime : Low-level installer brmspy.binaries.system_fingerprint : Platform detection</p> <p>Examples:</p> <p>Install from GitHub releases:</p> <pre><code>from brmspy.install import install_prebuilt\ninstall_prebuilt()\n</code></pre> <p>Install from local bundle:</p> <pre><code>install_prebuilt(bundle=\"/path/to/runtime.tar.gz\")\n</code></pre> <p>Install from custom URL:</p> <pre><code>    install_prebuilt(url=\"https://example.com/runtime.tar.gz\")\n</code></pre>"},{"location":"api/install/#brmspy.install.install_brms","title":"<code>install_brms(brms_version='latest', repo=None, install_cmdstanr=True, install_rstan=False, cmdstanr_version='latest', rstan_version='latest', use_prebuilt_binaries=False, install_rtools=False)</code>","text":"<p>Install brms R package, optionally cmdstanr and CmdStan compiler, or rstan.</p> <p>Parameters:</p> Name Type Description Default <code>brms_version</code> <code>str</code> <p>brms version: \"latest\", \"2.23.0\", or \"&gt;= 2.20.0\"</p> <code>\"latest\"</code> <code>repo</code> <code>str | None</code> <p>Extra CRAN repository URL</p> <code>None</code> <code>install_cmdstanr</code> <code>bool</code> <p>Whether to install cmdstanr and build CmdStan compiler</p> <code>True</code> <code>install_rstan</code> <code>bool</code> <p>Whether to install rstan (alternative to cmdstanr)</p> <code>False</code> <code>cmdstanr_version</code> <code>str</code> <p>cmdstanr version: \"latest\", \"0.8.1\", or \"&gt;= 0.8.0\"</p> <code>\"latest\"</code> <code>rstan_version</code> <code>str</code> <p>rstan version: \"latest\", \"2.32.6\", or \"&gt;= 2.32.0\"</p> <code>\"latest\"</code> <code>use_prebuilt_binaries</code> <code>bool</code> <p>Uses fully prebuilt binaries for cmdstanr and brms and their dependencies.  Ignores system R libraries and uses the latest brms and cmdstanr available  for your system. Requires R&gt;=4 and might not be compatible with some older systems or missing toolchains. Can reduce setup time by 50x.</p> <code>False</code> <code>install_rtools</code> <code>bool</code> <p>Installs RTools (windows only) if they cant be found.  WARNING: Modifies system path and runs the full rtools installer.  Use with caution!</p> <code>False</code> <p>Examples:</p> <p>Basic installation:</p> <p><pre><code>from brmspy import brms\nbrms.install_brms()\n</code></pre> Install specific version:</p> <pre><code>brms.install_brms(brms_version=\"2.23.0\")\n</code></pre> <p>Use rstan instead of cmdstanr:</p> <pre><code>brms.install_brms(install_cmdstanr=False, install_rstan=True)\n</code></pre> <p>Fast installation with prebuilt binaries: <pre><code>brms.install_brms(use_prebuilt_binaries=True)\n</code></pre></p>"},{"location":"api/types/","title":"Types","text":"<p>Result types for brmspy functions.</p>"},{"location":"api/types/#brmspy.types-classes","title":"Classes","text":""},{"location":"api/types/#brmspy.types.PriorSpec","title":"<code>PriorSpec</code>  <code>dataclass</code>","text":"<p>Python representation of a brms prior specification.</p> <p>This dataclass provides a typed interface to brms::prior_string() arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the <code>prior()</code> factory function to create instances.</p> <p>Attributes:</p> Name Type Description <code>prior</code> <code>str</code> <p>Prior distribution as string (e.g., \"normal(0, 1)\", \"exponential(2)\")</p> <code>class_</code> <code>(str, optional)</code> <p>Parameter class: \"b\" (fixed effects), \"sd\" (group SD), \"Intercept\", \"sigma\", \"cor\", etc.</p> <code>coef</code> <code>(str, optional)</code> <p>Specific coefficient name for class-level priors</p> <code>group</code> <code>(str, optional)</code> <p>Grouping variable for hierarchical effects</p> <code>dpar</code> <code>(str, optional)</code> <p>Distributional parameter (e.g., \"sigma\", \"phi\", \"zi\")</p> <code>resp</code> <code>(str, optional)</code> <p>Response variable for multivariate models</p> <code>nlpar</code> <code>(str, optional)</code> <p>Non-linear parameter name</p> <code>lb</code> <code>(float, optional)</code> <p>Lower bound for truncated priors</p> <code>ub</code> <code>(float, optional)</code> <p>Upper bound for truncated priors</p> See Also <p>prior : Factory function to create PriorSpec instances brms::prior_string : R documentation     https://paulbuerkner.com/brms/reference/prior_string.html</p> <p>Examples:</p> <p>Create prior specifications (prefer using <code>prior()</code> function):</p> <pre><code>from brmspy.types import PriorSpec\n\n# Fixed effect prior\np1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n# Group-level SD prior\np2 = PriorSpec(\n    prior=\"exponential(2)\",\n    class_=\"sd\",\n    group=\"patient\"\n)\n\n# Coefficient-specific prior with bounds\np3 = PriorSpec(\n    prior=\"normal(0, 1)\",\n    class_=\"b\",\n    coef=\"age\",\n    lb=0  # Truncated at zero\n)\n</code></pre>"},{"location":"api/types/#brmspy.types.PriorSpec-functions","title":"Functions","text":""},{"location":"api/types/#brmspy.types.PriorSpec.to_brms_kwargs","title":"<code>to_brms_kwargs()</code>","text":"<p>Convert PriorSpec to keyword arguments for brms::prior_string().</p> <p>Maps Python dataclass fields to R function arguments, handling the <code>class_</code> -&gt; <code>class</code> parameter name conversion.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keyword arguments ready for brms::prior_string()</p> <p>Examples:</p> <pre><code>from brmspy import prior\np = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\nkwargs = p.to_brms_kwargs()\nprint(kwargs)\n# {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n</code></pre>"},{"location":"api/types/#brmspy.types.IDFit","title":"<code>IDFit</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for fitted brms models.</p> <p>Extends arviz.InferenceData with type hints for IDE autocomplete. Guarantees the presence of specific data groups returned by <code>fit()</code>.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Posterior samples of model parameters</p> <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (with observation noise)</p> <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation</p> <code>observed_data</code> <code>Dataset</code> <p>Original observed response data</p> <code>coords</code> <code>dict</code> <p>Coordinate mappings for dimensions</p> <code>dims</code> <code>dict</code> <p>Dimension specifications for variables</p> See Also <p>brmspy.brms.fit : Creates IDFit objects arviz.InferenceData : Base class documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\nmodel = brms.fit(\"y ~ x\", data=df, chains=4)\n\n# Type checking and autocomplete\nassert isinstance(model.idata, IDFit)\nprint(model.idata.posterior)  # IDE autocomplete works!\n</code></pre>"},{"location":"api/types/#brmspy.types.IDEpred","title":"<code>IDEpred</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_epred results.</p> <p>Contains expected values E[Y|X] without observation noise.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Expected value samples (no observation noise)</p> See Also <p>brmspy.brms.posterior_epred : Creates IDEpred objects</p>"},{"location":"api/types/#brmspy.types.IDPredict","title":"<code>IDPredict</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_predict results.</p> <p>Contains posterior predictive samples with observation noise.</p> <p>Attributes:</p> Name Type Description <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (includes observation noise)</p> See Also <p>brmspy.brms.posterior_predict : Creates IDPredict objects</p>"},{"location":"api/types/#brmspy.types.IDLinpred","title":"<code>IDLinpred</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_linpred results.</p> <p>Contains linear predictor values (before applying link function).</p> <p>Attributes:</p> Name Type Description <code>predictions</code> <code>Dataset</code> <p>Linear predictor samples</p> See Also <p>brmspy.brms.posterior_linpred : Creates IDLinpred objects</p>"},{"location":"api/types/#brmspy.types.IDLogLik","title":"<code>IDLogLik</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for log_lik results.</p> <p>Contains log-likelihood values for model comparison.</p> <p>Attributes:</p> Name Type Description <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation</p> See Also <p>brmspy.brms.log_lik : Creates IDLogLik objects arviz.loo : LOO-CV using log-likelihood</p>"},{"location":"api/types/#brmspy.types.GenericResult","title":"<code>GenericResult</code>  <code>dataclass</code>","text":"<p>Generic result container with arviz and R objects.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData object</p> <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/types/#brmspy.types.FitResult","title":"<code>FitResult</code>  <code>dataclass</code>","text":"<p>Result from fit() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with posterior, posterior_predictive, log_likelihood, and observed_data groups</p> <code>r</code> <code>ListVector</code> <p>brmsfit R object from brms::brm()</p>"},{"location":"api/types/#brmspy.types.PosteriorEpredResult","title":"<code>PosteriorEpredResult</code>  <code>dataclass</code>","text":"<p>Result from posterior_epred() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with expected values in 'posterior' group</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_epred()</p>"},{"location":"api/types/#brmspy.types.PosteriorPredictResult","title":"<code>PosteriorPredictResult</code>  <code>dataclass</code>","text":"<p>Result from posterior_predict() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with predictions in 'posterior_predictive' group</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_predict()</p>"},{"location":"api/types/#brmspy.types.LogLikResult","title":"<code>LogLikResult</code>  <code>dataclass</code>","text":"<p>Result from log_lik() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>IDLogLik</code> <p>arviz InferenceData with log-likelihood values</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::log_lik()</p> See Also <p>brmspy.brms.log_lik : Creates LogLikResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nmodel = brms.fit(\"y ~ x\", data=df, chains=4)\nloglik = brms.log_lik(model)\n\n# Use for model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre>"},{"location":"api/types/#brmspy.types.PosteriorLinpredResult","title":"<code>PosteriorLinpredResult</code>  <code>dataclass</code>","text":"<p>Result from posterior_linpred() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>IDLinpred</code> <p>arviz InferenceData with linear predictor values</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_linpred()</p> See Also <p>brmspy.brms.posterior_linpred : Creates PosteriorLinpredResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.fit(\"count ~ age\", data=df, family=\"poisson\", chains=4)\nlinpred = brms.posterior_linpred(model)\n\n# Linear predictor on log scale (for Poisson)\nprint(linpred.idata.predictions)\n</code></pre>"},{"location":"api/types/#brmspy.types.FormulaResult","title":"<code>FormulaResult</code>  <code>dataclass</code>","text":"<p>Result from formula() function.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R brmsformula object</p> <code>dict</code> <code>Dict</code> <p>Python dictionary representation of formula</p> See Also <p>brmspy.brms.formula : Creates FormulaResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\n# Create formula with options\nf = brms.formula(\"y ~ x\", decomp=\"QR\")\n\n# Use in fit()\nmodel = brms.fit(f, data=df, chains=4)\n</code></pre>"},{"location":"api/types/#brmspy.types-functions","title":"Functions","text":""},{"location":"api/types/#brmspy.types.prior","title":"<code>prior(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None, **kwargs)</code>","text":"<p>Create a brms-style prior specification.</p> <p>This function mirrors the behavior of <code>brms::prior_string()</code> and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of <code>prior_string()</code> in brms.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>str</code> <p>The prior definition as a string, exactly as brms expects it. Examples include ::</p> <pre><code>\"normal(0, 1)\"\n\"student_t(3, 0, 1.5)\"\n\"exponential(2)\"\n\"lkj(2)\"\n</code></pre> required <code>class_</code> <code>str</code> <p>Parameter class (e.g. <code>\"b\"</code>, <code>\"sd\"</code>, <code>\"Intercept\"</code>). This corresponds to <code>class</code> in brms. <code>class</code> cannot be used as a parameter in Python (reserved keyword), so <code>class_</code> is used instead.</p> <code>None</code> <code>coef</code> <code>str</code> <p>Coefficient name for class-level effects.</p> <code>None</code> <code>group</code> <code>str</code> <p>Grouping variable for hierarchical/multilevel effects.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Distributional parameter (e.g. <code>\"sigma\"</code> or <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response variable name for multivariate models.</p> <code>None</code> <code>nlpar</code> <code>str</code> <p>Nonlinear parameter name if using nonlinear formulas.</p> <code>None</code> <code>lb</code> <code>float</code> <p>Lower bound for truncated priors.</p> <code>None</code> <code>ub</code> <code>float</code> <p>Upper bound for truncated priors.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Any additional keyword arguments supported by <code>brms::prior_string()</code>. These are forwarded unchanged.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriorSpec</code> <p>A typed prior specification object used by <code>brmspy.fit()</code> and <code>brmspy.make_stancode()</code>.</p> Notes <p>This function does not validate the prior expression string itself \u2014 validation occurs inside brms. Its purpose is to construct a structured, editor-friendly representation that seamlessly maps to rpy2 calls.</p> <p>Examples:</p> <p>Prior on the intercept ::</p> <pre><code>p = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\")\n</code></pre> <p>Prior on a coefficient ::</p> <pre><code>p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n</code></pre> <p>Group-level (hierarchical) SD prior ::</p> <pre><code>p = prior(\"exponential(2)\", class_=\"sd\", group=\"region\")\n</code></pre> <p>Truncated prior ::</p> <pre><code>p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0)\n</code></pre> <p>Multiple priors passed to <code>fit</code> ::</p> <pre><code>from brmspy import prior\npriors = [\n    prior(\"student_t(3, 0, 2)\", class_=\"b\", coef=\"zAge\"),\n    prior(\"exponential(2)\", class_=\"sd\", group=\"patient\"),\n]\nmodel = brms.fit(\"y ~ zAge + (1|patient)\", data=df, priors=priors)\n</code></pre>"},{"location":"binaries/build/","title":"Build","text":""},{"location":"binaries/build/#brmspy.binaries.build-functions","title":"Functions","text":""},{"location":"binaries/build/#brmspy.binaries.build.collect_runtime_metadata","title":"<code>collect_runtime_metadata()</code>","text":"<p>Collect comprehensive R environment metadata for runtime bundle.</p> <p>Queries R via rpy2 to gather complete information about the current R installation, including R version, CmdStan installation, and full dependency closure of brms + cmdstanr with all package details.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Metadata dictionary containing: - r_version : str - R version (e.g., \"4.3.1\") - cmdstan_path : str - Path to CmdStan installation - cmdstan_version : str - CmdStan version - packages : list of dict - Package information with fields:     - Package : str - Package name     - Version : str - Package version     - LibPath : str - Installation library path     - Priority : str - Package priority level</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If required R packages (jsonlite) cannot be installed If build-manifest.R script cannot be read</p> Notes <p>This function executes the build-manifest.R script which uses R's package dependency resolution to find the complete dependency closure. It ensures all transitive dependencies are included.</p> <p>Examples:</p> <pre><code>metadata = collect_runtime_metadata()\nprint(f\"R version: {metadata['r_version']}\")\nprint(f\"CmdStan: {metadata['cmdstan_version']}\")\nprint(f\"Packages: {len(metadata['packages'])}\")\n\n# Check if brms is included\npkg_names = [p[\"Package\"] for p in metadata[\"packages\"]]\nassert \"brms\" in pkg_names\n</code></pre>"},{"location":"binaries/build/#brmspy.binaries.build.stage_runtime_tree","title":"<code>stage_runtime_tree(base_dir, metadata, runtime_version)</code>","text":"<p>Create runtime directory structure and copy all required files.</p> <p>Builds the complete runtime directory tree by: 1. Creating fingerprint-specific directory structure 2. Copying all R packages to Rlib/ 3. Copying CmdStan installation to cmdstan/ 4. Generating manifest.json with checksums</p> <p>The resulting structure: base_dir/   {fingerprint}/     manifest.json     Rlib/       {package1}/       {package2}/       ...     cmdstan/       {cmdstan files}</p> <p>Parameters:</p> Name Type Description Default <code>base_dir</code> <code>Path</code> <p>Base directory for runtime tree</p> required <code>metadata</code> <code>dict</code> <p>Metadata from collect_runtime_metadata() containing: - packages : list - R package information - cmdstan_path : str - CmdStan location - r_version : str - cmdstan_version : str</p> required <code>runtime_version</code> <code>str</code> <p>Runtime schema version (e.g., \"0.1.0\")</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to the runtime root directory (base_dir/fingerprint)</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If system_fingerprint() returns None If no package metadata provided If package directories don't exist If cmdstan_path doesn't exist</p> Notes <p>The fingerprint is determined by system_fingerprint() which includes: - OS (linux/macos/windows) - Architecture (x86_64/arm64) - R version (major.minor)</p> <p>The manifest.json includes a SHA256 hash for integrity verification.</p> <p>Examples:</p> <pre><code>from pathlib import Path\n\nmetadata = collect_runtime_metadata()\nbase = Path(\"./runtime_build\")\n\nruntime_root = stage_runtime_tree(\n    base,\n    metadata,\n    runtime_version=\"0.1.0\"\n)\n\nprint(f\"Runtime staged at: {runtime_root}\")\nprint(f\"Manifest: {runtime_root / 'manifest.json'}\")\nprint(f\"R packages: {runtime_root / 'Rlib'}\")\nprint(f\"CmdStan: {runtime_root / 'cmdstan'}\")\n</code></pre>"},{"location":"binaries/build/#brmspy.binaries.build.pack_runtime","title":"<code>pack_runtime(runtime_root, out_dir, runtime_version)</code>","text":"<p>Create compressed tar archive from runtime directory.</p> <p>Packages the staged runtime directory into a distributable .tar.gz archive with standardized naming for platform/version identification.</p> <p>Archive naming format: brmspy-runtime-{runtime_version}-{fingerprint}.tar.gz</p> <p>For example: brmspy-runtime-0.1.0-linux-x86_64-r4.3.tar.gz</p> <p>Parameters:</p> Name Type Description Default <code>runtime_root</code> <code>Path</code> <p>Path to staged runtime directory (from stage_runtime_tree)</p> required <code>out_dir</code> <code>Path</code> <p>Output directory for archive file</p> required <code>runtime_version</code> <code>str</code> <p>Runtime schema version (e.g., \"0.1.0\")</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to created .tar.gz archive file</p> Notes <p>The archive contains a top-level \"runtime/\" directory with all runtime files. This structure is expected by install_and_activate_runtime().</p> <p>The fingerprint is extracted from runtime_root.name, which should match the fingerprint used in stage_runtime_tree().</p> <p>Examples:</p> <pre><code>from pathlib import Path\n\nruntime_root = Path(\"./runtime_build/linux-x86_64-r4.3\")\nout_dir = Path(\"./dist\")\n\narchive = pack_runtime(\n    runtime_root,\n    out_dir,\n    runtime_version=\"0.1.0\"\n)\n\nprint(f\"Archive created: {archive}\")\nprint(f\"Size: {archive.stat().st_size / 1024 / 1024:.1f} MB\")\n</code></pre>"},{"location":"binaries/build/#brmspy.binaries.build.main","title":"<code>main()</code>","text":"<p>CLI entry point for building brmspy prebuilt runtime bundles.</p> <p>Command-line tool that orchestrates the complete runtime build process: 1. Collect R environment metadata 2. Stage runtime directory tree 3. Pack into distributable archive</p> Command-line Arguments <p>--output-dir : str, default=\"runtime_build\"     Directory where runtime tree and archive will be written --runtime-version : str, default=\"0.1.0\"     Runtime schema version identifier (not pip version)</p> <p>Examples:</p> <p>Build with defaults:</p> <pre><code>python -m brmspy.binaries.build\n</code></pre> <p>Specify custom output directory and version:</p> <pre><code>python -m brmspy.binaries.build         --output-dir /tmp/runtime         --runtime-version 0.2.0\n</code></pre> Notes <p>Requires: - R with brms and cmdstanr installed - CmdStan compiled and configured - Write permissions to output directory</p> <p>The build process can take 5-10 minutes depending on the number of dependencies and disk speed.</p> See Also <p>collect_runtime_metadata : Gathers R environment info stage_runtime_tree : Creates runtime directory structure pack_runtime : Creates distributable archive</p>"},{"location":"binaries/env/","title":"Env","text":""},{"location":"binaries/env/#brmspy.binaries.env-functions","title":"Functions","text":""},{"location":"binaries/env/#brmspy.binaries.env.get_r_version_tuple","title":"<code>get_r_version_tuple()</code>","text":"<p>Get R version as tuple of integers.</p> <p>Queries the active R installation via rpy2 to retrieve version information. Returns None if R is not available or rpy2 cannot communicate with R.</p> <p>Returns:</p> Type Description <code>tuple of (int, int, int) or None</code> <p>(major, minor, patch) version numbers, or None if unavailable</p> <p>Examples:</p> <pre><code>version = get_r_version_tuple()\nif version:\n    major, minor, patch = version\n    print(f\"R {major}.{minor}.{patch}\")\nelse:\n    print(\"R not available\")\n</code></pre> See Also <p>r_available_and_supported : Check if R meets minimum requirements</p>"},{"location":"binaries/env/#brmspy.binaries.env.r_available_and_supported","title":"<code>r_available_and_supported(min_major=4, min_minor=0)</code>","text":"<p>Check if R is available and meets minimum version requirements.</p> <p>Parameters:</p> Name Type Description Default <code>min_major</code> <code>int</code> <p>Minimum required R major version</p> <code>4</code> <code>min_minor</code> <code>int</code> <p>Minimum required R minor version</p> <code>2</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if R is available and &gt;= min_major.min_minor</p> <p>Examples:</p> <pre><code>if r_available_and_supported():\n    print(\"R 4.2+ is available\")\n\n# Check for R 4.3+\nif r_available_and_supported(min_major=4, min_minor=3):\n    print(\"R 4.3+ is available\")\n</code></pre> See Also <p>get_r_version_tuple : Get detailed R version</p>"},{"location":"binaries/env/#brmspy.binaries.env.extract_glibc_version","title":"<code>extract_glibc_version(ldd_output)</code>","text":"<p>Parse glibc version from ldd command output.</p> <p>Extracts glibc version number from the output of <code>ldd --version</code>. Used on Linux to verify minimum glibc requirement for prebuilt binaries.</p> <p>Parameters:</p> Name Type Description Default <code>ldd_output</code> <code>str</code> <p>Output from <code>ldd --version</code> command</p> required <p>Returns:</p> Type Description <code>tuple of (int, int) or None</code> <p>(major, minor) version, or None if not found</p> <p>Examples:</p> <pre><code>import subprocess\n\nout = subprocess.check_output([\"ldd\", \"--version\"], text=True)\nversion = extract_glibc_version(out)\nif version and version &gt;= (2, 27):\n    print(\"glibc 2.27+ available\")\n</code></pre> See Also <p>linux_can_use_prebuilt : Uses this for Linux compatibility check</p>"},{"location":"binaries/env/#brmspy.binaries.env.parse_clang_version","title":"<code>parse_clang_version(version_output)</code>","text":"<p>Parse clang compiler version from command output.</p> <p>Extracts clang version number from the output of <code>clang --version</code>. Used on macOS to verify minimum compiler requirement.</p> <p>Parameters:</p> Name Type Description Default <code>version_output</code> <code>str</code> <p>Output from <code>clang --version</code> command</p> required <p>Returns:</p> Type Description <code>tuple of (int, int) or None</code> <p>(major, minor) version, or None if parsing fails</p> <p>Examples:</p> <pre><code>import subprocess\n\nout = subprocess.check_output([\"clang\", \"--version\"], text=True)\nversion = parse_clang_version(out)\nif version and version &gt;= (11, 0):\n    print(\"clang 11+ available\")\n</code></pre> See Also <p>macos_can_use_prebuilt : macOS compatibility check</p>"},{"location":"binaries/env/#brmspy.binaries.env.linux_can_use_prebuilt","title":"<code>linux_can_use_prebuilt()</code>","text":"<p>Check if Linux system meets prebuilt binary requirements.</p> <p>Verifies that the Linux system has compatible toolchain versions required to use prebuilt brms runtime bundles. Checks glibc and g++ compiler versions.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if system meets all requirements: - glibc &gt;= 2.27 (for binary compatibility) - g++ &gt;= 9.0 (for C++17 Stan compilation)</p> Notes <p>Requirements for prebuilt Linux bundles: - glibc 2.27+: Ensures binary compatibility with precompiled Stan models - g++ 9+: Minimum compiler for C++17 features used by CmdStan</p> <p>Examples:</p> <pre><code>from brmspy.binaries.env import linux_can_use_prebuilt\n\nif linux_can_use_prebuilt():\n    print(\"System can use prebuilt Linux binaries\")\nelse:\n    print(\"Must build from source\")\n</code></pre> See Also <p>extract_glibc_version : Parse glibc version from ldd _parse_gxx_version : Parse g++ version toolchain_is_compatible : Master toolchain check for all platforms</p>"},{"location":"binaries/env/#brmspy.binaries.env.macos_can_use_prebuilt","title":"<code>macos_can_use_prebuilt()</code>","text":"<p>Check if macOS system meets prebuilt binary requirements.</p> <p>Verifies that the macOS system has Xcode Command Line Tools and a compatible clang compiler version for using prebuilt brms bundles.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if system meets all requirements: - Xcode Command Line Tools installed - clang &gt;= 11.0 (for C++17 Stan compilation)</p> Notes <p>Requirements for prebuilt macOS bundles: - Xcode CLT: Provides essential build tools and system headers - clang 11+: Minimum compiler for C++17 features used by CmdStan</p> <p>To install Xcode Command Line Tools: <pre><code>xcode-select --install\n</code></pre></p> <p>Examples:</p> <pre><code>    from brmspy.binaries.env import macos_can_use_prebuilt\n\n    if macos_can_use_prebuilt():\n        print(\"System can use prebuilt macOS binaries\")\n    else:\n        print(\"Install Xcode CLT or upgrade clang\")\n</code></pre> See Also <p>parse_clang_version : Parse clang version from command output toolchain_is_compatible : Master toolchain check for all platforms</p>"},{"location":"binaries/env/#brmspy.binaries.env.windows_can_use_prebuilt","title":"<code>windows_can_use_prebuilt()</code>","text":"<p>Check if Windows system meets prebuilt binary requirements.</p> <p>Verifies that the Windows system has Rtools with MinGW g++ compiler required for using prebuilt brms runtime bundles.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if system meets all requirements: - Rtools toolchain installed (MinGW g++ available) - g++ &gt;= 9.0 (for C++17 Stan compilation)</p> Notes <p>Requirements for prebuilt Windows bundles: - Rtools 4.0+: Provides MinGW-w64 toolchain for Stan compilation - g++ 9+: Minimum compiler for C++17 features used by CmdStan</p> <p>Rtools can be downloaded from: https://cran.r-project.org/bin/windows/Rtools/</p> <p>Examples:</p> <pre><code>from brmspy.binaries.env import windows_can_use_prebuilt\n\nif windows_can_use_prebuilt():\n    print(\"System can use prebuilt Windows binaries\")\nelse:\n    print(\"Install Rtools 4.0+\")\n</code></pre> See Also <p>parse_gxx_version : Parse g++ version from command output toolchain_is_compatible : Master toolchain check for all platforms</p>"},{"location":"binaries/env/#brmspy.binaries.env.supported_platform","title":"<code>supported_platform()</code>","text":"<p>Check if current platform is officially supported for prebuilt binaries.</p> <p>Validates that the operating system and architecture combination is one of the officially supported platforms for prebuilt brms bundles.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if platform is in the supported list</p> Notes <p>Currently supported platforms: - linux-x86_64: Linux on x86_64/AMD64 processors - macos-x86_64: macOS on Intel processors - macos-arm64: macOS on Apple Silicon (M1/M2/M3) - windows-x86_64: Windows on x86_64/AMD64 processors</p> <p>Unsupported combinations (e.g., linux-arm64, windows-arm64) will return False even if technically compatible.</p> <p>Examples:</p> <pre><code>from brmspy.binaries.env import supported_platform\n\nif supported_platform():\n    print(\"Platform is supported for prebuilts\")\n    # Further checks: toolchain, R version, etc.\nelse:\n    print(\"Platform not supported, must build from source\")\n</code></pre> See Also <p>_normalized_os_arch : Get normalized platform identifiers can_use_prebuilt : Complete prebuilt eligibility check</p>"},{"location":"binaries/env/#brmspy.binaries.env.toolchain_is_compatible","title":"<code>toolchain_is_compatible()</code>","text":"<p>Check if system toolchain is compatible with prebuilt binaries.</p> <p>Routes to the appropriate platform-specific toolchain verification function based on the detected operating system.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if system has compatible compiler toolchain for current OS</p> Notes <p>Platform-specific requirements: - Linux: glibc &gt;= 2.27, g++ &gt;= 9 - macOS: Xcode CLT installed, clang &gt;= 11 - Windows: Rtools installed (MinGW g++ &gt;= 9)</p> <p>This is a high-level check that delegates to OS-specific functions: - <code>linux_can_use_prebuilt()</code> for Linux - <code>macos_can_use_prebuilt()</code> for macOS - <code>windows_can_use_prebuilt()</code> for Windows</p> <p>Examples:</p> <pre><code>from brmspy.binaries.env import toolchain_is_compatible\n\nif toolchain_is_compatible():\n    print(\"Toolchain is compatible\")\nelse:\n    print(\"Upgrade compiler or install build tools\")\n</code></pre> See Also <p>linux_can_use_prebuilt : Linux toolchain check macos_can_use_prebuilt : macOS toolchain check windows_can_use_prebuilt : Windows toolchain check</p>"},{"location":"binaries/env/#brmspy.binaries.env.system_fingerprint","title":"<code>system_fingerprint()</code>","text":"<p>Generate system fingerprint for prebuilt bundle selection.</p> <p>Creates a unique identifier string combining OS, architecture, and R version to match against available prebuilt runtime bundles.</p> <p>Returns:</p> Type Description <code>str or None</code> <p>Fingerprint string in format '{os}-{arch}-r{major}.{minor}', or None if R version cannot be determined</p> Notes <p>The fingerprint format is: <code>{os}-{arch}-r{major}.{minor}</code></p> <p>Example fingerprints: - 'linux-x86_64-r4.3' - 'macos-arm64-r4.4' - 'windows-x86_64-r4.2'</p> <p>This fingerprint is used to: 1. Select the correct prebuilt bundle for download 2. Verify bundle compatibility with current system 3. Cache bundles in system-specific directories</p> <p>Examples:</p> <pre><code>from brmspy.binaries.env import system_fingerprint\n\nfp = system_fingerprint()\nif fp:\n    print(f\"System fingerprint: {fp}\")\n    # Use fingerprint to select bundle\nelse:\n    print(\"Cannot determine R version\")\n</code></pre> See Also <p>_normalized_os_arch : Get OS and architecture get_r_version_tuple : Get R version prebuilt_available_for : Check bundle availability</p>"},{"location":"binaries/env/#brmspy.binaries.env.prebuilt_available_for","title":"<code>prebuilt_available_for(fingerprint)</code>","text":"<p>Check if prebuilt bundle exists for given system fingerprint.</p> <p>Verifies whether a prebuilt runtime bundle is available for the specified system fingerprint. Currently checks against a static set, but designed to support dynamic manifest/GitHub Releases lookup.</p> <p>Parameters:</p> Name Type Description Default <code>fingerprint</code> <code>str or None</code> <p>System fingerprint string (e.g., 'linux-x86_64-r4.3') from <code>system_fingerprint()</code></p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if prebuilt bundle exists for this fingerprint</p> Notes <p>The <code>PREBUILT_FINGERPRINTS</code> set contains all available bundle identifiers. This can be populated from: - Static manifest file in package - Remote JSON manifest from CDN/GitHub - GitHub Releases API</p> <p>Future enhancement: Dynamic manifest fetching to auto-discover new bundles without package updates.</p> <p>Examples:</p> <pre><code>    from brmspy.binaries.env import (\n        system_fingerprint, prebuilt_available_for\n    )\n\n    fp = system_fingerprint()\n    if fp and prebuilt_available_for(fp):\n        print(f\"Prebuilt available for {fp}\")\n    else:\n        print(\"No prebuilt available, must build from source\")\n</code></pre> See Also <p>system_fingerprint : Generate fingerprint for current system can_use_prebuilt : Complete eligibility check</p>"},{"location":"binaries/env/#brmspy.binaries.env.can_use_prebuilt","title":"<code>can_use_prebuilt()</code>","text":"<p>Master check for prebuilt binary eligibility.</p> <p>Comprehensive validation that system meets ALL requirements for using prebuilt brms runtime bundles. Acts as the primary gate for deciding whether to use prebuilts or build from source.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True only if ALL conditions are met: - Platform is supported (OS-architecture combination) - R &gt;= 4.2 is available and usable via rpy2 - System toolchain meets minimum requirements - Prebuilt bundle exists for this fingerprint (commented out)</p> Notes <p>This function performs checks in order of increasing cost: 1. <code>supported_platform()</code>: Quick OS/arch validation 2. <code>r_available_and_supported()</code>: Check R via rpy2 3. <code>toolchain_is_compatible()</code>: Verify compiler versions 4. <code>prebuilt_available_for()</code>: Check bundle availability (currently disabled)</p> <p>The prebuilt availability check is commented out to allow installation even when bundle registry is not yet populated.</p> <p>Examples:</p> <pre><code>from brmspy.binaries.env import can_use_prebuilt\n\nif can_use_prebuilt():\n    print(\"Using prebuilt binaries for fast installation\")\n    # Proceed with prebuilt installation\nelse:\n    print(\"Building from source\")\n    # Proceed with source build\n</code></pre> <pre><code># Diagnostic check with detailed feedback\nfrom brmspy.binaries.env import (\n    supported_platform, r_available_and_supported,\n    toolchain_is_compatible, system_fingerprint,\n    prebuilt_available_for\n)\n\nprint(f\"Platform supported: {supported_platform()}\")\nprint(f\"R available: {r_available_and_supported()}\")\nprint(f\"Toolchain compatible: {toolchain_is_compatible()}\")\nfp = system_fingerprint()\nprint(f\"System fingerprint: {fp}\")\nprint(f\"Bundle available: {prebuilt_available_for(fp)}\")\nprint(f\"Can use prebuilt: {can_use_prebuilt()}\")\n</code></pre> See Also <p>supported_platform : Check platform support r_available_and_supported : Check R availability toolchain_is_compatible : Check compiler compatibility system_fingerprint : Get system identifier prebuilt_available_for : Check bundle availability</p>"},{"location":"binaries/use/","title":"Use","text":""},{"location":"binaries/use/#brmspy.binaries.use-functions","title":"Functions","text":""},{"location":"binaries/use/#brmspy.binaries.use.activate_runtime","title":"<code>activate_runtime(runtime_root)</code>","text":"<p>Activate a prebuilt brms runtime bundle in the current R session.</p> <p>Configures the embedded R session (via rpy2) to use libraries and CmdStan from a prebuilt runtime bundle. Updates R's library paths and sets cmdstanr's CmdStan path, then performs sanity checks.</p> <p>Parameters:</p> Name Type Description Default <code>runtime_root</code> <code>str or Path</code> <p>Path to runtime bundle root directory containing: - manifest.json: Bundle metadata and fingerprint - Rlib/: R package library with brms, cmdstanr, etc. - cmdstan/: CmdStan installation</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If required directories/files are missing or validation fails</p> Notes <p>Important Limitations:</p> <p>This function reconfigures the running embedded R session to use an isolated  library environment from downloaded binaries. It does not mix or break the  default library tree already installed in the system.</p> <p>What this function does:</p> <ol> <li>Validates runtime bundle structure (manifest, Rlib, cmdstan directories)</li> <li>Optionally verifies system fingerprint matches bundle fingerprint</li> <li>Unloads brms, cmdstanr and rstan (if they are loaded)</li> <li>Replaces R's .libPaths() with runtime Rlib directory</li> <li>Sets cmdstanr::set_cmdstan_path() to runtime cmdstan directory</li> <li>Performs sanity checks (brms and cmdstanr load successfully)</li> </ol> <p>Fingerprint Validation:</p> <p>If available, validates that the runtime bundle's fingerprint (from manifest.json) matches the current system fingerprint. This prevents incompatible bundles (e.g., Linux bundle on macOS) from being activated.</p> <p>Examples:</p> <pre><code>from pathlib import Path\nfrom brmspy.binaries.use import activate_runtime\n\n# Activate a previously installed runtime\nruntime_path = Path.home() / \".brmspy\" / \"runtime\" / \"linux-x86_64-r4.3\"\nactivate_runtime(runtime_path)\n\n# Now brms and cmdstanr use the prebuilt bundle\nfrom brmspy import fit\n\nresult = fit(\"y ~ x\", data={\"y\": [1, 2, 3], \"x\": [1, 2, 3]})\n</code></pre> See Also <p>install_and_activate_runtime : Download, install, and activate runtime brmspy.binaries.env.system_fingerprint : Get current system identifier</p>"},{"location":"binaries/use/#brmspy.binaries.use.install_and_activate_runtime","title":"<code>install_and_activate_runtime(url=None, bundle=None, runtime_version='0.1.0', base_dir=None, activate=True, expected_hash=None, require_attestation=True)</code>","text":"<p>Download, install, and optionally activate a prebuilt brms runtime bundle.</p> <p>This is the high-level orchestration function. It:</p> <ol> <li>Resolves the source (URL \u2192 temp file, or local archive/dir)</li> <li>Determines the canonical runtime_root for this system+version</li> <li>Optionally reuses an existing runtime if the stored hash matches</li> <li>Installs from archive or directory into runtime_root</li> <li>Stores the expected hash (if provided) for fast future reuse</li> <li>Optionally activates the runtime in the current R session</li> </ol> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to download runtime bundle archive (.tar.gz, .tar.bz2, etc.). Mutually exclusive with <code>bundle</code>.</p> <code>None</code> <code>bundle</code> <code>str or Path</code> <p>Local path to runtime bundle, either: - Archive file (.tar.gz, .tar.bz2, etc.) to extract, or - Directory containing an extracted runtime (with manifest.json). Mutually exclusive with <code>url</code>.</p> <code>None</code> <code>runtime_version</code> <code>str</code> <p>Logical runtime version used in the canonical runtime path {base_dir}/{system_fingerprint}-{runtime_version}.</p> <code>\"0.1.0\"</code> <code>base_dir</code> <code>str or Path</code> <p>Base directory for runtime installation. Default: ~/.brmspy/runtime/</p> <code>None</code> <code>activate</code> <code>bool</code> <p>If True, call <code>activate_runtime()</code> after installation/reuse.</p> <code>True</code> <code>expected_hash</code> <code>str</code> <p>Attested hash (e.g. sha256 from GitHub release assets). If provided, the installer will: - Reuse an existing runtime only if its stored hash matches this value. - Store the hash into {runtime_root}/hash after (re)install. If NOT provided, but the binary is an official kaitumisuuringute-keskus/brmspy  one, the expected_hash will be automatically fetched</p> <code>None</code> <code>require_attestation</code> <code>bool</code> <p>If True, <code>expected_hash</code> must be provided; otherwise a ValueError is raised. This lets callers enforce that only attested runtimes are used.</p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the installed (or reused) runtime root directory.</p>"},{"location":"development/development/","title":"Development Guide","text":"<p>This guide covers the development infrastructure, build processes, and CI/CD architecture for brmspy.</p>"},{"location":"development/development/#quick-start","title":"Quick Start","text":""},{"location":"development/development/#setup","title":"Setup","text":"<pre><code># Clone and setup\ngit clone https://github.com/kaitumisuuringute-keskus/brmspy.git\ncd brmspy\n\n# Install with dev dependencies\npython -m venv .venv\nsource .venv/bin/activate  # or .venv\\Scripts\\activate on Windows\npip install -e \".[all]\"\n\n# Install R dependencies\npython -c \"import brmspy; brmspy.install_brms()\"\n</code></pre>"},{"location":"development/development/#project-architecture","title":"Project Architecture","text":""},{"location":"development/development/#directory-structure","title":"Directory Structure","text":"<pre><code>brmspy/\n\u251c\u2500\u2500 brmspy/                    # Main package\n\u2502   \u251c\u2500\u2500 brms.py               # Core API (fit, predict, etc.)\n\u2502   \u251c\u2500\u2500 types.py              # Type definitions\n\u2502   \u251c\u2500\u2500 install.py            # R dependency installation\n\u2502   \u251c\u2500\u2500 binaries/             # Prebuilt runtime system\n\u2502   \u2502   \u251c\u2500\u2500 build.py          # Create runtime bundles\n\u2502   \u2502   \u251c\u2500\u2500 env.py            # Platform detection\n\u2502   \u2502   \u2514\u2500\u2500 use.py            # Install runtimes\n\u2502   \u2514\u2500\u2500 helpers/              # Internal utilities\n\u2502       \u251c\u2500\u2500 conversion.py     # Python \u2194 R \u2194 ArviZ\n\u2502       \u251c\u2500\u2500 priors.py         # Prior builders\n\u2502       \u251c\u2500\u2500 rtools.py         # Windows Rtools\n\u2502       \u2514\u2500\u2500 singleton.py      # R package caching\n\u251c\u2500\u2500 .github/workflows/        # CI/CD pipelines\n\u251c\u2500\u2500 .runtime_builder/         # Docker for Linux builds\n\u251c\u2500\u2500 docs/                     # mkdocs documentation\n\u2514\u2500\u2500 tests/                    # Test suite\n</code></pre>"},{"location":"development/development/#core-components","title":"Core Components","text":"<p>brmspy/brms.py - High-level API for model fitting and predictions brmspy/types.py - Type definitions and result dataclasses brmspy/install.py - R dependency management brmspy/binaries/ - Prebuilt runtime bundle system brmspy/helpers/ - Internal conversion and utility functions</p>"},{"location":"development/development/#data-flow","title":"Data Flow","text":"<pre><code>Python Code\n    \u2193\nbrmspy.fit() [brms.py]\n    \u2193\nType Conversions [helpers/conversion.py]\n    \u2193\nR brms via rpy2\n    \u2193\nCmdStan MCMC Sampling\n    \u2193\nArviZ InferenceData\n    \u2193\nPython Result Objects\n</code></pre>"},{"location":"development/development/#runtime-binaries-system","title":"Runtime Binaries System","text":"<p>The runtime system provides prebuilt bundles to skip lengthy R package compilation.</p>"},{"location":"development/development/#system-fingerprint","title":"System Fingerprint","text":"<p>Each runtime is identified by: <code>{os}-{arch}-r{major}.{minor}</code></p> <p>Examples: - <code>linux-x86_64-r4.5</code> - <code>darwin-arm64-r4.5</code> (macOS Apple Silicon) - <code>windows-x86_64-r4.5</code></p>"},{"location":"development/development/#components","title":"Components","text":"<p>Platform Detection (<code>brmspy/binaries/env.py</code>): - Detect OS, architecture, R version - Generate system fingerprint - Check runtime compatibility</p> <p>Runtime Building (<code>brmspy/binaries/build.py</code>): - Bundle CmdStan binaries - Package R packages (cmdstanr, brms, posterior) - Include system libraries (Linux) - Create manifest with metadata</p> <p>Runtime Installation (<code>brmspy/binaries/use.py</code>): - Download from GitHub releases - Extract and activate runtime - Configure environment</p>"},{"location":"development/development/#bundle-structure","title":"Bundle Structure","text":"<pre><code>brmspy-runtime-{fingerprint}-{version}.tar.gz\n\u251c\u2500\u2500 manifest.json              # Metadata\n\u251c\u2500\u2500 cmdstan/                   # Compiled CmdStan\n\u251c\u2500\u2500 Rlib                       # R libraries\n</code></pre>"},{"location":"development/development/#usage","title":"Usage","text":"<pre><code>import brmspy\n\n# Install prebuilt runtime (2-3 minutes vs 20-30 from source)\nbrmspy.install_prebuilt(version=\"0.1.0\")\n\n# Build custom runtime locally\nfrom brmspy.binaries.build import build_runtime_bundle\nbuild_runtime_bundle(output_dir=\"dist/runtime\")\n</code></pre>"},{"location":"development/development/#cicd-pipelines","title":"CI/CD Pipelines","text":"<p>All workflows in <code>.github/workflows/</code>:</p>"},{"location":"development/development/#1-python-test-matrix-python-test-matrixyml","title":"1. Python Test Matrix (<code>python-test-matrix.yml</code>)","text":"<p>Trigger: Push/PR to master Purpose: Test Python 3.10, 3.12, 3.14 on Linux</p> <p>Workflow: 1. Build CmdStan once (cached) 2. Test matrix in parallel 3. Update coverage badge (3.12 only)</p> <p>Key Features: - Shared R/CmdStan cache - Parallel execution - Coverage reporting</p>"},{"location":"development/development/#2-r-dependencies-tests-r-dependencies-testsyml","title":"2. R Dependencies Tests (<code>r-dependencies-tests.yml</code>)","text":"<p>Trigger: Push/PR to master Purpose: Test on Linux, macOS, Windows</p> <p>Workflow: - Python 3.12 only - Tests marked with <code>@pytest.mark.crossplatform</code> - Fail-fast disabled</p>"},{"location":"development/development/#3-documentation-docsyml","title":"3. Documentation (<code>docs.yml</code>)","text":"<p>Trigger: Push to master Purpose: Deploy docs to GitHub Pages</p> <p>Stack: - mkdocstrings for API docs - Auto-deploys to https://kaitumisuuringute-keskus.github.io/brmspy/</p>"},{"location":"development/development/#4-pypi-publish-python-publishyml","title":"4. PyPI Publish (<code>python-publish.yml</code>)","text":"<p>Trigger: GitHub Release created Purpose: Publish to PyPI</p> <p>Workflow: 1. Run full test suite 2. Build: <code>python -m build</code> 3. Upload: <code>twine upload dist/*</code></p> <p>Requirements: <code>PYPI_USERNAME</code>, <code>PYPI_PASSWORD</code> secrets</p>"},{"location":"development/development/#5-runtime-publish-runtime-publishyml","title":"5. Runtime Publish (<code>runtime-publish.yml</code>)","text":"<p>Trigger: Manual dispatch Purpose: Build prebuilt runtimes for all platforms</p> <p>Architecture: 1. Create GitHub Release (tag: <code>runtime</code>) 2. Build runtimes in parallel (Linux in Docker, macOS/Windows native) 3. Upload to release with attestation</p> <p>Linux Build (Docker): <pre><code>- Pull: ghcr.io/.../brmspy-runtime-builder:ubuntu18-gcc9\n- Install R 4.5.0\n- Build runtime: python -m brmspy.binaries.build\n- Upload tarball\n</code></pre></p> <p>macOS/Windows Build (Native): <pre><code>- Setup Python 3.12 + R 4.5\n- Install dependencies\n- Build runtime\n- Upload tarball\n</code></pre></p>"},{"location":"development/development/#6-linux-runtime-builder-build-linux-runtime-imageyml","title":"6. Linux Runtime Builder (<code>build-linux-runtime-image.yml</code>)","text":"<p>Trigger: Manual dispatch Purpose: Build Docker image for Linux runtime compilation</p> <p>Image: Ubuntu 18.04 + GCC 9 + Python 3.12 (for old glibc compatibility)</p>"},{"location":"development/development/#runtime-builder-runtime_builderlinux","title":"Runtime Builder (<code>.runtime_builder/linux/</code>)","text":""},{"location":"development/development/#dockerfile","title":"Dockerfile","text":"<p>Creates build environment: - Base: Ubuntu 18.04 (glibc 2.27) - Toolchain: GCC 9, g++ 9, gfortran 9 - Python: 3.12.7 (compiled from source) - Dependencies: BLAS, LAPACK, V8, GLPK, graphics libs</p>"},{"location":"development/development/#install_rsh","title":"install_r.sh","text":"<p>Smart R installation: 1. Try APT (fast) 2. Fallback to source compilation if version unavailable</p>"},{"location":"development/development/#publishsh","title":"publish.sh","text":"<p>Builds and pushes Docker image to GHCR: <pre><code>docker build -t ghcr.io/{owner}/brmspy-runtime-builder:{tag}\ndocker push ghcr.io/{owner}/brmspy-runtime-builder:{tag}\n</code></pre></p>"},{"location":"development/development/#testing","title":"Testing","text":""},{"location":"development/development/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py              # Pytest fixtures\n\u251c\u2500\u2500 test_basic.py           # Basic tests\n\u251c\u2500\u2500 test_integration.py     # End-to-end tests\n\u251c\u2500\u2500 test_predictions.py     # Prediction tests\n\u2514\u2500\u2500 test_crossplatform.py   # Cross-platform tests\n</code></pre>"},{"location":"development/development/#running-tests","title":"Running Tests","text":"<pre><code>pytest tests/ -v                    # All tests\npytest tests/ -v --cov=brmspy      # With coverage\npytest -m crossplatform            # Cross-platform only\npytest -n auto                     # Parallel (requires pytest-xdist)\n</code></pre>"},{"location":"development/development/#test-markers","title":"Test Markers","text":"<pre><code>@pytest.mark.crossplatform\ndef test_basic_fit():\n    \"\"\"Runs on all platforms in CI\"\"\"\n    pass\n</code></pre>"},{"location":"development/development/#build-and-release","title":"Build and Release","text":""},{"location":"development/development/#version-management","title":"Version Management","text":"<p>Update in: - <code>pyproject.toml</code> - <code>settings.ini</code> - <code>brmspy/__init__.py</code></p>"},{"location":"development/development/#release-process","title":"Release Process","text":"<ol> <li>Update versions and CHANGELOG.md</li> <li>Test: <code>pytest</code></li> <li>Build: <code>make build</code></li> <li>Create GitHub Release (tag: <code>release-0...</code>)</li> <li>CI automatically tests and publishes to PyPI</li> </ol>"},{"location":"development/development/#building-runtimes","title":"Building Runtimes","text":"<p>Via GitHub Actions: 1. Go to Actions \u2192 runtime-publish 2. Run workflow with version and tag 3. Runtimes published to: <code>releases/tag/runtime</code></p> <p>Locally: <pre><code>python -m brmspy.binaries.build --output-dir dist/runtime\n</code></pre></p>"},{"location":"development/development/#documentation","title":"Documentation","text":""},{"location":"development/development/#mkdocs-configuration","title":"mkdocs Configuration","text":"<p>File: <code>mkdocs.yml</code></p> <pre><code>site_name: brmspy\ntheme:\n  name: shadcn\nplugins:\n  ...\n</code></pre>"},{"location":"development/development/#docstring-style","title":"Docstring Style","text":"<p>All docstrings use NumPy style with <code>```python</code> code blocks (no <code>.. code-block::</code>):</p> <pre><code>def example(param: str) -&gt; dict:\n    \"\"\"\n    One-line summary.\n\n    Detailed description.\n\n    Parameters\n    ----------\n    param : str\n        Parameter description\n\n    Returns\n    -------\n    dict\n        Return description\n\n    Examples\n    --------\n    Basic usage:\n\n    ```python\n    result = example(\"hello\")\n    print(result)\n    ```\n    \"\"\"\n    return {\"param\": param}\n</code></pre>"},{"location":"development/development/#performance","title":"Performance","text":""},{"location":"development/development/#r-package-caching","title":"R Package Caching","text":"<p>Singleton pattern in <code>brmspy/helpers/singleton.py</code>:</p> <pre><code>from brmspy.helpers.singleton import get_r_package\n\nbrms = get_r_package(\"brms\")  # First call: imports\nbrms = get_r_package(\"brms\")  # Cached, instant\n</code></pre>"},{"location":"development/development/#prebuilt-runtimes","title":"Prebuilt Runtimes","text":"Method Installation Time From source 20-30 minutes Prebuilt runtime 20-60 seconds"},{"location":"development/development/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/development/#r-package-installation-fails","title":"R Package Installation Fails","text":"<pre><code># Check R version (need 4.0+)\nR --version\n\n# Manual install\nR -e \"install.packages(c('cmdstanr', 'brms', 'posterior'))\"\n</code></pre>"},{"location":"development/development/#cmdstan-compilation-fails","title":"CmdStan Compilation Fails","text":"<p>Linux: <pre><code>sudo apt-get install build-essential\n</code></pre></p> <p>macOS: <pre><code>xcode-select --install\n</code></pre></p> <p>Windows: <pre><code>import brmspy.helpers.rtools as rtools\nrtools.install_rtools()\n</code></pre></p>"},{"location":"development/development/#runtime-incompatibility","title":"Runtime Incompatibility","text":"<pre><code># Build local runtime\nfrom brmspy.binaries.build import build_runtime_bundle\nbuild_runtime_bundle(output_dir=\"custom\")\n\n# Or install matching prebuilt\nbrmspy.install_prebuilt()  # Auto-detects platform\n</code></pre>"},{"location":"development/development/#contributing","title":"Contributing","text":""},{"location":"development/development/#code-style","title":"Code Style","text":"<ul> <li>Docstrings: NumPy style</li> <li>Type hints: Required for public APIs</li> </ul>"},{"location":"development/development/#pr-process","title":"PR Process","text":"<ol> <li>Fork and create feature branch</li> <li>Make changes and add tests</li> <li>Run: <code>make format &amp;&amp; make lint &amp;&amp; make test</code></li> <li>Commit with conventional commits format</li> <li>Open PR with clear description</li> </ol>"},{"location":"development/development/#resources","title":"Resources","text":"<ul> <li>Documentation: https://kaitumisuuringute-keskus.github.io/brmspy/</li> <li>Repository: https://github.com/kaitumisuuringute-keskus/brmspy</li> <li>Issues: https://github.com/kaitumisuuringute-keskus/brmspy/issues</li> <li>PyPI: https://pypi.org/project/brmspy/</li> </ul>"},{"location":"examples/advanced/","title":"Advanced Usage","text":""},{"location":"examples/advanced/#custom-sampling-parameters","title":"Custom Sampling Parameters","text":"<pre><code>from brmspy import brms\n\nmodel = brms.fit(\n    formula=\"y ~ x + (1|group)\",\n    data=data,\n    iter=2000,      # Total iterations per chain\n    warmup=1000,    # Warmup iterations\n    chains=4,       # Number of chains\n    cores=4,        # Parallel cores\n    thin=1,         # Thinning\n    seed=123,       # Random seed\n    control={'adapt_delta': 0.95}  # Stan control parameters\n)\n</code></pre>"},{"location":"examples/advanced/#multiple-prediction-types","title":"Multiple Prediction Types","text":"<pre><code># Expected value (without observation noise)\nepred = brms.posterior_epred(model, newdata=new_data)\n\n# Posterior predictive (with observation noise)\nypred = brms.posterior_predict(model, newdata=new_data)\n\n# Linear predictor\nlinpred = brms.posterior_linpred(model, newdata=new_data)\n\n# Log likelihood\nloglik = brms.log_lik(model, newdata=new_data)\n</code></pre>"},{"location":"examples/advanced/#dual-python-r-workflow","title":"Dual Python-R Workflow","text":"<pre><code>import arviz as az\nimport rpy2.robjects as ro\n\nmodel = brms.fit(formula=\"count ~ zAge + (1|patient)\", data=data, family=\"poisson\")\n\n# Python analysis\naz.summary(model.idata)\naz.plot_trace(model.idata)\n\n# R analysis (if needed)\nro.r('summary')(model.r)\nro.r('plot')(model.r)\nro.r('loo')(model.r)  # Leave-one-out cross-validation\n</code></pre>"},{"location":"examples/advanced/#different-families","title":"Different Families","text":""},{"location":"examples/advanced/#gaussian-default","title":"Gaussian (default)","text":"<pre><code>model = brms.fit(\n    formula=\"y ~ x\",\n    data=data,\n    family=\"gaussian\"\n)\n</code></pre>"},{"location":"examples/advanced/#poisson-count-data","title":"Poisson (count data)","text":"<pre><code>model = brms.fit(\n    formula=\"count ~ treatment + (1|subject)\",\n    data=data,\n    family=\"poisson\"\n)\n</code></pre>"},{"location":"examples/advanced/#binomial-binary-outcomes","title":"Binomial (binary outcomes)","text":"<pre><code>model = brms.fit(\n    formula=\"success | trials(n) ~ x\",\n    data=data,\n    family=\"binomial\"\n)\n</code></pre>"},{"location":"examples/advanced/#student-t-robust-to-outliers","title":"Student-t (robust to outliers)","text":"<pre><code>model = brms.fit(\n    formula=\"y ~ x\",\n    data=data,\n    family=\"student\"\n)\n</code></pre>"},{"location":"examples/advanced/#complex-random-effects","title":"Complex Random Effects","text":""},{"location":"examples/advanced/#nested-random-effects","title":"Nested Random Effects","text":"<pre><code>model = brms.fit(\n    formula=\"y ~ x + (1|country/region/city)\",\n    data=data\n)\n</code></pre>"},{"location":"examples/advanced/#random-slopes","title":"Random Slopes","text":"<pre><code>model = brms.fit(\n    formula=\"y ~ x + (x|subject)\",\n    data=data\n)\n</code></pre>"},{"location":"examples/advanced/#correlated-random-effects","title":"Correlated Random Effects","text":"<pre><code>model = brms.fit(\n    formula=\"y ~ x + (x + z|subject)\",\n    data=data\n)\n</code></pre>"},{"location":"examples/advanced/#working-with-results","title":"Working with Results","text":""},{"location":"examples/advanced/#extract-posterior-samples","title":"Extract Posterior Samples","text":"<pre><code># Get posterior as xarray Dataset\nposterior = model.idata.posterior\n\n# Extract specific parameter\nb_intercept = posterior['b_Intercept'].values\n\n# Extract all coefficients\ncoefficients = {\n    var: posterior[var].values \n    for var in posterior.data_vars \n    if var.startswith('b_')\n}\n</code></pre>"},{"location":"examples/advanced/#model-comparison","title":"Model Comparison","text":"<pre><code>import arviz as az\n\nmodel1 = brms.fit(formula=\"y ~ x\", data=data)\nmodel2 = brms.fit(formula=\"y ~ x + z\", data=data)\n\n# Compare models\ncomparison = az.compare({\n    'model1': model1.idata,\n    'model2': model2.idata\n})\nprint(comparison)\n</code></pre>"},{"location":"examples/advanced/#debugging","title":"Debugging","text":""},{"location":"examples/advanced/#check-stan-code","title":"Check Stan Code","text":"<pre><code>stan_code = brms.make_stancode(\n    formula=\"count ~ zAge + (1|patient)\",\n    data=data,\n    priors=[],\n    family=\"poisson\"\n)\nprint(stan_code)\n</code></pre>"},{"location":"examples/advanced/#compile-without-sampling","title":"Compile Without Sampling","text":"<p>```python</p>"},{"location":"examples/advanced/#just-compile-the-model","title":"Just compile the model","text":"<p>model = brms.fit(     formula=\"y ~ x\",     data=data,     sample=False  # Don't sample, just compile )</p>"},{"location":"examples/google-colab-example/","title":"Google colab example","text":"<p>This example runs in Google Colab environment. Dependency installation takes &lt;50s.</p> <p>The notebook can be run HERE</p> <pre><code>!pip install \"brmspy&gt;=0.1.10\"\n</code></pre> <pre><code>from brmspy import brms\n</code></pre> <pre><code>brms.install_brms(use_prebuilt_binaries=True)\n</code></pre> <pre><code>epilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    warmup=500,\n    iter=1000,\n    chains=4\n)\nidata = model.idata\n</code></pre> <pre><code>import arviz as az\nsummary = az.summary(\n    idata,\n    hdi_prob=0.95,\n    kind=\"stats\",\n    round_to=3\n)\n\nprint(\"Posterior Summary\")\nprint(\"=\"*60)\nprint(summary)\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nimport seaborn as sns\n\nfig = az.plot_posterior(\n    idata,\n    var_names=['b_Intercept', 'b_zAge', 'b_zBase', 'b_Trt1', 'b_zBase:Trt1'],\n    figsize=(12, 8),\n    textsize=10\n)\nplt.suptitle('Posterior Distributions - Fixed Effects', y=1.02, fontsize=14, fontweight='bold')\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"examples/quickstart/","title":"Quick Start Guide","text":""},{"location":"examples/quickstart/#installation","title":"Installation","text":"<pre><code>pip install brmspy\n</code></pre>"},{"location":"examples/quickstart/#first-time-setup","title":"First Time Setup","text":"<p>Install brms and CmdStan:</p> <pre><code>from brmspy import brms\nbrms.install_brms()\n</code></pre>"},{"location":"examples/quickstart/#basic-model","title":"Basic Model","text":"<pre><code>from brmspy import brms, prior\nimport arviz as az\n\n# Load example data\nepilepsy = brms.get_brms_data(\"epilepsy\")\n\n# Fit model\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    priors=[\n        prior(\"normal(0, 1)\", \"b\"),\n        prior(\"exponential(1)\", \"sd\", group=\"patient\"),\n        prior(\"student_t(3, 0, 2.5)\", \"Intercept\")\n    ],\n    chains=4,\n    iter=2000\n)\n\n# Analyze with arviz\naz.summary(model.idata)\naz.plot_posterior(model.idata)\n</code></pre>"},{"location":"examples/quickstart/#with-priors","title":"With Priors","text":"<pre><code>from brmspy import prior\n\nmodel = brms.fit(\n    formula=\"count ~ zAge + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    priors=[\n        prior(\"normal(0, 0.5)\", class_=\"b\"),\n        prior(\"cauchy(0, 1)\", class_=\"sd\")\n    ],\n    chains=4\n)\n</code></pre>"},{"location":"examples/quickstart/#model-summary","title":"Model Summary","text":"<pre><code>from brmspy import summary\n\n# Get summary as DataFrame\nsummary_df = summary(model)\nprint(summary_df)\n</code></pre>"},{"location":"examples/quickstart/#predictions","title":"Predictions","text":"<pre><code>import pandas as pd\n\n# New data for predictions\nnew_data = pd.DataFrame({\n    'zAge': [0, 0.5, 1.0],\n    'zBase': [0, 0, 0],\n    'Trt': [0, 0, 0],\n    'patient': [1, 1, 1]\n})\n\n# Expected value predictions\nepred = brms.posterior_epred(model, newdata=new_data)\n\n# Posterior predictive samples\nypred = brms.posterior_predict(model, newdata=new_data)\n</code></pre>"},{"location":"examples/quickstart/#access-r-object","title":"Access R Object","text":"<p>If you need direct R functionality:</p> <p>```python import rpy2.robjects as ro</p>"},{"location":"examples/quickstart/#access-r-brmsfit-object","title":"Access R brmsfit object","text":"<p>ro.r('summary')(model.r) ro.r('plot')(model.r)</p>"},{"location":"helpers/conversion/","title":"Conversion","text":""},{"location":"helpers/conversion/#brmspy.helpers.conversion-classes","title":"Classes","text":""},{"location":"helpers/conversion/#brmspy.helpers.conversion-functions","title":"Functions","text":""},{"location":"helpers/conversion/#brmspy.helpers.conversion.brmsfit_to_idata","title":"<code>brmsfit_to_idata(brmsfit_obj, model_data=None)</code>","text":"<p>Convert brmsfit R object to ArviZ InferenceData format.</p> <p>Comprehensive conversion that extracts all MCMC diagnostics, predictions, and observed data from a brms fitted model into ArviZ's InferenceData format. Handles proper chain/draw indexing and coordinates for ArviZ compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted Bayesian model from R's brms::brm() function</p> required <code>model_data</code> <code>dict or DataFrame</code> <p>Additional model data (currently unused, reserved for future use)</p> <code>None</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>Complete InferenceData object containing: - posterior: Model parameters (\u03b2, \u03c3, etc.) with shape (chains, draws, ...) - posterior_predictive: Predicted outcomes y with observation noise - log_likelihood: Log-likelihood values for LOO-CV and model comparison - observed_data: Original response variable from training data - coords: Observation IDs and other coordinates - dims: Dimension labels for each variable</p> Notes <p>InferenceData Groups:</p> <ol> <li>Posterior: Parameter samples from MCMC</li> <li>Includes all model parameters (intercepts, slopes, sigmas, etc.)</li> <li>Shape: (n_chains, n_draws) for scalars, (n_chains, n_draws, ...) for arrays</li> <li> <p>Extracted via posterior::as_draws_df()</p> </li> <li> <p>Posterior Predictive: Predictions including observation noise</p> </li> <li>Generated via brms::posterior_predict()</li> <li>Useful for posterior predictive checks</li> <li> <p>Shape: (n_chains, n_draws, n_obs)</p> </li> <li> <p>Log Likelihood: Pointwise log-likelihood values</p> </li> <li>Generated via brms::log_lik()</li> <li>Required for LOO-CV and WAIC model comparison</li> <li> <p>Shape: (n_chains, n_draws, n_obs)</p> </li> <li> <p>Observed Data: Original response variable</p> </li> <li>Extracted from fit$data</li> <li>Uses first column (brms convention for response variable)</li> <li>Shape: (n_obs,)</li> </ol> <p>Reshaping Strategy:</p> <p>brms/rstan return flat arrays with shape (total_draws, ...) where total_draws = n_chains \u00d7 n_draws. This function reshapes to ArviZ's expected format (n_chains, n_draws, ...) by: 1. Tracking chain IDs from .chain column 2. Computing per-chain draw indices 3. Pivoting and reshaping to 3D arrays</p> <p>Examples:</p> <pre><code>from brmspy import fit\nfrom brmspy.helpers.conversion import brmsfit_to_idata\nimport arviz as az\n\n# Fit a model (returns InferenceData directly)\nresult = fit(\"y ~ x\", data=pd.DataFrame({\"y\": [1, 2, 3], \"x\": [1, 2, 3]}))\nidata = result.idata\n\n# Or manually convert brmsfit object\n# brmsfit_r = ...  # R brmsfit object\n# idata = brmsfit_to_idata(brmsfit_r)\n\n# Use ArviZ for diagnostics\naz.summary(idata, var_names=[\"b_Intercept\", \"b_x\"])\naz.plot_trace(idata)\naz.plot_posterior(idata, var_names=[\"sigma\"])\n</code></pre> <pre><code># Access different groups\nidata.posterior  # Parameter samples\nidata.posterior_predictive  # Predicted outcomes with noise\nidata.log_likelihood  # For model comparison\nidata.observed_data  # Original data\n\n# Model comparison with LOO-CV\naz.loo(idata)\naz.waic(idata)\n</code></pre> See Also <p>brmspy.brms.fit : High-level fitting function (returns InferenceData) brms_epred_to_idata : Convert expected value predictions brms_predict_to_idata : Convert posterior predictions arviz.InferenceData : ArviZ's data structure documentation</p>"},{"location":"helpers/conversion/#brmspy.helpers.conversion.generic_pred_to_idata","title":"<code>generic_pred_to_idata(r_pred_obj, brmsfit_obj, newdata=None, var_name='pred', az_name='posterior')</code>","text":"<p>Generic converter for brms prediction matrices to ArviZ InferenceData.</p> <p>Flexible conversion function that handles various brms prediction types (posterior_predict, posterior_epred, posterior_linpred, log_lik) and stores them in appropriate InferenceData groups with proper structure.</p> <p>Parameters:</p> Name Type Description Default <code>r_pred_obj</code> <code>rpy2 R matrix</code> <p>Prediction matrix from any brms prediction function Shape: (total_draws, n_observations)</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model for extracting chain information</p> required <code>newdata</code> <code>DataFrame</code> <p>New data used for predictions. If provided, DataFrame index is used for observation coordinates</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Name for the variable in the InferenceData dataset</p> <code>\"pred\"</code> <code>az_name</code> <code>str</code> <p>InferenceData group name. Common values: - \"posterior\": For expected values (epred) - \"posterior_predictive\": For predictions with noise (predict) - \"predictions\": For linear predictor (linpred) - \"log_likelihood\": For log-likelihood values</p> <code>\"posterior\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with single group containing reshaped predictions as xarray DataArray with proper coordinates and dimensions</p> Notes <p>InferenceData Group Selection:</p> <p>Different prediction types should use appropriate groups: - Expected values (epred): 'posterior' - deterministic E[Y|X] - Predictions (predict): 'posterior_predictive' - with observation noise - Linear predictor (linpred): 'predictions' - before link function - Log-likelihood: 'log_likelihood' - for model comparison</p> <p>Coordinates:</p> <p>If newdata is a DataFrame, uses its index as observation coordinates. This preserves meaningful labels (dates, IDs, etc.) in ArviZ plots.</p> <p>Examples:</p> <pre><code>import pandas as pd\nfrom brmspy.helpers.conversion import generic_pred_to_idata\n\n# Assume we have fitted model and prediction matrix\n# r_epred = brms::posterior_epred(brmsfit, newdata=test_df)\n\ntest_df = pd.DataFrame({'x': [1, 2, 3]}, index=['A', 'B', 'C'])\n\nidata = generic_pred_to_idata(\n    r_pred_obj=r_epred,\n    brmsfit_obj=brmsfit,\n    newdata=test_df,\n    var_name=\"expected_y\",\n    az_name=\"posterior\"\n)\n\n# Access predictions\nprint(idata.posterior['expected_y'].dims)  # ('chain', 'draw', 'obs_id')\nprint(idata.posterior['expected_y'].coords['obs_id'])  # ['A', 'B', 'C']\n</code></pre> See Also <p>brms_epred_to_idata : Convenience wrapper for posterior_epred brms_predict_to_idata : Convenience wrapper for posterior_predict brms_linpred_to_idata : Convenience wrapper for posterior_linpred brms_log_lik_to_idata : Convenience wrapper for log_lik _reshape_r_prediction_to_arviz : Internal reshaping function</p>"},{"location":"helpers/conversion/#brmspy.helpers.conversion.brms_epred_to_idata","title":"<code>brms_epred_to_idata(r_epred_obj, brmsfit_obj, newdata=None, var_name='epred')</code>","text":"<p>Convert brms::posterior_epred result to ArviZ InferenceData.</p> <p>Convenience wrapper for converting expected value predictions (posterior_epred) to InferenceData format. Stores in 'posterior' group as deterministic expected values E[Y|X] without observation noise.</p> <p>Parameters:</p> Name Type Description Default <code>r_epred_obj</code> <code>rpy2 R matrix</code> <p>Result from brms::posterior_epred()</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model</p> required <code>newdata</code> <code>DataFrame</code> <p>New data used for predictions</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Variable name in InferenceData</p> <code>\"epred\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with 'posterior' group containing expected values</p> Notes <p>posterior_epred computes the expected value of the posterior predictive distribution (i.e., the mean outcome for given predictors): - For linear regression: E[Y|X] = \u03bc = X\u00b7\u03b2 - For Poisson regression: E[Y|X] = exp(X\u00b7\u03b2) - For logistic regression: E[Y|X] = logit\u207b\u00b9(X\u00b7\u03b2)</p> <p>This is stored in the 'posterior' group (not 'posterior_predictive') because it represents deterministic expected values, not noisy predictions.</p> See Also <p>brmspy.brms.posterior_epred : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_predict_to_idata : For predictions with observation noise</p>"},{"location":"helpers/conversion/#brmspy.helpers.conversion.brms_predict_to_idata","title":"<code>brms_predict_to_idata(r_predict_obj, brmsfit_obj, newdata=None, var_name='y')</code>","text":"<p>Convert brms::posterior_predict result to ArviZ InferenceData.</p> <p>Convenience wrapper for converting posterior predictions (posterior_predict) to InferenceData format. Stores in 'posterior_predictive' group as predictions including observation-level noise.</p> <p>Parameters:</p> Name Type Description Default <code>r_predict_obj</code> <code>rpy2 R matrix</code> <p>Result from brms::posterior_predict()</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model</p> required <code>newdata</code> <code>DataFrame</code> <p>New data used for predictions</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Variable name in InferenceData</p> <code>\"y\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with 'posterior_predictive' group containing predictions</p> Notes <p>posterior_predict generates predictions from the posterior predictive distribution, including observation-level noise: - For linear regression: Y ~ Normal(\u03bc, \u03c3) - For Poisson regression: Y ~ Poisson(\u03bb) - For logistic regression: Y ~ Bernoulli(p)</p> <p>These predictions include all sources of uncertainty (parameter and observation) and are useful for: - Posterior predictive checks - Generating realistic synthetic data - Assessing model fit to observed data</p> See Also <p>brmspy.brms.posterior_predict : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_epred_to_idata : For expected values without noise</p>"},{"location":"helpers/conversion/#brmspy.helpers.conversion.brms_linpred_to_idata","title":"<code>brms_linpred_to_idata(r_linpred_obj, brmsfit_obj, newdata=None, var_name='linpred')</code>","text":"<p>Convert brms::posterior_linpred result to ArviZ InferenceData.</p> <p>Convenience wrapper for converting linear predictor values (posterior_linpred) to InferenceData format. Stores in 'predictions' group as linear predictor values before applying the link function.</p> <p>Parameters:</p> Name Type Description Default <code>r_linpred_obj</code> <code>rpy2 R matrix</code> <p>Result from brms::posterior_linpred()</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model</p> required <code>newdata</code> <code>DataFrame</code> <p>New data used for predictions</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Variable name in InferenceData</p> <code>\"linpred\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with 'predictions' group containing linear predictor</p> Notes <p>posterior_linpred returns the linear predictor \u03b7 = X\u00b7\u03b2 before applying the link function: - For linear regression: linpred = \u03bc (same as epred since link is identity) - For Poisson regression: linpred = log(\u03bb), epred = \u03bb - For logistic regression: linpred = logit(p), epred = p</p> <p>The linear predictor is useful for: - Understanding the scale of effects before transformation - Diagnosing model specification issues - Custom post-processing with different link functions</p> See Also <p>brmspy.brms.posterior_linpred : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_epred_to_idata : For expected values on response scale</p>"},{"location":"helpers/conversion/#brmspy.helpers.conversion.brms_log_lik_to_idata","title":"<code>brms_log_lik_to_idata(r_log_lik_obj, brmsfit_obj, newdata=None, var_name='log_lik')</code>","text":"<p>Convert brms::log_lik result to ArviZ InferenceData.</p> <p>Convenience wrapper for converting pointwise log-likelihood values (log_lik) to InferenceData format. Stores in 'log_likelihood' group for use in model comparison and diagnostics.</p> <p>Parameters:</p> Name Type Description Default <code>r_log_lik_obj</code> <code>rpy2 R matrix</code> <p>Result from brms::log_lik()</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model</p> required <code>newdata</code> <code>DataFrame</code> <p>New data for log-likelihood calculation</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Variable name in InferenceData</p> <code>\"log_lik\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with 'log_likelihood' group</p> Notes <p>log_lik computes pointwise log-likelihood values for each observation, which are essential for:</p> <ul> <li>LOO-CV: Leave-one-out cross-validation via <code>az.loo()</code></li> <li>WAIC: Widely applicable information criterion via <code>az.waic()</code></li> <li>Model Comparison: Compare multiple models with <code>az.compare()</code></li> <li>Outlier Detection: Identify poorly fit observations</li> </ul> <p>Each MCMC draw \u00d7 observation gets a log-likelihood value, representing how well that parameter draw explains that specific observation.</p> <p>Examples:</p> <pre><code>from brmspy import fit\nimport arviz as az\n\n# Fit model (log_lik included automatically)\nresult = fit(\"y ~ x\", data={\"y\": [1, 2, 3], \"x\": [1, 2, 3]})\n\n# Model comparison with LOO-CV\nloo_result = az.loo(result.idata)\nprint(loo_result)\n\n# Compare multiple models\nmodel1_idata = fit(\"y ~ x\", data=data1).idata\nmodel2_idata = fit(\"y ~ x + x2\", data=data2).idata\ncomparison = az.compare({\"model1\": model1_idata, \"model2\": model2_idata})\n</code></pre> See Also <p>brmspy.brms.log_lik : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function arviz.loo : Leave-one-out cross-validation arviz.waic : WAIC computation arviz.compare : Model comparison</p>"},{"location":"helpers/conversion/#brmspy.helpers.conversion.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p>"},{"location":"helpers/conversion/#brmspy.helpers.conversion.r_to_py","title":"<code>r_to_py(obj)</code>","text":"<p>Convert R objects to Python objects via rpy2.</p> <p>Comprehensive converter that handles R lists (named/unnamed), vectors, formulas, and language objects. Provides sensible Python equivalents for all R types with special handling for edge cases.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>rpy2 R object</code> <p>R object to convert to Python</p> required <p>Returns:</p> Type Description <code>any</code> <p>Python representation of the R object: - R NULL \u2192 None - Named list \u2192 dict (recursively) - Unnamed list \u2192 list (recursively) - Length-1 vector \u2192 scalar (int, float, str, bool) - Length-N vector \u2192 list of scalars - Formula/Language object \u2192 str (descriptive representation) - Other objects \u2192 default rpy2 conversion or str fallback</p> Notes <p>Conversion Rules:</p> <ol> <li>R NULL: \u2192 Python None</li> <li>Atomic vectors (numeric, character, logical):</li> <li>Length 1: \u2192 Python scalar (int, float, str, bool)</li> <li>Length &gt;1: \u2192 Python list of scalars</li> <li>Named lists (ListVector with names): \u2192 Python dict, recursively</li> <li>Unnamed lists: \u2192 Python list, recursively</li> <li>Formulas (e.g., <code>y ~ x</code>): \u2192 String representation</li> <li>Language objects (calls, expressions): \u2192 String representation</li> <li>Functions: \u2192 String representation</li> <li>Everything else: Try default rpy2 conversion, fallback to string</li> </ol> <p>Recursive Conversion:</p> <p>List elements and dictionary values are recursively converted: <pre><code>list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n</code></pre></p> <p>Safe Fallback:</p> <p>R language objects, formulas, and functions are converted to descriptive strings rather than attempting complex conversions that might fail.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import r_to_py\nimport rpy2.robjects as ro\n\n# R NULL\nr_to_py(ro.NULL)  # None\n\n# Scalars\nr_to_py(ro.IntVector([5]))    # 5\nr_to_py(ro.FloatVector([3.14]))  # 3.14\nr_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n# Vectors\nr_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n</code></pre> See Also <p>py_to_r : Convert Python objects to R brmspy.brms.summary : Returns Python-friendly summary dict</p>"},{"location":"helpers/conversion/#brmspy.helpers.conversion.kwargs_r","title":"<code>kwargs_r(kwargs)</code>","text":"<p>Convert Python keyword arguments to R-compatible format.</p> <p>Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict or None</code> <p>Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with same keys but R-compatible values, or empty dict if None</p> Notes <p>This is a thin wrapper around <code>py_to_r()</code> that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import kwargs_r\nimport pandas as pd\nimport numpy as np\n\n# Prepare kwargs for R function\npy_kwargs = {\n    'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n    'prior': {'b': [0, 1]},\n    'chains': 4,\n    'iter': 2000\n}\n\nr_kwargs = kwargs_r(py_kwargs)\n# All values converted to R objects\n# Can now call: r_function(**r_kwargs)\n</code></pre> See Also <p>py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R</p>"},{"location":"helpers/priors/","title":"Priors","text":""},{"location":"helpers/priors/#brmspy.helpers.priors-classes","title":"Classes","text":""},{"location":"helpers/rtools/","title":"RTools (Windows)","text":""},{"location":"helpers/rtools/#brmspy.helpers.rtools-functions","title":"Functions","text":""},{"location":"helpers/rtools/#brmspy.helpers.rtools.pick_rtools_for_r","title":"<code>pick_rtools_for_r(r_ver)</code>","text":"<p>Select appropriate Rtools version tag for given R version.</p> <p>Maps R version to compatible Rtools major version. Rtools is required on Windows to compile Stan models and R packages with C++ code.</p> <p>Parameters:</p> Name Type Description Default <code>r_ver</code> <code>Version</code> <p>R version to match</p> required <p>Returns:</p> Type Description <code>str or None</code> <p>Rtools version tag ('40', '42', '43', '44', '45') or None if R version is too old (&lt; 4.0.0) for automatic handling</p> Notes <p>R to Rtools Version Mapping:</p> <ul> <li>R 4.0.x - 4.1.x: Rtools 40</li> <li>R 4.2.x: Rtools 42</li> <li>R 4.3.x: Rtools 43</li> <li>R 4.4.x: Rtools 44</li> <li>R 4.5.x+: Rtools 45</li> <li>R &lt; 4.0.0: None (legacy, not supported)</li> </ul> <p>Rtools Purpose:</p> <p>Rtools provides MinGW-w64 compiler toolchain on Windows for: - Compiling Stan models (required by cmdstanr) - Building R packages from source - C++ compilation for brms/Stan</p> <p>Examples:</p> <pre><code>from packaging.version import Version\nfrom brmspy.helpers.rtools import pick_rtools_for_r\n\n# R 4.3.2 needs Rtools 43\ntag = pick_rtools_for_r(Version(\"4.3.2\"))\nprint(tag)  # \"43\"\n\n# R 4.4.1 needs Rtools 44\ntag = pick_rtools_for_r(Version(\"4.4.1\"))\nprint(tag)  # \"44\"\n\n# Legacy R not supported\ntag = pick_rtools_for_r(Version(\"3.6.3\"))\nprint(tag)  # None\n</code></pre> See Also <p>_install_rtools_for_current_r : Automatically install matching Rtools _get_r_version : Get current R version</p> References <p>.. [1] Rtools download page: https://cran.r-project.org/bin/windows/Rtools/</p>"},{"location":"helpers/singleton/","title":"Singleton","text":""}]}