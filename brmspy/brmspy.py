# AUTOGENERATED! DO NOT EDIT! File to edit: core.ipynb (unless otherwise specified).

__all__ = ['install_brms', 'get_brms_version', 'get_brms_data', 'get_stan_code', 'fit', 'BrmsFitResult']

# Cell
#hide
import typing
import pandas as pd
import numpy as np
import re
import warnings

import rpy2.robjects.packages as rpackages
from rpy2.robjects import default_converter, pandas2ri, numpy2ri, ListVector, DataFrame, StrVector
from rpy2.robjects.conversion import localconverter

# Global variable for lazy brms import
_brms = None

# Cell
def install_brms(version: str = "latest", repo: str = "https://cran.rstudio.com", install_cmdstan: bool = True):
    """
    Install the brms R package, cmdstanr, and CmdStan compiler.
    
    This function provides explicit control over brms and CmdStan installation,
    replacing the automatic installation behavior from previous versions.
    
    Parameters
    ----------
    version : str, default="latest"
        Version specification for brms:
        - "latest": Install the latest version from CRAN
        - Specific version: e.g., "2.23.0"
        - Version constraint: e.g., ">=2.20.0" (requires remotes package)
    
    repo : str, default="https://cran.rstudio.com"
        CRAN repository URL to use for installation
    
    install_cmdstan : bool, default=True
        Whether to also install cmdstanr and CmdStan compiler if not present
    
    Examples
    --------
    Install latest version (brms + cmdstanr + CmdStan):
    >>> import brmspy
    >>> brmspy.install_brms()
    
    Install specific brms version:
    >>> brmspy.install_brms(version="2.23.0")
    
    Install brms only (skip cmdstanr/CmdStan):
    >>> brmspy.install_brms(install_cmdstan=False)
    
    Notes
    -----
    This is a one-time setup operation. Once installed, brms, cmdstanr, and
    CmdStan will be available for all subsequent brmspy sessions.
    """
    print("=" * 60)
    print("brmspy Setup - Installing Required Components")
    print("=" * 60)
    
    # Install cmdstanr and CmdStan if requested
    if install_cmdstan:
        print("\n[1/3] Installing cmdstanr R package...")
        try:
            cmdstanr = rpackages.importr("cmdstanr")
            print("✓ cmdstanr already installed")
        except:
            print("Installing cmdstanr from r-universe...")
            utils = rpackages.importr("utils")
            utils.install_packages(
                StrVector(('cmdstanr',)),
                repos=StrVector(('https://stan-dev.r-universe.dev', repo))
            )
            print("✓ cmdstanr installed successfully!")
        
        print("\n[2/3] Checking CmdStan installation...")
        try:
            import rpy2.robjects as ro
            ro.r('library(cmdstanr); cmdstan_path()')
            print("✓ CmdStan already installed")
        except Exception:
            print("Installing CmdStan compiler via cmdstanr...")
            print("This may take several minutes depending on your system.")
            try:
                import rpy2.robjects as ro
                ro.r('library(cmdstanr); install_cmdstan()')
                print("✓ CmdStan installed successfully!")
            except Exception as e:
                warnings.warn(f"Could not install CmdStan: {e}")
                print("You can install it manually later in R with:")
                print("  library(cmdstanr)")
                print("  install_cmdstan()")
    
    # Install brms
    print(f"\n[3/3] Installing brms R package (version: {version})...")
    
    utils = rpackages.importr("utils")
    utils.chooseCRANmirror(ind=1)
    
    if version == "latest":
        # Install latest version from CRAN
        print("Installing latest brms from CRAN...")
        utils.install_packages(StrVector(('brms',)), repos=repo)
        print("✓ brms installed successfully!")
    else:
        # Install specific version using remotes package
        print(f"Installing brms version {version}...")
        try:
            remotes = rpackages.importr("remotes")
        except:
            print("Installing remotes package (required for version-specific installation)...")
            utils.install_packages(StrVector(('remotes',)))
            remotes = rpackages.importr("remotes")
        
        # Handle version constraints
        if ">=" in version or "<=" in version or "==" in version:
            # Version constraint - install latest matching version
            warnings.warn(
                f"Version constraint '{version}' specified. "
                "Installing latest version that matches. "
                "For reproducibility, specify exact version (e.g., '2.23.0')"
            )
            # Extract version number for comparison
            version_num = version.replace(">=", "").replace("<=", "").replace("==", "").strip()
            remotes.install_version("brms", version=version_num, repos=repo)
        else:
            # Exact version
            remotes.install_version("brms", version=version, repos=repo)
        
        print(f"✓ brms {version} installed successfully!")
    
    # Clear cached brms import to force reload
    global _brms
    _brms = None
    
    # Verify installation
    print("\n" + "=" * 60)
    print("Installation Summary")
    print("=" * 60)
    
    if install_cmdstan:
        try:
            import rpy2.robjects as ro
            cmdstan_path = str(ro.r('library(cmdstanr); cmdstan_path()')[0])
            print(f"✓ cmdstanr: installed")
            print(f"✓ CmdStan: {cmdstan_path}")
        except:
            print("⚠ cmdstanr/CmdStan: Not installed")
    
    try:
        brms_version = get_brms_version()
        print(f"✓ brms: version {brms_version}")
    except Exception as e:
        print(f"⚠ brms: Could not verify ({e})")
    
    print("\n✅ Setup complete! You're ready to use brmspy.")
    print("\nExample usage:")
    print("  import brmspy")
    print("  epilepsy = brmspy.get_brms_data('epilepsy')")
    print("  fit = brmspy.fit('count ~ zAge + (1|patient)', epilepsy, family='poisson', chains=4)")

# Cell
def get_brms_version() -> str:
    """
    Get the installed version of the brms R package.
    
    Returns
    -------
    str
        Version string of installed brms package
    
    Raises
    ------
    ImportError
        If brms is not installed
    
    Examples
    --------
    >>> import brmspy
    >>> version = brmspy.get_brms_version()
    >>> print(f"brms version: {version}")
    """
    brms = _get_brms()
    utils = rpackages.importr("utils")
    
    # Get package version
    version_info = utils.packageVersion("brms")
    # Convert to string and clean up R output format
    version_str = str(version_info[0]).strip()
    
    # R returns format like '[1]  2 22  0' - extract just the numbers
    # and format as proper version string
    import re
    numbers = re.findall(r'\d+', version_str)
    if len(numbers) >= 3:
        return '.'.join(numbers[:3])
    elif len(numbers) == 2:
        return '.'.join(numbers)
    else:
        # Fallback - return cleaned string
        return version_str.replace('[1]', '').strip()

# Cell
def _get_brms():
    """
    Lazy import of brms with helpful error message if not installed.
    
    Returns
    -------
    brms module
        The imported brms R package
    
    Raises
    ------
    ImportError
        If brms is not installed, with instructions for installation
    """
    global _brms
    if _brms is None:
        try:
            _brms = rpackages.importr("brms")
        except Exception as e:
            raise ImportError(
                "brms R package not found. Install it using:\n\n"
                "  import brmspy\n"
                "  brmspy.install_brms()  # for latest version\n\n"
                "Or install a specific version:\n"
                "  brmspy.install_brms(version='2.23.0')\n\n"
                "Or install manually in R:\n"
                "  install.packages('brms')\n"
            ) from e
    return _brms

# Cell
def get_brms_data(dataset_name: str) -> pd.DataFrame:
    """
    Import example datasets included in the brms package.
    
    Parameters
    ----------
    dataset_name : str
        Name of the dataset to import (e.g., 'epilepsy', 'kidney', 'inhaler')
    
    Returns
    -------
    pd.DataFrame
        The requested dataset as a pandas DataFrame
    
    Examples
    --------
    >>> import brmspy
    >>> epilepsy = brmspy.get_brms_data("epilepsy")
    >>> print(epilepsy.head())
    
    Available datasets include:
    - epilepsy: Epilepsy seizure counts
    - kidney: Kidney infection data  
    - inhaler: Asthma inhaler data
    - And many more - see brms documentation
    """
    brms = _get_brms()
    with localconverter(default_converter + pandas2ri.converter + numpy2ri.converter) as cv:
        return pd.DataFrame(rpackages.data(brms).fetch(dataset_name)[dataset_name])

# Cell
def _convert_python_to_R(data: typing.Union[dict, pd.DataFrame]):
    """
    Convert Python data structures to R objects that brms can handle.
    
    Parameters
    ----------
    data : dict or pd.DataFrame
        Python data to convert
    
    Returns
    -------
    R object
        R list (from dict) or R data.frame (from DataFrame)
    
    Raises
    ------
    ValueError
        If data type is not supported
    """
    with localconverter(default_converter + pandas2ri.converter + numpy2ri.converter) as cv:
        if isinstance(data, pd.DataFrame):
            return DataFrame(data)
        elif isinstance(data, dict):
            return ListVector(data)
        else:
            raise ValueError(
                f"Data should be either a pandas DataFrame or a dictionary, "
                f"got {type(data).__name__}"
            )

# Cell
def get_stan_code(
    formula: str,
    data: typing.Union[dict, pd.DataFrame],
    priors: list,
    family: str,
    sample_prior: str = "no"
) -> str:
    """
    Generate Stan code for the model using brms.
    
    This calls brms::make_stancode() to generate the Stan program.
    
    Parameters
    ----------
    formula : str
        brms formula specification
    data : dict or pd.DataFrame
        Model data
    priors : list
        List of prior specifications
    family : str
        Distribution family
    sample_prior : str, default="no"
        Whether to sample from prior
    
    Returns
    -------
    str
        Generated Stan code
    """
    brms = _get_brms()
    if len(priors) > 0:
        return brms.make_stancode(
            formula=formula, data=data, prior=priors, family=family, sample_prior=sample_prior
        )[0]
    else:
        return brms.make_stancode(
            formula=formula, data=data, family=family, sample_prior=sample_prior
        )[0]

# Cell
def _convert_R_to_python(
    formula: str, 
    data: typing.Union[dict, pd.DataFrame], 
    family: str
) -> dict:
    """
    Convert R data structures from brms to Python dictionaries.
    
    Calls brms::make_standata() and converts the result to Python.
    
    Parameters
    ----------
    formula : str
        brms formula specification
    data : dict or pd.DataFrame
        Model data
    family : str
        Distribution family
    
    Returns
    -------
    dict
        Stan data as Python dictionary
    """
    brms = _get_brms()
    # Call brms to preprocess the data; returns an R ListVector
    model_data = brms.make_standata(formula, data, family=family)
    
    # Convert R objects to Python/pandas/numpy
    # We use a context manager because it conflicts with prior creation
    with localconverter(default_converter + pandas2ri.converter + numpy2ri.converter) as cv:
        model_data = dict(model_data.items())
    return model_data

# Cell
def _coerce_types(stan_code: str, stan_data: dict) -> dict:
    """
    Coerce Python types to match Stan's type requirements.
    
    Stan has strict type requirements (int vs float). This function parses
    the Stan data block to determine required types and coerces the data
    accordingly.
    
    Parameters
    ----------
    stan_code : str
        Generated Stan code
    stan_data : dict
        Data dictionary to coerce
    
    Returns
    -------
    dict
        Type-coerced data dictionary
    """
    pat_data = re.compile(r'(?<=data {)[^}]*')
    pat_identifiers = re.compile(r'([\w]+)')

    # Extract the data block and separate lines
    data_lines = pat_data.findall(stan_code)[0].split('\n')
    
    # Remove comments, <>-style bounds and []-style data size declarations
    data_lines_no_comments = [l.split('//')[0] for l in data_lines]
    data_lines_no_bounds = [re.sub('<[^>]+>', '', l) for l in data_lines_no_comments]
    data_lines_no_sizes = [re.sub(r'\[[^>]+\]', '', l) for l in data_lines_no_bounds]

    # Extract identifiers and handle both old and new Stan syntax
    # Old: int Y; or int Y[N]; -> type is first identifier
    # New: array[N] int Y; -> type is second identifier (after 'array')
    identifiers = [pat_identifiers.findall(l) for l in data_lines_no_sizes]
    
    var_types = []
    var_names = []
    for tokens in identifiers:
        if len(tokens) == 0:
            continue
        # New syntax: array[...] type name
        if tokens[0] == 'array' and len(tokens) >= 3:
            var_types.append(tokens[1])  # Type is second token
            var_names.append(tokens[-1])  # Name is last token
        # Old syntax: type name
        elif len(tokens) >= 2:
            var_types.append(tokens[0])  # Type is first token
            var_names.append(tokens[-1])  # Name is last token
    
    var_dict = dict(zip(var_names, var_types))

    # Coerce integers to int and 1-size arrays to scalars
    for k, v in stan_data.items():
        # Convert to numpy array if not already
        if not isinstance(v, np.ndarray):
            v = np.asarray(v)
            stan_data[k] = v
        
        # First, convert 1-size arrays to scalars
        if hasattr(v, 'size') and v.size == 1 and hasattr(v, 'ndim') and v.ndim > 0:
            v = v.item()
            stan_data[k] = v
        
        # Then coerce to int if Stan expects int
        if k in var_names and var_dict[k] == "int":
            # Handle both scalars and arrays
            if isinstance(v, (int, float, np.number)):  # Scalar
                stan_data[k] = int(v)
            elif isinstance(v, np.ndarray):  # Array
                stan_data[k] = v.astype(np.int64)
    
    return stan_data

# Cell
class BrmsFitResult:
    """
    Wrapper class containing both arviz InferenceData and brmsfit R object.
    
    This allows users to access both Python-native arviz functionality
    and R-native brms methods.
    
    Attributes
    ----------
    idata : arviz.InferenceData
        Arviz InferenceData object for Python analysis
    brmsfit : R brmsfit object
        Original brmsfit R object for R methods
    
    Examples
    --------
    >>> result = brmspy.fit(..., return_type='both')
    >>> # Use with arviz
    >>> az.plot_posterior(result.idata)
    >>> # Use with R
    >>> import rpy2.robjects as ro
    >>> ro.globalenv['fit'] = result.brmsfit
    >>> ro.r('summary(fit)')
    """
    def __init__(self, idata, brmsfit):
        self.idata = idata
        self.brmsfit = brmsfit
    
    def __repr__(self):
        return f"BrmsFitResult(idata={type(self.idata).__name__}, brmsfit=brmsfit)"

# Cell
def _brmsfit_to_idata(brmsfit_obj):
    """
    Convert brmsfit R object to arviz InferenceData.
    
    This uses posterior R package to extract draws and then converts
    to arviz InferenceData format.
    
    Parameters
    ----------
    brmsfit_obj : R brmsfit object
        Fitted brms model from brm()
    
    Returns
    -------
    arviz.InferenceData
        Arviz InferenceData object with properly named parameters
    
    Raises
    ------
    ImportError
        If arviz or required R packages are not installed
    """
    try:
        import arviz as az
    except ImportError:
        raise ImportError(
            "arviz is required for InferenceData conversion. Install it with:\n"
            "  pip install arviz\n"
            "Or install the viz extra:\n"
            "  pip install brmspy[viz]"
        )
    
    import rpy2.robjects as ro
    from rpy2.robjects import pandas2ri
    from rpy2.robjects.conversion import localconverter
    
    # Assign to R environment
    ro.globalenv['__temp_brmsfit'] = brmsfit_obj
    
    try:
        # Check if posterior package is available
        try:
            posterior = rpackages.importr('posterior')
        except:
            raise ImportError(
                "posterior R package is required for conversion. Install it in R with:\n"
                "  install.packages('posterior')"
            )
        
        # Extract draws using posterior package
        # This works with both rstan and cmdstanr backends
        draws = posterior.as_draws_df(brmsfit_obj)
        
        # Convert draws to pandas DataFrame
        with localconverter(default_converter + pandas2ri.converter):
            df = pandas2ri.rpy2py(draws)
        
        # Convert to arviz InferenceData using from_dict
        # Split into posterior and other groups
        chain_col = '.chain' if '.chain' in df.columns else 'chain'
        draw_col = '.draw' if '.draw' in df.columns else 'draw'
        
        # IMPORTANT: posterior R package numbers draws sequentially across chains
        # (e.g., chain1: 1-500, chain2: 501-1000), but arviz expects draws
        # numbered within each chain (e.g., each chain: 0-499).
        # We must renumber draws to start from 0 within each chain.
        df['draw_idx'] = df.groupby(chain_col)[draw_col].transform(lambda x: np.arange(len(x)))
        
        # Get unique chains and draws per chain
        chains = sorted(df[chain_col].unique())
        n_draws = df['draw_idx'].max() + 1
        
        # Prepare posterior dict
        posterior_dict = {}
        for col in df.columns:
            if col not in [chain_col, draw_col, '.iteration', 'draw_idx']:
                # Reshape to (chain, draw) format using renumbered draws
                values = df.pivot(index='draw_idx', columns=chain_col, values=col).values.T
                posterior_dict[col] = values
        
        # Create InferenceData
        idata = az.from_dict(posterior=posterior_dict)
        
        return idata
    finally:
        # Clean up temporary R variable
        try:
            ro.r('rm(__temp_brmsfit)')
        except:
            pass

# Cell
def fit(
    formula: str,
    data: typing.Union[dict, pd.DataFrame],
    priors: list = [],
    family: str = "gaussian",
    sample_prior: str = "no",
    sample: bool = True,
    backend: str = "cmdstanr",
    return_type: str = "both",
    **brm_args,
) -> typing.Union[BrmsFitResult, 'arviz.InferenceData', 'brmsfit']:
    """
    Fit a Bayesian regression model using brms.
    
    This function uses brms' native fitting capabilities with the cmdstanr
    backend, ensuring proper parameter naming and full brms functionality.
    
    Parameters
    ----------
    formula : str
        Model formula in brms syntax, e.g., "y ~ x + (1|group)"
    data : dict or pd.DataFrame
        Data for the model
    priors : list, optional
        List of prior specifications as tuples, e.g.,
        [("normal(0,1)", "b"), ("cauchy(0,2)", "sd")]
    family : str, default="gaussian"
        Distribution family: "gaussian", "poisson", "binomial", etc.
    sample_prior : str, default="no"
        Whether to sample from the prior: "no", "yes", or "only"
    sample : bool, default=True
        Whether to sample from the model. If False, returns compiled model only
        with empty=TRUE.
    backend : str, default="cmdstanr"
        Stan backend to use: "cmdstanr" (recommended), "rstan", or "mock"
    return_type : str, default="idata"
        Type of object to return:
        - "idata": arviz InferenceData (recommended for Python users)
        - "brmsfit": R brmsfit object (for R users or advanced use)
        - "both": BrmsFitResult with both idata and brmsfit attributes
    **brm_args
        Additional arguments passed to brms::brm(), e.g.,
        chains=4, iter=2000, warmup=1000, cores=4, seed=123
        
        Common brm() parameters:
        - iter: Total iterations per chain (default: 2000)
        - warmup: Warmup iterations (default: iter/2)
        - chains: Number of chains (default: 4)
        - cores: Number of cores for parallel chains (default: 1)
        - thin: Thinning rate (default: 1)
        - control: Stan control parameters (default: NULL)
        - seed: Random seed (default: NA)
        - silent: Verbosity level (default: 1)
    
    Returns
    -------
    arviz.InferenceData, brmsfit, or BrmsFitResult
        Depending on return_type parameter:
        
        - "idata": arviz.InferenceData object with properly named parameters
          for use with arviz plotting and analysis functions
        
        - "brmsfit": R brmsfit object for use with R/brms functions
          Access via rpy2: ro.globalenv['fit'] = result
        
        - "both": BrmsFitResult object with .idata and .brmsfit attributes
          allowing access to both Python and R functionality
    
    Examples
    --------
    Basic usage with arviz (default):
    >>> import brmspy
    >>> import arviz as az
    >>> epilepsy = brmspy.get_brms_data("epilepsy")
    >>>
    >>> # Returns arviz InferenceData by default
    >>> idata = brmspy.fit(
    ...     formula="count ~ zAge + zBase * Trt + (1|patient)",
    ...     data=epilepsy,
    ...     family="poisson",
    ...     chains=4,
    ...     iter=2000
    ... )
    >>>
    >>> # Use arviz for analysis
    >>> az.plot_posterior(idata)
    >>> az.summary(idata)
    
    Return brmsfit for R methods:
    >>> fit = brmspy.fit(..., return_type="brmsfit")
    >>> import rpy2.robjects as ro
    >>> ro.globalenv['fit'] = fit
    >>> ro.r('summary(fit)')
    >>> ro.r('plot(fit)')
    
    Get both for maximum flexibility:
    >>> result = brmspy.fit(..., return_type="both")
    >>> az.plot_posterior(result.idata)  # Python
    >>> ro.globalenv['fit'] = result.brmsfit  # R
    >>> ro.r('summary(fit)')
    
    With priors:
    >>> fit = brmspy.fit(
    ...     formula="count ~ zAge + zBase * Trt + (1|patient)",
    ...     data=epilepsy,
    ...     family="poisson",
    ...     priors=[("normal(0, 0.5)", "b"), ("cauchy(0, 1)", "sd")],
    ...     chains=4,
    ...     iter=2000
    ... )
    
    Notes
    -----
    The default return_type="idata" provides the most Pythonic interface,
    returning an arviz InferenceData object with properly named parameters
    (e.g., b_Intercept, b_zAge, sd_patient__Intercept) that works seamlessly
    with the Python Bayesian ecosystem (arviz, matplotlib, etc.).
    
    For users who need R-specific brms functionality, use return_type="brmsfit"
    or return_type="both" for maximum flexibility.
    
    The backend uses brms with cmdstanr, ensuring proper parameter naming
    and full brms functionality. This replaced the direct CmdStanPy approach
    from earlier versions.
    """
    brms = _get_brms()
    
    # Check if cmdstanr backend is available
    if backend == "cmdstanr":
        try:
            import rpy2.robjects.packages as rpackages
            rpackages.importr("cmdstanr")
        except:
            raise ImportError(
                "cmdstanr R package not found. Install it using:\n\n"
                "  install.packages('cmdstanr', repos = c('https://stan-dev.r-universe.dev', getOption('repos')))\n\n"
                "Or use backend='rstan' (requires rstan package)"
            )
    
    # Convert formula to brms formula object
    formula_obj = brms.bf(formula)
    
    # Convert data to R format
    data_r = _convert_python_to_R(data)

    # Setup priors
    if len(priors) > 0:
        brms_prior = brms.prior_string(*priors[0])
        for p in priors[1:]:
            brms_prior = brms_prior + brms.prior_string(*p)
        assert brms.is_brmsprior(brms_prior)
    else:
        brms_prior = []

    # Prepare brm() arguments
    brm_kwargs = {
        'formula': formula_obj,
        'data': data_r,
        'family': family,
        'sample_prior': sample_prior,
        'backend': backend,
    }
    
    # Add priors if specified
    if len(priors) > 0:
        brm_kwargs['prior'] = brms_prior
    
    # Add user-specified arguments
    brm_kwargs.update(brm_args)
    
    # Set empty=TRUE if not sampling
    if not sample:
        brm_kwargs['empty'] = True
        print("Creating empty brmsfit object (no sampling)...")
    else:
        print(f"Fitting model with brms (backend: {backend})...")
    
    # Call brms::brm() with all arguments
    fit = brms.brm(**brm_kwargs)
    
    # Handle return type conversion
    if not sample:
        # For empty models, only brmsfit makes sense
        if return_type != "brmsfit":
            warnings.warn(
                "Empty models (sample=False) only support return_type='brmsfit'. "
                "Setting return_type='brmsfit'."
            )
        print("✓ Empty brmsfit object created (no sampling)!")
        return fit
    
    print("✓ Model fitted successfully!")
    
    # Convert based on return_type
    if return_type == "idata":
        idata = _brmsfit_to_idata(fit)
        return idata
    
    elif return_type == "brmsfit":
        return fit
    
    elif return_type == "both":
        print("\nConverting to arviz InferenceData...")
        idata = _brmsfit_to_idata(fit)
        print("✓ Conversion complete!")
        print("\nReturned BrmsFitResult with both formats.")
        print("Access via result.idata (arviz) or result.brmsfit (R object)")
        return BrmsFitResult(idata=idata, brmsfit=fit)
    
    else:
        raise ValueError(
            f"Invalid return_type='{return_type}'. "
            "Must be 'idata', 'brmsfit', or 'both'."
        )