{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"brmspy","text":"<p>Python-first access to R's brms  with proper parameter names, ArviZ support, and cmdstanr performance. The easiest way to run brms models from Python.</p> <p>Github repo and issues</p> <p> </p> <p> </p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#r-configuration","title":"R Configuration","text":"<p>R&gt;=4 is required before installing brmspy.</p> <p>On Linux and macOS brmspy will usually auto-detect <code>R_HOME</code>, and the session layer attempts to prepend <code>$R_HOME/lib</code> to <code>LD_LIBRARY_PATH</code> when needed for rpy2 ABI mode.</p> <p>If you run into errors like \u201ccannot find libR\u201d (or similar dynamic loader issues), set these explicitly:</p> <pre><code># Set R_HOME and add lib directory to LD_LIBRARY_PATH (Unix)\nexport R_HOME=$(R RHOME)\nexport LD_LIBRARY_PATH=\"${R_HOME}/lib:${LD_LIBRARY_PATH}\"\n\n# Recommended for stability\nexport RPY2_CFFI_MODE=ABI\n</code></pre>"},{"location":"#python","title":"Python","text":"<pre><code>pip install brmspy\n</code></pre> <p>First-time setup (installs brms, cmdstanr, and CmdStan in R):</p> <pre><code>from brmspy import brms\n\nwith brms.manage() as ctx: # requires R to be installed already\n    ctx.install_brms()\n</code></pre>"},{"location":"#prebuilt-runtimes-optional","title":"Prebuilt Runtimes (Optional)","text":"<p>For faster installation (~20-60 seconds vs 20-30 minutes), use prebuilt runtime bundles:</p> <pre><code>from brmspy import brms\n\nwith brms.manage() as ctx:\n    ctx.install_brms(use_prebuilt=True)\n</code></pre>"},{"location":"#windows-rtools","title":"Windows RTools","text":"<p>In case you don't have RTools installed, you can use the flag install_rtools = True. This is disabled by default, because the flag runs the full rtools installer and modifies system path.  Use with caution!</p> <pre><code>from brmspy import brms\n\nwith brms.manage() as ctx:\n    ctx.install_brms(\n        use_prebuilt=True,\n        install_rtools=True,  # works for both prebuilt and compiled installs\n    )\n</code></pre>"},{"location":"#system-requirements","title":"System Requirements","text":"<p>Linux (x86_64): - glibc &gt;= 2.27 (Ubuntu 18.04+, Debian 10+, RHEL 8+) - g++ &gt;= 9.0 - R &gt;= 4.0</p> <p>macOS (Intel &amp; Apple Silicon): - Xcode Command Line Tools: <code>xcode-select --install</code> - clang &gt;= 11.0 - R &gt;= 4.0</p> <p>Windows (x86_64): - Rtools - R &gt;= 4.0</p> <p>Download Rtools from: https://cran.r-project.org/bin/windows/Rtools/</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Proper parameter names: Returns <code>b_Intercept</code>, <code>b_zAge</code>, <code>sd_patient__Intercept</code> instead of generic names like <code>b_dim_0</code></li> <li>ArviZ integration: Returns <code>arviz.InferenceData</code> by default for Python workflow</li> <li>brms formula syntax: Full support for brms formula interface including random effects</li> <li>Dual access: Results include <code>.idata</code> (ArviZ) plus a lightweight <code>.r</code> handle that can be passed back to brmspy to reference the underlying R object (the R object itself stays in the worker process)</li> <li>No reimplementation: Delegates all modeling logic to real brms. No Python-side reimplementation, no divergence from native behavior</li> <li>Prebuilt Binaries: Fast installation with precompiled runtimes (50x faster, ~25 seconds on Google Colab)</li> <li>Stays true to brms: Function names, parameters, and returned objects are designed to be as close as possible to brms</li> <li>Composable formula DSL: Build multivariate, non-linear, and distributional formulas by simply adding components together, identical to brms</li> </ul>"},{"location":"#examples","title":"Examples","text":""},{"location":"#1-quick-start","title":"1. Quick Start","text":"<p>Basic Bayesian regression with ArviZ diagnostics:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\n# Fit Poisson model with random effects\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.brm(\"count ~ zAge + (1|patient)\", data=epilepsy, family=\"poisson\")\n\n# Proper parameter names automatically!\nprint(az.summary(model.idata))\n#                  mean     sd  hdi_3%  hdi_97%  ...  r_hat\n# b_Intercept     1.234  0.123   1.012    1.456  ...   1.00\n# b_zAge          0.567  0.089   0.398    0.732  ...   1.00\n# sd_patient__... 0.345  0.067   0.223    0.467  ...   1.00\n</code></pre>"},{"location":"#2-multivariate-models-python-vs-r","title":"2. Multivariate Models (Python vs R)","text":"<p>Model multiple responses simultaneously with seamless ArviZ integration:</p> Python (brmspy)R (brms) <pre><code>from brmspy import brms\nfrom brmspy.brms import bf, set_rescor\nimport arviz as az\n\n# Fit multivariate model\nmv = brms.brm(\n    bf(\"mvbind(tarsus, back) ~ sex + (1|p|fosternest)\")\n    + set_rescor(True),\n    data=btdata\n)\n\n# ArviZ just works!\naz.loo(mv.idata, var_name=\"tarsus\")\naz.loo(mv.idata, var_name=\"back\")\naz.plot_ppc(mv.idata, var_names=[\"tarsus\"])\n</code></pre> <pre><code>library(brms)\nlibrary(loo)\n\n# Fit multivariate model\nfit &lt;- brm(\n  bf(mvbind(tarsus, back) ~ sex + (1|p|fosternest))\n  + set_rescor(TRUE),\n  data = BTdata\n)\n\n# Separate LOO for each response\nloo_tarsus &lt;- loo(fit, resp = \"tarsus\")\nloo_back &lt;- loo(fit, resp = \"back\")\n</code></pre>"},{"location":"#3-distributional-regression","title":"3. Distributional Regression","text":"<p>Model heteroscedasticity (variance depends on predictors):</p> <pre><code>from brmspy import brms\nfrom brmspy.brms import bf\n\n# Model both mean AND variance\nmodel = brms.brm(\n    bf(\"reaction ~ days\", sigma = \"~ days\"),  # sigma varies with days!\n    data=sleep_data,\n    family=\"gaussian\"\n)\n\n# Extract distributional parameters\nprint(model.idata.posterior.data_vars)\n# b_Intercept, b_days, b_sigma_Intercept, b_sigma_days, ...\n</code></pre>"},{"location":"#4-complete-diagnostic-workflow-with-arviz","title":"4. Complete Diagnostic Workflow with ArviZ","text":"<p>Full model checking in ~10 lines:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nmodel = brms.brm(\"count ~ zAge * Trt + (1|patient)\", data=epilepsy, family=\"poisson\")\n\n# Check convergence\nassert az.rhat(model.idata).max() &lt; 1.01, \"Convergence issues!\"\nassert az.ess(model.idata).min() &gt; 400, \"Low effective sample size!\"\n\n# Posterior predictive check\naz.plot_ppc(model.idata, num_pp_samples=100)\n\n# Model comparison\nmodel2 = brms.brm(\"count ~ zAge + Trt + (1|patient)\", data=epilepsy, family=\"poisson\")\ncomparison = az.compare({\"interaction\": model.idata, \"additive\": model2.idata})\nprint(comparison)\n#              rank  loo    p_loo  d_loo  weight\n# interaction     0 -456.2   12.3    0.0    0.89\n# additive        1 -461.5   10.8    5.3    0.11\n</code></pre>"},{"location":"#5-advanced-formulas-splines-non-linear-effects","title":"5. Advanced Formulas: Splines &amp; Non-linear Effects","text":"<p>Smooth non-linear relationships with splines:</p> <pre><code>from brmspy import brms\n\n# Generalized additive model (GAM) with spline\nmodel = brms.brm(\n    \"y ~ s(x, bs='cr', k=10) + (1 + x | group)\",\n    data=data,\n    family=\"gaussian\"\n)\n\n# Polynomial regression\npoly_model = brms.brm(\n    \"y ~ poly(x, 3) + (1|group)\",\n    data=data\n)\n\n# Extract and visualize smooth effects\nconditional_effects = brms.call(\"conditional_effects\", model, \"x\")\n</code></pre>"},{"location":"#additional-features","title":"Additional Features","text":"<p>Custom Priors: <pre><code>from brmspy.brms import prior\n\nmodel = brms.brm(\n    \"count ~ zAge + (1|patient)\",\n    data=epilepsy,\n    priors=[\n        prior(\"normal(0, 0.5)\", class_=\"b\"),\n        prior(\"exponential(1)\", class_=\"sd\", group=\"patient\")\n    ],\n    family=\"poisson\"\n)\n</code></pre></p> <p>Predictions: <pre><code>import pandas as pd\n\nnew_data = pd.DataFrame({\"zAge\": [-1, 0, 1], \"patient\": [999, 999, 999]})\n\n# Expected value (without observation noise)\nepred = brms.posterior_epred(model, newdata=new_data)\n\n# Posterior predictive (with noise)\nypred = brms.posterior_predict(model, newdata=new_data)\n\n# Access as InferenceData for ArviZ\naz.plot_violin(epred.idata)\n</code></pre></p>"},{"location":"#6-maximalist-example-kitchen-sink","title":"6. Maximalist Example: Kitchen Sink","text":"<p>Everything at once - multivariate responses, different families, distributional parameters, splines, and complete diagnostics:</p> <pre><code>from brmspy.brms import bf, lf, set_rescor, skew_normal, gaussian\nfrom brmspy import brms\nimport arviz as az\n\n# Load data\nbtdata = brms.get_data(\"BTdata\", package=\"MCMCglmm\")\n\nbf_tarsus = (\n    bf(\"tarsus ~ sex + (1|p|fosternest) + (1|q|dam)\") +\n    lf(\"sigma ~ 0 + sex\") +\n    skew_normal()\n)\n\nbf_back = (\n    bf(\"back ~ s(hatchdate) + (1|p|fosternest) + (1|q|dam)\") +\n    gaussian()\n)\n\nmodel = brms.brm(\n    bf_tarsus + bf_back + set_rescor(False),\n    data=btdata,\n    chains=2,\n    control={\"adapt_delta\": 0.95}\n)\n\n# ArviZ diagnostics work seamlessly\nfor response in [\"tarsus\", \"back\"]:\n    print(f\"\\n=== {response.upper()} ===\")\n\n    # Model comparison\n    loo = az.loo(model.idata, var_name=response)\n    print(f\"LOO: {loo.loo:.1f} \u00b1 {loo.loo_se:.1f}\")\n\n    # Posterior predictive check\n    az.plot_ppc(model.idata, var_names=[response])\n\n    # Parameter summaries\n    print(az.summary(\n        model.idata,\n        var_names=[f\"b_{response}\"],\n        filter_vars=\"like\"\n    ))\n\n# Visualize non-linear effect\nconditional = brms.call(\"conditional_effects\", model, \"hatchdate\", resp=\"back\")\n# Returns proper pandas DataFrame ready for plotting!\n</code></pre> <p>Output shows: - Proper parameter naming: <code>b_tarsus_Intercept</code>, <code>b_tarsus_sex</code>, <code>b_sigma_sex</code>, <code>sd_fosternest__tarsus_Intercept</code>, etc. - Separate posterior predictive for each response - Per-response LOO for model comparison - All parameters accessible via ArviZ</p>"},{"location":"#api-reference-partial","title":"API Reference (partial)","text":"<p>brmspy documentation</p> <p>brms documentation</p>"},{"location":"#setup-functions","title":"Setup Functions","text":"<p>Any operation that installs/uninstalls R packages or changes the runtime/environment should be done via <code>brms.manage()</code> (it restarts the worker, giving you a fresh embedded R session).</p> <ul> <li><code>brms.manage()</code> - Context manager for safe installation and environment management</li> <li><code>ctx.install_brms(...)</code> - Install brms + toolchain (from source or using a prebuilt runtime)</li> <li><code>ctx.install_runtime(...)</code> - Install the latest prebuilt runtime for the current system</li> <li><code>ctx.install_rpackage(...)</code> / <code>ctx.uninstall_rpackage(...)</code> - Manage extra R packages in an environment user library</li> <li><code>environment_exists(name)</code> - Check if an environment exists</li> <li><code>environment_activate(name)</code> - Activate an existing environment (switches worker session state)</li> <li><code>get_brms_version()</code> - Get installed brms version</li> <li><code>find_local_runtime()</code> - Find a matching locally installed runtime</li> <li><code>get_active_runtime()</code> - Get the configured runtime path</li> <li><code>status()</code> - Inspect runtime/toolchain status</li> </ul>"},{"location":"#data-functions","title":"Data Functions","text":"<ul> <li><code>get_brms_data()</code> - Load example datasets from brms</li> <li><code>get_data()</code> - Load example datasets from any package</li> <li><code>save_rds()</code> - Save an R object to .rds (executed in the worker)</li> <li><code>read_rds_fit()</code> - Load saved brmsfit object as FitResult (with idata)</li> <li><code>read_rds_raw()</code> - Load an R object (raw)</li> </ul>"},{"location":"#model-functions","title":"Model Functions","text":"<ul> <li><code>bf</code>, <code>lf</code>, <code>nlf</code>, <code>acformula</code>, <code>set_rescor</code>, <code>set_mecor</code>, <code>set_nl</code> - formula functions</li> <li><code>brm()</code> - Fit Bayesian regression model</li> <li><code>make_stancode()</code> - Generate Stan code for model</li> </ul>"},{"location":"#diagnostics-functions","title":"Diagnostics Functions","text":"<ul> <li><code>summary()</code> - Comprehensive model summary as SummaryResult dataclass</li> <li><code>fixef()</code> - Extract population-level (fixed) effects</li> <li><code>ranef()</code> - Extract group-level (random) effects as xarray</li> <li><code>posterior_summary()</code> - Summary statistics for all parameters</li> <li><code>prior_summary()</code> - Extract prior specifications used in model</li> <li><code>validate_newdata()</code> - Validate new data for predictions</li> <li>For loo, waic etc use arviz!</li> </ul>"},{"location":"#prior-functions","title":"Prior Functions","text":"<ul> <li><code>prior()</code> - Define a prior with same syntax as r-s <code>prior_string</code></li> <li><code>get_prior()</code> - Get pd.DataFrame describing default priors</li> <li><code>default_prior()</code> - Get pd.DataFrame describing default priors</li> </ul>"},{"location":"#families-functions","title":"Families Functions","text":"<ul> <li><code>family()</code> - Get family object of FitResult</li> <li><code>brmsfamily()</code> - Construct family object from kwargs</li> <li><code>gaussian()</code>, <code>...bernoulli()</code>, <code>...beta_binomial()</code>, etc - Wrappers around brmsfamily for faster family object construction</li> </ul>"},{"location":"#prediction-functions","title":"Prediction Functions","text":"<ul> <li><code>posterior_epred()</code> - Expected value predictions (without noise)</li> <li><code>posterior_predict()</code> - Posterior predictive samples (with noise)</li> <li><code>posterior_linpred()</code> - Linear predictor values</li> <li><code>log_lik()</code> - Log-likelihood values</li> </ul>"},{"location":"#generic-function-access","title":"Generic Function Access","text":"<ul> <li><code>call()</code> - Call any brms/R function by name with automatic type conversion</li> </ul>"},{"location":"#known-issues","title":"Known issues","text":"<ul> <li>If you have multiple R installations, explicitly setting <code>R_HOME</code> can help avoid \u201cwrong R\u201d / loader issues.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Python: 3.10-3.14</p> <p>R packages (auto-installed via <code>ctx.install_brms()</code> inside <code>brms.manage()</code>): - brms &gt;= 2.20.0 - cmdstanr - posterior</p> <p>Python dependencies: - rpy2 &gt;= 3.5.0 - pandas &gt;= 1.3.0 - numpy &gt;= 1.20.0 - arviz (optional, for InferenceData)</p>"},{"location":"#development","title":"Development","text":"<pre><code>git clone https://github.com/kaitumisuuringute-keskus/brmspy.git\ncd brmspy\nsh script/init-venv.sh\n./run_tests.sh\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<p>brmspy uses: - brms::brm() with cmdstanr backend for fitting (ensures proper parameter naming) - posterior R package for conversion to draws format - arviz for Python-native analysis and visualization - rpy2 for Python-R communication</p> <p>The current architecture isolates embedded R inside a worker process; the main Python process exposes the <code>brms</code> API surface and forwards calls to the worker. This improves stability (crash containment) and enables \u201cresettable\u201d R sessions for installs/environment changes.</p>"},{"location":"#license","title":"License","text":"<p>Apache License 2.0</p>"},{"location":"#credits","title":"Credits","text":"<ul> <li>Current maintainer: Remi Sebastian Kits</li> <li>Original concept: Adam Haber</li> <li>Built on brms by Paul-Christian B\u00fcrkner</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>API Reference</li> <li>Examples</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#031-standardized-and-modular-inferencedata-improved-memory-management","title":"0.3.1 - Standardized and modular InferenceData, improved memory management","text":"<p>25.12.23</p> <p>This release standardizes the <code>InferenceData</code> structure across all prediction methods, ensuring consistent dimensions (<code>chain</code>, <code>draw</code>, <code>obs_id</code>) and variable naming conventions. It also improves shared-memory transport for Pandas DataFrames, enabling high-fidelity roundtripping of Categoricals and mixed types between R and Python.</p>"},{"location":"changelog/#standardised-idata","title":"Standardised idata","text":"<p>All idata returned from brmspy functions is now standardised to be joinable with one another, keep DataFrame indexes correctly in obs_id and works uniformly for univariate and multivariate models.</p> <ul> <li>brm(): Optional <code>return_idata: bool</code> argument. In case of large models, using false and only running methods you may need can be better for memory management (e.g brms.posterior_pred(fit)). When <code>return_idata=True</code> the function now also includes <code>constant_data</code> (Issue #51)</li> <li>posterior(): Returns draws in <code>posterior</code> and <code>constant_data</code> as idata. (Issue #51)</li> <li>observed_data() Returns <code>observed_data</code> and <code>constant_data</code> as idata (Issue #51)</li> <li>posterior_epred() Now returns <code>predictions</code> and <code>predictions_constant_data</code> in case there is newdata and <code>posterior</code> and <code>constant_data</code> when no newdata. Target variables are now suffixed with <code>_mean</code>. (Issue #51) </li> <li>posterior_predict() Now returns <code>predictions</code> and <code>predictions_constant_data</code> in case there is newdata and <code>posterior_predictive</code> and <code>constant_data</code> when no newdata. idata. (Issue #51)</li> <li>posterior_linpred() Now returns <code>predictions</code> and <code>predictions_constant_data</code> in case there is newdata and <code>posterior</code> and <code>constant_data</code> when no newdata. Target variables are now suffixed with <code>_linpred</code>. (Issue #51)</li> <li>log_lik() (Issue #51) Always returns <code>log_likelihood</code> and depending on <code>newdata=None</code> returns  <code>constant_data</code> or <code>predictions_constant_data</code>.</li> <li>Added <code>newdata</code> kwarg based overloads for static typechecking to automatically recognise the correct returned groups for idata</li> </ul> <p>This change allows composable architectures, where the user picks only the parts of idata they need for their analysis.</p>"},{"location":"changelog/#pandas-r-type-conversion","title":"Pandas &amp; R Type Conversion","text":"<ul> <li>Columnar SHM Transport: Improved <code>ShmDataFrameColumns</code> to transport DataFrames with mixed types via shared memory. Numeric and categorical columns now move between processes with zero-copy overhead, while complex object columns fall back to pickling individually.</li> <li>Categorical Fidelity: R factors now correctly roundtrip to <code>pandas.CategoricalDtype</code>, preserving categories, integer codes, and ordered status across the main-worker boundary. (issue #52)</li> <li>Broad Dtype Support: Enhanced converters to robustly handle pandas nullable integers (<code>Int64</code>), nullable floats, strings during R conversion.</li> </ul>"},{"location":"changelog/#bug-fixes-and-enhancements","title":"Bug fixes and enhancements","text":"<ul> <li>Worker crash recovery (Issue #50): Added automatic recovery for R worker crashes     (segfaults, BrokenPipeError, ConnectionResetError). The worker is restarted     transparently and the call raises <code>RWorkerCrashedError</code>. The exception     includes a <code>recovered: bool</code> flag indicating whether a clean worker session     was successfully started, allowing pipelines to distinguish retryable     crashes (<code>recovered=True</code>) from hard failures (<code>recovered=False</code>).</li> <li>Numpy Encoding: Standardised encoding for object arrays. String arrays are now optimized as <code>ShmArray</code>; mixed object arrays gracefully fall back to pickling.</li> <li>Improved SHM memory management: Introduced explicit temporary buffers that are cleaned up immediately after use, while non-temporary buffers are now tracked by ShmPool only until the next main &lt;-&gt; worker exchange; buffer lifetime is then transferred to CodecRegistry, which ties shared-memory mappings to reconstructed objects via weakrefs, minimizing the number of active mappings and allowing timely resource release once those objects are garbage-collected.</li> </ul>"},{"location":"changelog/#030-process-isolated-r-hot-swappable-runtimes","title":"0.3.0 - Process-Isolated R &amp; Hot-Swappable Runtimes","text":"<p>25.12.14</p> <p>This release introduces a redesigned main\u2013worker\u2013R architecture to address stability issues caused by embedding R directly in the Python process. In real-world use, unpredictable failures, ranging from R segfaults to rpy2 crashes, could take down the entire Python runtime, invalidate IDE sessions, and make test behavior OS-dependent. The old single-process model also made R state effectively immutable after import, limited runtime switching, and required brittle workarounds for package management and CI isolation. These issues were not fixable at the level of defensive coding alone.</p> <p>The new architecture jails R inside a dedicated worker process with shared-memory transport, zero-copy codecs, and a proxy module session that preserves the public API. All R data structures (matrices, data frames, ArviZ objects) transfer via shared memory without heap duplication, keeping memory use equivalent to the original design even for multi-gigabyte posteriors. R runtimes and environments are now fully isolated, hot-swappable, and safely mutable through a context manager. Worker-side crashes no longer affect the main interpreter, and previously fragile operations (e.g., loo functions) run without instability. The result is a predictable, reproducible, OS-agnostic execution model with significantly reduced failure modes.</p>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Removal of top-level functions: <code>brmspy.fit</code>, <code>brmspy.install_brms</code>, and other direct exports from the root package have been removed. Users should import the <code>brms</code> module (e.g., <code>from brmspy import brms</code> or <code>from brmspy.brms import bf</code>).</li> <li><code>install_brms</code> API change: Global installation functions (<code>install_brms</code>, <code>install_runtime</code>, <code>install_rpackage</code>) are removed from the public namespace. Installation and environment modification must now be performed inside a <code>brms.manage()</code> context to ensure safe worker restarts.</li> <li>Opaque R handles: The <code>.r</code> attribute on result objects (e.g., <code>FitResult.r</code>) is no longer a live <code>rpy2</code> object but a <code>SexpWrapper</code> handle. These handles cannot be manipulated directly in the main process but can be passed back into <code>brms</code> functions for processing in the worker. They retain the R repr for debugging purposes.</li> <li>Runtime module internalization: <code>brmspy.runtime</code> has been moved to <code>brmspy._runtime</code> and is considered internal. Public runtime interactions should occur via <code>brms.manage()</code>.</li> <li>Formula logic: <code>FormulaResult</code> has been replaced by <code>FormulaConstruct</code>. Formulas are now built as pure Python DSL trees and only converted to R objects during execution in the worker.</li> </ul>"},{"location":"changelog/#new-features","title":"New Features","text":"<ul> <li>Context-managed environments: Added <code>brms.manage()</code>, a context manager that spins up a dedicated worker for administrative tasks. Exposes methods <code>ctx.install_brms()</code>, <code>ctx.install_runtime()</code>, and <code>ctx.install_rpackage()</code> among others which persist changes to the active environment.</li> <li>Multi-environment support: Users can create and switch between named environments (e.g., <code>with brms.manage(environment_name=\"dev\"): ...</code>) which maintain separate user libraries (<code>Rlib</code>) layered on top of the base runtime.</li> <li>Environment persistence: Active environment configurations are saved to <code>~/.brmspy/environment_state.json</code> and <code>~/.brmspy/environment/&lt;name&gt;/config.json</code>.</li> <li>Status API: Added <code>brms.environment_exists()</code> and <code>brms.environment_activate()</code> helpers for managing the lifecycle of R environments programmatically.</li> </ul>"},{"location":"changelog/#environments-runtime","title":"Environments &amp; Runtime","text":"<ul> <li>Process Isolation: R now runs in a dedicated <code>spawn</code>ed worker process. Calls from the main process are serialized and sent via IPC.</li> <li>Shared Memory Transport: Implemented a custom <code>SharedMemoryManager</code> based transport layer. Large numeric payloads (NumPy arrays, pandas DataFrames, ArviZ InferenceData) are written to shared memory buffers, avoiding serialization overhead.</li> <li>Hot-swappable sessions: The R worker can be restarted with a different configuration (R_HOME, library paths) on the fly without restarting the Python interpreter.</li> <li>Zero-copy codecs: Added internal codecs (<code>NumpyArrayCodec</code>, <code>PandasDFCodec</code>, <code>InferenceDataCodec</code>) that handle SHM allocation and view reconstruction transparently.</li> <li>Sexp Cache: Implemented a worker-side cache for R objects (<code>Sexp</code>). The main process holds lightweight <code>SexpWrapper</code> references (by ID) which are rehydrated into real R objects when passed back to the worker.</li> </ul>"},{"location":"changelog/#api-behaviour","title":"API &amp; Behaviour","text":"<ul> <li>Pure Python Formulas: Formula helpers (<code>bf</code>, <code>lf</code>, <code>nlf</code>, etc.) now return <code>FormulaConstruct</code> dataclasses. This allows formula composition (<code>+</code> operator) to happen in Python without requiring a running R session until fit time.</li> <li>Worker Proxy: The <code>brmspy.brms</code> module is now a dynamic proxy (<code>RModuleSession</code>). Accessing attributes triggers remote lookups, and calling functions triggers IPC requests.</li> <li>Logging Bridge: Worker-side logs (including R console output) are captured and forwarded to the main process's logging handlers via a <code>QueueListener</code>.</li> </ul>"},{"location":"changelog/#documentation-infrastructure","title":"Documentation &amp; Infrastructure","text":"<ul> <li>Versioned Documentation: Added <code>mike</code> support for deploying versioned docs (e.g., <code>/0.3/</code>, <code>/stable/</code>) to GitHub Pages via the <code>docs-versioned</code> workflow.</li> <li>Architecture enforcement: Added <code>import-linter</code> with strict contracts to prevent leakage of internal layers (e.g., ensuring <code>rpy2.robjects</code> is never imported in the main process).</li> <li>Internal Docs Generation: Added scripts to auto-generate API reference stubs for internal modules (<code>_runtime</code>, <code>_session</code>, etc.) to aid development.</li> </ul>"},{"location":"changelog/#testing-ci","title":"Testing &amp; CI","text":"<ul> <li>Hot-swap stress tests: Added tests that repeatedly restart the entire R runtime and SharedMemoryManager in a loop, then immediately access old SHM-backed arrays and InferenceData. These scenarios would crash instantly if any lifetime or reference handling were incorrect, making them an effective torture test of the new architecture.</li> <li>Worker Test Marker: Introduced <code>@pytest.mark.worker</code> and a <code>worker_runner</code> fixture to execute specific tests inside the isolated worker process.</li> <li>Coverage Aggregation: Updated CI to merge coverage reports from the main process and the spawned worker process.</li> <li>R Dependency Tests: Switched <code>r-dependencies-tests</code> workflow to use the new isolated test runner script.</li> </ul>"},{"location":"changelog/#021-stability-hotfix","title":"0.2.1 - Stability hotfix","text":"<p>25.12.07</p> <ul> <li>Try to enforce rpy2 RPY2_CFFI_MODE ABI mode on import with warnings if not possible. API/BOTH can cause instability on linux and macos (Issue: #45)</li> <li>Added R_HOME and LD_LIBRARY_PATH to github workflows (required on most environments in ABI mode)</li> <li>The environment now does its best attempts to detect invalid R setups and log them</li> </ul>"},{"location":"changelog/#020-runtime-refactor-formula-dsl","title":"0.2.0 - Runtime Refactor &amp; Formula DSL","text":"<p>25.12.07</p>"},{"location":"changelog/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>Removed Diagnostics: Removed <code>loo</code>, <code>loo_compare</code>, and <code>add_criterion</code> due to frequent segfaults in embedded R mode. Users should rely on <code>arviz.loo</code> and <code>arviz.compare</code> using the <code>idata</code> property of the fit result.</li> <li>Installation API: Renamed <code>use_prebuilt_binaries</code> argument to <code>use_prebuilt</code> in <code>install_brms()</code>.</li> <li>Installation API now consists of: <code>install_brms</code>, <code>install_runtime</code>, <code>deactivate_runtime</code>, <code>activate_runtime</code>, <code>find_local_runtime</code>, <code>get_active_runtime</code>, <code>get_brms_version</code></li> <li>Deprecations: Renamed <code>fit</code> to <code>brm</code> and <code>formula</code> to <code>bf</code>. Previous names are still exported as aliases, but might be removed in a future version.</li> </ul>"},{"location":"changelog/#new-features_1","title":"New Features","text":"<ul> <li>Formula DSL: Implemented <code>bf</code>, <code>lf</code>, <code>nlf</code>, <code>acformula</code>, <code>set_rescor</code>, <code>set_mecor</code>, and <code>set_nl</code>. These objects support additive syntax (e.g., <code>bf(...) + set_rescor(True) + gaussian()</code>) mirroring native brms behavior.</li> <li>Generic Data Loader: Added <code>get_data()</code> to load datasets from any installed R package, complementing <code>get_brms_data()</code>.</li> <li>Runtime Status: Added <code>brmspy.runtime.status()</code> to programmatically inspect the current R environment, toolchain compatibility, and active runtime configuration.</li> <li>Families now in package root: Families can now be imported from package root, e.g <code>from brmspy import gaussian</code></li> </ul>"},{"location":"changelog/#runtime-installation","title":"Runtime &amp; Installation","text":"<ul> <li>Core Refactor: Completely re-architected <code>brmspy.runtime</code> into strict layers (<code>_config</code>, <code>_r_env</code>, <code>_platform</code>, <code>_install</code>, etc) to eliminate side effects during import and prevent circular dependencies.</li> <li>Atomic Activation: <code>activate_runtime()</code> now validates manifest integrity and system fingerprints before mutating the R environment, ensuring atomic success or rollback.</li> <li>Auto-Persistence: The last successfully activated runtime is automatically restored on module import via <code>runtime._autoload</code>, creating persistent sessions across restarts.</li> <li>Windows Toolchain: Modularized RTools detection logic to accurately map R versions to RTools versions (4.0\u20134.5) and handle path updates safely.</li> </ul>"},{"location":"changelog/#documentation-infrastructure_1","title":"Documentation &amp; Infrastructure","text":"<ul> <li>MkDocs Migration: Ported all documentation to MkDocs with the Material theme for better navigability and API references.</li> <li>Rendered notebooks: Added more notebook examples that are now rendered fully with links to running each in Google Colab.</li> <li>ArViz diagnostics examples: can now be found under API reference</li> <li>Test coverage: Test coverage for brms functions is now at 88% and for R environment and package management at 68%</li> </ul>"},{"location":"changelog/#0113-enhanced-diagnostics-type-safe-summaries","title":"0.1.13 - Enhanced Diagnostics &amp; Type-Safe Summaries","text":"<p>25.12.04</p>"},{"location":"changelog/#diagnostics","title":"Diagnostics","text":"<ul> <li><code>summary()</code> Rewrite: Returns <code>SummaryResult</code> dataclass with structured access to <code>fixed</code>, <code>spec_pars</code>, <code>random</code>, <code>prior</code>, and model metadata. Includes pretty-print support.</li> <li><code>fixef()</code>: Extract population-level effects as DataFrame. Supports <code>summary</code>, <code>robust</code>, <code>probs</code>, and <code>pars</code> arguments.</li> <li><code>ranef()</code>: Extract group-level effects as xarray DataArrays. Returns dict mapping grouping factors to arrays with configurable summary/raw modes.</li> <li><code>posterior_summary()</code>: Extract all model parameters (fixed, random, auxiliary) as DataFrame. Supports variable selection and regex patterns.</li> <li><code>prior_summary()</code>: Return DataFrame of prior specifications. Option to show all priors or only user-specified.</li> <li><code>loo()</code>: Compute LOO-CV using PSIS. Returns <code>LooResult</code> with elpd_loo, p_loo, looic, and Pareto k diagnostics.</li> <li><code>loo_compare()</code>: Compare multiple models via LOO-CV. Returns <code>LooCompareResult</code> ranked by performance with <code>elpd_diff</code> and standard errors.</li> <li><code>validate_newdata()</code>: Validate prediction data against fitted model requirements. Checks variables, factor levels, and grouping structure.</li> </ul>"},{"location":"changelog/#type-system","title":"Type System","text":"<ul> <li>DataFrame Detection: <code>r_to_py()</code> now correctly preserves row indexes, column names, and proper type conversion from R DataFrames.</li> <li><code>LooResult</code>/<code>LooCompareResult</code>: Added <code>__repr__()</code> for formatted notebook output.</li> </ul>"},{"location":"changelog/#generic-function-access","title":"Generic Function Access","text":"<ul> <li><code>call()</code>: Universal wrapper for calling any brms or R function by name with automatic type conversion.</li> <li><code>sanitised_name()</code>: Helper to convert Python-style names to valid R identifiers.</li> </ul>"},{"location":"changelog/#testing","title":"Testing","text":"<ul> <li>Added 14 tests covering all new diagnostics functions.</li> <li>Optimized test iterations (<code>iter=100, warmup=50</code>) for faster CI.</li> </ul>"},{"location":"changelog/#0112-rds-io-families-module-default-priors","title":"0.1.12 - RDS I/O, Families Module, Default Priors","text":"<p>25.12.03</p>"},{"location":"changelog/#new-features_2","title":"New Features","text":"<ul> <li><code>save_rds()</code>: Save <code>brmsfit</code> or generic R objects to RDS files.</li> <li><code>load_rds_fit()</code>: Load saved <code>brmsfit</code> objects, returning <code>FitResult</code> with attached <code>InferenceData</code>.</li> <li><code>load_rds_raw()</code>: Load arbitrary R objects from RDS files.</li> <li><code>brm</code> Alias: Added <code>brm</code> as alias for <code>fit</code>.</li> </ul>"},{"location":"changelog/#families","title":"Families","text":"<ul> <li>Added <code>brmspy.families</code> module with <code>brmsfamily()</code> and <code>family()</code> wrappers.</li> <li>Implemented keyword-argument wrappers for 40+ families: <code>student</code>, <code>bernoulli</code>, <code>beta_binomial</code>, <code>negbinomial</code>, <code>geometric</code>, <code>lognormal</code>, <code>shifted_lognormal</code>, <code>skew_normal</code>, <code>exponential</code>, <code>weibull</code>, <code>frechet</code>, <code>gen_extreme_value</code>, <code>exgaussian</code>, <code>wiener</code>, <code>Beta</code>, <code>dirichlet</code>, <code>logistic_normal</code>, <code>von_mises</code>, <code>asym_laplace</code>, <code>cox</code>, <code>hurdle_*</code>, <code>zero_inflated_*</code>, <code>categorical</code>, <code>multinomial</code>, <code>cumulative</code>, <code>sratio</code>, <code>cratio</code>, <code>acat</code>.</li> </ul>"},{"location":"changelog/#priors","title":"Priors","text":"<ul> <li><code>default_prior()</code>: Retrieve default priors for a model formula and dataset.</li> <li><code>get_prior()</code>: Inspect prior structure before fitting.</li> </ul>"},{"location":"changelog/#internal","title":"Internal","text":"<ul> <li>Reorganized brms wrappers into modular files under <code>brmspy/brms_functions/</code>.</li> <li>Added <code>RListVectorExtension</code> protocol for automatic R list extraction in type conversion.</li> </ul>"},{"location":"changelog/#0111-persistent-runtimes-logging","title":"0.1.11 - Persistent Runtimes &amp; Logging","text":"<p>25.12.01</p>"},{"location":"changelog/#new-features_3","title":"New Features","text":"<ul> <li>Persistent Runtimes: Activated runtime path saved to <code>~/.brmspy/config.json</code> and auto-loaded on import.</li> <li>Configurable Logging: Replaced print statements with centralized logger.</li> <li>Optimized Activation: Made aggressive unloading conditional for faster runtime activation.</li> </ul>"},{"location":"changelog/#0110-windows-stability-ci-improvements","title":"0.1.10 - Windows Stability &amp; CI Improvements","text":"<p>25.12.01</p>"},{"location":"changelog/#windows-support","title":"Windows Support","text":"<ul> <li>Implemented aggressive R package unloading (detach, unloadNamespace, DLL unload) to prevent file locking errors.</li> <li>Refined RTools detection; relaxed <code>g++</code> version requirements when valid RTools is detected.</li> <li>Changed <code>install_rtools</code> default to <code>False</code> in <code>install_brms()</code> to prevent unintended PATH modifications.</li> <li>Fixed PowerShell command syntax generation.</li> <li>Windows prebuilt binaries currently require R4.5.</li> </ul>"},{"location":"changelog/#build-ci","title":"Build &amp; CI","text":"<ul> <li>Expanded CI matrix: Windows, macOS, Ubuntu on Python 3.12.</li> <li>Optimized GitHub Actions caching for R libraries and CmdStan.</li> <li>Fixed artifact pruning logic in runtime builder workflows.</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Ensured <code>jsonlite</code> dependency is explicitly resolved during manifest generation.</li> <li>Fixed workflow path referencing and quoting issues.</li> </ul>"},{"location":"changelog/#019-prebuilt-runtimes-windows-toolchain","title":"0.1.9 - Prebuilt Runtimes &amp; Windows Toolchain","text":"<p>25.11.30</p>"},{"location":"changelog/#new-features_4","title":"New Features","text":"<ul> <li>Prebuilt Runtimes: Added <code>brmspy.binaries</code> subpackage for precompiled R environments with <code>brms</code> and <code>cmdstanr</code> (up to 50x faster install).</li> <li>Fast Installation: Added <code>use_prebuilt_binaries=True</code> argument to <code>install_brms()</code>.</li> <li>Windows Toolchain: Automatic Rtools (MinGW-w64) detection and installation in <code>install_brms()</code>.</li> </ul>"},{"location":"changelog/#enhancements","title":"Enhancements","text":"<ul> <li>Linux Binaries: Prioritize Posit Package Manager (P3M) binary repositories based on OS codename.</li> <li>Documentation: Added docstrings to all public and internal functions.</li> </ul>"},{"location":"changelog/#infrastructure","title":"Infrastructure","text":"<ul> <li>Added <code>.runtime_builder</code> Dockerfiles for reproducible Linux runtime environments.</li> </ul>"},{"location":"changelog/#018-rstan-support-version-pinning","title":"0.1.8 - RStan Support &amp; Version Pinning","text":"<p>25.11.29</p>"},{"location":"changelog/#new-features_5","title":"New Features","text":"<ul> <li>RStan Backend: Added <code>rstan</code> as alternative backend. <code>install_brms()</code> accepts <code>install_rstan</code> param; <code>fit()</code> accepts <code>backend=\"rstan\"</code>.</li> <li>Version Pinning: <code>install_brms()</code> supports pinning specific R package versions (e.g., <code>version=\"2.21.0\"</code>) via <code>remotes</code>.</li> </ul>"},{"location":"changelog/#platform-support","title":"Platform Support","text":"<ul> <li>Windows Toolchain: Automatic Rtools detection and setup in <code>install_brms()</code>.</li> <li>macOS/Windows Binaries: Fixed installation failures by defaulting to <code>type=\"both\"</code> instead of forcing source compilation.</li> </ul>"},{"location":"changelog/#infrastructure_1","title":"Infrastructure","text":"<ul> <li>Added cross-platform CI workflow (Windows, macOS, Ubuntu).</li> </ul>"},{"location":"changelog/#017-import-fixes","title":"0.1.7 - Import Fixes","text":"<p>25.11.29</p> <ul> <li>Fixed library refusing import when R dependencies are missing.</li> <li>R libraries now automatically imported after installation.</li> </ul>"},{"location":"changelog/#016-segfault-fix-stability","title":"0.1.6 - Segfault Fix &amp; Stability","text":"<p>25.11.29</p>"},{"location":"changelog/#core-stability","title":"Core Stability","text":"<ul> <li>Fixed segfault occurring when <code>fit()</code> was called inside <code>tqdm</code> loops or repeated call contexts.</li> <li>All R imports (<code>brms</code>, <code>cmdstanr</code>, <code>posterior</code>) now performed once at module import, never inside functions.</li> </ul>"},{"location":"changelog/#performance","title":"Performance","text":"<ul> <li>Repeated model fits now faster due to eliminated R namespace reloads.</li> <li>Reduced memory churn by removing redundant converter/namespace setup.</li> </ul>"},{"location":"changelog/#testing_1","title":"Testing","text":"<ul> <li>Added <code>test_fit_tqdm_segfault()</code> regression test.</li> </ul>"},{"location":"changelog/#015-priors-formula-helper-typed-arviz","title":"0.1.5 - Priors, Formula Helper, Typed ArviZ","text":"<p>25.11.28</p>"},{"location":"changelog/#api-types","title":"API &amp; Types","text":"<ul> <li><code>formula()</code>: Added helper for building reusable model formulas with kwargs support.</li> <li>Typed ArviZ Aliases: Added <code>IDFit</code>, <code>IDPredict</code>, <code>IDLinpred</code>, <code>IDLogLik</code>, <code>IDEpred</code> for different <code>InferenceData</code> shapes.</li> <li>Exported Types: <code>FitResult</code>, <code>PosteriorEpredResult</code>, <code>PosteriorPredictResult</code>, <code>PosteriorLinpredResult</code>, <code>LogLikResult</code>, <code>GenericResult</code> now in public API.</li> </ul>"},{"location":"changelog/#priors_1","title":"Priors","text":"<ul> <li><code>prior()</code> Helper: Now recommended way to specify priors instead of raw tuples.</li> <li>Improved internal prior-building logic for better mapping to <code>brms::set_prior()</code>.</li> <li>Supports <code>class_</code>, <code>coef</code>, <code>group</code>, <code>dpar</code> combinations.</li> </ul>"},{"location":"changelog/#internal_1","title":"Internal","text":"<ul> <li>Improved <code>fit()</code> kwargs parsing for more robust forwarding to <code>brms</code>/<code>cmdstanr</code>.</li> <li>Expanded test coverage for priors, <code>get_stancode</code>, <code>summary</code>, and fit-without-sampling paths.</li> </ul>"},{"location":"api/brms/","title":"Main Module","text":"<p>User-facing brms API.</p> <p>Import this module to call <code>brms</code> functions from Python (for example <code>brm</code>, <code>prior</code>, <code>posterior_predict</code>, etc.). brmspy runs these calls through an isolated runtime so that R-side instability is less likely to take down your Python process.</p> <p>Use <code>brms.manage()</code> to install brms / CmdStan, and to work with multiple isolated environments.</p> <p>Examples:</p> <pre><code>from brmspy import brms\nwith brms.manage(environment_name=\"default\") as ctx:\n    ctx.install_brms(use_prebuilt=True)\n</code></pre>"},{"location":"api/brms/#brmspy.brms-classes","title":"Classes","text":""},{"location":"api/brms/#brmspy.brms.IDResult","title":"<code>IDResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T_idata]</code>, <code>RListVectorExtension</code></p> <p>Generic result container with arviz and R objects.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData object</p> <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/brms/#brmspy.brms.LooResult","title":"<code>LooResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Parsed <code>brms::loo()</code> result.</p> <p>Attributes:</p> Name Type Description <code>estimates, pointwise, diagnostics</code> <code>DataFrame</code> <p>LOO tables.</p> <code>psis_object</code> <code>Any or None</code> <p>PSIS object (if present). May be an R-handle wrapper depending on conversion.</p> <code>elpd_loo, p_loo, looic</code> <code>float</code> <p>Key scalar metrics.</p> <code>se_elpd_loo, se_p_loo, se_looic</code> <code>float</code> <p>Standard errors for the corresponding scalars.</p>"},{"location":"api/brms/#brmspy.brms.LooResult-functions","title":"Functions","text":""},{"location":"api/brms/#brmspy.brms.LooResult.__repr__","title":"<code>__repr__()</code>","text":"<p>Pretty print LOO-CV results.</p>"},{"location":"api/brms/#brmspy.brms.LooCompareResult","title":"<code>LooCompareResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result of comparing models by a LOO-style criterion.</p> <p>Attributes:</p> Name Type Description <code>table</code> <code>DataFrame</code> <p>Comparison table.</p> <code>criterion</code> <code>str</code> <p>Criterion name (e.g. <code>\"loo\"</code>).</p>"},{"location":"api/brms/#brmspy.brms.IDPosterior","title":"<code>IDPosterior</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .posterior extension to idata</p>"},{"location":"api/brms/#brmspy.brms.IDPosteriorPredictive","title":"<code>IDPosteriorPredictive</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .posterior_predictive extension to idata</p>"},{"location":"api/brms/#brmspy.brms.IDPredictions","title":"<code>IDPredictions</code>","text":"<p>               Bases: <code>IDPredictionsConstantData</code></p> <p>Typed .predictions extension to idata</p>"},{"location":"api/brms/#brmspy.brms.IDLogLikelihoodInsample","title":"<code>IDLogLikelihoodInsample</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .log_likelihood extension to idata</p>"},{"location":"api/brms/#brmspy.brms.IDLogLikelihoodOutsample","title":"<code>IDLogLikelihoodOutsample</code>","text":"<p>               Bases: <code>IDPredictionsConstantData</code></p> <p>Typed .log_likelihood extension to idata</p>"},{"location":"api/brms/#brmspy.brms.IDObservedData","title":"<code>IDObservedData</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .posterior extension to idata</p>"},{"location":"api/brms/#brmspy.brms.IDConstantData","title":"<code>IDConstantData</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed .constant_data extension to idata</p>"},{"location":"api/brms/#brmspy.brms.IDPredictionsConstantData","title":"<code>IDPredictionsConstantData</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed .predictions_constant_data extension to idata</p>"},{"location":"api/brms/#brmspy.brms.RListVectorExtension","title":"<code>RListVectorExtension</code>  <code>dataclass</code>","text":"<p>Generic result container with R objects.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/brms/#brmspy.brms.IDBrm","title":"<code>IDBrm</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed <code>arviz.InferenceData</code> for fitted brms models.</p> <p>Extends <code>arviz.InferenceData</code> with type hints for IDE autocomplete. In brmspy, the fitted model result typically exposes an <code>.idata</code> attribute of this type.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Posterior samples of model parameters.</p> <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (with observation noise).</p> <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation.</p> <code>observed_data</code> <code>Dataset</code> <p>Original observed response data.</p> <code>coords</code> <code>dict</code> <p>Coordinate mappings for dimensions (inherited from <code>arviz.InferenceData</code>).</p> <code>dims</code> <code>dict</code> <p>Dimension specifications for variables (inherited from <code>arviz.InferenceData</code>).</p> See Also <p>brmspy.brms.brm : Creates fitted model results (alias: <code>brmspy.brms.fit</code>). arviz.InferenceData : Base class documentation.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.brm(\"y ~ x\", data=df, chains=4)\n\n# Type checking and autocomplete\nassert isinstance(model.idata, IDFit)\nprint(model.idata.posterior)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.PriorSpec","title":"<code>PriorSpec</code>  <code>dataclass</code>","text":"<p>Python representation of a brms prior specification.</p> <p>This dataclass provides a typed interface to <code>brms::prior_string()</code> arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the <code>prior()</code> factory function to create instances.</p> <p>Attributes:</p> Name Type Description <code>prior</code> <code>str</code> <p>Prior distribution as string (e.g., <code>\"normal(0, 1)\"</code>, <code>\"exponential(2)\"</code>).</p> <code>class_</code> <code>(str, optional)</code> <p>Parameter class: <code>\"b\"</code> (fixed effects), <code>\"sd\"</code> (group SD), <code>\"Intercept\"</code>, <code>\"sigma\"</code>, <code>\"cor\"</code>, etc.</p> <code>coef</code> <code>(str, optional)</code> <p>Specific coefficient name for class-level priors.</p> <code>group</code> <code>(str, optional)</code> <p>Grouping variable for hierarchical effects.</p> <code>dpar</code> <code>(str, optional)</code> <p>Distributional parameter (e.g., <code>\"sigma\"</code>, <code>\"phi\"</code>, <code>\"zi\"</code>).</p> <code>resp</code> <code>(str, optional)</code> <p>Response variable for multivariate models.</p> <code>nlpar</code> <code>(str, optional)</code> <p>Non-linear parameter name.</p> <code>lb</code> <code>(float, optional)</code> <p>Lower bound for truncated priors.</p> <code>ub</code> <code>(float, optional)</code> <p>Upper bound for truncated priors.</p> See Also <p>prior : Factory function to create <code>PriorSpec</code> instances. brms::prior_string : R documentation</p> <p>Examples:</p> <p>Create prior specifications (prefer using <code>prior()</code>):</p> <pre><code>from brmspy.types import PriorSpec\n\n# Fixed effect prior\np1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n# Group-level SD prior\np2 = PriorSpec(prior=\"exponential(2)\", class_=\"sd\", group=\"patient\")\n\n# Coefficient-specific prior with bounds\np3 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\", coef=\"age\", lb=0)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.PriorSpec-functions","title":"Functions","text":""},{"location":"api/brms/#brmspy.brms.PriorSpec.to_brms_kwargs","title":"<code>to_brms_kwargs()</code>","text":"<p>Convert PriorSpec to keyword arguments for brms::prior_string().</p> <p>Maps Python dataclass fields to R function arguments, handling the <code>class_</code> -&gt; <code>class</code> parameter name conversion.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keyword arguments ready for brms::prior_string()</p> <p>Examples:</p> <pre><code>from brmspy import prior\np = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\nkwargs = p.to_brms_kwargs()\nprint(kwargs)\n# {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n</code></pre>"},{"location":"api/brms/#brmspy.brms.FormulaConstruct","title":"<code>FormulaConstruct</code>  <code>dataclass</code>","text":"<p>A composite formula expression built from parts.</p> <p><code>FormulaConstruct</code> stores a tree of nodes (<code>FormulaPart</code> and/or R objects) representing expressions combined with <code>+</code>. It is primarily created by calling the public formula helpers exposed by <code>brmspy.brms</code>.</p> Notes <p>The <code>+</code> operator supports grouping:</p> <ul> <li><code>a + b + c</code> becomes a single summand (one \u201cgroup\u201d)</li> <li><code>(a + b) + (a + b)</code> becomes two summands (two \u201cgroups\u201d)</li> </ul> <p>Use <code>iter_summands()</code> to iterate over these groups in a deterministic way.</p>"},{"location":"api/brms/#brmspy.brms.FormulaConstruct-functions","title":"Functions","text":""},{"location":"api/brms/#brmspy.brms.FormulaConstruct.__add__","title":"<code>__add__(other)</code>","text":"<p>Combine two formula expressions with <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Other</code> <p>Value to add. Strings are treated as <code>bf(&lt;string&gt;)</code>.</p> required <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>New combined expression.</p>"},{"location":"api/brms/#brmspy.brms.FormulaConstruct.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Support <code>\"y ~ x\" + bf(\"z ~ 1\")</code> by coercing the left operand.</p>"},{"location":"api/brms/#brmspy.brms.FormulaConstruct.iter_summands","title":"<code>iter_summands()</code>","text":"<p>Iterate over arithmetic groups (summands).</p> <p>Returns:</p> Type Description <code>Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]</code> <p>Each yielded tuple represents one summand/group.</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, gaussian, set_rescor\n\nf = bf(\"y ~ x\") + gaussian() + set_rescor(True)\nfor summand in f.iter_summands():\n    print(summand)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.FormulaConstruct.__iter__","title":"<code>__iter__()</code>","text":"<p>Alias for <code>iter_summands()</code>.</p>"},{"location":"api/brms/#brmspy.brms.FormulaConstruct.iterate","title":"<code>iterate()</code>","text":"<p>Iterate over all leaf nodes in left-to-right order.</p> <p>This flattens the expression tree, unlike <code>iter_summands()</code>, which respects grouping.</p> <p>Returns:</p> Type Description <code>Iterator[FormulaPart | ProxyListSexpVector]</code>"},{"location":"api/brms/#brmspy.brms.FormulaPart","title":"<code>FormulaPart</code>  <code>dataclass</code>","text":"<p>A single formula helper invocation.</p> <p>Instances of this type represent a call like <code>bf(\"y ~ x\")</code> or <code>set_rescor(True)</code> without executing anything. They are primarily used as nodes inside a <code>FormulaConstruct</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_fun</code> <code>Literal[...]</code> <p>Whitelisted formula helper name.</p> required <code>_args</code> <code>Sequence[Primitive]</code> <p>Positional arguments for the helper.</p> required <code>_kwargs</code> <code>Mapping[str, Primitive]</code> <p>Keyword arguments for the helper.</p> required Notes <p>This is a low-level type. Most users should construct these via the public helper functions in <code>brmspy.brms</code>.</p>"},{"location":"api/brms/#brmspy.brms.FormulaPart-functions","title":"Functions","text":""},{"location":"api/brms/#brmspy.brms.FormulaPart.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate <code>_fun</code>, <code>_args</code>, and <code>_kwargs</code> types after construction.</p>"},{"location":"api/brms/#brmspy.brms.FormulaPart.__str__","title":"<code>__str__()</code>","text":"<p>Render a readable <code>fun(arg1, ..., kw=...)</code> representation.</p>"},{"location":"api/brms/#brmspy.brms-functions","title":"Functions","text":""},{"location":"api/brms/#brmspy.brms.log","title":"<code>log(*msg, method_name=None, level=logging.INFO)</code>","text":"<p>Log a message with automatic method name detection.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log</p> <code>()</code> <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> <code>level</code> <code>int</code> <p>Logging level (default: logging.INFO)</p> <code>INFO</code>"},{"location":"api/brms/#brmspy.brms.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code>"},{"location":"api/brms/#brmspy.brms.get_brms_data","title":"<code>get_brms_data(dataset_name, **kwargs)</code>","text":"<p>Load an example dataset from the R <code>brms</code> package.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Dataset name (for example <code>\"epilepsy\"</code> or <code>\"kidney\"</code>).</p> required <code>**kwargs</code> <p>Forwarded to R <code>utils::data()</code> via <code>get_data()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset converted to a DataFrame.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nassert epilepsy.shape[0] &gt; 0\n</code></pre>"},{"location":"api/brms/#brmspy.brms.read_rds_fit","title":"<code>read_rds_fit(file, **kwargs)</code>","text":"<p>Load a saved brms model from an <code>.rds</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Input path containing a saved brmsfit.</p> required <code>**kwargs</code> <p>Forwarded to R <code>readRDS()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p><code>FitResult</code> containing ArviZ <code>InferenceData</code> and an underlying R handle.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.read_rds_fit(\"model.rds\")\nfit.idata.posterior\n</code></pre>"},{"location":"api/brms/#brmspy.brms.read_rds_raw","title":"<code>read_rds_raw(file, **kwargs)</code>","text":"<p>Load an R object from an <code>.rds</code> file via R <code>readRDS()</code>.</p> <p>This returns the raw R object handle.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Input path.</p> required <code>**kwargs</code> <p>Forwarded to R <code>readRDS()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ListSexpVector</code> <p>Raw R object.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nobj = brms.read_rds_raw(\"model.rds\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.save_rds","title":"<code>save_rds(object, file, **kwargs)</code>","text":"<p>Save an R object to an <code>.rds</code> file via R <code>saveRDS()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>RListVectorExtension or ProxyListSexpVector</code> <p>Object to save. If you pass a <code>FitResult</code>, the underlying brmsfit is saved.</p> required <code>file</code> <code>str</code> <p>Output path.</p> required <code>**kwargs</code> <p>Forwarded to R <code>saveRDS()</code> (for example <code>compress=\"xz\"</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.brm(\"y ~ x\", data=df, chains=4)\nbrms.save_rds(model, \"model.rds\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.get_data","title":"<code>get_data(dataset_name, **kwargs)</code>","text":"<p>Load an R dataset and return it as a pandas DataFrame.</p> <p>This is a thin wrapper around R's <code>data()</code> that loads the object into the R global environment and converts it to a :class:<code>pandas.DataFrame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Name of the dataset as used in R (e.g. <code>\"BTdata\"</code>).</p> required <code>**kwargs</code> <p>Additional keyword arguments forwarded to R's <code>data()</code> function, for example <code>package=\"MCMCglmm\"</code> or other arguments supported by <code>utils::data()</code> in R.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset converted to a pandas DataFrame.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the dataset is not found in the R global environment after calling <code>data()</code>.</p> <code>RuntimeError</code> <p>If conversion from the R object to a pandas DataFrame fails.</p> See Also <p>get_brms_data     Convenience wrapper for datasets from the <code>brms</code> package.</p>"},{"location":"api/brms/#brmspy.brms.prior","title":"<code>prior(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None, **kwargs)</code>","text":"<p>Create a brms-style prior specification.</p> <p>This function mirrors the behavior of <code>brms::prior_string()</code> and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of <code>prior_string()</code> in brms.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>str</code> <p>The prior definition as a string, exactly as brms expects it. Examples include ::</p> <pre><code>\"normal(0, 1)\"\n\"student_t(3, 0, 1.5)\"\n\"exponential(2)\"\n\"lkj(2)\"\n</code></pre> required <code>class_</code> <code>str</code> <p>Parameter class (e.g. <code>\"b\"</code>, <code>\"sd\"</code>, <code>\"Intercept\"</code>). This corresponds to <code>class</code> in brms. <code>class</code> cannot be used as a parameter in Python (reserved keyword), so <code>class_</code> is used instead.</p> <code>None</code> <code>coef</code> <code>str</code> <p>Coefficient name for class-level effects.</p> <code>None</code> <code>group</code> <code>str</code> <p>Grouping variable for hierarchical/multilevel effects.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Distributional parameter (e.g. <code>\"sigma\"</code> or <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response variable name for multivariate models.</p> <code>None</code> <code>nlpar</code> <code>str</code> <p>Nonlinear parameter name if using nonlinear formulas.</p> <code>None</code> <code>lb</code> <code>float</code> <p>Lower bound for truncated priors.</p> <code>None</code> <code>ub</code> <code>float</code> <p>Upper bound for truncated priors.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Any additional keyword arguments supported by <code>brms::prior_string()</code>. These are forwarded unchanged.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriorSpec</code> <p>A typed prior specification object used by <code>brmspy.brms.brm()</code> and <code>brmspy.brms.make_stancode()</code>.</p> See Also <p>brms::prior_string : R documentation</p> Notes <p>This function does not validate the prior expression string itself \u2014 validation occurs inside brms.</p> <p>Examples:</p> <pre><code>from brmspy.brms import prior\n\np_intercept = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\")\np_slope = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\np_sd = prior(\"exponential(2)\", class_=\"sd\", group=\"region\")\np_trunc = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.get_prior","title":"<code>get_prior(formula, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for a model specification.</p> <p>Wrapper around R <code>brms::get_prior()</code>.</p> <p>Returns a DataFrame with default priors for each parameter class in the specified brms model. Useful for reviewing and customizing priors before fitting.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula (e.g. <code>\"y ~ x + (1|group)\"</code>) or a composed formula.</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListSexpVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\")</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row represents a parameter or parameter class that can have a custom prior.</p> See Also <p>default_prior : Generic function for getting default priors prior : Create custom prior specifications brms::get_prior : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms import prior\n\npriors_df = brms.get_prior(\"y ~ x\", data=df)\n\ncustom_priors = [\n    prior(\"normal(0, 0.5)\", class_=\"b\"),\n    prior(\"exponential(2)\", class_=\"sigma\"),\n]\n\nfit = brms.brm(\"y ~ x\", data=df, priors=custom_priors, chains=4)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.default_prior","title":"<code>default_prior(object, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for brms model parameters (generic function).</p> <p>Wrapper around R <code>brms::default_prior()</code>.</p> <p>Generic function to retrieve default prior specifications for all parameters in a brms model. Accepts formula objects, brmsformula objects, or other model specification objects. This is the generic version of get_prior().</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>str, FormulaResult, or ListSexpVector</code> <p>Model specification: formula string, brmsformula object, mvbrmsformula, or any object that can be coerced to these classes</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListSexpVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\"). Can be a list of families for multivariate models</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels, sparse)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row specifies a parameter class with its default prior. The 'prior' column is empty except for internal defaults.</p> See Also <p>get_prior : Convenience function with formula parameter prior : Create custom prior specifications brms::default_prior : R documentation</p> <p>Examples:</p> <p>Get default priors for a Poisson model:</p> <pre><code>from brmspy import brms\n\npriors = brms.default_prior(\n    object=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\nprint(priors)\n</code></pre> <p>Use with formula object:</p> <pre><code>from brmspy import brms\n\nf = brms.formula(\"y ~ x + (1|group)\")\npriors = brms.default_prior(f, data=df, family=\"gaussian\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.brm","title":"<code>brm(formula, data, priors=None, family='gaussian', sample_prior='no', sample=True, backend='cmdstanr', formula_args=None, cores=2, *, return_idata=True, **brm_args)</code>","text":"<pre><code>brm(formula: FormulaConstruct | ProxyListSexpVector | str, data: dict | pd.DataFrame, priors: Sequence[PriorSpec] | None = ..., family: str | ListSexpVector | None = ..., sample_prior: str = ..., sample: bool = ..., backend: str = ..., formula_args: dict | None = ..., cores: int | None = ..., *, return_idata: Literal[True] = True, **brm_args: Any) -&gt; FitResult\n</code></pre><pre><code>brm(formula: FormulaConstruct | ProxyListSexpVector | str, data: dict | pd.DataFrame, priors: Sequence[PriorSpec] | None = ..., family: str | ListSexpVector | None = ..., sample_prior: str = ..., sample: bool = ..., backend: str = ..., formula_args: dict | None = ..., cores: int | None = ..., *, return_idata: Literal[False], **brm_args: Any) -&gt; ProxyListSexpVector\n</code></pre> <p>Fit a Bayesian regression model with brms.</p> <p>This is a thin wrapper around R <code>brms::brm()</code> that returns a structured <code>FitResult</code> (including an ArviZ <code>InferenceData</code>).</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula. Accepts a plain brms formula string (e.g. <code>\"y ~ x + (1|g)\"</code>) or a composed formula created via <code>brmspy.brms.bf()</code> / <code>brmspy.brms.lf()</code> (typically imported as <code>from brmspy.brms import bf, lf</code>).</p> required <code>data</code> <code>dict or DataFrame</code> <p>Model data.</p> required <code>priors</code> <code>Sequence[PriorSpec] or None</code> <p>Optional prior specifications created via <code>brmspy.brms.prior()</code>.</p> <code>None</code> <code>family</code> <code>str or ListSexpVector or None</code> <p>brms family specification (e.g. <code>\"gaussian\"</code>, <code>\"poisson\"</code>).</p> <code>\"gaussian\"</code> <code>sample_prior</code> <code>str</code> <p>Passed to brms. Common values: <code>\"no\"</code>, <code>\"yes\"</code>, <code>\"only\"</code>.</p> <code>\"no\"</code> <code>sample</code> <code>bool</code> <p>If <code>False</code>, compile the model without sampling (brms <code>empty=TRUE</code>).</p> <code>True</code> <code>backend</code> <code>str</code> <p>Stan backend. Common values: <code>\"cmdstanr\"</code> or <code>\"rstan\"</code>.</p> <code>\"cmdstanr\"</code> <code>formula_args</code> <code>dict or None</code> <p>Reserved for future use. Currently ignored.</p> <code>None</code> <code>cores</code> <code>int or None</code> <p>Number of cores for brms/cmdstanr.</p> <code>2</code> <code>return_idata</code> <code>bool</code> <p>When working with large datasets, you might not want the full idata. when False, you get the R object proxy which can be forwarded to posterior_epred or other functions</p> <code>True</code> <code>**brm_args</code> <p>Additional keyword arguments passed to R <code>brms::brm()</code> (e.g. <code>chains</code>, <code>iter</code>, <code>warmup</code>, <code>seed</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Result object with <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::brm : R documentation</p> Warnings <p>Using <code>cores &lt;= 1</code> can be unstable in embedded R sessions and may crash the worker process. Prefer <code>cores &gt;= 2</code>.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x + (1|g)\", data=df, family=\"gaussian\", chains=4, cores=4)\n\nfit.idata.posterior\n</code></pre>"},{"location":"api/brms/#brmspy.brms.fit","title":"<code>fit(formula, data, priors=None, family='gaussian', sample_prior='no', sample=True, backend='cmdstanr', formula_args=None, cores=2, *, return_idata=True, **brm_args)</code>","text":"<pre><code>brm(formula: FormulaConstruct | ProxyListSexpVector | str, data: dict | pd.DataFrame, priors: Sequence[PriorSpec] | None = ..., family: str | ListSexpVector | None = ..., sample_prior: str = ..., sample: bool = ..., backend: str = ..., formula_args: dict | None = ..., cores: int | None = ..., *, return_idata: Literal[True] = True, **brm_args: Any) -&gt; FitResult\n</code></pre><pre><code>brm(formula: FormulaConstruct | ProxyListSexpVector | str, data: dict | pd.DataFrame, priors: Sequence[PriorSpec] | None = ..., family: str | ListSexpVector | None = ..., sample_prior: str = ..., sample: bool = ..., backend: str = ..., formula_args: dict | None = ..., cores: int | None = ..., *, return_idata: Literal[False], **brm_args: Any) -&gt; ProxyListSexpVector\n</code></pre> <p>Fit a Bayesian regression model with brms.</p> <p>This is a thin wrapper around R <code>brms::brm()</code> that returns a structured <code>FitResult</code> (including an ArviZ <code>InferenceData</code>).</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula. Accepts a plain brms formula string (e.g. <code>\"y ~ x + (1|g)\"</code>) or a composed formula created via <code>brmspy.brms.bf()</code> / <code>brmspy.brms.lf()</code> (typically imported as <code>from brmspy.brms import bf, lf</code>).</p> required <code>data</code> <code>dict or DataFrame</code> <p>Model data.</p> required <code>priors</code> <code>Sequence[PriorSpec] or None</code> <p>Optional prior specifications created via <code>brmspy.brms.prior()</code>.</p> <code>None</code> <code>family</code> <code>str or ListSexpVector or None</code> <p>brms family specification (e.g. <code>\"gaussian\"</code>, <code>\"poisson\"</code>).</p> <code>\"gaussian\"</code> <code>sample_prior</code> <code>str</code> <p>Passed to brms. Common values: <code>\"no\"</code>, <code>\"yes\"</code>, <code>\"only\"</code>.</p> <code>\"no\"</code> <code>sample</code> <code>bool</code> <p>If <code>False</code>, compile the model without sampling (brms <code>empty=TRUE</code>).</p> <code>True</code> <code>backend</code> <code>str</code> <p>Stan backend. Common values: <code>\"cmdstanr\"</code> or <code>\"rstan\"</code>.</p> <code>\"cmdstanr\"</code> <code>formula_args</code> <code>dict or None</code> <p>Reserved for future use. Currently ignored.</p> <code>None</code> <code>cores</code> <code>int or None</code> <p>Number of cores for brms/cmdstanr.</p> <code>2</code> <code>return_idata</code> <code>bool</code> <p>When working with large datasets, you might not want the full idata. when False, you get the R object proxy which can be forwarded to posterior_epred or other functions</p> <code>True</code> <code>**brm_args</code> <p>Additional keyword arguments passed to R <code>brms::brm()</code> (e.g. <code>chains</code>, <code>iter</code>, <code>warmup</code>, <code>seed</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Result object with <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::brm : R documentation</p> Warnings <p>Using <code>cores &lt;= 1</code> can be unstable in embedded R sessions and may crash the worker process. Prefer <code>cores &gt;= 2</code>.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x + (1|g)\", data=df, family=\"gaussian\", chains=4, cores=4)\n\nfit.idata.posterior\n</code></pre>"},{"location":"api/brms/#brmspy.brms.summary","title":"<code>summary(model, **kwargs)</code>","text":"<p>Generate comprehensive summary statistics for a fitted brms model.</p> <p>Returns a <code>SummaryResult</code> dataclass containing model information, parameter estimates, and diagnostic information. The SummaryResult object provides pretty printing via <code>str()</code> or <code>print()</code> and structured access to all components.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code>.</p> required <code>**kwargs</code> <p>Additional arguments passed to brms::summary(), such as: - probs: Quantiles for credible intervals, e.g., <code>probs=(0.025, 0.975)</code> - robust: Use robust estimates (median, MAD), default False</p> <code>{}</code> <p>Returns:</p> Type Description <code>SummaryResult</code> <p>A dataclass containing:</p> <ul> <li>formula (str): Model formula as string</li> <li>data_name (str): Name of the data object used</li> <li>group (str): Grouping structure information</li> <li>nobs (int): Number of observations</li> <li>ngrps (Dict[str, int]): Number of groups per grouping variable</li> <li>autocor (Optional[dict]): Autocorrelation structure if present</li> <li>prior (pd.DataFrame): Prior specifications used</li> <li>algorithm (str): Sampling algorithm (e.g., \"sampling\")</li> <li>sampler (str): Sampler specification (e.g., \"sample(hmc)\")</li> <li>total_ndraws (int): Total number of post-warmup draws</li> <li>chains (float): Number of chains</li> <li>iter (float): Iterations per chain</li> <li>warmup (float): Warmup iterations per chain</li> <li>thin (float): Thinning interval</li> <li>has_rhat (bool): Whether Rhat diagnostics are reported</li> <li>fixed (pd.DataFrame): Population-level (fixed) effects estimates</li> <li>spec_pars (pd.DataFrame): Family-specific parameters (e.g., sigma)</li> <li>cor_pars (pd.DataFrame): Correlation parameters if present</li> <li>random (dict): Group-level (random) effects by grouping variable</li> </ul> See Also <p>brms::summary.brmsfit : R documentation</p> <p>Examples:</p> <p>Basic usage with pretty printing:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x\", data=data, chains=4)\nsummary = brmspy.summary(model)\n\n# Pretty print full summary\nprint(summary)\n</code></pre> <p>Access specific components:</p> <pre><code># Get population-level effects as DataFrame\nfixed_effects = summary.fixed\nprint(fixed_effects)\n\n# Get family-specific parameters (e.g., sigma)\nspec_params = summary.spec_pars\nprint(spec_params)\n\n# Access random effects (if present)\nrandom_effects = summary.random\nfor group_name, group_df in random_effects.items():\n    print(f\"Random effects for {group_name}:\")\n    print(group_df)\n\n# Check model metadata\nprint(f\"Formula: {summary.formula}\")\nprint(f\"Total draws: {summary.total_ndraws}\")\nprint(f\"Rhat reported: {summary.has_rhat}\")\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Use 90% credible intervals instead of default 95%\nsummary_90 = brmspy.summary(model, probs=(0.05, 0.95))\nprint(summary_90.fixed)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.fixef","title":"<code>fixef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, **kwargs)</code>","text":"<p>Extract population-level (fixed) effects estimates from a fitted brms model.</p> <p>Returns a pandas DataFrame containing estimates and uncertainty intervals for all population-level parameters (fixed effects). By default, returns summary statistics (mean, standard error, credible intervals). Can also return raw posterior samples when <code>summary=False</code>.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListSexpVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>summary</code> <code>bool</code> <p>If True, return summary statistics (mean/median, SE/MAD, credible intervals). If False, return matrix of posterior samples (iterations \u00d7 parameters).</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics. Only used when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>list of str</code> <p>Specific parameter names to extract. If None, returns all fixed effects. Useful for subsetting when you only need specific coefficients.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::fixef()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>When <code>summary=True</code> (default):     DataFrame with parameters as rows and columns for Estimate, Est.Error,     Q2.5, Q97.5 (or other quantiles specified in <code>probs</code>), and optionally     Rhat and Bulk_ESS/Tail_ESS diagnostics.</p> <p>When <code>summary=False</code>:     DataFrame with posterior samples where rows are iterations and columns     are parameters. Shape is (n_iterations \u00d7 n_parameters).</p> See Also <p>brms::fixef.brmsfit : R documentation summary() : Full model summary with all parameter types</p> <p>Examples:</p> <p>Basic usage with summary statistics:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=data, chains=4)\n\n# Get fixed effects summary\nfixed_effects = brmspy.fixef(model)\nprint(fixed_effects)\n#             Estimate  Est.Error      Q2.5     Q97.5\n# Intercept  10.234567   0.123456  9.992345  10.47689\n# x1          0.456789   0.098765  0.263456   0.65012\n# x2         -0.234567   0.087654 -0.406789  -0.06234\n</code></pre> <p>Get specific parameters only:</p> <pre><code># Extract only specific coefficients\nx1_x2_effects = brmspy.fixef(model, pars=[\"x1\", \"x2\"])\nprint(x1_x2_effects)\n</code></pre> <p>Use robust estimates (median and MAD):</p> <pre><code># Use median and MAD instead of mean and SD\nrobust_effects = brmspy.fixef(model, robust=True)\nprint(robust_effects)\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Get 90% credible intervals\neffects_90 = brmspy.fixef(model, probs=(0.05, 0.95))\nprint(effects_90)\n</code></pre> <p>Get raw posterior samples:</p> <pre><code># Get full posterior samples matrix\nsamples = brmspy.fixef(model, summary=False)\nprint(samples.shape)  # (n_iterations, n_parameters)\n\n# Can then compute custom statistics\nimport numpy as np\ncustom_quantile = np.percentile(samples[\"x1\"], 90)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.ranef","title":"<code>ranef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, groups=None, **kwargs)</code>","text":"<p>Extract group-level (random) effects as xarray DataArrays.</p> <p>This is a wrapper around <code>brms::ranef()</code>. For <code>summary=True</code> (default), each grouping factor is returned as a 3D array with dimensions <code>(\"group\", \"stat\", \"coef\")</code>. For <code>summary=False</code>, each factor is returned as <code>(\"draw\", \"group\", \"coef\")</code> with one slice per posterior draw.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model returned by :func:<code>brmspy.brms.fit</code> or an R <code>brmsfit</code> object / summary list.</p> required <code>summary</code> <code>bool</code> <p>If True, return posterior summaries for the group-level effects (means, errors, intervals). If False, return per-draw random effects.</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use robust summaries (median and MAD) instead of mean and SD. Passed through to <code>brms::ranef()</code> when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Central posterior interval probabilities, as in <code>brms::ranef()</code>. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>str or sequence of str</code> <p>Subset of group-level parameters to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>groups</code> <code>str or sequence of str</code> <p>Subset of grouping factors to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments forwarded to <code>brms::ranef()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, DataArray]</code> <p>Mapping from grouping-factor name (e.g. <code>\"patient\"</code>) to a <code>DataArray</code>:</p> <ul> <li><code>summary=True</code>: dims <code>(\"group\", \"stat\", \"coef\")</code>,   with <code>stat</code> typically containing   <code>[\"Estimate\", \"Est.Error\", \"Q2.5\", \"Q97.5\"]</code>.</li> <li><code>summary=False</code>: dims <code>(\"draw\", \"group\", \"coef\")</code>,   where <code>draw</code> indexes posterior samples.</li> </ul> <p>Examples:</p> <p>Compute summary random effects and inspect all coefficients for a single group level:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms import ranef\n\nfit = brms.fit(\"count ~ zAge + zBase * Trt + (1 + zBase + Trt | patient)\",\n               data=data, family=\"poisson\")\n\nre = ranef(fit)  # summary=True by default\npatient_re = re[\"patient\"].sel(group=\"1\", stat=\"Estimate\")\n</code></pre> <p>Extract per-draw random effects for downstream MCMC analysis:</p> <pre><code>re_draws = ranef(fit, summary=False)\npatient_draws = re_draws[\"patient\"]       # dims: (\"draw\", \"group\", \"coef\")\nfirst_draw = patient_draws.sel(draw=0)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.posterior_summary","title":"<code>posterior_summary(object, variable=None, probs=(0.025, 0.975), robust=False, **kwargs)</code>","text":"<p>Extract posterior summary statistics for all or selected model parameters.</p> <p>Provides a DataFrame with estimates, standard errors, and credible intervals for all parameters in a brms model, including fixed effects, random effects, and auxiliary parameters. More comprehensive than <code>fixef()</code> or <code>ranef()</code> as it covers all parameter types.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListSexpVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>variable</code> <code>str or list of str</code> <p>Specific variable name(s) to extract. If None, returns all parameters. Supports regex patterns for flexible selection.</p> <code>None</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals.</p> <code>(0.025, 0.975)</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments passed to brms::posterior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with parameters as rows and columns for Estimate, Est.Error, and quantiles (e.g., Q2.5, Q97.5). Includes all model parameters: population-level effects, group-level effects, and auxiliary parameters.</p> See Also <p>brms::posterior_summary : R documentation     https://paulbuerkner.com/brms/reference/posterior_summary.brmsfit.html fixef() : Extract only population-level effects ranef() : Extract only group-level effects</p> <p>Examples:</p> <p>Get summary for all parameters:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + (1|group)\", data=data, chains=4)\n\n# Get all parameter summaries\nall_params = brmspy.posterior_summary(model)\nprint(all_params)\n</code></pre> <p>Extract specific parameters:</p> <pre><code># Get summary for specific parameters\nintercept = brmspy.posterior_summary(model, variable=\"b_Intercept\")\nprint(intercept)\n\n# Multiple parameters\nfixed_only = brmspy.posterior_summary(model, variable=[\"b_Intercept\", \"b_x1\"])\nprint(fixed_only)\n</code></pre> <p>Custom credible intervals with robust estimates:</p> <pre><code># 90% intervals with median/MAD\nrobust_summary = brmspy.posterior_summary(\n    model,\n    probs=(0.05, 0.95),\n    robust=True\n)\nprint(robust_summary)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.prior_summary","title":"<code>prior_summary(object, all=True, **kwargs)</code>","text":"<p>Extract prior specifications used in a fitted brms model.</p> <p>Returns a DataFrame containing all prior distributions that were used (either explicitly set or defaults) when fitting the model. Useful for documenting model specifications and understanding which priors were applied.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>all</code> <code>bool</code> <p>If True, return all priors including default priors. If False, return only explicitly set priors.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to brms::prior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns describing prior specifications: - prior: Prior distribution formula - class: Parameter class (b, sd, Intercept, etc.) - coef: Specific coefficient (if applicable) - group: Grouping factor (if applicable) - resp: Response variable (for multivariate models) - dpar: Distributional parameter (if applicable) - nlpar: Non-linear parameter (if applicable) - lb/ub: Bounds for truncated priors - source: Origin of prior (default, user, etc.)</p> See Also <p>brms::prior_summary : R documentation     https://paulbuerkner.com/brms/reference/prior_summary.brmsfit.html get_prior() : Get prior structure before fitting default_prior() : Get default priors for a model</p> <p>Examples:</p> <p>Get all priors used in a model:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\n    \"y ~ x1 + (1|group)\",\n    data=data,\n    priors=[brmspy.prior(\"normal(0, 1)\", \"b\")],\n    chains=4\n)\n\n# Get all priors (including defaults)\npriors = brmspy.prior_summary(model)\nprint(priors)\n</code></pre> <p>Get only explicitly set priors:</p> <pre><code># Get only user-specified priors\nuser_priors = brmspy.prior_summary(model, all=False)\nprint(user_priors)\n</code></pre> <p>Compare with what would be used before fitting:</p> <pre><code># Before fitting - check default priors\ndefault_priors = brmspy.get_prior(\"y ~ x1\", data=data)\n\n# After fitting - see what was actually used\nused_priors = brmspy.prior_summary(model)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.validate_newdata","title":"<code>validate_newdata(newdata, object, re_formula=None, allow_new_levels=False, newdata2=None, resp=None, check_response=True, incl_autocor=True, group_vars=None, req_vars=None, **kwargs)</code>","text":"<p>Validate new data for predictions from a fitted brms model.</p> <p>Ensures that new data contains all required variables and has the correct structure for making predictions. Checks variable types, factor levels, grouping variables, and autocorrelation structures. This function is primarily used internally by prediction methods but can be called directly for debugging or validation purposes.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>DataFrame</code> <p>DataFrame containing new data to be validated against the model. Must include all predictor variables used in the model formula.</p> required <code>object</code> <code>FitResult or ListSexpVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>re_formula</code> <code>str</code> <p>Formula string specifying group-level effects to include in validation. If None (default), include all group-level effects. If NA, include no group-level effects.</p> <code>None</code> <code>allow_new_levels</code> <code>bool</code> <p>Whether to allow new levels of grouping variables not present in the original training data. If False, raises an error for new levels.</p> <code>False</code> <code>newdata2</code> <code>DataFrame</code> <p>Additional data that cannot be passed via <code>newdata</code>, such as objects used in autocorrelation structures or stanvars.</p> <code>None</code> <code>resp</code> <code>str or list of str</code> <p>Names of response variables to validate. If specified, validation is performed only for the specified responses (relevant for multivariate models).</p> <code>None</code> <code>check_response</code> <code>bool</code> <p>Whether to check if response variables are present in newdata. Set to False when making predictions where response is not needed.</p> <code>True</code> <code>incl_autocor</code> <code>bool</code> <p>Whether to include autocorrelation structures originally specified in the model. If True, validates autocorrelation-related variables.</p> <code>True</code> <code>group_vars</code> <code>list of str</code> <p>Names of specific grouping variables to validate. If None (default), validates all grouping variables present in the model.</p> <code>None</code> <code>req_vars</code> <code>list of str</code> <p>Names of specific variables required in newdata. If None (default), all variables from the original training data are required (unless excluded by other parameters).</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::validate_newdata()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Validated DataFrame based on newdata, potentially with added or modified columns to ensure compatibility with the model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If newdata is missing required variables</p> <code>ValueError</code> <p>If factor levels in newdata don't match those in training data (when allow_new_levels=False)</p> <code>ValueError</code> <p>If grouping variables have invalid structure</p> See Also <p>brms::validate_newdata : R documentation     https://paulbuerkner.com/brms/reference/validate_newdata.html posterior_predict() : Uses validate_newdata internally posterior_epred() : Uses validate_newdata internally</p> <p>Examples:</p> <p>Basic validation for prediction data:</p> <pre><code>import brmspy\nimport pandas as pd\n\n# Fit model\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=train_data, chains=4)\n\n# Prepare new data\nnew_data = pd.DataFrame({\n    'x1': [1.0, 2.0, 3.0],\n    'x2': [0.5, 1.0, 1.5]\n})\n\n# Validate before prediction\nvalidated_data = brmspy.validate_newdata(new_data, model)\nprint(validated_data)\n</code></pre> <p>Validate with group-level effects:</p> <pre><code># Model with random effects\nmodel = brmspy.fit(\"y ~ x + (1|group)\", data=train_data, chains=4)\n\n# New data with grouping variable\nnew_data = pd.DataFrame({\n    'x': [1.0, 2.0],\n    'group': ['A', 'B']  # Must match training data groups\n})\n\n# Validate - will error if groups A or B weren't in training\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    allow_new_levels=False\n)\n</code></pre> <p>Allow new levels for population-level predictions:</p> <pre><code># Allow new group levels (makes population-level predictions only)\nnew_data_with_new_groups = pd.DataFrame({\n    'x': [3.0, 4.0],\n    'group': ['C', 'D']  # New groups not in training\n})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data_with_new_groups,\n    model,\n    allow_new_levels=True\n)\n</code></pre> <p>Skip response variable checking:</p> <pre><code># When making predictions, response not needed\nnew_data = pd.DataFrame({'x1': [1.0, 2.0]})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    check_response=False\n)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.call","title":"<code>call(function, *args, **kwargs)</code>","text":"<p>Call an R function by name with brmspy type conversion.</p> <p>This is intended as an escape hatch for R/brms functionality that does not yet have a dedicated wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Function name. If not namespaced, brmspy tries <code>brms::&lt;function&gt;</code> first, then falls back to evaluating the name directly (e.g. <code>\"stats::AIC\"</code>).</p> required <code>*args</code> <p>Positional arguments.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Converted return value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; fit = brms.brm(\"y ~ x\", data=df, chains=4)\n&gt;&gt;&gt; aic = brms.call(\"stats::AIC\", fit)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.bf","title":"<code>bf(*formulas, **formula_args)</code>","text":"<p>Build a brms model formula.</p> <p>This is the primary entrypoint for specifying the mean model and can be combined with other formula parts (e.g. <code>lf</code>, <code>nlf</code>, <code>acformula</code>) using <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str</code> <p>One or more brms formula strings (e.g. <code>\"y ~ x + (1|group)\"</code>). Multiple formulas are commonly used for multivariate models.</p> <code>()</code> <code>**formula_args</code> <p>Keyword arguments forwarded to R <code>brms::brmsformula()</code> (for example <code>decomp=\"QR\"</code>, <code>center=True</code>, <code>sparse=True</code>, <code>nl=True</code>, <code>loop=True</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::brmsformula : R documentation</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>QR decomposition (often helps with collinearity):</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"reaction ~ days + (days|subject)\", decomp=\"QR\")\n</code></pre> <p>Multivariate formula + residual correlation:</p> <pre><code>from brmspy.brms import bf, set_rescor\n\nf = bf(\"mvbind(y1, y2) ~ x\") + set_rescor(True)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.lf","title":"<code>lf(*formulas, flist=None, dpar=None, resp=None, center=None, cmc=None, sparse=None, decomp=None)</code>","text":"<p>Add linear formulas for distributional / non-linear parameters.</p> <p>This wraps R <code>brms::lf()</code> and is typically used to model distributional parameters such as <code>sigma</code> (heteroskedasticity) or to specify predictors for non-linear parameters.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str | FormulaConstruct | FormulaPart | ProxyListSexpVector</code> <p>One or more formulas such as <code>\"sigma ~ x\"</code>.</p> <code>()</code> <code>flist</code> <p>Optional list of formulas (advanced; mirrors brms).</p> <code>None</code> <code>dpar</code> <code>str or None</code> <p>Distributional parameter name (e.g. <code>\"sigma\"</code>, <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <code>center</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <code>cmc</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <code>sparse</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <code>decomp</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification that can be combined using <code>+</code>.</p> See Also <p>brms::lf : R documentation</p> <p>Examples:</p> <p>Model mean + sigma:</p> <pre><code>from brmspy.brms import bf, lf\n\nf = bf(\"y ~ x\") + lf(\"sigma ~ x\", dpar=\"sigma\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.nlf","title":"<code>nlf(*formulas, flist=None, dpar=None, resp=None, loop=None)</code>","text":"<p>Add non-linear formulas.</p> <p>Wraps R <code>brms::nlf()</code>. This is used together with <code>set_nl()</code> and parameter definitions in <code>lf()</code> to specify non-linear models.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str | FormulaConstruct | FormulaPart | ProxyListSexpVector</code> <p>One or more non-linear formulas (e.g. <code>\"y ~ a * exp(b * x)\"</code>).</p> <code>()</code> <code>flist</code> <p>Optional list of formulas (advanced; mirrors brms).</p> <code>None</code> <code>dpar</code> <code>str or None</code> <p>Distributional parameter name (optional).</p> <code>None</code> <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <code>loop</code> <code>bool or None</code> <p>Forwarded to R <code>brms::nlf(loop=...)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::nlf : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, nlf, set_nl\n\nf = bf(\"y ~ 1\") + nlf(\"y ~ a * exp(b * x)\") + set_nl()\n</code></pre>"},{"location":"api/brms/#brmspy.brms.acformula","title":"<code>acformula(autocor, resp=None)</code>","text":"<p>Add an autocorrelation structure.</p> <p>Wraps R <code>brms::acformula()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>autocor</code> <code>str</code> <p>One-sided autocorrelation formula (e.g. <code>\"~ arma(p = 1, q = 1)\"</code>).</p> required <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::acformula : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, acformula\n\nf = bf(\"y ~ x\") + acformula(\"~ arma(p = 1, q = 1)\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.set_rescor","title":"<code>set_rescor(rescor=True)</code>","text":"<p>Control residual correlations in multivariate models.</p> <p>Wraps R <code>brms::set_rescor()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rescor</code> <code>bool</code> <p>Whether to model residual correlations.</p> <code>True</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::set_rescor : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, set_rescor\n\nf = bf(\"y1 ~ x\") + bf(\"y2 ~ z\") + set_rescor(True)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.set_mecor","title":"<code>set_mecor(mecor=True)</code>","text":"<p>Control correlations between latent <code>me()</code> terms.</p> <p>Wraps R <code>brms::set_mecor()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mecor</code> <code>bool</code> <p>Whether to model correlations between latent variables introduced by <code>me()</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::set_mecor : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, set_mecor\n\nf = bf(\"y ~ me(x, sdx)\") + set_mecor(True)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.set_nl","title":"<code>set_nl(dpar=None, resp=None)</code>","text":"<p>Mark a model (or part of it) as non-linear.</p> <p>Wraps R <code>brms::set_nl()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dpar</code> <code>str or None</code> <p>Distributional parameter name (if only part of the model is non-linear).</p> <code>None</code> <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::set_nl : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, lf, set_nl\n\nf = bf(\"y ~ a * inv_logit(x * b)\") + lf(\"a + b ~ z\") + set_nl()\n</code></pre>"},{"location":"api/brms/#brmspy.brms.formula","title":"<code>formula(*formulas, **formula_args)</code>","text":"<p>Build a brms model formula.</p> <p>This is the primary entrypoint for specifying the mean model and can be combined with other formula parts (e.g. <code>lf</code>, <code>nlf</code>, <code>acformula</code>) using <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str</code> <p>One or more brms formula strings (e.g. <code>\"y ~ x + (1|group)\"</code>). Multiple formulas are commonly used for multivariate models.</p> <code>()</code> <code>**formula_args</code> <p>Keyword arguments forwarded to R <code>brms::brmsformula()</code> (for example <code>decomp=\"QR\"</code>, <code>center=True</code>, <code>sparse=True</code>, <code>nl=True</code>, <code>loop=True</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::brmsformula : R documentation</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>QR decomposition (often helps with collinearity):</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"reaction ~ days + (days|subject)\", decomp=\"QR\")\n</code></pre> <p>Multivariate formula + residual correlation:</p> <pre><code>from brmspy.brms import bf, set_rescor\n\nf = bf(\"mvbind(y1, y2) ~ x\") + set_rescor(True)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.posterior_epred","title":"<code>posterior_epred(model, newdata=None, **kwargs)</code>","text":"<pre><code>posterior_epred(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None) -&gt; IDResult[IDPosterior]\n</code></pre><pre><code>posterior_epred(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame) -&gt; IDResult[IDPredictions]\n</code></pre> <p>Compute expected posterior predictions (noise-free).</p> <p>Wrapper around R <code>brms::posterior_epred()</code>. This returns draws of the expected value (typically on the response scale), without observation noise.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data for predictions. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::posterior_epred()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorEpredResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::posterior_epred : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nep = brms.posterior_epred(fit)\n\nep.idata.posterior\n</code></pre>"},{"location":"api/brms/#brmspy.brms.posterior_linpred","title":"<code>posterior_linpred(model, newdata=None, **kwargs)</code>","text":"<pre><code>posterior_linpred(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None, **kwargs) -&gt; IDResult[IDPosterior]\n</code></pre><pre><code>posterior_linpred(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame, **kwargs) -&gt; IDResult[IDPredictions]\n</code></pre> <p>Draw from the linear predictor.</p> <p>Wrapper around R <code>brms::posterior_linpred()</code>. This typically returns draws on the link scale (before applying the inverse link), unless you pass <code>transform=True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data for predictions. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::posterior_linpred()</code> (commonly <code>transform</code> or <code>ndraws</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorLinpredResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::posterior_linpred : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nlp = brms.posterior_linpred(fit, transform=False)\n\nlp.idata.predictions\n</code></pre>"},{"location":"api/brms/#brmspy.brms.posterior_predict","title":"<code>posterior_predict(model, newdata=None, **kwargs)</code>","text":"<pre><code>posterior_predict(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None, **kwargs) -&gt; IDResult[IDPosteriorPredictive]\n</code></pre><pre><code>posterior_predict(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame, **kwargs) -&gt; IDResult[IDPredictions]\n</code></pre> <p>Draw from the posterior predictive distribution (includes observation noise).</p> <p>Wrapper around R <code>brms::posterior_predict()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data for predictions. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::posterior_predict()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorPredictResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::posterior_predict : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\npp = brms.posterior_predict(fit)\n\npp.idata.posterior_predictive\n</code></pre>"},{"location":"api/brms/#brmspy.brms.log_lik","title":"<code>log_lik(model, newdata=None, **kwargs)</code>","text":"<pre><code>log_lik(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None, **kwargs) -&gt; IDResult[IDLogLikelihoodInsample]\n</code></pre><pre><code>log_lik(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame, **kwargs) -&gt; IDResult[IDLogLikelihoodOutsample]\n</code></pre> <p>Compute pointwise log-likelihood draws.</p> <p>Wrapper around R <code>brms::log_lik()</code>. The result is useful for LOO/WAIC via ArviZ.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::log_lik()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>LogLikResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::log_lik : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nll = brms.log_lik(fit)\n\naz.loo(ll.idata)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.posterior","title":"<code>posterior(model, **kwargs)</code>","text":"<p>Return posterior draws as idata.</p> <p>Wrapper around R <code>posterior::as_draws_df()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>**kwargs</code> <p>Forwarded to <code>posterior::as_draws_df()</code>. e.g inc_warmup, regex, variable</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorEpredResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nep = brms.posterior(fit)\n\nep.idata.posterior\n</code></pre>"},{"location":"api/brms/#brmspy.brms.make_stancode","title":"<code>make_stancode(formula, data, priors=None, family='poisson', sample_prior='no', formula_args=None)</code>","text":"<p>Generate Stan code using R <code>brms::make_stancode()</code>.</p> <p>Useful for inspecting the generated Stan model before fitting.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula.</p> required <code>data</code> <code>DataFrame</code> <p>Model data.</p> required <code>priors</code> <code>Sequence[PriorSpec] or None</code> <p>Optional prior specifications created via <code>brmspy.brms.prior()</code>.</p> <code>None</code> <code>family</code> <code>str</code> <p>Distribution family (e.g. <code>\"gaussian\"</code>, <code>\"poisson\"</code>).</p> <code>\"poisson\"</code> <code>sample_prior</code> <code>str</code> <p>Prior sampling mode passed to brms (<code>\"no\"</code>, <code>\"yes\"</code>, <code>\"only\"</code>).</p> <code>\"no\"</code> <code>formula_args</code> <code>dict or None</code> <p>Reserved for future use. Currently ignored.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Complete Stan program as a string.</p> See Also <p>brms::make_stancode : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\ncode = brms.make_stancode(\n    \"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n)\n\nassert isinstance(code, str)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.brmsfamily","title":"<code>brmsfamily(family, link=None, link_sigma='log', link_shape='log', link_nu='logm1', link_phi='log', link_kappa='log', link_beta='log', link_zi='logit', link_hu='logit', link_zoi='logit', link_coi='logit', link_disc='log', link_bs='log', link_ndt='log', link_bias='logit', link_xi='log1p', link_alpha='identity', link_quantile='logit', threshold='flexible', refcat=None, **kwargs)</code>","text":"<p>Family objects provide a convenient way to specify the details of the models used by many model fitting functions. The family functions presented here are for use with brms only and will not work with other model fitting functions such as glm or glmer. However, the standard family functions as described in family will work with brms.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <p>A character string naming the distribution family of the response variable to be used in the model. Currently, the following families are supported: gaussian, student, binomial, bernoulli, beta-binomial, poisson, negbinomial, geometric, Gamma, skew_normal, lognormal, shifted_lognormal, exgaussian, wiener, inverse.gaussian, exponential, weibull, frechet, Beta, dirichlet, von_mises, asym_laplace, gen_extreme_value, categorical, multinomial, cumulative, cratio, sratio, acat, hurdle_poisson, hurdle_negbinomial, hurdle_gamma, hurdle_lognormal, hurdle_cumulative, zero_inflated_binomial, zero_inflated_beta_binomial, zero_inflated_beta, zero_inflated_negbinomial, zero_inflated_poisson, and zero_one_inflated_beta.</p> required <code>link</code> <code>str | None</code> <p>A specification for the model link function. This can be a name/expression or character string. See the 'Details' section for more information on link functions supported by each family.</p> <code>None</code> <code>link_sigma</code> <code>str</code> <p>Link of auxiliary parameter sigma if being predicted.</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link of auxiliary parameter shape if being predicted.</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link of auxiliary parameter nu if being predicted.</p> <code>'logm1'</code> <code>link_phi</code> <code>str</code> <p>Link of auxiliary parameter phi if being predicted.</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link of auxiliary parameter kappa if being predicted.</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link of auxiliary parameter beta if being predicted.</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link of auxiliary parameter zi if being predicted.</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link of auxiliary parameter hu if being predicted.</p> <code>'logit'</code> <code>link_zoi</code> <code>str</code> <p>Link of auxiliary parameter zoi if being predicted.</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link of auxiliary parameter coi if being predicted.</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link of auxiliary parameter disc if being predicted.</p> <code>'log'</code> <code>link_bs</code> <code>str</code> <p>Link of auxiliary parameter bs if being predicted.</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link of auxiliary parameter ndt if being predicted.</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link of auxiliary parameter bias if being predicted.</p> <code>'logit'</code> <code>link_xi</code> <code>str</code> <p>Link of auxiliary parameter xi if being predicted.</p> <code>'log1p'</code> <code>link_alpha</code> <code>str</code> <p>Link of auxiliary parameter alpha if being predicted.</p> <code>'identity'</code> <code>link_quantile</code> <code>str</code> <p>Link of auxiliary parameter quantile if being predicted.</p> <code>'logit'</code> <code>threshold</code> <code>str</code> <p>A character string indicating the type of thresholds (i.e. intercepts) used in an ordinal model. \"flexible\" provides the standard unstructured thresholds, \"equidistant\" restricts the distance between consecutive thresholds to the same value, and \"sum_to_zero\" ensures the thresholds sum to zero.</p> <code>'flexible'</code> <code>refcat</code> <code>str | None</code> <p>Optional name of the reference response category used in categorical, multinomial, dirichlet and logistic_normal models. If NULL (the default), the first category is used as the reference. If NA, all categories will be predicted, which requires strong priors or carefully specified predictor terms in order to lead to an identified model.</p> <code>None</code>"},{"location":"api/brms/#brmspy.brms.family","title":"<code>family(fit, **kwargs)</code>","text":"<p>Extract family object from a fitted model.</p> <p>Parameters:</p> Name Type Description Default <code>fit</code> <code>FitResult or ListSexpVector</code> <p>Fitted brms model</p> required"},{"location":"api/brms/#brmspy.brms.student","title":"<code>student(link='identity', link_sigma='log', link_nu='logm1', **kwargs)</code>","text":"<p>Student's t distribution for robust regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for degrees of freedom parameter</p> <code>'logm1'</code>"},{"location":"api/brms/#brmspy.brms.bernoulli","title":"<code>bernoulli(link='logit', **kwargs)</code>","text":"<p>Bernoulli distribution for binary 0/1 outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.beta_binomial","title":"<code>beta_binomial(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta-binomial distribution for overdispersed binomial data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.negbinomial","title":"<code>negbinomial(link='log', link_shape='log', **kwargs)</code>","text":"<p>Negative binomial distribution for overdispersed count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.geometric","title":"<code>geometric(link='log', **kwargs)</code>","text":"<p>Geometric distribution for count data (negative binomial with shape=1).</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.lognormal","title":"<code>lognormal(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Lognormal distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean on log scale</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.shifted_lognormal","title":"<code>shifted_lognormal(link='identity', link_sigma='log', link_ndt='log', **kwargs)</code>","text":"<p>Shifted lognormal distribution with non-decision time parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.skew_normal","title":"<code>skew_normal(link='identity', link_sigma='log', link_alpha='identity', **kwargs)</code>","text":"<p>Skew normal distribution for asymmetric continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_alpha</code> <code>str</code> <p>Link function for skewness parameter</p> <code>'identity'</code>"},{"location":"api/brms/#brmspy.brms.exponential","title":"<code>exponential(link='log', **kwargs)</code>","text":"<p>Exponential distribution for time-to-event data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.weibull","title":"<code>weibull(link='log', link_shape='log', **kwargs)</code>","text":"<p>Weibull distribution for survival and reliability analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.frechet","title":"<code>frechet(link='log', link_nu='logm1', **kwargs)</code>","text":"<p>Frechet distribution for extreme value analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'logm1'</code>"},{"location":"api/brms/#brmspy.brms.gen_extreme_value","title":"<code>gen_extreme_value(link='identity', link_sigma='log', link_xi='log1p', **kwargs)</code>","text":"<p>Generalized extreme value distribution for extreme events.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location parameter</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_xi</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log1p'</code>"},{"location":"api/brms/#brmspy.brms.exgaussian","title":"<code>exgaussian(link='identity', link_sigma='log', link_beta='log', **kwargs)</code>","text":"<p>Ex-Gaussian distribution for reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for Gaussian SD parameter</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link function for exponential rate parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.wiener","title":"<code>wiener(link='identity', link_bs='log', link_ndt='log', link_bias='logit', **kwargs)</code>","text":"<p>Wiener diffusion model for two-choice reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for drift rate</p> <code>'identity'</code> <code>link_bs</code> <code>str</code> <p>Link function for boundary separation</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link function for initial bias</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.Beta","title":"<code>Beta(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta distribution for data between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.xbeta","title":"<code>xbeta(link='logit', link_phi='log', link_kappa='log', **kwargs)</code>","text":"<p>Extended beta distribution with additional shape parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link function for kappa shape parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.dirichlet","title":"<code>dirichlet(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms/#brmspy.brms.logistic_normal","title":"<code>logistic_normal(link='identity', link_sigma='log', refcat=None, **kwargs)</code>","text":"<p>Logistic-normal distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms/#brmspy.brms.von_mises","title":"<code>von_mises(link='tan_half', link_kappa='log', **kwargs)</code>","text":"<p>Von Mises distribution for circular/directional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean direction</p> <code>'tan_half'</code> <code>link_kappa</code> <code>str</code> <p>Link function for concentration parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.asym_laplace","title":"<code>asym_laplace(link='identity', link_sigma='log', link_quantile='logit', **kwargs)</code>","text":"<p>Asymmetric Laplace distribution for quantile regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_quantile</code> <code>str</code> <p>Link function for the quantile parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.cox","title":"<code>cox(link='log', **kwargs)</code>","text":"<p>Cox proportional hazards model for survival data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the hazard rate</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.hurdle_poisson","title":"<code>hurdle_poisson(link='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Poisson distribution for zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.hurdle_negbinomial","title":"<code>hurdle_negbinomial(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle negative binomial for overdispersed zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.hurdle_gamma","title":"<code>hurdle_gamma(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Gamma distribution for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.hurdle_lognormal","title":"<code>hurdle_lognormal(link='identity', link_sigma='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle lognormal for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.hurdle_cumulative","title":"<code>hurdle_cumulative(link='logit', link_hu='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Hurdle cumulative for zero-inflated ordinal data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the ordinal response</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms/#brmspy.brms.zero_inflated_beta","title":"<code>zero_inflated_beta(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta for data between 0 and 1 with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.zero_one_inflated_beta","title":"<code>zero_one_inflated_beta(link='logit', link_phi='log', link_zoi='logit', link_coi='logit', **kwargs)</code>","text":"<p>Zero-one-inflated beta for data between 0 and 1 with excess zeros and ones.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zoi</code> <code>str</code> <p>Link function for zero-or-one inflation parameter</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link function for conditional one inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.zero_inflated_poisson","title":"<code>zero_inflated_poisson(link='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated Poisson for count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.zero_inflated_negbinomial","title":"<code>zero_inflated_negbinomial(link='log', link_shape='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated negative binomial for overdispersed count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.zero_inflated_binomial","title":"<code>zero_inflated_binomial(link='logit', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated binomial for binary count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.zero_inflated_beta_binomial","title":"<code>zero_inflated_beta_binomial(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta-binomial for overdispersed binomial data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.categorical","title":"<code>categorical(link='logit', refcat=None, **kwargs)</code>","text":"<p>Categorical distribution for unordered multi-category outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms/#brmspy.brms.multinomial","title":"<code>multinomial(link='logit', refcat=None, **kwargs)</code>","text":"<p>Multinomial distribution for count data across multiple categories.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms/#brmspy.brms.dirichlet_multinomial","title":"<code>dirichlet_multinomial(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet-multinomial for overdispersed categorical count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms/#brmspy.brms.cumulative","title":"<code>cumulative(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Cumulative (proportional odds) model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for cumulative probabilities</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms/#brmspy.brms.sratio","title":"<code>sratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Sequential (stopping) ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for sequential ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms/#brmspy.brms.cratio","title":"<code>cratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Continuation ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for continuation ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms/#brmspy.brms.acat","title":"<code>acat(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Adjacent category model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for adjacent category ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms/#brmspy.brms.gaussian","title":"<code>gaussian(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Gaussian (normal) distribution for continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the standard deviation</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.poisson","title":"<code>poisson(link='log', **kwargs)</code>","text":"<p>Poisson distribution for count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.binomial","title":"<code>binomial(link='logit', **kwargs)</code>","text":"<p>Binomial distribution for binary count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code>"},{"location":"api/brms/#brmspy.brms.Gamma","title":"<code>Gamma(link='log', link_shape='log', **kwargs)</code>","text":"<p>Gamma distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.inverse_gaussian","title":"<code>inverse_gaussian(link='1/mu^2', link_shape='log', **kwargs)</code>","text":"<p>Inverse Gaussian distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'1/mu^2'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms/#brmspy.brms.get_brms_version","title":"<code>get_brms_version()</code>","text":"<p>Get installed brms R package version.</p> <p>Returns:</p> Type Description <code>str</code> <p>Version object or None</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If brms is not installed</p> <p>Examples:</p> <pre><code>from brmspy import brms\nversion = brms.get_brms_version()\nprint(f\"brms version: {version}\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.find_local_runtime","title":"<code>find_local_runtime()</code>","text":"<p>Find an installed runtime matching the current system fingerprint.</p> <p>Uses <code>system_fingerprint()</code> to compute the current system identity and searches the local runtime store for a matching runtime directory.</p> <p>Returns:</p> Type Description <code>Path or None</code> <p>Path to the matching runtime root directory if found, otherwise <code>None</code>.</p> Notes <p>This function is a pure lookup: it does not install, activate, or modify any runtime state.</p>"},{"location":"api/brms/#brmspy.brms.get_active_runtime","title":"<code>get_active_runtime()</code>","text":"<p>Get path to currently active prebuilt runtime.</p> <p>Returns CONFIGURED runtime, not whether it is loaded.</p> <p>Returns:</p> Type Description <code>Path or None</code> <p>Path to active runtime directory, or None if not configured</p> Notes <p>Returns None if: - No runtime configured in config file - Config file doesn't exist - Config file is corrupted</p> <p>Examples:</p> <pre><code>from brmspy import get_active_runtime\n\nruntime_path = get_active_runtime()\nif runtime_path and runtime_path.exists():\n    print(f\"Active runtime: {runtime_path}\")\nelse:\n    print(\"No active runtime configured\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.status","title":"<code>status()</code>","text":"<p>Query current runtime status without side effects.</p> <p>Returns:</p> Type Description <code>RuntimeStatus</code> <p>Dataclass with comprehensive state information including:</p> <ul> <li>Active runtime path and activation state</li> <li>System fingerprint and toolchain info</li> <li>Prebuilt compatibility and availability</li> <li>Installed brms/cmdstanr/rstan versions</li> </ul>"},{"location":"api/diagnostics-arviz/","title":"Diagnostics with ArviZ","text":"<p>This guide covers how to use ArviZ for comprehensive diagnostics with brmspy models. All fitted models return <code>arviz.InferenceData</code> objects by default, enabling seamless integration with ArviZ's extensive diagnostic toolkit.</p> <p>Key Feature: brmspy's InferenceData outputs are in the correct format for both univariate and multivariate models, so any ArviZ analysis function works directly without additional conversion or configuration.</p>"},{"location":"api/diagnostics-arviz/#inferencedata-structure","title":"InferenceData Structure","text":"<p>Each fitted model's <code>.idata</code> attribute contains:</p> <ul> <li>posterior: Parameter samples (population-level effects, group-level effects, etc.)   All parameters retain brms naming conventions (e.g., <code>b_Intercept</code>, <code>b_zAge</code>, <code>sd_patient__Intercept</code>)</li> <li>posterior_predictive: Posterior predictive samples for each response variable</li> <li>log_likelihood: Pointwise log-likelihood values for model comparison (LOO, WAIC)</li> <li>observed_data: Original response variable values</li> <li>coords: Coordinate labels (chain, draw, obs_id) for indexing</li> </ul>"},{"location":"api/diagnostics-arviz/#basic-diagnostics-with-arviz","title":"Basic Diagnostics with ArviZ","text":""},{"location":"api/diagnostics-arviz/#summary-statistics","title":"Summary Statistics","text":"<p>Use <code>az.summary()</code> to get posterior estimates with convergence diagnostics:</p> <pre><code>import brmspy\nimport arviz as az\n\n# Fit model\nmodel = brmspy.fit(\"count ~ zAge + (1|patient)\", data=data, family=\"poisson\")\n\n# Get summary with Rhat and ESS\nsummary = az.summary(model.idata)\nprint(summary)\n#                mean     sd  hdi_3%  hdi_97%  mcse_mean  mcse_sd  ess_bulk  ess_tail  r_hat\n# b_Intercept   1.234  0.123   1.012    1.456      0.002    0.001    3421.0    3012.0   1.00\n# b_zAge        0.567  0.089   0.398    0.732      0.001    0.001    4123.0    3456.0   1.00\n# ...\n</code></pre>"},{"location":"api/diagnostics-arviz/#convergence-diagnostics","title":"Convergence Diagnostics","text":"<p>Check for convergence issues:</p> <pre><code># Rhat values (should be &lt; 1.01)\nrhat = az.rhat(model.idata)\nprint(f\"Max Rhat: {rhat.max().values}\")\n\n# Effective sample size\ness_bulk = az.ess(model.idata, method=\"bulk\")\ness_tail = az.ess(model.idata, method=\"tail\")\nprint(f\"Min bulk ESS: {ess_bulk.min().values}\")\n</code></pre>"},{"location":"api/diagnostics-arviz/#trace-plots","title":"Trace Plots","text":"<p>Visualize MCMC chains:</p> <pre><code># All parameters\naz.plot_trace(model.idata)\n\n# Specific parameters only\naz.plot_trace(model.idata, var_names=[\"b_Intercept\", \"b_zAge\"])\n</code></pre>"},{"location":"api/diagnostics-arviz/#posterior-predictive-checks","title":"Posterior Predictive Checks","text":""},{"location":"api/diagnostics-arviz/#univariate-models","title":"Univariate Models","text":"<p>Use <code>az.plot_ppc()</code> to assess model fit:</p> <pre><code># Basic posterior predictive check\naz.plot_ppc(model.idata)\n\n# With specific number of samples\naz.plot_ppc(model.idata, num_pp_samples=100)\n\n# Different plot types\naz.plot_ppc(model.idata, kind=\"cumulative\")\naz.plot_ppc(model.idata, kind=\"scatter\")\n</code></pre>"},{"location":"api/diagnostics-arviz/#multivariate-models","title":"Multivariate Models","text":"<p>For multivariate models with multiple response variables, specify which response to check using the <code>var_names</code> parameter:</p> <pre><code># Fit multivariate model\nfrom brmspy import bf, set_rescor\n\nmv_model = brmspy.fit(\n    bf(\"mvbind(tarsus, back) ~ sex + (1|p|fosternest)\") + set_rescor(True),\n    data=data\n)\n\n# Check each response separately\naz.plot_ppc(mv_model.idata, var_names=[\"tarsus\"])\naz.plot_ppc(mv_model.idata, var_names=[\"back\"])\n</code></pre>"},{"location":"api/diagnostics-arviz/#model-comparison","title":"Model Comparison","text":""},{"location":"api/diagnostics-arviz/#leave-one-out-cross-validation-loo","title":"Leave-One-Out Cross-Validation (LOO)","text":"<p>Compute LOO information criterion for model comparison:</p> <pre><code># Univariate model\nloo_result = az.loo(model.idata)\nprint(loo_result)\n# Computed from 4000 posterior samples and 100 observations log-likelihood matrix.\n#          Estimate       SE\n# elpd_loo   -234.5      8.2\n# p_loo         12.3      1.1\n# looic        469.0     16.4\n\n# Multivariate model - specify response variable\nloo_tarsus = az.loo(mv_model.idata, var_name=\"tarsus\")\nloo_back = az.loo(mv_model.idata, var_name=\"back\")\n</code></pre>"},{"location":"api/diagnostics-arviz/#waic-widely-applicable-information-criterion","title":"WAIC (Widely Applicable Information Criterion)","text":"<p>Alternative to LOO for model comparison:</p> <pre><code>waic_result = az.waic(model.idata)\nprint(waic_result)\n\n# For multivariate models\nwaic_tarsus = az.waic(mv_model.idata, var_name=\"tarsus\")\n</code></pre>"},{"location":"api/diagnostics-arviz/#comparing-multiple-models","title":"Comparing Multiple Models","text":"<p>Use <code>az.compare()</code> to compare multiple models:</p> <pre><code># Fit competing models\nmodel1 = brmspy.fit(\"y ~ x1\", data=data)\nmodel2 = brmspy.fit(\"y ~ x1 + x2\", data=data)\nmodel3 = brmspy.fit(\"y ~ x1 * x2\", data=data)\n\n# Compare with LOO\ncomparison = az.compare({\n    \"model1\": model1.idata,\n    \"model2\": model2.idata,\n    \"model3\": model3.idata\n}, ic=\"loo\")\n\nprint(comparison)\n#         rank  loo    p_loo   d_loo   weight    se   dse  warning  loo_scale\n# model3     0 -234.5   12.3    0.0    0.72    8.2   0.0    False        log\n# model2     1 -237.8   10.1    3.3    0.24    8.0   2.1    False        log\n# model1     2 -245.2    8.9   10.7    0.04    7.8   4.5    False        log\n\n# Visualize comparison\naz.plot_compare(comparison)\n</code></pre>"},{"location":"api/diagnostics-arviz/#multivariate-model-comparison","title":"Multivariate Model Comparison","text":"<p>For multivariate models, compare each response separately:</p> <pre><code># Fit two multivariate models\nmv_model1 = brmspy.fit(\n    bf(\"mvbind(tarsus, back) ~ sex + (1|p|fosternest)\") + set_rescor(True),\n    data=data\n)\n\nmv_model2 = brmspy.fit(\n    bf(\"mvbind(tarsus, back) ~ sex + hatchdate + (1|p|fosternest)\") + set_rescor(True),\n    data=data\n)\n\n# Compare for 'back' response\ncomparison_back = az.compare(\n    {\"model1\": mv_model1.idata, \"model2\": mv_model2.idata},\n    ic=\"loo\",\n    var_name=\"back\"\n)\nprint(comparison_back)\n\n# Compare for 'tarsus' response\ncomparison_tarsus = az.compare(\n    {\"model1\": mv_model1.idata, \"model2\": mv_model2.idata},\n    ic=\"loo\",\n    var_name=\"tarsus\"\n)\n</code></pre>"},{"location":"api/diagnostics-arviz/#advanced-visualizations","title":"Advanced Visualizations","text":""},{"location":"api/diagnostics-arviz/#posterior-distributions","title":"Posterior Distributions","text":"<p>Visualize parameter posteriors:</p> <pre><code># Forest plot\naz.plot_forest(model.idata, var_names=[\"b\"])\n\n# Posterior densities\naz.plot_posterior(model.idata, var_names=[\"b_Intercept\", \"b_zAge\"])\n\n# With reference values\naz.plot_posterior(\n    model.idata,\n    var_names=[\"b_zAge\"],\n    ref_val=0,  # Add reference line at 0\n    hdi_prob=0.95\n)\n</code></pre>"},{"location":"api/diagnostics-arviz/#pairwise-relationships","title":"Pairwise Relationships","text":"<p>Examine parameter correlations:</p> <pre><code># Pair plot for selected parameters\naz.plot_pair(\n    model.idata,\n    var_names=[\"b_Intercept\", \"b_zAge\"],\n    kind=\"hexbin\"\n)\n\n# Include divergences (if any)\naz.plot_pair(\n    model.idata,\n    var_names=[\"b\"],\n    divergences=True\n)\n</code></pre>"},{"location":"api/diagnostics-arviz/#energy-plots","title":"Energy Plots","text":"<p>Diagnose sampling issues:</p> <pre><code>az.plot_energy(model.idata)\n</code></pre>"},{"location":"api/diagnostics-arviz/#complete-diagnostic-workflow","title":"Complete Diagnostic Workflow","text":"<p>Here's a complete example showing the full diagnostic workflow:</p> <pre><code>from brmspy import brms\nimport arviz as az\nimport matplotlib.pyplot as plt\n\n# Fit model\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    \"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    chains=4,\n    iter=2000\n)\n\n# 1. Check convergence\nprint(az.summary(model.idata))\nassert all(az.rhat(model.idata) &lt; 1.01), \"Convergence issues detected\"\n\n# 2. Visualize chains\naz.plot_trace(model.idata, var_names=[\"b\"])\nplt.tight_layout()\nplt.show()\n\n# 3. Posterior predictive check\naz.plot_ppc(model.idata, num_pp_samples=100)\nplt.show()\n\n# 4. Model comparison\nloo = az.loo(model.idata)\nprint(f\"LOO: {loo.loo:.1f} \u00b1 {loo.loo_se:.1f}\")\n\n# 5. Examine specific parameters\naz.plot_posterior(\n    model.idata,\n    var_names=[\"b_zAge\", \"b_Trt\"],\n    ref_val=0\n)\nplt.show()\n</code></pre>"},{"location":"api/diagnostics-arviz/#notes","title":"Notes","text":""},{"location":"api/diagnostics-arviz/#parameter-naming","title":"Parameter Naming","text":"<p>brmspy preserves brms parameter naming conventions:</p> <ul> <li>Population-level effects: <code>b_Intercept</code>, <code>b_variable_name</code></li> <li>Group-level standard deviations: <code>sd_group__effect</code></li> <li>Correlations: <code>cor_group__effect1__effect2</code></li> <li>Family-specific parameters: <code>sigma</code>, <code>nu</code>, <code>shape</code>, etc.</li> </ul>"},{"location":"api/diagnostics-arviz/#multivariate-models_1","title":"Multivariate Models","text":"<p>When working with multivariate models, remember to specify the <code>var_name</code> parameter in ArviZ functions that operate on response variables (e.g., <code>az.loo()</code>, <code>az.waic()</code>, <code>az.plot_ppc()</code>).</p>"},{"location":"api/diagnostics-arviz/#performance","title":"Performance","text":"<p>For large models or datasets, LOO computation can be slow. Consider using <code>az.loo(..., pointwise=False)</code> or WAIC as alternatives.</p>"},{"location":"api/diagnostics-arviz/#see-also","title":"See Also","text":"<ul> <li>arviz.summary - Posterior summary statistics</li> <li>arviz.loo - Leave-one-out cross-validation</li> <li>arviz.waic - WAIC information criterion</li> <li>arviz.compare - Compare multiple models</li> <li>arviz.plot_ppc - Posterior predictive checks</li> <li>arviz.plot_trace - MCMC trace plots</li> <li>ArviZ Documentation - Complete ArviZ API reference</li> </ul>"},{"location":"api/manage/","title":"Manage/install","text":"<p>Manage brmspy runtimes and R environments.</p> <p>This module defines the surface returned by <code>brmspy.brms.manage()</code>.</p> <p>The file is safe to import in the main Python process (no top-level <code>rpy2.robjects</code> imports). In normal use these methods are invoked through the <code>manage()</code> context, and the actual work executes in the worker process that hosts the embedded R session.</p> <p>Example: <pre><code>env = \"mrp\"\nif not brms.environment_exists(env):\n    with brms.manage(environment_name=env) as ctx:\n        ctx.install_brms(use_prebuilt=True)\n        ctx.install_rpackage(\"MCMCglmm\")\nelse:\n    brms.environment_activate(env)\n</code></pre></p> Notes <ul> <li>Use the context manager to ensure the worker (and its embedded R session) is   started with the desired environment configuration.</li> <li>Calling these methods directly in the main process is unsupported and may   reintroduce the same stability issues that the worker isolation is designed   to avoid.</li> </ul>"},{"location":"api/manage/#brmspy.brms._manage_module-classes","title":"Classes","text":""},{"location":"api/manage/#brmspy.brms._manage_module.ManageModule","title":"<code>ManageModule</code>","text":"<p>Management surface returned by <code>brmspy.brms.manage()</code>.</p> <p>The returned object is a proxy that executes these methods inside the worker process. Use it to install brms/toolchains, manage R packages in the active environment, and query basic runtime state.</p> Notes <p>The worker process must be able to run R and (depending on the installation mode) may require an OS toolchain for compiling packages / CmdStan.</p>"},{"location":"api/manage/#brmspy.brms._manage_module.ManageModule-functions","title":"Functions","text":""},{"location":"api/manage/#brmspy.brms._manage_module.ManageModule.install_runtime","title":"<code>install_runtime(*, install_rtools=False)</code>  <code>staticmethod</code>","text":"<p>Install the prebuilt brmspy runtime bundle.</p> <p>This is a convenience wrapper around <code>install_brms(use_prebuilt=True)</code>. It downloads (if necessary) a precompiled runtime and optionally activates it.</p> <p>Parameters:</p> Name Type Description Default <code>install_rtools</code> <code>bool</code> <p>If <code>True</code>, install Rtools on Windows if missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>Path or None</code> <p>Path to the installed runtime directory (prebuilt mode). Returns <code>None</code> if no runtime was installed (unexpected for prebuilt mode).</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no compatible prebuilt runtime exists for the current platform.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n...     runtime = ctx.install_runtime()\n</code></pre>"},{"location":"api/manage/#brmspy.brms._manage_module.ManageModule.install_brms","title":"<code>install_brms(*, use_prebuilt=False, install_rtools=False, brms_version=None, cmdstanr_version=None, install_rstan=True, install_cmdstanr=True, rstan_version=None, activate=True)</code>  <code>staticmethod</code>","text":"<p>Install brms and its toolchain dependencies.</p> <p>In traditional mode (<code>use_prebuilt=False</code>), this installs into the active R library (typically the active brmspy environment) and may build CmdStan from source.</p> <p>In prebuilt mode (<code>use_prebuilt=True</code>), this downloads a brmspy runtime bundle (R packages + CmdStan) and can activate it.</p> <p>Parameters:</p> Name Type Description Default <code>use_prebuilt</code> <code>bool</code> <p>If <code>True</code>, use a prebuilt runtime bundle instead of installing via R.</p> <code>False</code> <code>install_rtools</code> <code>bool</code> <p>If <code>True</code>, install Rtools on Windows if missing.</p> <code>False</code> <code>brms_version</code> <code>str or None</code> <p>Version spec for the brms R package (traditional mode only). <code>None</code> means \"latest\".</p> <code>None</code> <code>cmdstanr_version</code> <code>str or None</code> <p>Version spec for cmdstanr (traditional mode only). <code>None</code> means \"latest\".</p> <code>None</code> <code>install_rstan</code> <code>bool</code> <p>If <code>True</code>, install rstan (traditional mode).</p> <code>True</code> <code>install_cmdstanr</code> <code>bool</code> <p>If <code>True</code>, install cmdstanr and CmdStan (traditional mode).</p> <code>True</code> <code>rstan_version</code> <code>str or None</code> <p>Version spec for rstan (traditional mode only). <code>None</code> means \"latest\".</p> <code>None</code> <code>activate</code> <code>bool</code> <p>If <code>True</code> and <code>use_prebuilt=True</code>, activate the downloaded runtime in the worker's embedded R session.</p> <code>True</code> <p>Returns:</p> Type Description <code>Path or None</code> <p>If <code>use_prebuilt=True</code>, returns the installed runtime directory. If <code>use_prebuilt=False</code>, returns <code>None</code>.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If installation fails (for example missing toolchain, or no compatible prebuilt runtime exists).</p> <p>Examples:</p> <p>Prebuilt (fast) install:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n...     ctx.install_brms(use_prebuilt=True)\n</code></pre> <p>Traditional (R installs + builds CmdStan):</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n...     ctx.install_brms(use_prebuilt=False, install_cmdstanr=True, install_rstan=False)\n</code></pre>"},{"location":"api/manage/#brmspy.brms._manage_module.ManageModule.install_rpackage","title":"<code>install_rpackage(name, version=None, repos_extra=None)</code>  <code>staticmethod</code>","text":"<p>Install an R package into the active environment library.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>R package name (e.g. <code>\"MCMCglmm\"</code>).</p> required <code>version</code> <code>str or None</code> <p>Optional version spec. <code>None</code> means \"latest\".</p> <code>None</code> <code>repos_extra</code> <code>list[str] or None</code> <p>Extra repositories to add (for example R-universe URLs).</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Notes <p>This installs into the active R library path (usually the brmspy environment library), not into the system R library tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; with brms.manage(environment_name=\"mrp\") as ctx:\n...     ctx.install_rpackage(\"MCMCglmm\")\n</code></pre>"},{"location":"api/manage/#brmspy.brms._manage_module.ManageModule.uninstall_rpackage","title":"<code>uninstall_rpackage(name)</code>  <code>staticmethod</code>","text":"<p>Uninstall an R package from the active library paths.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>R package name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the package appears removed, otherwise <code>False</code>.</p> Notes <p>Package unloading/removal can be OS-dependent (especially on Windows where DLLs may be locked). This function makes a best effort.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; with brms.manage(environment_name=\"mrp\") as ctx:\n...     ok = ctx.uninstall_rpackage(\"MCMCglmm\")\n</code></pre>"},{"location":"api/manage/#brmspy.brms._manage_module.ManageModule.import_rpackages","title":"<code>import_rpackages(*names)</code>  <code>staticmethod</code>","text":"<p>Import (load) one or more R packages into the worker's embedded R session.</p> <p>This does not install packages. Use <code>install_rpackage()</code> first if needed.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>str</code> <p>One or more package names.</p> <code>()</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n...     ctx.import_rpackages(\"brms\", \"cmdstanr\")\n</code></pre>"},{"location":"api/manage/#brmspy.brms._manage_module.ManageModule.is_rpackage_loaded","title":"<code>is_rpackage_loaded(name)</code>  <code>staticmethod</code>","text":"<p>Check whether an R package is loaded in the current R session.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>R package name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the package is loaded (namespace loaded or attached).</p>"},{"location":"api/manage/#brmspy.brms._manage_module.ManageModule.get_rpackage_version","title":"<code>get_rpackage_version(name)</code>  <code>staticmethod</code>","text":"<p>Get installed version of an R package.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>R package name.</p> required <p>Returns:</p> Type Description <code>str or None</code> <p>Installed version string, or <code>None</code> if not installed / not found.</p>"},{"location":"api/manage/#brmspy.brms._manage_module.ManageModule.is_rpackage_installed","title":"<code>is_rpackage_installed(name)</code>  <code>staticmethod</code>","text":"<p>Check whether an R package is installed in the active library paths.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>R package name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if installed, otherwise <code>False</code>.</p>"},{"location":"api/manage/#brmspy.brms._manage_module.ManageModule.get_lib_paths","title":"<code>get_lib_paths()</code>  <code>staticmethod</code>","text":"<p>Get the current R <code>.libPaths()</code> search paths.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>R library search paths (highest priority first).</p>"},{"location":"api/manage/#brmspy.brms._manage_module.ManageModule.get_cmdstan_path","title":"<code>get_cmdstan_path()</code>  <code>staticmethod</code>","text":"<p>Get the current CmdStan path configured in cmdstanr.</p> <p>Returns:</p> Type Description <code>str or None</code> <p>CmdStan directory path, or <code>None</code> if not configured / cmdstanr unavailable.</p>"},{"location":"api/brms_functions/brm/","title":"brm","text":"<p>Model fitting wrappers.</p> <p>This module contains the <code>brms::brm()</code> wrapper used by <code>brmspy.brms.fit()</code> / <code>brmspy.brms.brm()</code>.</p> Notes <p>This code executes inside the worker process (the process that hosts the embedded R session).</p>"},{"location":"api/brms_functions/brm/#brmspy._brms_functions.brm-classes","title":"Classes","text":""},{"location":"api/brms_functions/brm/#brmspy._brms_functions.brm-functions","title":"Functions","text":""},{"location":"api/brms_functions/brm/#brmspy._brms_functions.brm.brm","title":"<code>brm(formula, data, priors=None, family='gaussian', sample_prior='no', sample=True, backend='cmdstanr', formula_args=None, cores=2, *, return_idata=True, **brm_args)</code>","text":"<pre><code>brm(formula: FormulaConstruct | ProxyListSexpVector | str, data: dict | pd.DataFrame, priors: Sequence[PriorSpec] | None = ..., family: str | ListSexpVector | None = ..., sample_prior: str = ..., sample: bool = ..., backend: str = ..., formula_args: dict | None = ..., cores: int | None = ..., *, return_idata: Literal[True] = True, **brm_args: Any) -&gt; FitResult\n</code></pre><pre><code>brm(formula: FormulaConstruct | ProxyListSexpVector | str, data: dict | pd.DataFrame, priors: Sequence[PriorSpec] | None = ..., family: str | ListSexpVector | None = ..., sample_prior: str = ..., sample: bool = ..., backend: str = ..., formula_args: dict | None = ..., cores: int | None = ..., *, return_idata: Literal[False], **brm_args: Any) -&gt; ProxyListSexpVector\n</code></pre> <p>Fit a Bayesian regression model with brms.</p> <p>This is a thin wrapper around R <code>brms::brm()</code> that returns a structured <code>FitResult</code> (including an ArviZ <code>InferenceData</code>).</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula. Accepts a plain brms formula string (e.g. <code>\"y ~ x + (1|g)\"</code>) or a composed formula created via <code>brmspy.brms.bf()</code> / <code>brmspy.brms.lf()</code> (typically imported as <code>from brmspy.brms import bf, lf</code>).</p> required <code>data</code> <code>dict or DataFrame</code> <p>Model data.</p> required <code>priors</code> <code>Sequence[PriorSpec] or None</code> <p>Optional prior specifications created via <code>brmspy.brms.prior()</code>.</p> <code>None</code> <code>family</code> <code>str or ListSexpVector or None</code> <p>brms family specification (e.g. <code>\"gaussian\"</code>, <code>\"poisson\"</code>).</p> <code>\"gaussian\"</code> <code>sample_prior</code> <code>str</code> <p>Passed to brms. Common values: <code>\"no\"</code>, <code>\"yes\"</code>, <code>\"only\"</code>.</p> <code>\"no\"</code> <code>sample</code> <code>bool</code> <p>If <code>False</code>, compile the model without sampling (brms <code>empty=TRUE</code>).</p> <code>True</code> <code>backend</code> <code>str</code> <p>Stan backend. Common values: <code>\"cmdstanr\"</code> or <code>\"rstan\"</code>.</p> <code>\"cmdstanr\"</code> <code>formula_args</code> <code>dict or None</code> <p>Reserved for future use. Currently ignored.</p> <code>None</code> <code>cores</code> <code>int or None</code> <p>Number of cores for brms/cmdstanr.</p> <code>2</code> <code>return_idata</code> <code>bool</code> <p>When working with large datasets, you might not want the full idata. when False, you get the R object proxy which can be forwarded to posterior_epred or other functions</p> <code>True</code> <code>**brm_args</code> <p>Additional keyword arguments passed to R <code>brms::brm()</code> (e.g. <code>chains</code>, <code>iter</code>, <code>warmup</code>, <code>seed</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Result object with <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::brm : R documentation</p> Warnings <p>Using <code>cores &lt;= 1</code> can be unstable in embedded R sessions and may crash the worker process. Prefer <code>cores &gt;= 2</code>.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x + (1|g)\", data=df, family=\"gaussian\", chains=4, cores=4)\n\nfit.idata.posterior\n</code></pre>"},{"location":"api/brms_functions/diagnostics/","title":"diagnostics","text":"<p>Diagnostic functions for brms models with ArviZ integration.</p> <p>This module provides diagnostic functions for analyzing fitted brms models. All fitted models return <code>arviz.InferenceData</code> objects by default through the <code>.idata</code> attribute, enabling seamless integration with ArviZ's diagnostic toolkit.</p> ArviZ Integration <p>brmspy models work directly with ArviZ functions without conversion:</p> <ul> <li>Summary &amp; Convergence: <code>az.summary()</code>, <code>az.rhat()</code>, <code>az.ess()</code></li> <li>Visualization: <code>az.plot_trace()</code>, <code>az.plot_posterior()</code>, <code>az.plot_pair()</code></li> <li>Model Comparison: <code>az.loo()</code>, <code>az.waic()</code>, <code>az.compare()</code></li> <li>Predictive Checks: <code>az.plot_ppc()</code></li> </ul> <p>For multivariate models, use the <code>var_name</code> parameter in ArviZ functions to specify which response variable to analyze (e.g., <code>az.loo(model.idata, var_name=\"y1\")</code>).</p> Quick Example <pre><code>import brmspy\nimport arviz as az\n\n# Fit model\nmodel = brmspy.fit(\"count ~ zAge + (1|patient)\", data=data, family=\"poisson\")\n\n# Diagnostics\nprint(az.summary(model.idata))  # Parameter estimates with Rhat, ESS\naz.plot_trace(model.idata)       # MCMC trace plots\naz.plot_ppc(model.idata)         # Posterior predictive check\n\n# Model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre> See Also <p>Diagnostics with ArviZ : Complete guide with examples     https://kaitumisuuringute-keskus.github.io/brmspy/api/diagnostics-arviz/</p> Notes <p>The InferenceData structure contains:</p> <ul> <li>posterior: All parameter samples with brms naming (e.g., <code>b_Intercept</code>, <code>sd_patient__Intercept</code>)</li> <li>posterior_predictive: Posterior predictive samples for each response</li> <li>log_likelihood: Pointwise log-likelihood for LOO/WAIC</li> <li>observed_data: Original response values</li> </ul>"},{"location":"api/brms_functions/diagnostics/#brmspy._brms_functions.diagnostics-classes","title":"Classes","text":""},{"location":"api/brms_functions/diagnostics/#brmspy._brms_functions.diagnostics-functions","title":"Functions","text":""},{"location":"api/brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.summary","title":"<code>summary(model, **kwargs)</code>","text":"<p>Generate comprehensive summary statistics for a fitted brms model.</p> <p>Returns a <code>SummaryResult</code> dataclass containing model information, parameter estimates, and diagnostic information. The SummaryResult object provides pretty printing via <code>str()</code> or <code>print()</code> and structured access to all components.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code>.</p> required <code>**kwargs</code> <p>Additional arguments passed to brms::summary(), such as: - probs: Quantiles for credible intervals, e.g., <code>probs=(0.025, 0.975)</code> - robust: Use robust estimates (median, MAD), default False</p> <code>{}</code> <p>Returns:</p> Type Description <code>SummaryResult</code> <p>A dataclass containing:</p> <ul> <li>formula (str): Model formula as string</li> <li>data_name (str): Name of the data object used</li> <li>group (str): Grouping structure information</li> <li>nobs (int): Number of observations</li> <li>ngrps (Dict[str, int]): Number of groups per grouping variable</li> <li>autocor (Optional[dict]): Autocorrelation structure if present</li> <li>prior (pd.DataFrame): Prior specifications used</li> <li>algorithm (str): Sampling algorithm (e.g., \"sampling\")</li> <li>sampler (str): Sampler specification (e.g., \"sample(hmc)\")</li> <li>total_ndraws (int): Total number of post-warmup draws</li> <li>chains (float): Number of chains</li> <li>iter (float): Iterations per chain</li> <li>warmup (float): Warmup iterations per chain</li> <li>thin (float): Thinning interval</li> <li>has_rhat (bool): Whether Rhat diagnostics are reported</li> <li>fixed (pd.DataFrame): Population-level (fixed) effects estimates</li> <li>spec_pars (pd.DataFrame): Family-specific parameters (e.g., sigma)</li> <li>cor_pars (pd.DataFrame): Correlation parameters if present</li> <li>random (dict): Group-level (random) effects by grouping variable</li> </ul> See Also <p>brms::summary.brmsfit : R documentation</p> <p>Examples:</p> <p>Basic usage with pretty printing:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x\", data=data, chains=4)\nsummary = brmspy.summary(model)\n\n# Pretty print full summary\nprint(summary)\n</code></pre> <p>Access specific components:</p> <pre><code># Get population-level effects as DataFrame\nfixed_effects = summary.fixed\nprint(fixed_effects)\n\n# Get family-specific parameters (e.g., sigma)\nspec_params = summary.spec_pars\nprint(spec_params)\n\n# Access random effects (if present)\nrandom_effects = summary.random\nfor group_name, group_df in random_effects.items():\n    print(f\"Random effects for {group_name}:\")\n    print(group_df)\n\n# Check model metadata\nprint(f\"Formula: {summary.formula}\")\nprint(f\"Total draws: {summary.total_ndraws}\")\nprint(f\"Rhat reported: {summary.has_rhat}\")\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Use 90% credible intervals instead of default 95%\nsummary_90 = brmspy.summary(model, probs=(0.05, 0.95))\nprint(summary_90.fixed)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.fixef","title":"<code>fixef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, **kwargs)</code>","text":"<p>Extract population-level (fixed) effects estimates from a fitted brms model.</p> <p>Returns a pandas DataFrame containing estimates and uncertainty intervals for all population-level parameters (fixed effects). By default, returns summary statistics (mean, standard error, credible intervals). Can also return raw posterior samples when <code>summary=False</code>.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListSexpVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>summary</code> <code>bool</code> <p>If True, return summary statistics (mean/median, SE/MAD, credible intervals). If False, return matrix of posterior samples (iterations \u00d7 parameters).</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics. Only used when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>list of str</code> <p>Specific parameter names to extract. If None, returns all fixed effects. Useful for subsetting when you only need specific coefficients.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::fixef()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>When <code>summary=True</code> (default):     DataFrame with parameters as rows and columns for Estimate, Est.Error,     Q2.5, Q97.5 (or other quantiles specified in <code>probs</code>), and optionally     Rhat and Bulk_ESS/Tail_ESS diagnostics.</p> <p>When <code>summary=False</code>:     DataFrame with posterior samples where rows are iterations and columns     are parameters. Shape is (n_iterations \u00d7 n_parameters).</p> See Also <p>brms::fixef.brmsfit : R documentation summary() : Full model summary with all parameter types</p> <p>Examples:</p> <p>Basic usage with summary statistics:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=data, chains=4)\n\n# Get fixed effects summary\nfixed_effects = brmspy.fixef(model)\nprint(fixed_effects)\n#             Estimate  Est.Error      Q2.5     Q97.5\n# Intercept  10.234567   0.123456  9.992345  10.47689\n# x1          0.456789   0.098765  0.263456   0.65012\n# x2         -0.234567   0.087654 -0.406789  -0.06234\n</code></pre> <p>Get specific parameters only:</p> <pre><code># Extract only specific coefficients\nx1_x2_effects = brmspy.fixef(model, pars=[\"x1\", \"x2\"])\nprint(x1_x2_effects)\n</code></pre> <p>Use robust estimates (median and MAD):</p> <pre><code># Use median and MAD instead of mean and SD\nrobust_effects = brmspy.fixef(model, robust=True)\nprint(robust_effects)\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Get 90% credible intervals\neffects_90 = brmspy.fixef(model, probs=(0.05, 0.95))\nprint(effects_90)\n</code></pre> <p>Get raw posterior samples:</p> <pre><code># Get full posterior samples matrix\nsamples = brmspy.fixef(model, summary=False)\nprint(samples.shape)  # (n_iterations, n_parameters)\n\n# Can then compute custom statistics\nimport numpy as np\ncustom_quantile = np.percentile(samples[\"x1\"], 90)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.ranef","title":"<code>ranef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, groups=None, **kwargs)</code>","text":"<p>Extract group-level (random) effects as xarray DataArrays.</p> <p>This is a wrapper around <code>brms::ranef()</code>. For <code>summary=True</code> (default), each grouping factor is returned as a 3D array with dimensions <code>(\"group\", \"stat\", \"coef\")</code>. For <code>summary=False</code>, each factor is returned as <code>(\"draw\", \"group\", \"coef\")</code> with one slice per posterior draw.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model returned by :func:<code>brmspy.brms.fit</code> or an R <code>brmsfit</code> object / summary list.</p> required <code>summary</code> <code>bool</code> <p>If True, return posterior summaries for the group-level effects (means, errors, intervals). If False, return per-draw random effects.</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use robust summaries (median and MAD) instead of mean and SD. Passed through to <code>brms::ranef()</code> when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Central posterior interval probabilities, as in <code>brms::ranef()</code>. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>str or sequence of str</code> <p>Subset of group-level parameters to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>groups</code> <code>str or sequence of str</code> <p>Subset of grouping factors to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments forwarded to <code>brms::ranef()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, DataArray]</code> <p>Mapping from grouping-factor name (e.g. <code>\"patient\"</code>) to a <code>DataArray</code>:</p> <ul> <li><code>summary=True</code>: dims <code>(\"group\", \"stat\", \"coef\")</code>,   with <code>stat</code> typically containing   <code>[\"Estimate\", \"Est.Error\", \"Q2.5\", \"Q97.5\"]</code>.</li> <li><code>summary=False</code>: dims <code>(\"draw\", \"group\", \"coef\")</code>,   where <code>draw</code> indexes posterior samples.</li> </ul> <p>Examples:</p> <p>Compute summary random effects and inspect all coefficients for a single group level:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms import ranef\n\nfit = brms.fit(\"count ~ zAge + zBase * Trt + (1 + zBase + Trt | patient)\",\n               data=data, family=\"poisson\")\n\nre = ranef(fit)  # summary=True by default\npatient_re = re[\"patient\"].sel(group=\"1\", stat=\"Estimate\")\n</code></pre> <p>Extract per-draw random effects for downstream MCMC analysis:</p> <pre><code>re_draws = ranef(fit, summary=False)\npatient_draws = re_draws[\"patient\"]       # dims: (\"draw\", \"group\", \"coef\")\nfirst_draw = patient_draws.sel(draw=0)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.posterior_summary","title":"<code>posterior_summary(object, variable=None, probs=(0.025, 0.975), robust=False, **kwargs)</code>","text":"<p>Extract posterior summary statistics for all or selected model parameters.</p> <p>Provides a DataFrame with estimates, standard errors, and credible intervals for all parameters in a brms model, including fixed effects, random effects, and auxiliary parameters. More comprehensive than <code>fixef()</code> or <code>ranef()</code> as it covers all parameter types.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListSexpVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>variable</code> <code>str or list of str</code> <p>Specific variable name(s) to extract. If None, returns all parameters. Supports regex patterns for flexible selection.</p> <code>None</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals.</p> <code>(0.025, 0.975)</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments passed to brms::posterior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with parameters as rows and columns for Estimate, Est.Error, and quantiles (e.g., Q2.5, Q97.5). Includes all model parameters: population-level effects, group-level effects, and auxiliary parameters.</p> See Also <p>brms::posterior_summary : R documentation     https://paulbuerkner.com/brms/reference/posterior_summary.brmsfit.html fixef() : Extract only population-level effects ranef() : Extract only group-level effects</p> <p>Examples:</p> <p>Get summary for all parameters:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + (1|group)\", data=data, chains=4)\n\n# Get all parameter summaries\nall_params = brmspy.posterior_summary(model)\nprint(all_params)\n</code></pre> <p>Extract specific parameters:</p> <pre><code># Get summary for specific parameters\nintercept = brmspy.posterior_summary(model, variable=\"b_Intercept\")\nprint(intercept)\n\n# Multiple parameters\nfixed_only = brmspy.posterior_summary(model, variable=[\"b_Intercept\", \"b_x1\"])\nprint(fixed_only)\n</code></pre> <p>Custom credible intervals with robust estimates:</p> <pre><code># 90% intervals with median/MAD\nrobust_summary = brmspy.posterior_summary(\n    model,\n    probs=(0.05, 0.95),\n    robust=True\n)\nprint(robust_summary)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.prior_summary","title":"<code>prior_summary(object, all=True, **kwargs)</code>","text":"<p>Extract prior specifications used in a fitted brms model.</p> <p>Returns a DataFrame containing all prior distributions that were used (either explicitly set or defaults) when fitting the model. Useful for documenting model specifications and understanding which priors were applied.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>all</code> <code>bool</code> <p>If True, return all priors including default priors. If False, return only explicitly set priors.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to brms::prior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns describing prior specifications: - prior: Prior distribution formula - class: Parameter class (b, sd, Intercept, etc.) - coef: Specific coefficient (if applicable) - group: Grouping factor (if applicable) - resp: Response variable (for multivariate models) - dpar: Distributional parameter (if applicable) - nlpar: Non-linear parameter (if applicable) - lb/ub: Bounds for truncated priors - source: Origin of prior (default, user, etc.)</p> See Also <p>brms::prior_summary : R documentation     https://paulbuerkner.com/brms/reference/prior_summary.brmsfit.html get_prior() : Get prior structure before fitting default_prior() : Get default priors for a model</p> <p>Examples:</p> <p>Get all priors used in a model:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\n    \"y ~ x1 + (1|group)\",\n    data=data,\n    priors=[brmspy.prior(\"normal(0, 1)\", \"b\")],\n    chains=4\n)\n\n# Get all priors (including defaults)\npriors = brmspy.prior_summary(model)\nprint(priors)\n</code></pre> <p>Get only explicitly set priors:</p> <pre><code># Get only user-specified priors\nuser_priors = brmspy.prior_summary(model, all=False)\nprint(user_priors)\n</code></pre> <p>Compare with what would be used before fitting:</p> <pre><code># Before fitting - check default priors\ndefault_priors = brmspy.get_prior(\"y ~ x1\", data=data)\n\n# After fitting - see what was actually used\nused_priors = brmspy.prior_summary(model)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.validate_newdata","title":"<code>validate_newdata(newdata, object, re_formula=None, allow_new_levels=False, newdata2=None, resp=None, check_response=True, incl_autocor=True, group_vars=None, req_vars=None, **kwargs)</code>","text":"<p>Validate new data for predictions from a fitted brms model.</p> <p>Ensures that new data contains all required variables and has the correct structure for making predictions. Checks variable types, factor levels, grouping variables, and autocorrelation structures. This function is primarily used internally by prediction methods but can be called directly for debugging or validation purposes.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>DataFrame</code> <p>DataFrame containing new data to be validated against the model. Must include all predictor variables used in the model formula.</p> required <code>object</code> <code>FitResult or ListSexpVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>re_formula</code> <code>str</code> <p>Formula string specifying group-level effects to include in validation. If None (default), include all group-level effects. If NA, include no group-level effects.</p> <code>None</code> <code>allow_new_levels</code> <code>bool</code> <p>Whether to allow new levels of grouping variables not present in the original training data. If False, raises an error for new levels.</p> <code>False</code> <code>newdata2</code> <code>DataFrame</code> <p>Additional data that cannot be passed via <code>newdata</code>, such as objects used in autocorrelation structures or stanvars.</p> <code>None</code> <code>resp</code> <code>str or list of str</code> <p>Names of response variables to validate. If specified, validation is performed only for the specified responses (relevant for multivariate models).</p> <code>None</code> <code>check_response</code> <code>bool</code> <p>Whether to check if response variables are present in newdata. Set to False when making predictions where response is not needed.</p> <code>True</code> <code>incl_autocor</code> <code>bool</code> <p>Whether to include autocorrelation structures originally specified in the model. If True, validates autocorrelation-related variables.</p> <code>True</code> <code>group_vars</code> <code>list of str</code> <p>Names of specific grouping variables to validate. If None (default), validates all grouping variables present in the model.</p> <code>None</code> <code>req_vars</code> <code>list of str</code> <p>Names of specific variables required in newdata. If None (default), all variables from the original training data are required (unless excluded by other parameters).</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::validate_newdata()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Validated DataFrame based on newdata, potentially with added or modified columns to ensure compatibility with the model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If newdata is missing required variables</p> <code>ValueError</code> <p>If factor levels in newdata don't match those in training data (when allow_new_levels=False)</p> <code>ValueError</code> <p>If grouping variables have invalid structure</p> See Also <p>brms::validate_newdata : R documentation     https://paulbuerkner.com/brms/reference/validate_newdata.html posterior_predict() : Uses validate_newdata internally posterior_epred() : Uses validate_newdata internally</p> <p>Examples:</p> <p>Basic validation for prediction data:</p> <pre><code>import brmspy\nimport pandas as pd\n\n# Fit model\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=train_data, chains=4)\n\n# Prepare new data\nnew_data = pd.DataFrame({\n    'x1': [1.0, 2.0, 3.0],\n    'x2': [0.5, 1.0, 1.5]\n})\n\n# Validate before prediction\nvalidated_data = brmspy.validate_newdata(new_data, model)\nprint(validated_data)\n</code></pre> <p>Validate with group-level effects:</p> <pre><code># Model with random effects\nmodel = brmspy.fit(\"y ~ x + (1|group)\", data=train_data, chains=4)\n\n# New data with grouping variable\nnew_data = pd.DataFrame({\n    'x': [1.0, 2.0],\n    'group': ['A', 'B']  # Must match training data groups\n})\n\n# Validate - will error if groups A or B weren't in training\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    allow_new_levels=False\n)\n</code></pre> <p>Allow new levels for population-level predictions:</p> <pre><code># Allow new group levels (makes population-level predictions only)\nnew_data_with_new_groups = pd.DataFrame({\n    'x': [3.0, 4.0],\n    'group': ['C', 'D']  # New groups not in training\n})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data_with_new_groups,\n    model,\n    allow_new_levels=True\n)\n</code></pre> <p>Skip response variable checking:</p> <pre><code># When making predictions, response not needed\nnew_data = pd.DataFrame({'x1': [1.0, 2.0]})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    check_response=False\n)\n</code></pre>"},{"location":"api/brms_functions/families/","title":"families","text":"<p>Reference: https://paulbuerkner.com/brms/reference/brmsfamily.html</p>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families-classes","title":"Classes","text":""},{"location":"api/brms_functions/families/#brmspy._brms_functions.families-functions","title":"Functions","text":""},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.brmsfamily","title":"<code>brmsfamily(family, link=None, link_sigma='log', link_shape='log', link_nu='logm1', link_phi='log', link_kappa='log', link_beta='log', link_zi='logit', link_hu='logit', link_zoi='logit', link_coi='logit', link_disc='log', link_bs='log', link_ndt='log', link_bias='logit', link_xi='log1p', link_alpha='identity', link_quantile='logit', threshold='flexible', refcat=None, **kwargs)</code>","text":"<p>Family objects provide a convenient way to specify the details of the models used by many model fitting functions. The family functions presented here are for use with brms only and will not work with other model fitting functions such as glm or glmer. However, the standard family functions as described in family will work with brms.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <p>A character string naming the distribution family of the response variable to be used in the model. Currently, the following families are supported: gaussian, student, binomial, bernoulli, beta-binomial, poisson, negbinomial, geometric, Gamma, skew_normal, lognormal, shifted_lognormal, exgaussian, wiener, inverse.gaussian, exponential, weibull, frechet, Beta, dirichlet, von_mises, asym_laplace, gen_extreme_value, categorical, multinomial, cumulative, cratio, sratio, acat, hurdle_poisson, hurdle_negbinomial, hurdle_gamma, hurdle_lognormal, hurdle_cumulative, zero_inflated_binomial, zero_inflated_beta_binomial, zero_inflated_beta, zero_inflated_negbinomial, zero_inflated_poisson, and zero_one_inflated_beta.</p> required <code>link</code> <code>str | None</code> <p>A specification for the model link function. This can be a name/expression or character string. See the 'Details' section for more information on link functions supported by each family.</p> <code>None</code> <code>link_sigma</code> <code>str</code> <p>Link of auxiliary parameter sigma if being predicted.</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link of auxiliary parameter shape if being predicted.</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link of auxiliary parameter nu if being predicted.</p> <code>'logm1'</code> <code>link_phi</code> <code>str</code> <p>Link of auxiliary parameter phi if being predicted.</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link of auxiliary parameter kappa if being predicted.</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link of auxiliary parameter beta if being predicted.</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link of auxiliary parameter zi if being predicted.</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link of auxiliary parameter hu if being predicted.</p> <code>'logit'</code> <code>link_zoi</code> <code>str</code> <p>Link of auxiliary parameter zoi if being predicted.</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link of auxiliary parameter coi if being predicted.</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link of auxiliary parameter disc if being predicted.</p> <code>'log'</code> <code>link_bs</code> <code>str</code> <p>Link of auxiliary parameter bs if being predicted.</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link of auxiliary parameter ndt if being predicted.</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link of auxiliary parameter bias if being predicted.</p> <code>'logit'</code> <code>link_xi</code> <code>str</code> <p>Link of auxiliary parameter xi if being predicted.</p> <code>'log1p'</code> <code>link_alpha</code> <code>str</code> <p>Link of auxiliary parameter alpha if being predicted.</p> <code>'identity'</code> <code>link_quantile</code> <code>str</code> <p>Link of auxiliary parameter quantile if being predicted.</p> <code>'logit'</code> <code>threshold</code> <code>str</code> <p>A character string indicating the type of thresholds (i.e. intercepts) used in an ordinal model. \"flexible\" provides the standard unstructured thresholds, \"equidistant\" restricts the distance between consecutive thresholds to the same value, and \"sum_to_zero\" ensures the thresholds sum to zero.</p> <code>'flexible'</code> <code>refcat</code> <code>str | None</code> <p>Optional name of the reference response category used in categorical, multinomial, dirichlet and logistic_normal models. If NULL (the default), the first category is used as the reference. If NA, all categories will be predicted, which requires strong priors or carefully specified predictor terms in order to lead to an identified model.</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.family","title":"<code>family(fit, **kwargs)</code>","text":"<p>Extract family object from a fitted model.</p> <p>Parameters:</p> Name Type Description Default <code>fit</code> <code>FitResult or ListSexpVector</code> <p>Fitted brms model</p> required"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.student","title":"<code>student(link='identity', link_sigma='log', link_nu='logm1', **kwargs)</code>","text":"<p>Student's t distribution for robust regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for degrees of freedom parameter</p> <code>'logm1'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.bernoulli","title":"<code>bernoulli(link='logit', **kwargs)</code>","text":"<p>Bernoulli distribution for binary 0/1 outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.beta_binomial","title":"<code>beta_binomial(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta-binomial distribution for overdispersed binomial data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.negbinomial","title":"<code>negbinomial(link='log', link_shape='log', **kwargs)</code>","text":"<p>Negative binomial distribution for overdispersed count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.geometric","title":"<code>geometric(link='log', **kwargs)</code>","text":"<p>Geometric distribution for count data (negative binomial with shape=1).</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.lognormal","title":"<code>lognormal(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Lognormal distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean on log scale</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.shifted_lognormal","title":"<code>shifted_lognormal(link='identity', link_sigma='log', link_ndt='log', **kwargs)</code>","text":"<p>Shifted lognormal distribution with non-decision time parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.skew_normal","title":"<code>skew_normal(link='identity', link_sigma='log', link_alpha='identity', **kwargs)</code>","text":"<p>Skew normal distribution for asymmetric continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_alpha</code> <code>str</code> <p>Link function for skewness parameter</p> <code>'identity'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.exponential","title":"<code>exponential(link='log', **kwargs)</code>","text":"<p>Exponential distribution for time-to-event data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.weibull","title":"<code>weibull(link='log', link_shape='log', **kwargs)</code>","text":"<p>Weibull distribution for survival and reliability analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.frechet","title":"<code>frechet(link='log', link_nu='logm1', **kwargs)</code>","text":"<p>Frechet distribution for extreme value analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'logm1'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.gen_extreme_value","title":"<code>gen_extreme_value(link='identity', link_sigma='log', link_xi='log1p', **kwargs)</code>","text":"<p>Generalized extreme value distribution for extreme events.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location parameter</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_xi</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log1p'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.exgaussian","title":"<code>exgaussian(link='identity', link_sigma='log', link_beta='log', **kwargs)</code>","text":"<p>Ex-Gaussian distribution for reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for Gaussian SD parameter</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link function for exponential rate parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.wiener","title":"<code>wiener(link='identity', link_bs='log', link_ndt='log', link_bias='logit', **kwargs)</code>","text":"<p>Wiener diffusion model for two-choice reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for drift rate</p> <code>'identity'</code> <code>link_bs</code> <code>str</code> <p>Link function for boundary separation</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link function for initial bias</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.Beta","title":"<code>Beta(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta distribution for data between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.xbeta","title":"<code>xbeta(link='logit', link_phi='log', link_kappa='log', **kwargs)</code>","text":"<p>Extended beta distribution with additional shape parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link function for kappa shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.dirichlet","title":"<code>dirichlet(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.logistic_normal","title":"<code>logistic_normal(link='identity', link_sigma='log', refcat=None, **kwargs)</code>","text":"<p>Logistic-normal distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.von_mises","title":"<code>von_mises(link='tan_half', link_kappa='log', **kwargs)</code>","text":"<p>Von Mises distribution for circular/directional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean direction</p> <code>'tan_half'</code> <code>link_kappa</code> <code>str</code> <p>Link function for concentration parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.asym_laplace","title":"<code>asym_laplace(link='identity', link_sigma='log', link_quantile='logit', **kwargs)</code>","text":"<p>Asymmetric Laplace distribution for quantile regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_quantile</code> <code>str</code> <p>Link function for the quantile parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.cox","title":"<code>cox(link='log', **kwargs)</code>","text":"<p>Cox proportional hazards model for survival data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the hazard rate</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.hurdle_poisson","title":"<code>hurdle_poisson(link='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Poisson distribution for zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.hurdle_negbinomial","title":"<code>hurdle_negbinomial(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle negative binomial for overdispersed zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.hurdle_gamma","title":"<code>hurdle_gamma(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Gamma distribution for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.hurdle_lognormal","title":"<code>hurdle_lognormal(link='identity', link_sigma='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle lognormal for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.hurdle_cumulative","title":"<code>hurdle_cumulative(link='logit', link_hu='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Hurdle cumulative for zero-inflated ordinal data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the ordinal response</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.zero_inflated_beta","title":"<code>zero_inflated_beta(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta for data between 0 and 1 with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.zero_one_inflated_beta","title":"<code>zero_one_inflated_beta(link='logit', link_phi='log', link_zoi='logit', link_coi='logit', **kwargs)</code>","text":"<p>Zero-one-inflated beta for data between 0 and 1 with excess zeros and ones.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zoi</code> <code>str</code> <p>Link function for zero-or-one inflation parameter</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link function for conditional one inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.zero_inflated_poisson","title":"<code>zero_inflated_poisson(link='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated Poisson for count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.zero_inflated_negbinomial","title":"<code>zero_inflated_negbinomial(link='log', link_shape='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated negative binomial for overdispersed count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.zero_inflated_binomial","title":"<code>zero_inflated_binomial(link='logit', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated binomial for binary count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.zero_inflated_beta_binomial","title":"<code>zero_inflated_beta_binomial(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta-binomial for overdispersed binomial data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.categorical","title":"<code>categorical(link='logit', refcat=None, **kwargs)</code>","text":"<p>Categorical distribution for unordered multi-category outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.multinomial","title":"<code>multinomial(link='logit', refcat=None, **kwargs)</code>","text":"<p>Multinomial distribution for count data across multiple categories.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.dirichlet_multinomial","title":"<code>dirichlet_multinomial(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet-multinomial for overdispersed categorical count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.cumulative","title":"<code>cumulative(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Cumulative (proportional odds) model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for cumulative probabilities</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.sratio","title":"<code>sratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Sequential (stopping) ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for sequential ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.cratio","title":"<code>cratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Continuation ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for continuation ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.acat","title":"<code>acat(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Adjacent category model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for adjacent category ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.gaussian","title":"<code>gaussian(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Gaussian (normal) distribution for continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the standard deviation</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.poisson","title":"<code>poisson(link='log', **kwargs)</code>","text":"<p>Poisson distribution for count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.binomial","title":"<code>binomial(link='logit', **kwargs)</code>","text":"<p>Binomial distribution for binary count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.Gamma","title":"<code>Gamma(link='log', link_shape='log', **kwargs)</code>","text":"<p>Gamma distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy._brms_functions.families.inverse_gaussian","title":"<code>inverse_gaussian(link='1/mu^2', link_shape='log', **kwargs)</code>","text":"<p>Inverse Gaussian distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'1/mu^2'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/formula/","title":"formula","text":"<p>Formula helpers and DSL.</p> <p>This module provides a small Pythonic DSL for composing brms formulas. The public functions (<code>bf</code>, <code>lf</code>, <code>nlf</code>, <code>acformula</code>, <code>set_rescor</code>, <code>set_mecor</code>, <code>set_nl</code>) build a <code>FormulaConstruct</code> that can be passed to <code>brmspy.brms.brm()</code> or combined using the <code>+</code> operator.</p> Notes <ul> <li>The returned objects are lightweight formula specifications; the actual R brms   formula object is built in the worker when fitting / generating Stan code.</li> <li>This module is part of the public API documented under docs/api/brms_functions/formula.md.</li> </ul>"},{"location":"api/brms_functions/formula/#brmspy._brms_functions.formula-classes","title":"Classes","text":""},{"location":"api/brms_functions/formula/#brmspy._brms_functions.formula-functions","title":"Functions","text":""},{"location":"api/brms_functions/formula/#brmspy._brms_functions.formula.bf","title":"<code>bf(*formulas, **formula_args)</code>","text":"<p>Build a brms model formula.</p> <p>This is the primary entrypoint for specifying the mean model and can be combined with other formula parts (e.g. <code>lf</code>, <code>nlf</code>, <code>acformula</code>) using <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str</code> <p>One or more brms formula strings (e.g. <code>\"y ~ x + (1|group)\"</code>). Multiple formulas are commonly used for multivariate models.</p> <code>()</code> <code>**formula_args</code> <p>Keyword arguments forwarded to R <code>brms::brmsformula()</code> (for example <code>decomp=\"QR\"</code>, <code>center=True</code>, <code>sparse=True</code>, <code>nl=True</code>, <code>loop=True</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::brmsformula : R documentation</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>QR decomposition (often helps with collinearity):</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"reaction ~ days + (days|subject)\", decomp=\"QR\")\n</code></pre> <p>Multivariate formula + residual correlation:</p> <pre><code>from brmspy.brms import bf, set_rescor\n\nf = bf(\"mvbind(y1, y2) ~ x\") + set_rescor(True)\n</code></pre>"},{"location":"api/brms_functions/formula/#brmspy._brms_functions.formula.lf","title":"<code>lf(*formulas, flist=None, dpar=None, resp=None, center=None, cmc=None, sparse=None, decomp=None)</code>","text":"<p>Add linear formulas for distributional / non-linear parameters.</p> <p>This wraps R <code>brms::lf()</code> and is typically used to model distributional parameters such as <code>sigma</code> (heteroskedasticity) or to specify predictors for non-linear parameters.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str | FormulaConstruct | FormulaPart | ProxyListSexpVector</code> <p>One or more formulas such as <code>\"sigma ~ x\"</code>.</p> <code>()</code> <code>flist</code> <p>Optional list of formulas (advanced; mirrors brms).</p> <code>None</code> <code>dpar</code> <code>str or None</code> <p>Distributional parameter name (e.g. <code>\"sigma\"</code>, <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <code>center</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <code>cmc</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <code>sparse</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <code>decomp</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification that can be combined using <code>+</code>.</p> See Also <p>brms::lf : R documentation</p> <p>Examples:</p> <p>Model mean + sigma:</p> <pre><code>from brmspy.brms import bf, lf\n\nf = bf(\"y ~ x\") + lf(\"sigma ~ x\", dpar=\"sigma\")\n</code></pre>"},{"location":"api/brms_functions/formula/#brmspy._brms_functions.formula.nlf","title":"<code>nlf(*formulas, flist=None, dpar=None, resp=None, loop=None)</code>","text":"<p>Add non-linear formulas.</p> <p>Wraps R <code>brms::nlf()</code>. This is used together with <code>set_nl()</code> and parameter definitions in <code>lf()</code> to specify non-linear models.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str | FormulaConstruct | FormulaPart | ProxyListSexpVector</code> <p>One or more non-linear formulas (e.g. <code>\"y ~ a * exp(b * x)\"</code>).</p> <code>()</code> <code>flist</code> <p>Optional list of formulas (advanced; mirrors brms).</p> <code>None</code> <code>dpar</code> <code>str or None</code> <p>Distributional parameter name (optional).</p> <code>None</code> <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <code>loop</code> <code>bool or None</code> <p>Forwarded to R <code>brms::nlf(loop=...)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::nlf : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, nlf, set_nl\n\nf = bf(\"y ~ 1\") + nlf(\"y ~ a * exp(b * x)\") + set_nl()\n</code></pre>"},{"location":"api/brms_functions/formula/#brmspy._brms_functions.formula.acformula","title":"<code>acformula(autocor, resp=None)</code>","text":"<p>Add an autocorrelation structure.</p> <p>Wraps R <code>brms::acformula()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>autocor</code> <code>str</code> <p>One-sided autocorrelation formula (e.g. <code>\"~ arma(p = 1, q = 1)\"</code>).</p> required <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::acformula : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, acformula\n\nf = bf(\"y ~ x\") + acformula(\"~ arma(p = 1, q = 1)\")\n</code></pre>"},{"location":"api/brms_functions/formula/#brmspy._brms_functions.formula.set_rescor","title":"<code>set_rescor(rescor=True)</code>","text":"<p>Control residual correlations in multivariate models.</p> <p>Wraps R <code>brms::set_rescor()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rescor</code> <code>bool</code> <p>Whether to model residual correlations.</p> <code>True</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::set_rescor : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, set_rescor\n\nf = bf(\"y1 ~ x\") + bf(\"y2 ~ z\") + set_rescor(True)\n</code></pre>"},{"location":"api/brms_functions/formula/#brmspy._brms_functions.formula.set_mecor","title":"<code>set_mecor(mecor=True)</code>","text":"<p>Control correlations between latent <code>me()</code> terms.</p> <p>Wraps R <code>brms::set_mecor()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mecor</code> <code>bool</code> <p>Whether to model correlations between latent variables introduced by <code>me()</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::set_mecor : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, set_mecor\n\nf = bf(\"y ~ me(x, sdx)\") + set_mecor(True)\n</code></pre>"},{"location":"api/brms_functions/formula/#brmspy._brms_functions.formula.set_nl","title":"<code>set_nl(dpar=None, resp=None)</code>","text":"<p>Mark a model (or part of it) as non-linear.</p> <p>Wraps R <code>brms::set_nl()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dpar</code> <code>str or None</code> <p>Distributional parameter name (if only part of the model is non-linear).</p> <code>None</code> <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::set_nl : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, lf, set_nl\n\nf = bf(\"y ~ a * inv_logit(x * b)\") + lf(\"a + b ~ z\") + set_nl()\n</code></pre>"},{"location":"api/brms_functions/generic/","title":"generic","text":"<p>Generic R function caller.</p> <p>Use <code>call()</code> to invoke R functions by name (including brms functions) when there is no dedicated wrapper in <code>brmspy.brms</code>.</p> Notes <p>Executed inside the worker process that hosts the embedded R session.</p>"},{"location":"api/brms_functions/generic/#brmspy._brms_functions.generic-functions","title":"Functions","text":""},{"location":"api/brms_functions/generic/#brmspy._brms_functions.generic.sanitised_name","title":"<code>sanitised_name(function)</code>","text":"<p>Sanitize a function name for safe R execution.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Function name (optionally namespaced, e.g. <code>\"brms::loo\"</code>).</p> required <p>Returns:</p> Type Description <code>str</code> <p>A sanitized name where invalid characters are replaced with underscores, and where leading digits are avoided (except after a namespace).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sanitised_name(\"my-function\")\n'my_function'\n&gt;&gt;&gt; sanitised_name(\"123func\")\n'_123func'\n</code></pre>"},{"location":"api/brms_functions/generic/#brmspy._brms_functions.generic.call","title":"<code>call(function, *args, **kwargs)</code>","text":"<p>Call an R function by name with brmspy type conversion.</p> <p>This is intended as an escape hatch for R/brms functionality that does not yet have a dedicated wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Function name. If not namespaced, brmspy tries <code>brms::&lt;function&gt;</code> first, then falls back to evaluating the name directly (e.g. <code>\"stats::AIC\"</code>).</p> required <code>*args</code> <p>Positional arguments.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Converted return value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; fit = brms.brm(\"y ~ x\", data=df, chains=4)\n&gt;&gt;&gt; aic = brms.call(\"stats::AIC\", fit)\n</code></pre>"},{"location":"api/brms_functions/io/","title":"io","text":"<p>I/O helpers for brmspy.</p> <p>This module contains helpers for: - loading example datasets from R packages - saving/loading R objects via <code>saveRDS</code> / <code>readRDS</code></p> Notes <p>These functions are executed inside the worker process that hosts the embedded R session.</p>"},{"location":"api/brms_functions/io/#brmspy._brms_functions.io-classes","title":"Classes","text":""},{"location":"api/brms_functions/io/#brmspy._brms_functions.io-functions","title":"Functions","text":""},{"location":"api/brms_functions/io/#brmspy._brms_functions.io.get_data","title":"<code>get_data(dataset_name, **kwargs)</code>","text":"<p>Load an R dataset and return it as a pandas DataFrame.</p> <p>This is a thin wrapper around R's <code>data()</code> that loads the object into the R global environment and converts it to a :class:<code>pandas.DataFrame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Name of the dataset as used in R (e.g. <code>\"BTdata\"</code>).</p> required <code>**kwargs</code> <p>Additional keyword arguments forwarded to R's <code>data()</code> function, for example <code>package=\"MCMCglmm\"</code> or other arguments supported by <code>utils::data()</code> in R.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset converted to a pandas DataFrame.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the dataset is not found in the R global environment after calling <code>data()</code>.</p> <code>RuntimeError</code> <p>If conversion from the R object to a pandas DataFrame fails.</p> See Also <p>get_brms_data     Convenience wrapper for datasets from the <code>brms</code> package.</p>"},{"location":"api/brms_functions/io/#brmspy._brms_functions.io.get_brms_data","title":"<code>get_brms_data(dataset_name, **kwargs)</code>","text":"<p>Load an example dataset from the R <code>brms</code> package.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Dataset name (for example <code>\"epilepsy\"</code> or <code>\"kidney\"</code>).</p> required <code>**kwargs</code> <p>Forwarded to R <code>utils::data()</code> via <code>get_data()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset converted to a DataFrame.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nassert epilepsy.shape[0] &gt; 0\n</code></pre>"},{"location":"api/brms_functions/io/#brmspy._brms_functions.io.save_rds","title":"<code>save_rds(object, file, **kwargs)</code>","text":"<p>Save an R object to an <code>.rds</code> file via R <code>saveRDS()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>RListVectorExtension or ProxyListSexpVector</code> <p>Object to save. If you pass a <code>FitResult</code>, the underlying brmsfit is saved.</p> required <code>file</code> <code>str</code> <p>Output path.</p> required <code>**kwargs</code> <p>Forwarded to R <code>saveRDS()</code> (for example <code>compress=\"xz\"</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.brm(\"y ~ x\", data=df, chains=4)\nbrms.save_rds(model, \"model.rds\")\n</code></pre>"},{"location":"api/brms_functions/io/#brmspy._brms_functions.io.read_rds_raw","title":"<code>read_rds_raw(file, **kwargs)</code>","text":"<p>Load an R object from an <code>.rds</code> file via R <code>readRDS()</code>.</p> <p>This returns the raw R object handle.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Input path.</p> required <code>**kwargs</code> <p>Forwarded to R <code>readRDS()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ListSexpVector</code> <p>Raw R object.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nobj = brms.read_rds_raw(\"model.rds\")\n</code></pre>"},{"location":"api/brms_functions/io/#brmspy._brms_functions.io.read_rds_fit","title":"<code>read_rds_fit(file, **kwargs)</code>","text":"<p>Load a saved brms model from an <code>.rds</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Input path containing a saved brmsfit.</p> required <code>**kwargs</code> <p>Forwarded to R <code>readRDS()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p><code>FitResult</code> containing ArviZ <code>InferenceData</code> and an underlying R handle.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.read_rds_fit(\"model.rds\")\nfit.idata.posterior\n</code></pre>"},{"location":"api/brms_functions/prediction/","title":"prediction","text":"<p>Prediction helpers for brms models.</p> <p>This module wraps brms prediction utilities and returns typed result objects that contain both an ArviZ <code>InferenceData</code> view and the underlying R result.</p> Notes <p>Executed inside the worker process that hosts the embedded R session.</p>"},{"location":"api/brms_functions/prediction/#brmspy._brms_functions.prediction-classes","title":"Classes","text":""},{"location":"api/brms_functions/prediction/#brmspy._brms_functions.prediction-functions","title":"Functions","text":""},{"location":"api/brms_functions/prediction/#brmspy._brms_functions.prediction.posterior","title":"<code>posterior(model, **kwargs)</code>","text":"<p>Return posterior draws as idata.</p> <p>Wrapper around R <code>posterior::as_draws_df()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>**kwargs</code> <p>Forwarded to <code>posterior::as_draws_df()</code>. e.g inc_warmup, regex, variable</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorEpredResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nep = brms.posterior(fit)\n\nep.idata.posterior\n</code></pre>"},{"location":"api/brms_functions/prediction/#brmspy._brms_functions.prediction.posterior_epred","title":"<code>posterior_epred(model, newdata=None, **kwargs)</code>","text":"<pre><code>posterior_epred(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None) -&gt; IDResult[IDPosterior]\n</code></pre><pre><code>posterior_epred(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame) -&gt; IDResult[IDPredictions]\n</code></pre> <p>Compute expected posterior predictions (noise-free).</p> <p>Wrapper around R <code>brms::posterior_epred()</code>. This returns draws of the expected value (typically on the response scale), without observation noise.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data for predictions. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::posterior_epred()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorEpredResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::posterior_epred : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nep = brms.posterior_epred(fit)\n\nep.idata.posterior\n</code></pre>"},{"location":"api/brms_functions/prediction/#brmspy._brms_functions.prediction.posterior_predict","title":"<code>posterior_predict(model, newdata=None, **kwargs)</code>","text":"<pre><code>posterior_predict(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None, **kwargs) -&gt; IDResult[IDPosteriorPredictive]\n</code></pre><pre><code>posterior_predict(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame, **kwargs) -&gt; IDResult[IDPredictions]\n</code></pre> <p>Draw from the posterior predictive distribution (includes observation noise).</p> <p>Wrapper around R <code>brms::posterior_predict()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data for predictions. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::posterior_predict()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorPredictResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::posterior_predict : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\npp = brms.posterior_predict(fit)\n\npp.idata.posterior_predictive\n</code></pre>"},{"location":"api/brms_functions/prediction/#brmspy._brms_functions.prediction.posterior_linpred","title":"<code>posterior_linpred(model, newdata=None, **kwargs)</code>","text":"<pre><code>posterior_linpred(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None, **kwargs) -&gt; IDResult[IDPosterior]\n</code></pre><pre><code>posterior_linpred(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame, **kwargs) -&gt; IDResult[IDPredictions]\n</code></pre> <p>Draw from the linear predictor.</p> <p>Wrapper around R <code>brms::posterior_linpred()</code>. This typically returns draws on the link scale (before applying the inverse link), unless you pass <code>transform=True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data for predictions. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::posterior_linpred()</code> (commonly <code>transform</code> or <code>ndraws</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorLinpredResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::posterior_linpred : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nlp = brms.posterior_linpred(fit, transform=False)\n\nlp.idata.predictions\n</code></pre>"},{"location":"api/brms_functions/prediction/#brmspy._brms_functions.prediction.log_lik","title":"<code>log_lik(model, newdata=None, **kwargs)</code>","text":"<pre><code>log_lik(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None, **kwargs) -&gt; IDResult[IDLogLikelihoodInsample]\n</code></pre><pre><code>log_lik(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame, **kwargs) -&gt; IDResult[IDLogLikelihoodOutsample]\n</code></pre> <p>Compute pointwise log-likelihood draws.</p> <p>Wrapper around R <code>brms::log_lik()</code>. The result is useful for LOO/WAIC via ArviZ.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::log_lik()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>LogLikResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::log_lik : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nll = brms.log_lik(fit)\n\naz.loo(ll.idata)\n</code></pre>"},{"location":"api/brms_functions/prior/","title":"prior","text":"<p>Prior specification helpers.</p> <p>This module provides helpers for constructing brms-compatible prior specifications and for querying the default priors implied by a model.</p> Notes <p>Executed inside the worker process that hosts the embedded R session.</p>"},{"location":"api/brms_functions/prior/#brmspy._brms_functions.prior-classes","title":"Classes","text":""},{"location":"api/brms_functions/prior/#brmspy._brms_functions.prior-functions","title":"Functions","text":""},{"location":"api/brms_functions/prior/#brmspy._brms_functions.prior.prior","title":"<code>prior(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None, **kwargs)</code>","text":"<p>Create a brms-style prior specification.</p> <p>This function mirrors the behavior of <code>brms::prior_string()</code> and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of <code>prior_string()</code> in brms.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>str</code> <p>The prior definition as a string, exactly as brms expects it. Examples include ::</p> <pre><code>\"normal(0, 1)\"\n\"student_t(3, 0, 1.5)\"\n\"exponential(2)\"\n\"lkj(2)\"\n</code></pre> required <code>class_</code> <code>str</code> <p>Parameter class (e.g. <code>\"b\"</code>, <code>\"sd\"</code>, <code>\"Intercept\"</code>). This corresponds to <code>class</code> in brms. <code>class</code> cannot be used as a parameter in Python (reserved keyword), so <code>class_</code> is used instead.</p> <code>None</code> <code>coef</code> <code>str</code> <p>Coefficient name for class-level effects.</p> <code>None</code> <code>group</code> <code>str</code> <p>Grouping variable for hierarchical/multilevel effects.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Distributional parameter (e.g. <code>\"sigma\"</code> or <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response variable name for multivariate models.</p> <code>None</code> <code>nlpar</code> <code>str</code> <p>Nonlinear parameter name if using nonlinear formulas.</p> <code>None</code> <code>lb</code> <code>float</code> <p>Lower bound for truncated priors.</p> <code>None</code> <code>ub</code> <code>float</code> <p>Upper bound for truncated priors.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Any additional keyword arguments supported by <code>brms::prior_string()</code>. These are forwarded unchanged.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriorSpec</code> <p>A typed prior specification object used by <code>brmspy.brms.brm()</code> and <code>brmspy.brms.make_stancode()</code>.</p> See Also <p>brms::prior_string : R documentation</p> Notes <p>This function does not validate the prior expression string itself \u2014 validation occurs inside brms.</p> <p>Examples:</p> <pre><code>from brmspy.brms import prior\n\np_intercept = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\")\np_slope = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\np_sd = prior(\"exponential(2)\", class_=\"sd\", group=\"region\")\np_trunc = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0)\n</code></pre>"},{"location":"api/brms_functions/prior/#brmspy._brms_functions.prior.get_prior","title":"<code>get_prior(formula, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for a model specification.</p> <p>Wrapper around R <code>brms::get_prior()</code>.</p> <p>Returns a DataFrame with default priors for each parameter class in the specified brms model. Useful for reviewing and customizing priors before fitting.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula (e.g. <code>\"y ~ x + (1|group)\"</code>) or a composed formula.</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListSexpVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\")</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row represents a parameter or parameter class that can have a custom prior.</p> See Also <p>default_prior : Generic function for getting default priors prior : Create custom prior specifications brms::get_prior : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms import prior\n\npriors_df = brms.get_prior(\"y ~ x\", data=df)\n\ncustom_priors = [\n    prior(\"normal(0, 0.5)\", class_=\"b\"),\n    prior(\"exponential(2)\", class_=\"sigma\"),\n]\n\nfit = brms.brm(\"y ~ x\", data=df, priors=custom_priors, chains=4)\n</code></pre>"},{"location":"api/brms_functions/prior/#brmspy._brms_functions.prior.default_prior","title":"<code>default_prior(object, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for brms model parameters (generic function).</p> <p>Wrapper around R <code>brms::default_prior()</code>.</p> <p>Generic function to retrieve default prior specifications for all parameters in a brms model. Accepts formula objects, brmsformula objects, or other model specification objects. This is the generic version of get_prior().</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>str, FormulaResult, or ListSexpVector</code> <p>Model specification: formula string, brmsformula object, mvbrmsformula, or any object that can be coerced to these classes</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListSexpVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\"). Can be a list of families for multivariate models</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels, sparse)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row specifies a parameter class with its default prior. The 'prior' column is empty except for internal defaults.</p> See Also <p>get_prior : Convenience function with formula parameter prior : Create custom prior specifications brms::default_prior : R documentation</p> <p>Examples:</p> <p>Get default priors for a Poisson model:</p> <pre><code>from brmspy import brms\n\npriors = brms.default_prior(\n    object=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\nprint(priors)\n</code></pre> <p>Use with formula object:</p> <pre><code>from brmspy import brms\n\nf = brms.formula(\"y ~ x + (1|group)\")\npriors = brms.default_prior(f, data=df, family=\"gaussian\")\n</code></pre>"},{"location":"api/brms_functions/stan/","title":"stan","text":"<p>Stan code helpers.</p> <p>This module exposes wrappers for generating Stan code from brms models without running sampling.</p> Notes <p>Executed inside the worker process that hosts the embedded R session.</p>"},{"location":"api/brms_functions/stan/#brmspy._brms_functions.stan-classes","title":"Classes","text":""},{"location":"api/brms_functions/stan/#brmspy._brms_functions.stan-functions","title":"Functions","text":""},{"location":"api/brms_functions/stan/#brmspy._brms_functions.stan.make_stancode","title":"<code>make_stancode(formula, data, priors=None, family='poisson', sample_prior='no', formula_args=None)</code>","text":"<p>Generate Stan code using R <code>brms::make_stancode()</code>.</p> <p>Useful for inspecting the generated Stan model before fitting.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula.</p> required <code>data</code> <code>DataFrame</code> <p>Model data.</p> required <code>priors</code> <code>Sequence[PriorSpec] or None</code> <p>Optional prior specifications created via <code>brmspy.brms.prior()</code>.</p> <code>None</code> <code>family</code> <code>str</code> <p>Distribution family (e.g. <code>\"gaussian\"</code>, <code>\"poisson\"</code>).</p> <code>\"poisson\"</code> <code>sample_prior</code> <code>str</code> <p>Prior sampling mode passed to brms (<code>\"no\"</code>, <code>\"yes\"</code>, <code>\"only\"</code>).</p> <code>\"no\"</code> <code>formula_args</code> <code>dict or None</code> <p>Reserved for future use. Currently ignored.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Complete Stan program as a string.</p> See Also <p>brms::make_stancode : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\ncode = brms.make_stancode(\n    \"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n)\n\nassert isinstance(code, str)\n</code></pre>"},{"location":"api/types/brms_results/","title":"brms results","text":"<p>Result types for brmspy functions.</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results-classes","title":"Classes","text":""},{"location":"api/types/brms_results/#brmspy.types.brms_results.PriorSpec","title":"<code>PriorSpec</code>  <code>dataclass</code>","text":"<p>Python representation of a brms prior specification.</p> <p>This dataclass provides a typed interface to <code>brms::prior_string()</code> arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the <code>prior()</code> factory function to create instances.</p> <p>Attributes:</p> Name Type Description <code>prior</code> <code>str</code> <p>Prior distribution as string (e.g., <code>\"normal(0, 1)\"</code>, <code>\"exponential(2)\"</code>).</p> <code>class_</code> <code>(str, optional)</code> <p>Parameter class: <code>\"b\"</code> (fixed effects), <code>\"sd\"</code> (group SD), <code>\"Intercept\"</code>, <code>\"sigma\"</code>, <code>\"cor\"</code>, etc.</p> <code>coef</code> <code>(str, optional)</code> <p>Specific coefficient name for class-level priors.</p> <code>group</code> <code>(str, optional)</code> <p>Grouping variable for hierarchical effects.</p> <code>dpar</code> <code>(str, optional)</code> <p>Distributional parameter (e.g., <code>\"sigma\"</code>, <code>\"phi\"</code>, <code>\"zi\"</code>).</p> <code>resp</code> <code>(str, optional)</code> <p>Response variable for multivariate models.</p> <code>nlpar</code> <code>(str, optional)</code> <p>Non-linear parameter name.</p> <code>lb</code> <code>(float, optional)</code> <p>Lower bound for truncated priors.</p> <code>ub</code> <code>(float, optional)</code> <p>Upper bound for truncated priors.</p> See Also <p>prior : Factory function to create <code>PriorSpec</code> instances. brms::prior_string : R documentation</p> <p>Examples:</p> <p>Create prior specifications (prefer using <code>prior()</code>):</p> <pre><code>from brmspy.types import PriorSpec\n\n# Fixed effect prior\np1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n# Group-level SD prior\np2 = PriorSpec(prior=\"exponential(2)\", class_=\"sd\", group=\"patient\")\n\n# Coefficient-specific prior with bounds\np3 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\", coef=\"age\", lb=0)\n</code></pre>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.PriorSpec-functions","title":"Functions","text":""},{"location":"api/types/brms_results/#brmspy.types.brms_results.PriorSpec.to_brms_kwargs","title":"<code>to_brms_kwargs()</code>","text":"<p>Convert PriorSpec to keyword arguments for brms::prior_string().</p> <p>Maps Python dataclass fields to R function arguments, handling the <code>class_</code> -&gt; <code>class</code> parameter name conversion.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keyword arguments ready for brms::prior_string()</p> <p>Examples:</p> <pre><code>from brmspy import prior\np = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\nkwargs = p.to_brms_kwargs()\nprint(kwargs)\n# {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n</code></pre>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.IDConstantData","title":"<code>IDConstantData</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed .constant_data extension to idata</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.IDPredictionsConstantData","title":"<code>IDPredictionsConstantData</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed .predictions_constant_data extension to idata</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.IDObservedData","title":"<code>IDObservedData</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .posterior extension to idata</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.IDPosterior","title":"<code>IDPosterior</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .posterior extension to idata</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.IDPosteriorPredictive","title":"<code>IDPosteriorPredictive</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .posterior_predictive extension to idata</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.IDPredictions","title":"<code>IDPredictions</code>","text":"<p>               Bases: <code>IDPredictionsConstantData</code></p> <p>Typed .predictions extension to idata</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.IDLogLikelihoodInsample","title":"<code>IDLogLikelihoodInsample</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .log_likelihood extension to idata</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.IDLogLikelihoodOutsample","title":"<code>IDLogLikelihoodOutsample</code>","text":"<p>               Bases: <code>IDPredictionsConstantData</code></p> <p>Typed .log_likelihood extension to idata</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.IDBrm","title":"<code>IDBrm</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed <code>arviz.InferenceData</code> for fitted brms models.</p> <p>Extends <code>arviz.InferenceData</code> with type hints for IDE autocomplete. In brmspy, the fitted model result typically exposes an <code>.idata</code> attribute of this type.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Posterior samples of model parameters.</p> <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (with observation noise).</p> <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation.</p> <code>observed_data</code> <code>Dataset</code> <p>Original observed response data.</p> <code>coords</code> <code>dict</code> <p>Coordinate mappings for dimensions (inherited from <code>arviz.InferenceData</code>).</p> <code>dims</code> <code>dict</code> <p>Dimension specifications for variables (inherited from <code>arviz.InferenceData</code>).</p> See Also <p>brmspy.brms.brm : Creates fitted model results (alias: <code>brmspy.brms.fit</code>). arviz.InferenceData : Base class documentation.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.brm(\"y ~ x\", data=df, chains=4)\n\n# Type checking and autocomplete\nassert isinstance(model.idata, IDFit)\nprint(model.idata.posterior)\n</code></pre>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.RListVectorExtension","title":"<code>RListVectorExtension</code>  <code>dataclass</code>","text":"<p>Generic result container with R objects.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.IDResult","title":"<code>IDResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T_idata]</code>, <code>RListVectorExtension</code></p> <p>Generic result container with arviz and R objects.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData object</p> <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.SummaryResult","title":"<code>SummaryResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Parsed summary output for a fitted model.</p> <p>This is a convenience container that holds both:</p> <ul> <li>structured Python data (mostly pandas DataFrames)</li> <li>the underlying R object reference in <code>.r</code> (as a worker-side handle)</li> </ul> <p>Attributes:</p> Name Type Description <code>formula</code> <code>str</code> <p>Model formula string as reported by brms.</p> <code>data_name</code> <code>str</code> <p>Data name as reported by brms (may be an internal label).</p> <code>nobs</code> <code>int</code> <p>Number of observations.</p> <code>prior</code> <code>DataFrame</code> <p>Prior summary table.</p> <code>fixed</code> <code>DataFrame</code> <p>Fixed effects summary table.</p> <code>random</code> <code>dict[str, DataFrame] or None</code> <p>Random effects summary tables (if present).</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.LooResult","title":"<code>LooResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Parsed <code>brms::loo()</code> result.</p> <p>Attributes:</p> Name Type Description <code>estimates, pointwise, diagnostics</code> <code>DataFrame</code> <p>LOO tables.</p> <code>psis_object</code> <code>Any or None</code> <p>PSIS object (if present). May be an R-handle wrapper depending on conversion.</p> <code>elpd_loo, p_loo, looic</code> <code>float</code> <p>Key scalar metrics.</p> <code>se_elpd_loo, se_p_loo, se_looic</code> <code>float</code> <p>Standard errors for the corresponding scalars.</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.LooResult-functions","title":"Functions","text":""},{"location":"api/types/brms_results/#brmspy.types.brms_results.LooResult.__repr__","title":"<code>__repr__()</code>","text":"<p>Pretty print LOO-CV results.</p>"},{"location":"api/types/brms_results/#brmspy.types.brms_results.LooCompareResult","title":"<code>LooCompareResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result of comparing models by a LOO-style criterion.</p> <p>Attributes:</p> Name Type Description <code>table</code> <code>DataFrame</code> <p>Comparison table.</p> <code>criterion</code> <code>str</code> <p>Criterion name (e.g. <code>\"loo\"</code>).</p>"},{"location":"api/types/errors/","title":"errors","text":""},{"location":"api/types/errors/#brmspy.types.errors-classes","title":"Classes","text":""},{"location":"api/types/errors/#brmspy.types.errors.RSessionError","title":"<code>RSessionError</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Error raised when a worker call fails.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error message (often derived from R error messages).</p> required <code>remote_traceback</code> <code>str or None</code> <p>Best-effort traceback text from the worker process. For R errors this may be an R traceback string; for Python errors inside the worker it may be a Python traceback.</p> <code>None</code> Notes <p>This exception type is designed to preserve the remote failure context while keeping the main process free of rpy2/R state.</p>"},{"location":"api/types/errors/#brmspy.types.errors.RSessionError-functions","title":"Functions","text":""},{"location":"api/types/errors/#brmspy.types.errors.RSessionError.__str__","title":"<code>__str__()</code>","text":"<p>Return message plus the remote traceback (if available).</p>"},{"location":"api/types/errors/#brmspy.types.errors.RWorkerCrashedError","title":"<code>RWorkerCrashedError</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when the R worker process crashes during an operation.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable description of the failure.</p> required <code>recovered</code> <code>bool</code> <p>Indicates whether a fresh worker session was successfully started.</p> <ul> <li><code>True</code>  \u2013 The crash occurred, but automatic recovery succeeded.               The failed operation did not complete, but the worker               is now in a clean state. Callers may safely retry.</li> <li><code>False</code> \u2013 The crash occurred and automatic recovery failed.               A usable worker session is not available. Callers should               treat this as a hard failure and abort or escalate.</li> </ul> required <code>cause</code> <code>BaseException</code> <p>The original exception that triggered the crash. Stored as <code>__cause__</code> for chained exception inspection.</p> <code>None</code> Usage <p>In user code or automated pipelines, you can distinguish between a recoverable and unrecoverable crash:</p> <pre><code>try:\n    brms.brm(...)\nexcept RWorkerCrashedError as err:\n    if err.recovered:\n        # Crash occurred, but a fresh worker is ready.\n        # Safe to retry the operation once.\n        brms.brm(...)\n    else:\n        # Worker could not be restarted.\n        # Treat this as a hard failure.\n        raise\n</code></pre> Notes <p>All crashes automatically produce a new exception that wraps the original failure using Python's exception chaining (<code>raise ... from cause</code>). Inspect <code>err.__cause__</code> for the underlying system error.</p>"},{"location":"api/types/formula_dsl/","title":"formula DSL","text":"<p>Formula DSL types.</p> <p>This module contains lightweight Python types used by the public formula helpers (<code>bf()</code>, <code>set_rescor()</code>, etc.) to represent brms formula expressions in a structured way.</p> <p>The main entry point for end users is the set of helpers exposed via <code>brmspy.brms</code>. Those helpers return <code>FormulaConstruct</code> instances which can be combined with <code>+</code> to build multivariate or compound models.</p> Notes <ul> <li>These objects are data containers; the execution (turning them into actual R   formula objects) happens in the worker process.</li> <li><code>ProxyListSexpVector</code> values inside the tree represent R-side objects (for   example brms family objects) and are only meaningful while the worker process   that created them is alive.</li> </ul> <p>Examples:</p> <p>Compose formula parts using the public helpers:</p> <pre><code>from brmspy.brms import bf, set_rescor\n\nf = bf(\"y ~ x\") + bf(\"z ~ 1\") + set_rescor(True)\nprint(f)\n</code></pre>"},{"location":"api/types/formula_dsl/#brmspy.types.formula_dsl-classes","title":"Classes","text":""},{"location":"api/types/formula_dsl/#brmspy.types.formula_dsl.FormulaPart","title":"<code>FormulaPart</code>  <code>dataclass</code>","text":"<p>A single formula helper invocation.</p> <p>Instances of this type represent a call like <code>bf(\"y ~ x\")</code> or <code>set_rescor(True)</code> without executing anything. They are primarily used as nodes inside a <code>FormulaConstruct</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_fun</code> <code>Literal[...]</code> <p>Whitelisted formula helper name.</p> required <code>_args</code> <code>Sequence[Primitive]</code> <p>Positional arguments for the helper.</p> required <code>_kwargs</code> <code>Mapping[str, Primitive]</code> <p>Keyword arguments for the helper.</p> required Notes <p>This is a low-level type. Most users should construct these via the public helper functions in <code>brmspy.brms</code>.</p>"},{"location":"api/types/formula_dsl/#brmspy.types.formula_dsl.FormulaPart-functions","title":"Functions","text":""},{"location":"api/types/formula_dsl/#brmspy.types.formula_dsl.FormulaPart.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate <code>_fun</code>, <code>_args</code>, and <code>_kwargs</code> types after construction.</p>"},{"location":"api/types/formula_dsl/#brmspy.types.formula_dsl.FormulaPart.__str__","title":"<code>__str__()</code>","text":"<p>Render a readable <code>fun(arg1, ..., kw=...)</code> representation.</p>"},{"location":"api/types/formula_dsl/#brmspy.types.formula_dsl.FormulaConstruct","title":"<code>FormulaConstruct</code>  <code>dataclass</code>","text":"<p>A composite formula expression built from parts.</p> <p><code>FormulaConstruct</code> stores a tree of nodes (<code>FormulaPart</code> and/or R objects) representing expressions combined with <code>+</code>. It is primarily created by calling the public formula helpers exposed by <code>brmspy.brms</code>.</p> Notes <p>The <code>+</code> operator supports grouping:</p> <ul> <li><code>a + b + c</code> becomes a single summand (one \u201cgroup\u201d)</li> <li><code>(a + b) + (a + b)</code> becomes two summands (two \u201cgroups\u201d)</li> </ul> <p>Use <code>iter_summands()</code> to iterate over these groups in a deterministic way.</p>"},{"location":"api/types/formula_dsl/#brmspy.types.formula_dsl.FormulaConstruct-functions","title":"Functions","text":""},{"location":"api/types/formula_dsl/#brmspy.types.formula_dsl.FormulaConstruct.__add__","title":"<code>__add__(other)</code>","text":"<p>Combine two formula expressions with <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Other</code> <p>Value to add. Strings are treated as <code>bf(&lt;string&gt;)</code>.</p> required <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>New combined expression.</p>"},{"location":"api/types/formula_dsl/#brmspy.types.formula_dsl.FormulaConstruct.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Support <code>\"y ~ x\" + bf(\"z ~ 1\")</code> by coercing the left operand.</p>"},{"location":"api/types/formula_dsl/#brmspy.types.formula_dsl.FormulaConstruct.iter_summands","title":"<code>iter_summands()</code>","text":"<p>Iterate over arithmetic groups (summands).</p> <p>Returns:</p> Type Description <code>Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]</code> <p>Each yielded tuple represents one summand/group.</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, gaussian, set_rescor\n\nf = bf(\"y ~ x\") + gaussian() + set_rescor(True)\nfor summand in f.iter_summands():\n    print(summand)\n</code></pre>"},{"location":"api/types/formula_dsl/#brmspy.types.formula_dsl.FormulaConstruct.__iter__","title":"<code>__iter__()</code>","text":"<p>Alias for <code>iter_summands()</code>.</p>"},{"location":"api/types/formula_dsl/#brmspy.types.formula_dsl.FormulaConstruct.iterate","title":"<code>iterate()</code>","text":"<p>Iterate over all leaf nodes in left-to-right order.</p> <p>This flattens the expression tree, unlike <code>iter_summands()</code>, which respects grouping.</p> <p>Returns:</p> Type Description <code>Iterator[FormulaPart | ProxyListSexpVector]</code>"},{"location":"api/types/rpy2_converters/","title":"rpy2 converters","text":"<p>Type aliases for R\u2194Python conversion functions.</p> <p>brmspy performs most conversion inside the worker process (where embedded R lives). Converters may optionally use shared memory (<code>ShmPool</code>) to avoid extra copies when moving large numeric data across the main\u2194worker boundary.</p> <p>This module only defines type aliases used by converter registries and helper code under [<code>brmspy.helpers._rpy2</code>][].</p> Notes <ul> <li>The main process must not import <code>rpy2.robjects</code>. These aliases only refer to   the lower-level <code>rpy2.rinterface_lib.sexp.Sexp</code> handle type.</li> </ul>"},{"location":"api/types/rpy2_converters/#brmspy.types.rpy2_converters-attributes","title":"Attributes","text":""},{"location":"api/types/rpy2_converters/#brmspy.types.rpy2_converters.PyObject","title":"<code>PyObject = Union[dict, list, str, float, int, np.dtype, None, Any, pd.DataFrame, pd.Series, np.ndarray, az.InferenceData, xr.DataArray, xr.Dataset]</code>  <code>module-attribute</code>","text":"<p>Union of common Python-side objects produced by R\u2192Python conversion.</p> <p>This is intentionally broad: brmspy frequently returns standard scientific Python types (NumPy/pandas/xarray/ArviZ), plus plain dict/list primitives.</p> Note <p>Avoid adding <code>Any</code> here unless absolutely necessary; it defeats the purpose of having this alias.</p>"},{"location":"api/types/rpy2_converters/#brmspy.types.rpy2_converters.R2pyConverter","title":"<code>R2pyConverter = Callable[[Any, ShmPool | None], PyObject]</code>  <code>module-attribute</code>","text":"<p>Callable signature for an R\u2192Python converter.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>R-side object (usually an rpy2 wrapper type).</p> required <code>shm</code> <code>ShmPool or None</code> <p>Shared memory pool used to allocate backing buffers for large numeric payloads.</p> required <p>Returns:</p> Type Description <code>PyObject</code>"},{"location":"api/types/rpy2_converters/#brmspy.types.rpy2_converters.Py2rConverter","title":"<code>Py2rConverter = Callable[[Any], Sexp]</code>  <code>module-attribute</code>","text":"<p>Callable signature for a Python\u2192R converter.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Python object to convert.</p> required <p>Returns:</p> Type Description <code>Sexp</code> <p>Low-level R object handle.</p>"},{"location":"api/types/rpy2_converters/#brmspy.types.rpy2_converters-classes","title":"Classes","text":""},{"location":"api/types/runtime/","title":"runtime","text":"<p>Runtime management types.</p> <p>These dataclasses are returned by runtime/status helper functions and are used internally to decide whether a \"prebuilt runtime\" can be used on the current machine.</p> <p>Conceptually:</p> <ul> <li>A runtime is a bundle containing CmdStan and a set of R packages installed   into an isolated library directory (typically under <code>~/.brmspy/runtime/...</code>).</li> <li>An environment (see <code>EnvironmentConfig</code>) is a   named, user-managed library (<code>~/.brmspy/environment/&lt;name&gt;/Rlib</code>) layered on   top of a runtime.</li> </ul> Notes <p>All snapshot types in this module are immutable (<code>frozen=True</code>) so they can be cached safely and won't be mutated accidentally by callers.</p>"},{"location":"api/types/runtime/#brmspy.types.runtime-classes","title":"Classes","text":""},{"location":"api/types/runtime/#brmspy.types.runtime.SystemInfo","title":"<code>SystemInfo</code>  <code>dataclass</code>","text":"<p>Immutable snapshot of the system environment relevant to runtime selection.</p> <p>Attributes:</p> Name Type Description <code>os</code> <code>str</code> <p>Operating system identifier (for example <code>\"linux\"</code>, <code>\"macos\"</code>, <code>\"windows\"</code>).</p> <code>arch</code> <code>str</code> <p>CPU architecture (for example <code>\"x86_64\"</code>, <code>\"arm64\"</code>).</p> <code>r_version</code> <code>tuple[int, int, int] or None</code> <p>Detected R version as <code>(major, minor, patch)</code>.</p> <code>fingerprint</code> <code>str</code> <p>Fingerprint used for runtime lookup and caching (for example <code>\"linux-x86_64-r4.3\"</code>).</p> <code>glibc_version</code> <code>tuple[int, int] or None</code> <p>Linux-only: glibc major/minor version used for compatibility checks.</p> <code>clang_version</code> <code>tuple[int, int] or None</code> <p>macOS-only: clang major/minor version.</p> <code>gxx_version</code> <code>tuple[int, int] or None</code> <p>C++ compiler major/minor version if detected.</p> <code>has_rtools</code> <code>bool</code> <p>Windows-only: whether Rtools is available.</p>"},{"location":"api/types/runtime/#brmspy.types.runtime.RuntimeManifest","title":"<code>RuntimeManifest</code>  <code>dataclass</code>","text":"<p>Manifest for a prebuilt runtime bundle.</p> <p>This structure is typically loaded from a <code>manifest.json</code> stored alongside a runtime directory.</p> <p>Attributes:</p> Name Type Description <code>runtime_version</code> <code>str</code> <p>brmspy runtime bundle version.</p> <code>fingerprint</code> <code>str</code> <p>System fingerprint this runtime was built for.</p> <code>r_version</code> <code>str</code> <p>R version string used for the runtime build (for example <code>\"4.5.0\"</code>).</p> <code>cmdstan_version</code> <code>str</code> <p>CmdStan version included in the runtime.</p> <code>r_packages</code> <code>dict[str, str]</code> <p>Mapping of R package names to versions.</p> <code>manifest_hash</code> <code>str</code> <p>Hash used to validate the runtime contents.</p> <code>built_at</code> <code>str</code> <p>Build timestamp.</p>"},{"location":"api/types/runtime/#brmspy.types.runtime.RuntimeStatus","title":"<code>RuntimeStatus</code>  <code>dataclass</code>","text":"<p>Immutable snapshot of current runtime state.</p> <p>Attributes:</p> Name Type Description <code>active_runtime</code> <code>Path or None</code> <p>Path to the currently selected runtime (if any).</p> <code>is_activated</code> <code>bool</code> <p>Whether the worker's embedded R session has been modified/activated to use the active runtime.</p> <code>system</code> <code>SystemInfo</code> <p>Detected system info used for compatibility evaluation.</p> <code>can_use_prebuilt</code> <code>bool</code> <p>Whether a prebuilt runtime could be used in principle.</p> <code>prebuilt_available</code> <code>bool</code> <p>Whether a compatible prebuilt runtime is available for the current fingerprint.</p> <code>compatibility_issues</code> <code>tuple[str, ...]</code> <p>Human-readable reasons why prebuilt runtime usage is not possible.</p> <code>installed_runtimes</code> <code>tuple[Path, ...]</code> <p>Runtime directories currently installed under brmspy storage.</p> <code>brms_version, cmdstanr_version, rstan_version</code> <code>str or None</code> <p>Detected versions in the current worker session (if available).</p>"},{"location":"api/types/runtime/#brmspy.types.runtime.StoredEnv","title":"<code>StoredEnv</code>  <code>dataclass</code>","text":"<p>Captured R environment used for deactivation/restoration.</p> <p>Attributes:</p> Name Type Description <code>lib_paths</code> <code>list[str]</code> <p><code>.libPaths()</code> values captured before activation.</p> <code>cmdstan_path</code> <code>str or None</code> <p>CmdStan path captured before activation.</p>"},{"location":"api/types/session/","title":"session","text":""},{"location":"api/types/session/#brmspy.types.session-classes","title":"Classes","text":""},{"location":"api/types/session/#brmspy.types.session.SexpWrapper","title":"<code>SexpWrapper</code>  <code>dataclass</code>","text":"<p>Lightweight handle for an R object stored in the worker.</p> <p>The worker keeps the real rpy2 <code>Sexp</code> in an internal cache and replaces it in results with this wrapper. When passed back to the worker, the wrapper is resolved to the original <code>Sexp</code> again.</p> Notes <ul> <li><code>SexpWrapper</code> instances are only meaningful within the lifetime of the   worker process that produced them. After a worker restart, previously   returned wrappers can no longer be reattached.</li> <li>This type exists to keep the main process free of rpy2 / embedded-R state.</li> </ul>"},{"location":"api/types/session/#brmspy.types.session.PayloadRef","title":"<code>PayloadRef</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Encoded argument/result payload sent over the control pipe.</p> <p>A payload is:</p> <ul> <li><code>codec</code>: the codec identifier used by the registry</li> <li><code>meta</code>: JSON-serializable metadata needed to reconstruct the value</li> <li><code>buffers</code>: shared-memory buffer references backing the payload</li> </ul>"},{"location":"api/types/session/#brmspy.types.session.Request","title":"<code>Request</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>IPC request message sent from main process to worker.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Correlation id for the request/response pair.</p> <code>cmd</code> <code>{'CALL', 'SHUTDOWN', 'PING', '_RUN_TEST_BY_NAME'}</code> <p>Command type.</p> <code>target</code> <code>str</code> <p>Worker target spec (see <code>_resolve_module_target()</code>).</p> <code>args, kwargs</code> <p>Encoded arguments.</p>"},{"location":"api/types/session/#brmspy.types.session.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>IPC response message sent from worker back to the main process.</p>"},{"location":"api/types/session/#brmspy.types.session.EnvironmentConfig","title":"<code>EnvironmentConfig</code>  <code>dataclass</code>","text":"<p>Worker environment configuration.</p> <p>This configuration is applied in the worker before importing/using brms.</p> <p>Parameters:</p> Name Type Description Default <code>r_home</code> <code>str or None</code> <p>Override for <code>R_HOME</code>. If None, the worker will rely on system detection.</p> <code>None</code> <code>startup_scripts</code> <code>list[str]</code> <p>R code snippets executed in the worker after initialization.</p> <code>list()</code> <code>environment_name</code> <code>str</code> <p>brmspy environment name (used to determine <code>~/.brmspy/environment/&lt;name&gt;/Rlib</code>).</p> <code>'default'</code> <code>runtime_path</code> <code>str or None</code> <p>Path to a brmspy runtime bundle to activate in the worker.</p> <code>None</code> <code>env</code> <code>dict[str, str]</code> <p>Extra environment variables applied when spawning the worker.</p> <code>dict()</code>"},{"location":"api/types/session/#brmspy.types.session.EnvironmentConfig-functions","title":"Functions","text":""},{"location":"api/types/session/#brmspy.types.session.EnvironmentConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize configuration for persistence to JSON.</p>"},{"location":"api/types/session/#brmspy.types.session.EnvironmentConfig.from_dict","title":"<code>from_dict(obj)</code>  <code>classmethod</code>","text":"<p>Deserialize configuration from a JSON object.</p>"},{"location":"api/types/session/#brmspy.types.session.EnvironmentConfig.from_obj","title":"<code>from_obj(obj)</code>  <code>classmethod</code>","text":"<p>Normalize <code>None | dict | EnvironmentConfig</code> into an <code>EnvironmentConfig</code>.</p>"},{"location":"api/types/session/#brmspy.types.session.EncodeResult","title":"<code>EncodeResult</code>  <code>dataclass</code>","text":"<p>Result of encoding a Python value for IPC transfer.</p> <p>Attributes:</p> Name Type Description <code>codec</code> <code>str</code> <p>Codec identifier.</p> <code>meta</code> <code>dict[str, Any]</code> <p>JSON-serializable metadata required for decoding.</p> <code>buffers</code> <code>list[ShmRef]</code> <p>Shared-memory blocks backing the encoded payload.</p>"},{"location":"api/types/session/#brmspy.types.session.Encoder","title":"<code>Encoder</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol implemented by codecs in the session codec registry.</p>"},{"location":"api/types/shm/","title":"shm","text":"<p>SHM-backed NumPy and pandas helpers.</p> <p>These types are thin wrappers around NumPy/pandas objects that keep a reference to the shared-memory block that backs the underlying data. They enable brmspy's codecs to avoid extra copies when transporting large numeric payloads between the main process and the worker.</p> See Also <p><code>brmspy._session.codec.builtin.NumpyArrayCodec</code>     Encodes/decodes NumPy arrays into shared memory. <code>brmspy._session.codec.builtin.PandasDFCodec</code>     Encodes/decodes DataFrames into shared memory. <code>brmspy.types.shm</code>     Base shared-memory block and pool types.</p>"},{"location":"api/types/shm/#brmspy.types.shm_extensions-classes","title":"Classes","text":""},{"location":"api/types/shm/#brmspy.types.shm_extensions.ShmArray","title":"<code>ShmArray</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>NumPy array view backed by a shared-memory block.</p> <p>Attributes:</p> Name Type Description <code>block</code> <code>ShmRef</code> <p>Reference to the shared-memory block backing the array data.</p> Notes <p>This is a view over <code>SharedMemory.buf</code>. Closing/unlinking the underlying shared memory while the array is still in use will lead to undefined behavior.</p>"},{"location":"api/types/shm/#brmspy.types.shm_extensions.ShmArray-functions","title":"Functions","text":""},{"location":"api/types/shm/#brmspy.types.shm_extensions.ShmArray.from_block","title":"<code>from_block(block, shape, dtype, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create an array view backed by an existing shared-memory block.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>ShmBlock</code> <p>Attached shared-memory block.</p> required <code>shape</code> <code>tuple[int, ...]</code> <p>Desired array shape.</p> required <code>dtype</code> <code>dtype</code> <p>NumPy dtype of the array.</p> required <code>**kwargs</code> <p>Reserved for future compatibility. Currently unused.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ShmArray</code> <p>Array view into the shared-memory buffer.</p>"},{"location":"api/types/shm/#brmspy.types.shm_extensions.ShmArray.array_order","title":"<code>array_order(a)</code>  <code>classmethod</code>","text":"<p>Determine how an array can be reconstructed from a raw buffer.</p> <p>Returns <code>\"C\"</code> for C-contiguous arrays, <code>\"F\"</code> for Fortran-contiguous arrays, otherwise <code>\"non-contiguous\"</code> (meaning: bytes were obtained by forcing a contiguous copy during encoding).</p>"},{"location":"api/types/shm/#brmspy.types.shm_extensions.ShmDataFrameSimple","title":"<code>ShmDataFrameSimple</code>","text":"<p>               Bases: <code>DataFrame</code></p> <p>pandas DataFrame backed by a single shared-memory block (numeric only).</p> <p>Attributes:</p> Name Type Description <code>block</code> <code>ShmRef</code> <p>Reference to the shared-memory block backing the DataFrame's values.</p>"},{"location":"api/types/shm/#brmspy.types.shm_extensions.ShmDataFrameSimple-functions","title":"Functions","text":""},{"location":"api/types/shm/#brmspy.types.shm_extensions.ShmDataFrameSimple.from_block","title":"<code>from_block(block, nrows, ncols, columns, index, dtype)</code>  <code>classmethod</code>","text":"<p>Construct a DataFrame backed by a single SHM block.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>ShmBlock</code> <p>Attached shared-memory block containing a contiguous 2D numeric matrix.</p> required <code>nrows</code> <code>int</code> <p>DataFrame shape.</p> required <code>ncols</code> <code>int</code> <p>DataFrame shape.</p> required <code>columns</code> <code>list[Any] or None</code> <p>Column/index labels.</p> required <code>index</code> <code>list[Any] or None</code> <p>Column/index labels.</p> required <code>dtype</code> <code>str or dtype</code> <p>Dtype of the matrix stored in the block.</p> required <p>Returns:</p> Type Description <code>ShmDataFrameSimple</code>"},{"location":"api/types/shm/#brmspy.types.shm_extensions.ShmDataFrameColumns","title":"<code>ShmDataFrameColumns</code>","text":"<p>               Bases: <code>DataFrame</code></p> <p>pandas DataFrame backed by per-column shared-memory blocks (numeric only).</p> <p>Attributes:</p> Name Type Description <code>_blocks_columns</code> <code>dict[str, PandasColumnMetadata]</code> <p>Mapping from column name to data required for its reconstruction</p>"},{"location":"api/types/shm/#brmspy.types.shm-classes","title":"Classes","text":""},{"location":"api/types/shm/#brmspy.types.shm.ShmRef","title":"<code>ShmRef</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Reference to a shared-memory block sent over IPC.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Shared memory block name (as assigned by <code>SharedMemoryManager</code>).</p> <code>size</code> <code>int</code> <p>Allocated block size in bytes.</p> <code>content_size</code> <code>int</code> <p>Actual used size</p> <code>temporary</code> <code>bool</code> <p>Whether this buffer can be GC-d immediately after use or should it be attached to object its constructed into.</p> Notes <p>Codecs may store a logical payload smaller than <code>size</code>. In that case, the codec metadata must include the logical <code>nbytes</code>/length so that decoders can slice the buffer appropriately.</p>"},{"location":"api/types/shm/#brmspy.types.shm.ShmBlock","title":"<code>ShmBlock</code>  <code>dataclass</code>","text":"<p>Attached shared-memory block (name/size + live <code>SharedMemory</code> handle).</p> Notes <p>This object owns a <code>SharedMemory</code> handle and must be closed when no longer needed. In brmspy this is managed by a <code>ShmPool</code> implementation.</p>"},{"location":"api/types/shm/#brmspy.types.shm.ShmPool","title":"<code>ShmPool</code>","text":"<p>Minimal interface for allocating and attaching shared-memory blocks.</p> <p>The concrete implementation lives in <code>brmspy._session.transport.ShmPool</code> and tracks blocks so they can be closed on teardown.</p>"},{"location":"api/types/shm/#brmspy.types.shm.ShmPool-functions","title":"Functions","text":""},{"location":"api/types/shm/#brmspy.types.shm.ShmPool.__init__","title":"<code>__init__(manager)</code>","text":"<p>Create a pool bound to an existing <code>SharedMemoryManager</code>.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SharedMemoryManager</code> <p>Manager used to allocate blocks.</p> required"},{"location":"api/types/shm/#brmspy.types.shm.ShmPool.alloc","title":"<code>alloc(size, temporary=False)</code>","text":"<p>Allocate a new shared-memory block.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size in bytes.</p> required <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Newly allocated block.</p>"},{"location":"api/types/shm/#brmspy.types.shm.ShmPool.attach","title":"<code>attach(ref)</code>","text":"<p>Attach to an existing shared-memory block by name.</p> <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Attached block.</p>"},{"location":"api/types/shm/#brmspy.types.shm.ShmPool.close_all","title":"<code>close_all()</code>","text":"<p>Close all tracked shared-memory handles owned by this pool.</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"development/development/","title":"Development Guide","text":"<p>This guide covers brmspy\u2019s development workflows, architecture, testing strategy, and CI/CD.</p> <p>brmspy has been refactored around an explicit process boundary:</p> <ul> <li>Main process: exposes a normal-looking <code>brmspy.brms</code> module surface to the user and IDEs and must not import <code>rpy2.robjects</code>.</li> <li>Worker process: runs the \u201creal\u201d brms/rpy2 code (and embeds R) and is isolated from the main process.</li> <li>Embedded R: lives inside the worker.</li> </ul> <p>This is primarily about stability (segfault isolation), predictable environment management, and enabling \u201cresettable\u201d R sessions.</p>"},{"location":"development/development/#quick-start","title":"Quick Start","text":""},{"location":"development/development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10\u20133.14</li> <li>R installed (CI uses R 4.5; prebuilt runtimes are fingerprinted by <code>{os}-{arch}-r{major}.{minor}</code>)</li> <li>A working toolchain if you use the \u201ctraditional\u201d install path (prebuilt runtimes avoid most compilation)</li> </ul>"},{"location":"development/development/#setup","title":"Setup","text":"<pre><code># Clone and setup\ngit clone https://github.com/kaitumisuuringute-keskus/brmspy.git\ncd brmspy\n\n# Create and install dev env (uses uv)\nsh script/init-venv.sh\n</code></pre>"},{"location":"development/development/#install-r-dependencies-brms-backend","title":"Install R dependencies (brms + backend)","text":"<p>The recommended way to install and mutate the R-side environment is via <code>brms.manage()</code>.</p> <p>Fast install with a prebuilt runtime:</p> <pre><code>python - &lt;&lt;'PY'\nfrom brmspy import brms\n\nwith brms.manage() as ctx:\n    ctx.install_brms(use_prebuilt=True)\nPY\n</code></pre> <p>Traditional install (compiles packages and builds toolchain; can take ~20\u201330 minutes):</p> <pre><code>python - &lt;&lt;'PY'\nfrom brmspy import brms\n\nwith brms.manage() as ctx:\n    ctx.install_brms()\nPY\n</code></pre>"},{"location":"development/development/#project-architecture","title":"Project Architecture","text":""},{"location":"development/development/#directory-structure","title":"Directory Structure","text":"<pre><code>\u251c\u2500\u2500 brmspy/                    # Main package\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 _brms_functions         # Worker-only: brms:: wrappers\n\u2502   \u251c\u2500\u2500 _build                  # Worker-only: runtime packaging pipeline\n\u2502   \u251c\u2500\u2500 _runtime                # Worker-only: R/toolchain/runtime operations\n\u2502   \u251c\u2500\u2500 _session                # Main\u2194worker architecture (IPC + SHM + codecs)\n\u2502   \u251c\u2500\u2500 _singleton              # Internal singletons and SHM access\n\u2502   \u251c\u2500\u2500 brms                    # Public entry point (proxy in main, real module in worker)\n\u2502   \u251c\u2500\u2500 helpers                 # Logging and worker-only rpy2 converters\n\u2502   \u2514\u2500\u2500 types                   # Public types and SHM helper types\n\u251c\u2500\u2500 .github/workflows/          # CI/CD pipelines\n\u251c\u2500\u2500 .runtime_builder/           # Docker for Linux runtime builds\n\u251c\u2500\u2500 docs/                       # mkdocs documentation\n\u2514\u2500\u2500 tests/                      # Test suite\n</code></pre>"},{"location":"development/development/#import-graph","title":"Import graph","text":""},{"location":"development/development/#architecture-overview-main-worker-embedded-r","title":"Architecture Overview (main \u2194 worker \u2194 embedded R)","text":""},{"location":"development/development/#high-level-picture","title":"High-level picture","text":"<pre><code>flowchart LR\n  User[User code] --&gt; Brms[brmspy.brms module surface]\n  Brms --&gt; IPC[Pipe and shared memory]\n  IPC --&gt; Worker[Worker process]\n  Worker --&gt; R[Embedded R via rpy2]\n  R --&gt; CmdStan[CmdStan toolchain]\n</code></pre>"},{"location":"development/development/#core-concept-brmspybrms-is-a-proxy-in-the-main-process","title":"Core concept: <code>brmspy.brms</code> is a proxy in the main process","text":"<p>In the main process, importing <code>from brmspy import brms</code> returns a module-like proxy:</p> <ul> <li>The proxy is implemented in <code>brmspy/brms/__init__.py</code> and uses the session layer in <code>brmspy/_session/session.py</code>.</li> <li>It mirrors the public API surface of the worker module for IDEs and static analysis.</li> <li>Any function call is forwarded to the worker over IPC, with arguments/results serialized via codecs and SHM.</li> <li>Importantly: the main process must not import <code>rpy2.robjects</code>.</li> </ul> <p>In the worker process (<code>BRMSPY_WORKER=1</code>), <code>brmspy.brms</code> imports the real implementation module:</p> <ul> <li><code>brmspy/brms/_brms_module.py</code> imports the brms wrappers under <code>brmspy/_brms_functions/</code> and may import/initialize rpy2 + embedded R.</li> <li>Optional autoloading is controlled by <code>BRMSPY_AUTOLOAD</code> (the main proxy typically spawns the worker with autoload enabled, but <code>brms.manage()</code> restarts it with autoload disabled).</li> </ul>"},{"location":"development/development/#why-this-split-exists","title":"Why this split exists","text":"<p>Key goals:</p> <ul> <li>Crash containment: if embedded R segfaults, it takes down the worker, not the user\u2019s main process/IDE.</li> <li>Resettable R session: the worker can be restarted, making it possible to \u201creset\u201d R and switch runtime/environment state without restarting Python.</li> <li>Predictable imports: main process stays lightweight; worker is the only place that touches rpy2/brms.</li> </ul>"},{"location":"development/development/#ipc-what-crosses-the-process-boundary","title":"IPC: What crosses the process boundary","text":""},{"location":"development/development/#request-response-model","title":"Request / response model","text":"<p>At runtime, the proxy starts a worker using <code>multiprocessing</code> spawn semantics and wires:</p> <ul> <li>a <code>Pipe</code> for control + metadata messages</li> <li>a <code>SharedMemoryManager</code> for large payloads</li> <li>a log queue so worker logs/prints are forwarded into the parent\u2019s logging handlers</li> </ul> <p>The main process sends requests to the worker with:</p> <ul> <li><code>cmd</code>: one of <code>CALL</code>, <code>PING</code>, <code>SHUTDOWN</code>, or internal test commands</li> <li><code>target</code>: what to execute in the worker</li> <li><code>args</code>/<code>kwargs</code>: encoded payloads (plus SHM buffer references)</li> </ul> <p>The worker replies with:</p> <ul> <li>success/error fields</li> <li>an encoded return value payload</li> </ul> <p>Startup is guarded by an explicit <code>PING</code> handshake to avoid race conditions and zombie workers.</p>"},{"location":"development/development/#target-resolution","title":"Target resolution","text":"<p>Targets are strings and support:</p> <ul> <li>Module function: <code>mod:pkg.module.func</code></li> <li>Attribute chain (for class-based \u201csurface\u201d APIs like <code>manage()</code> and <code>_build()</code>): <code>mod:pkg.module::ClassName.method_name</code></li> </ul> <p>This is what allows <code>brms.manage().install_brms(...)</code> to work as a \u201cnormal-looking\u201d call from the main process even though the work executes inside the worker.</p>"},{"location":"development/development/#example-call-flow-encode-run-in-worker-decode","title":"Example call flow (encode \u2192 run in worker \u2192 decode)","text":"<pre><code>sequenceDiagram\n  participant Main as Main process\n  participant Worker as Worker process\n  participant R as Embedded R\n\n  Note over Main: Encode args via codec registry\\nAllocate SHM blocks for large buffers\n  Main-&gt;&gt;Worker: CALL target + arg meta + SHM refs\n\n  Note over Worker: Decode args from SHM\\nReattach cached Sexp wrappers if present\n  Worker-&gt;&gt;R: brms call via rpy2\n\n  Note over Worker: Convert R data into SHM buffers\\nReplace Sexp with lightweight wrappers\\nEncode result payload\n  R--&gt;&gt;Worker: Return value\n\n  Worker--&gt;&gt;Main: Response meta + SHM refs\n  Note over Main: Decode result from SHM\\nReturn Python objects to user\n</code></pre>"},{"location":"development/development/#data-transport-shm-codecs-no-r-objects-in-main","title":"Data transport: SHM + codecs + \u201cno R objects in main\u201d","text":""},{"location":"development/development/#shared-memory-shm","title":"Shared memory (SHM)","text":"<p>Large data payloads are moved using shared memory blocks:</p> <ul> <li>The main process allocates SHM blocks via a <code>SharedMemoryManager</code> and passes only <code>(name, size)</code> references over the pipe.</li> <li>The worker attaches to blocks by name and reads/writes buffers in-place.</li> <li>Payloads sent over IPC contain only metadata + SHM block references, not the raw data.</li> </ul> <p>Important detail: SHM blocks may be larger than the logical payload, so codecs carry an explicit <code>nbytes</code>/length in metadata and decoders slice buffers accordingly.</p>"},{"location":"development/development/#codec-registry","title":"Codec registry","text":"<p>All arguments and return values are passed through a codec registry (see <code>brmspy/_session/codec/</code>):</p> <ul> <li>Prefer SHM-backed codecs for large numeric data (NumPy, ArviZ, many pandas frames).</li> <li>Fall back to pickle only when needed, and log warnings for large pickle payloads.</li> </ul> <p>Default codec priority is:</p> <ol> <li>NumPy arrays (SHM-backed)</li> <li>ArviZ <code>InferenceData</code> (stores underlying arrays in SHM; reconstructs datasets in-place)</li> <li>pandas DataFrames (numeric-only; object dtype columns fall back to pickle)</li> <li>Dataclasses (encodes fields recursively via the registry)</li> <li>Pickle fallback (always available, but discouraged for large payloads)</li> </ol> <p>Dataclass results (public brmspy result types) are encoded field-by-field by delegating each field back into the registry. This avoids per-function bespoke serialization logic.</p>"},{"location":"development/development/#handling-r-objects-sexp","title":"Handling R objects (<code>Sexp</code>)","text":"<p>R objects are not shipped to the main process.</p> <ul> <li>R objects live inside the worker as rpy2 <code>Sexp</code> instances.</li> <li>When a call returns an R object (or includes one inside a dataclass), it is replaced by a lightweight wrapper containing:</li> <li>a stable internal id (<code>rid</code>)</li> <li>a printable representation (for debugging)</li> </ul> <p>When the main process sends such wrappers back to the worker later, the worker reattaches them from its <code>Sexp</code> cache.</p> <p>This prevents rpy2/R object lifetimes from leaking into the main process and makes it harder to accidentally import/use rpy2 in the main process.</p>"},{"location":"development/development/#r-session-safety-and-initialization","title":"R session safety and initialization","text":"<p>The worker configures embedded R for safer execution:</p> <ul> <li>Enforces <code>RPY2_CFFI_MODE=ABI</code> when possible (ABI mode is the recommended stable mode).</li> <li>Disables fork-based R parallelism that is unsafe in embedded R contexts (e.g. <code>future::multicore</code>, <code>parallel::mclapply</code>).</li> <li>Keeps cmdstanr sampling parallelism intact (that\u2019s outside R\u2019s fork-based parallel machinery).</li> </ul> <p>This is the main reason you should avoid importing rpy2 directly in the main process: stability depends on initialization order and consistent environment configuration.</p>"},{"location":"development/development/#runtime-environment-lifecycle","title":"Runtime + environment lifecycle","text":"<p>brmspy separates two concepts:</p> <ul> <li>Runtime: a prebuilt bundle containing R libraries + CmdStan binaries (or a \u201ctraditional\u201d system install).</li> <li>Environment: a named, isolated user library for additional packages (e.g. \u201cmrp\u201d, \u201clegacy\u201d).</li> </ul>"},{"location":"development/development/#on-disk-layout","title":"On-disk layout","text":"<p>Typical <code>~/.brmspy</code> structure:</p> <pre><code>.brmspy\n\u251c\u2500\u2500 environment\n\u2502   \u251c\u2500\u2500 default\n\u2502   \u2502   \u251c\u2500\u2500 config.json\n\u2502   \u2502   \u2514\u2500\u2500 Rlib\n\u2502   \u251c\u2500\u2500 mrp\n\u2502   \u2502   \u251c\u2500\u2500 config.json\n\u2502   \u2502   \u2514\u2500\u2500 Rlib\n\u2502   \u2514\u2500\u2500 legacy\n\u2502       \u251c\u2500\u2500 config.json\n\u2502       \u2514\u2500\u2500 Rlib\n\u251c\u2500\u2500 environment_state.json\n\u251c\u2500\u2500 runtime\n\u2502   \u251c\u2500\u2500 macos-arm64-r4.5-0.2.0\n\u2502   \u2502   \u251c\u2500\u2500 cmdstan\n\u2502   \u2502   \u251c\u2500\u2500 hash\n\u2502   \u2502   \u251c\u2500\u2500 manifest.json\n\u2502   \u2502   \u2514\u2500\u2500 Rlib\n\u2502   \u2514\u2500\u2500 macos-arm64-r4.4-0.2.0\n\u2502       \u251c\u2500\u2500 cmdstan\n\u2502       \u251c\u2500\u2500 hash\n\u2502       \u251c\u2500\u2500 manifest.json\n\u2502       \u2514\u2500\u2500 Rlib\n\u2514\u2500\u2500 runtime_state.json\n</code></pre> <p>Notes:</p> <ul> <li>Runtime selection is fingerprint-based: <code>{os}-{arch}-r{major}.{minor}</code> plus the runtime version.</li> <li><code>runtime_state.json</code> stores the last configured runtime path.</li> <li><code>environment_state.json</code> stores the last active environment name.</li> </ul>"},{"location":"development/development/#brmsmanage-semantics","title":"<code>brms.manage()</code> semantics","text":"<p><code>brms.manage(...)</code> is intentionally \u201cstrongly isolated\u201d (see <code>brmspy/_session/session.py</code> and <code>brmspy/brms/_manage_module.py</code>):</p> <ul> <li>On enter:</li> <li>the worker is restarted (fresh embedded R session)</li> <li>autoloading is disabled for this session (autoload prevents safe unloading/switching)</li> <li>the requested environment config is applied (or <code>default</code>)</li> <li> <p>the worker prepends <code>~/.brmspy/environment/&lt;name&gt;/Rlib</code> to R <code>.libPaths()</code></p> </li> <li> <p>On exit:</p> </li> <li>environment config is persisted to <code>~/.brmspy/environment/&lt;name&gt;/config.json</code></li> <li>the active environment name is recorded in <code>~/.brmspy/environment_state.json</code></li> </ul> <p>This is the supported way to:</p> <ul> <li>install/uninstall R packages into an environment user library</li> <li>switch prebuilt runtimes / R_HOME without polluting the main process</li> <li>apply startup scripts in a controlled way</li> <li>avoid \u201cmutated global R session\u201d problems</li> </ul> <p>Note: runtime configuration is stored separately in <code>~/.brmspy/runtime_state.json</code> (see <code>brmspy/_runtime/_config.py</code>).</p>"},{"location":"development/development/#invariants-and-guardrails","title":"Invariants and guardrails","text":"<p>This refactor relies on strict invariants. Breaking them can reintroduce hard-to-debug segfaults and import-order issues.</p>"},{"location":"development/development/#1-main-process-must-not-import-rpy2robjects","title":"1) Main process must not import <code>rpy2.robjects</code>","text":"<p>Enforced in multiple layers:</p> <ul> <li>Import-linter contracts forbid importing <code>rpy2.robjects</code> outside the allowlist (see <code>.importlinter</code> and <code>script/importlinter_contracts.py</code>). This is run via <code>lint-imports</code> (wired into <code>./run_tests.sh</code>).</li> <li>Runtime sanity check: importing <code>brmspy.brms</code> in the main process will raise if <code>rpy2.robjects</code> was already imported (this catches \u201cimport order footguns\u201d early).</li> <li>Test sentinel: tests install a \u201cbomb\u201d in <code>sys.modules[\"rpy2.robjects*\"]</code> in the main process so accidental access fails fast (see <code>tests/conftest.py</code>).</li> </ul>"},{"location":"development/development/#2-worker-only-modules-must-stay-worker-only","title":"2) Worker-only modules must stay worker-only","text":"<p>Large parts of the codebase are explicitly worker-only, including:</p> <ul> <li>the rpy2 conversion helpers</li> <li>the brms wrapper functions</li> <li>runtime activation/install logic</li> </ul> <p>The import-linter setup also enforces layering constraints between these modules to prevent dependency cycles and accidental \u201cmain imports worker-only\u201d leaks.</p>"},{"location":"development/development/#testing","title":"Testing","text":""},{"location":"development/development/#test-markers-and-categories","title":"Test markers and categories","text":"<ul> <li><code>@pytest.mark.requires_brms</code></li> <li>tests that need brms to be installed and loadable inside the worker</li> <li><code>@pytest.mark.rdeps</code></li> <li>destructive R-dependency tests; only run when explicitly enabled</li> <li><code>@pytest.mark.worker</code></li> <li>run the test function inside the worker process (useful for testing worker-only code paths safely)</li> </ul>"},{"location":"development/development/#main-process-protection-no-rpy2-in-tests","title":"Main-process protection: \u201cno rpy2 in tests\u201d","text":"<p>Tests install a sentinel object in <code>sys.modules</code> for <code>rpy2.robjects*</code> in the main process so that any accidental usage fails fast.</p> <p>This is intentional: it keeps contributor tests honest and ensures the \u201cno rpy2 in main\u201d invariant stays true.</p>"},{"location":"development/development/#running-tests-locally","title":"Running tests locally","text":"<p>Main test run (pytest + coverage combine + import-linter):</p> <pre><code>./run_tests.sh\n</code></pre> <p>Notes:</p> <ul> <li><code>./run_tests.sh</code> runs <code>lint-imports</code> at the end (provided by the <code>import-linter</code> package).</li> <li>If <code>uv</code> is installed, the script prefers <code>uv run ...</code> for reproducibility.</li> </ul> <p>R-dependency tests (destructive; opt-in):</p> <pre><code>BRMSPY_DESTRUCTIVE_RDEPS_TESTS=1 ./run_tests_rdeps.sh\n</code></pre> <p>Worker-marked tests:</p> <pre><code>pytest -m worker -v\n</code></pre> <p>Notes for <code>@pytest.mark.worker</code>:</p> <ul> <li>Worker tests currently must not use pytest fixtures (until fixture shipping is implemented).</li> <li>Worker tests are executed by telling the worker to import the test module and call the function by name (an internal <code>_RUN_TEST_BY_NAME</code> command).</li> <li>In non-rdeps runs, the test collection step tries to ensure a prebuilt brms environment exists (typically named <code>_test</code>) so contributor test runs work \u201cout of the box\u201d without manual R setup.</li> </ul>"},{"location":"development/development/#cicd","title":"CI/CD","text":"<p>Workflows live in <code>.github/workflows/</code>.</p>"},{"location":"development/development/#python-test-matrix","title":"<code>python-test-matrix</code>","text":"<ul> <li>Builds and caches CmdStan + R libs per OS (cache keys include cmdstanr/brms/posterior and CmdStan 2.36.0).</li> <li>Runs Python matrix:</li> <li>Linux: Python 3.10 / 3.12 / 3.14</li> <li>macOS/Windows: Python 3.12</li> <li>Uses R 4.5 in CI and fixes ABI-mode environment vars (R_HOME + LD_LIBRARY_PATH on Unix).</li> <li>Runs <code>./run_tests.sh</code> (pytest + coverage combine + <code>lint-imports</code>).</li> <li>Updates the main coverage badge from the Ubuntu 3.12 job on <code>master</code>.</li> </ul>"},{"location":"development/development/#r-dependencies-tests","title":"<code>r-dependencies-tests</code>","text":"<ul> <li>Runs destructive R dependency tests on Linux/macOS/Windows.</li> <li>Enables destructive mode via <code>BRMSPY_DESTRUCTIVE_RDEPS_TESTS=1</code>.</li> <li>Ensures ABI-mode environment setup (R_HOME + platform-specific dynamic library search config).</li> <li>On Windows, caches and provides an Rtools installer so toolchain installation can be tested.</li> <li>Runs <code>./run_tests_rdeps.sh</code> which executes <code>pytest -m rdeps</code> and merges coverage shards.</li> <li>Uploads per-OS coverage artifacts and merges them on Ubuntu for a combined rdeps coverage badge.</li> </ul>"},{"location":"development/development/#runtime-publish","title":"<code>runtime-publish</code>","text":"<p>Manual workflow to build prebuilt runtimes for:</p> <ul> <li>OS: Linux (in Docker), macOS, Windows</li> <li>R versions: 4.0 through 4.5</li> </ul> <p>Linux builds happen inside the pinned builder image to keep glibc compatibility stable.</p> <p>The runtime archive is produced by:</p> <pre><code>python -m brmspy.build --output-dir dist/runtime --runtime-version \"$RUNTIME_VERSION\"\n</code></pre>"},{"location":"development/development/#python-publish","title":"<code>python-publish</code>","text":"<ul> <li>Runs tests, builds distributions, uploads to PyPI on release tags following the repo conventions.</li> <li>Uses cached CmdStan + R libs similarly to the test matrix.</li> </ul>"},{"location":"development/development/#docs","title":"<code>docs</code>","text":"<ul> <li>Builds mkdocs and deploys GitHub Pages on push to <code>master</code>.</li> </ul>"},{"location":"development/development/#debugging-worker-issues","title":"Debugging worker issues","text":""},{"location":"development/development/#understand-the-logging-pipeline","title":"Understand the logging pipeline","text":"<p>Worker output is forwarded to the main process:</p> <ul> <li>Worker uses a log queue to forward Python logging records to the parent\u2019s handlers.</li> <li>Worker also overrides <code>print()</code> so that raw output (including carriage returns used by progress bars) is emitted via logging without losing control characters.</li> </ul> <p>Practical consequence: R output, cmdstan progress, and Python logs all show up in one stream when the main process logger is configured.</p>"},{"location":"development/development/#common-environment-variables","title":"Common environment variables","text":"<p>These are the most relevant knobs when diagnosing issues:</p> <ul> <li><code>BRMSPY_WORKER=1</code></li> <li>run \u201cworker mode\u201d directly (no proxy). This is useful to isolate \u201cIPC/proxy\u201d issues from \u201crpy2/R\u201d issues during debugging, but it is not the recommended normal usage mode.</li> <li><code>BRMSPY_AUTOLOAD=0|1</code></li> <li>whether the worker should auto-activate the last runtime from <code>runtime_state.json</code> on startup</li> <li><code>BRMSPY_TEST=1</code></li> <li>enables some test-only paths (notably worker test execution by name)</li> <li><code>BRMSPY_DESTRUCTIVE_RDEPS_TESTS=1</code></li> <li>required to run <code>@pytest.mark.rdeps</code></li> <li><code>RPY2_CFFI_MODE=ABI</code></li> <li>recommended for stability</li> <li><code>R_HOME</code></li> <li>explicit R home directory; can help when multiple R installations exist</li> <li><code>LD_LIBRARY_PATH</code></li> <li>Unix-only; must include <code>$R_HOME/lib</code> for ABI mode to find libR. The main session tries to construct this itself for current R home.</li> <li><code>PATH</code> (Windows)</li> <li>must include the R <code>bin/x64</code> directory so DLLs are discoverable</li> </ul>"},{"location":"development/development/#reproducing-failures","title":"Reproducing failures","text":"<p>Prefer short, deterministic repro scripts that:</p> <ul> <li>create a new environment via <code>brms.manage(environment_name=\"...\")</code></li> <li>install dependencies</li> <li>run a single operation (<code>brms.brm</code>, <code>brms.loo</code>, etc.)</li> </ul> <p>Example structure:</p> <pre><code>from brmspy import brms\n\nwith brms.manage(environment_name=\"repro\") as ctx:\n    ctx.install_brms(use_prebuilt=True)\n\n# then run the minimal call that crashes\n</code></pre>"},{"location":"development/development/#restarting-a-stuck-session-during-development","title":"Restarting a stuck session during development","text":"<p>The proxy owns the worker lifecycle. If the worker gets into a bad state during development, restarting the Python process is the most reliable reset.</p> <p>For internal debugging, the proxy also supports restarting/shutdown, but these are not public API guarantees and may change.</p>"},{"location":"development/development/#documentation","title":"Documentation","text":"<p>Docs are built with mkdocs (see <code>mkdocs.yml</code>) and deployed via the <code>docs</code> GitHub Actions workflow.</p>"},{"location":"development/development/#docstring-style","title":"Docstring style","text":"<p>Docstrings use NumPy style and Markdown fenced code blocks.</p>"},{"location":"development/development/#contributing","title":"Contributing","text":""},{"location":"development/development/#code-style","title":"Code style","text":"<ul> <li>Format/lint: <code>ruff</code></li> <li>Type checking: <code>mypy</code></li> <li>Import discipline: <code>import-linter</code> (run as part of <code>./run_tests.sh</code>)</li> </ul>"},{"location":"development/development/#pr-expectations","title":"PR expectations","text":"<ul> <li>Keep the \u201cno rpy2 in main process\u201d invariant.</li> <li>Prefer adding coverage via:</li> <li>main-process tests for proxy behavior, codec behavior, and high-level API behavior</li> <li><code>@pytest.mark.worker</code> tests for worker-only implementation details</li> </ul>"},{"location":"examples/brmspy-estimating-multivariate-models/","title":"brmspy - Estimating Multivariate Models","text":"In\u00a0[1]: Copied! <pre>import os\nimport sys\n\nimport sys, os # for running from repo\nsys.path.insert(0, os.path.abspath(\"../../\"))\n\ntry: from brmspy import brms; import seaborn;\nexcept ImportError:\n    %pip install -q brmspy seaborn\n    from brmspy import brms\n\nfrom brmspy.brms import set_rescor, bf, lf\n\nimport pandas as pd\nimport arviz as az\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set_style(\"darkgrid\")\n\nrenv = \"multivariate-models\"\n\nif not brms.environment_exists(renv):\n    with brms.manage(environment_name=renv) as ctx:\n        ctx.install_runtime()\n        ctx.install_rpackage(\"MCMCglmm\")\nelse:\n    brms.environment_activate(renv)\n</pre>  import os import sys  import sys, os # for running from repo sys.path.insert(0, os.path.abspath(\"../../\"))  try: from brmspy import brms; import seaborn; except ImportError:     %pip install -q brmspy seaborn     from brmspy import brms  from brmspy.brms import set_rescor, bf, lf  import pandas as pd import arviz as az import numpy as np import matplotlib.pyplot as plt import seaborn as sns  sns.set_style(\"darkgrid\")  renv = \"multivariate-models\"  if not brms.environment_exists(renv):     with brms.manage(environment_name=renv) as ctx:         ctx.install_runtime()         ctx.install_rpackage(\"MCMCglmm\") else:     brms.environment_activate(renv) <pre>[brmspy][_call_with_frames_removed] Running autoload!\n[brmspy][_autoload] Activating runtime /Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0\n[brmspy][_autoload] lib paths are ['/Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/library', '/Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0/Rlib']\n[brmspy][_autoload] Setting cmdstan path to /Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0/cmdstan\n</pre> In\u00a0[2]: Copied! <pre>df = brms.get_data(\"BTdata\", package = \"MCMCglmm\")\ndf.head()\n</pre> df = brms.get_data(\"BTdata\", package = \"MCMCglmm\") df.head() Out[2]: tarsus back animal dam fosternest hatchdate sex 1 -1.892297 1.146421 R187142 R187557 F2102 -0.687402 Fem 2 1.136110 -0.759652 R187154 R187559 F1902 -0.687402 Male 3 0.984689 0.144937 R187341 R187568 A602 -0.427981 Male 4 0.379008 0.255585 R046169 R187518 A1302 -1.465664 Male 5 -0.075253 -0.300699 R046161 R187528 A2602 -1.465664 Fem In\u00a0[3]: Copied! <pre>bform1 = bf(\"\"\"\nmvbind(tarsus, back) ~\n    sex + \n    hatchdate + \n    (1|p|fosternest) + \n    (1|q|dam)\n\"\"\") + set_rescor(rescor=True)\n\nfit1 = brms.brm(bform1, data = df, chains = 2, cores = 2, silent = 2, refresh = 0)\n</pre> bform1 = bf(\"\"\" mvbind(tarsus, back) ~     sex +      hatchdate +      (1|p|fosternest) +      (1|q|dam) \"\"\") + set_rescor(rescor=True)  fit1 = brms.brm(bform1, data = df, chains = 2, cores = 2, silent = 2, refresh = 0) <pre>[brmspy][worker_main] Fitting model with brms (backend: cmdstanr)...\n[brmspy][worker_main] Fit done!\n</pre> <p>As can be seen in the model code, we have used mvbind notation to tell brms that both tarsus and back are separate response variables. The term (1|p|fosternest) indicates a varying intercept over fosternest. By writing |p| in between we indicate that all varying effects of fosternest should be modeled as correlated. This makes sense since we actually have two model parts, one for tarsus and one for back. The indicator p is arbitrary and can be replaced by other symbols that comes into your mind (for details about the multilevel syntax of brms, see help(\"brmsformula\") and vignette(\"brms_multilevel\")). Similarly, the term (1|q|dam) indicates correlated varying effects of the genetic mother of the chicks. Alternatively, we could have also modeled the genetic similarities through pedigrees and corresponding relatedness matrices, but this is not the focus of this vignette (please see vignette(\"brms_phylogenetics\")). The model results are readily summarized via</p> In\u00a0[4]: Copied! <pre>for var in fit1.idata.posterior_predictive.data_vars:\n    print(var)\n    print(az.loo(fit1.idata, var_name=var))\n    print(\"\\n\")\n</pre> for var in fit1.idata.posterior_predictive.data_vars:     print(var)     print(az.loo(fit1.idata, var_name=var))     print(\"\\n\") <pre>tarsus\n</pre> <pre>/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.70 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n</pre> <pre>Computed from 2000 posterior samples and 828 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo -2905.97    15.70\np_loo     2104.33        -\n\nThere has been a warning during the calculation. Please check the results.\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.70]   (good)        0    0.0%\n   (0.70, 1]   (bad)         0    0.0%\n   (1, Inf)   (very bad)  828  100.0%\n\n\n\nback\nComputed from 2000 posterior samples and 828 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo -1488.51     1.91\np_loo      523.89        -\n\nThere has been a warning during the calculation. Please check the results.\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.70]   (good)      182   22.0%\n   (0.70, 1]   (bad)       626   75.6%\n   (1, Inf)   (very bad)   20    2.4%\n\n\n\n</pre> <pre>/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.70 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n</pre> In\u00a0[5]: Copied! <pre>brms.summary(fit1)\n</pre> brms.summary(fit1) Out[5]: <pre> Family: MV(gaussian, gaussian) \n  Links: mu = identity\n         mu = identity \nFormula: tarsus ~ sex + hatchdate + (1 | p | fosternest) + (1 | q | dam) \n         back ~ sex + hatchdate + (1 | p | fosternest) + (1 | q | dam) \n   Data: structure(list(tarsus = c(-1.89229718155107, 1.136 (Number of observations: 828) \n  Draws: 2 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 2000\n\nMultilevel Hyperparameters:\n~dam (Number of levels: 106) \n                                     Estimate Est.Error l-95% CI u-95% CI Rhat\nsd(tarsus_Intercept)                     0.49      0.05     0.39     0.60 1.00\nsd(back_Intercept)                       0.24      0.08     0.09     0.39 1.02\ncor(tarsus_Intercept,back_Intercept)    -0.52      0.23    -0.95    -0.04 1.01\n                                     Bulk_ESS Tail_ESS\nsd(tarsus_Intercept)                      655     1202\nsd(back_Intercept)                        233      458\ncor(tarsus_Intercept,back_Intercept)      305      382\n\n~fosternest (Number of levels: 104) \n                                     Estimate Est.Error l-95% CI u-95% CI Rhat\nsd(tarsus_Intercept)                     0.27      0.06     0.16     0.37 1.00\nsd(back_Intercept)                       0.35      0.06     0.23     0.46 1.01\ncor(tarsus_Intercept,back_Intercept)     0.69      0.21     0.18     0.98 1.02\n                                     Bulk_ESS Tail_ESS\nsd(tarsus_Intercept)                      547     1079\nsd(back_Intercept)                        476      943\ncor(tarsus_Intercept,back_Intercept)      133      355\n\nRegression Coefficients:\n                 Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\ntarsus_Intercept    -0.41      0.07    -0.54    -0.27 1.00      969     1339\nback_Intercept      -0.01      0.06    -0.14     0.12 1.00     1185     1030\ntarsus_sexMale       0.77      0.06     0.66     0.88 1.00     2809     1472\ntarsus_sexUNK        0.23      0.13    -0.02     0.49 1.00     1837     1162\ntarsus_hatchdate    -0.04      0.06    -0.15     0.08 1.00      938     1095\nback_sexMale         0.01      0.06    -0.11     0.13 1.00     2284     1704\nback_sexUNK          0.15      0.15    -0.14     0.45 1.00     2219     1725\nback_hatchdate      -0.09      0.05    -0.19     0.01 1.00     1465     1460\n\nFurther Distributional Parameters:\n             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma_tarsus     0.76      0.02     0.72     0.80 1.00     1744     1390\nsigma_back       0.90      0.02     0.85     0.95 1.00     1380     1375\n\nResidual Correlations: \n                    Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nrescor(tarsus,back)    -0.05      0.04    -0.13     0.02 1.00     2054     1235\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).</pre> <p>The summary output of multivariate models closely resembles those of univariate models, except that the parameters now have the corresponding response variable as prefix. Across dams, tarsus length and back color seem to be negatively correlated, while across fosternests the opposite is true. This indicates differential effects of genetic and environmental factors on these two characteristics. Further, the small residual correlation rescor(tarsus, back) on the bottom of the output indicates that there is little unmodeled dependency between tarsus length and back color. Although not necessary at this point, we have already computed and stored the LOO information criterion of fit1, which we will use for model comparisons. Next, let\u2019s take a look at some posterior-predictive checks, which give us a first impression of the model fit.</p> In\u00a0[6]: Copied! <pre>az.plot_ppc(fit1.idata, var_names=['tarsus'])\n</pre> az.plot_ppc(fit1.idata, var_names=['tarsus']) Out[6]: <pre>&lt;Axes: xlabel='tarsus'&gt;</pre> In\u00a0[7]: Copied! <pre>az.plot_ppc(fit1.idata, var_names=[\"back\"])\n</pre> az.plot_ppc(fit1.idata, var_names=[\"back\"]) Out[7]: <pre>&lt;Axes: xlabel='back'&gt;</pre> <p>This looks pretty solid, but we notice a slight unmodeled left skewness in the distribution of tarsus. We will come back to this later on. Next, we want to investigate how much variation in the response variables can be explained by our model and we use a Bayesian generalization of the \ud835\udc452 coefficient.</p> In\u00a0[8]: Copied! <pre>brms.call(\"bayes_R2\", fit1)\n</pre> brms.call(\"bayes_R2\", fit1) Out[8]: Estimate Est.Error Q2.5 Q97.5 R2tarsus 0.435203 0.198050 0.023223 0.027383 R2back 0.388903 0.142697 0.479798 0.250811 <p>Clearly, there is much variation in both animal characteristics that we can not explain, but apparently we can explain more of the variation in tarsus length than in back color.</p> In\u00a0[9]: Copied! <pre>bf_tarsus = bf(\"tarsus ~ sex + (1|p|fosternest) + (1|q|dam)\")\nbf_back = bf(\"back ~ hatchdate + (1|p|fosternest) + (1|q|dam)\")\n\nfit2 = brms.brm(bf_tarsus + bf_back + set_rescor(True), data = df, chains = 2, cores = 2, silent = 2, refresh = 0)\n</pre> bf_tarsus = bf(\"tarsus ~ sex + (1|p|fosternest) + (1|q|dam)\") bf_back = bf(\"back ~ hatchdate + (1|p|fosternest) + (1|q|dam)\")  fit2 = brms.brm(bf_tarsus + bf_back + set_rescor(True), data = df, chains = 2, cores = 2, silent = 2, refresh = 0) <pre>[brmspy][worker_main] Fitting model with brms (backend: cmdstanr)...\n[brmspy][worker_main] Fit done!\n</pre> <p>Note that we have literally added the two model parts via the + operator, which is in this case equivalent to writing mvbf(bf_tarsus, bf_back). See help(\"brmsformula\") and help(\"mvbrmsformula\") for more details about this syntax. Again, we summarize the model first.</p> In\u00a0[10]: Copied! <pre>for var in fit2.idata.posterior_predictive.data_vars:\n    print(var)\n    print(az.loo(fit2.idata, var_name=var))\n    print(\"\\n\")\n</pre> for var in fit2.idata.posterior_predictive.data_vars:     print(var)     print(az.loo(fit2.idata, var_name=var))     print(\"\\n\") <pre>tarsus\n</pre> <pre>/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.70 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n</pre> <pre>Computed from 2000 posterior samples and 828 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo -2920.82    14.77\np_loo     2119.06        -\n\nThere has been a warning during the calculation. Please check the results.\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.70]   (good)        0    0.0%\n   (0.70, 1]   (bad)         0    0.0%\n   (1, Inf)   (very bad)  828  100.0%\n\n\n\nback\nComputed from 2000 posterior samples and 828 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo -1492.26     1.79\np_loo      528.38        -\n\nThere has been a warning during the calculation. Please check the results.\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.70]   (good)      149   18.0%\n   (0.70, 1]   (bad)       661   79.8%\n   (1, Inf)   (very bad)   18    2.2%\n\n\n\n</pre> <pre>/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.70 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n</pre> In\u00a0[11]: Copied! <pre>brms.summary(fit2)\n</pre> brms.summary(fit2) Out[11]: <pre> Family: MV(gaussian, gaussian) \n  Links: mu = identity\n         mu = identity \nFormula: tarsus ~ sex + (1 | p | fosternest) + (1 | q | dam) \n         back ~ hatchdate + (1 | p | fosternest) + (1 | q | dam) \n   Data: structure(list(tarsus = c(-1.89229718155107, 1.136 (Number of observations: 828) \n  Draws: 2 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 2000\n\nMultilevel Hyperparameters:\n~dam (Number of levels: 106) \n                                     Estimate Est.Error l-95% CI u-95% CI Rhat\nsd(tarsus_Intercept)                     0.48      0.05     0.39     0.58 1.00\nsd(back_Intercept)                       0.25      0.07     0.11     0.39 1.00\ncor(tarsus_Intercept,back_Intercept)    -0.50      0.22    -0.93    -0.07 1.00\n                                     Bulk_ESS Tail_ESS\nsd(tarsus_Intercept)                      977     1316\nsd(back_Intercept)                        356      784\ncor(tarsus_Intercept,back_Intercept)      643      902\n\n~fosternest (Number of levels: 104) \n                                     Estimate Est.Error l-95% CI u-95% CI Rhat\nsd(tarsus_Intercept)                     0.27      0.05     0.17     0.37 1.00\nsd(back_Intercept)                       0.35      0.06     0.24     0.46 1.00\ncor(tarsus_Intercept,back_Intercept)     0.68      0.20     0.22     0.98 1.02\n                                     Bulk_ESS Tail_ESS\nsd(tarsus_Intercept)                      719     1374\nsd(back_Intercept)                        527     1129\ncor(tarsus_Intercept,back_Intercept)      334      660\n\nRegression Coefficients:\n                 Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\ntarsus_Intercept    -0.41      0.07    -0.55    -0.28 1.00     1604     1815\nback_Intercept      -0.00      0.06    -0.11     0.11 1.00     2361     1687\ntarsus_sexMale       0.77      0.06     0.66     0.88 1.00     3761     1564\ntarsus_sexUNK        0.22      0.13    -0.03     0.49 1.00     3471     1515\nback_hatchdate      -0.08      0.05    -0.18     0.02 1.00     2359     1469\n\nFurther Distributional Parameters:\n             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma_tarsus     0.76      0.02     0.71     0.80 1.00     2873     1325\nsigma_back       0.90      0.02     0.86     0.95 1.00     3119     1553\n\nResidual Correlations: \n                    Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nrescor(tarsus,back)    -0.05      0.04    -0.13     0.02 1.00     3180     1756\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).</pre> <p>Let\u2019s find out, how model fit changed due to excluding certain effects from the initial model:</p> In\u00a0[12]: Copied! <pre>var = \"back\"\nloo1 = az.loo(fit1.idata, var_name=var)\nloo2 = az.loo(fit2.idata, var_name=var)\ncmp = az.compare({\"m1\": fit1.idata, \"m2\": fit2.idata}, ic=\"loo\", var_name=var)\ncmp\n</pre> var = \"back\" loo1 = az.loo(fit1.idata, var_name=var) loo2 = az.loo(fit2.idata, var_name=var) cmp = az.compare({\"m1\": fit1.idata, \"m2\": fit2.idata}, ic=\"loo\", var_name=var) cmp <pre>/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.70 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.70 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.70 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.70 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n</pre> Out[12]: rank elpd_loo p_loo elpd_diff weight se dse warning scale m1 0 -1488.510819 523.891116 0.000000 1.000000e+00 1.906331 0.000000 True log m2 1 -1492.264498 528.376009 3.753679 7.993606e-15 1.793305 2.450533 True log <p>Apparently, there is no noteworthy difference in the model fit. Accordingly, we do not really need to model sex and hatchdate for both response variables, but there is also no harm in including them (so I would probably just include them).</p> <p>To give you a glimpse of the capabilities of brms\u2019 multivariate syntax, we change our model in various directions at the same time. Remember the slight left skewness of tarsus, which we will now model by using the skew_normal family instead of the gaussian family. Since we do not have a multivariate normal (or student-t) model, anymore, estimating residual correlations is no longer possible. We make this explicit using the set_rescor function. Further, we investigate if the relationship of back and hatchdate is really linear as previously assumed by fitting a non-linear spline of hatchdate. On top of it, we model separate residual variances of tarsus for male and female chicks.</p> In\u00a0[13]: Copied! <pre>from brmspy.brms import skew_normal, gaussian\n</pre> from brmspy.brms import skew_normal, gaussian In\u00a0[14]: Copied! <pre>bf_tarsus = bf(\"tarsus ~ sex + (1|p|fosternest) + (1|q|dam)\") + lf(\"sigma ~ 0 + sex\") + skew_normal()\nbf_back = bf(\"back ~ s(hatchdate) + (1|p|fosternest) + (1|q|dam)\") + gaussian()\n\nfit3 = brms.brm(\n  bf_tarsus + bf_back + set_rescor(False),\n  data = df, chains = 2, cores = 2,\n  control = {\"adapt_delta\": 0.95},\n  silent = 2, refresh = 0\n)\n</pre>  bf_tarsus = bf(\"tarsus ~ sex + (1|p|fosternest) + (1|q|dam)\") + lf(\"sigma ~ 0 + sex\") + skew_normal() bf_back = bf(\"back ~ s(hatchdate) + (1|p|fosternest) + (1|q|dam)\") + gaussian()  fit3 = brms.brm(   bf_tarsus + bf_back + set_rescor(False),   data = df, chains = 2, cores = 2,   control = {\"adapt_delta\": 0.95},   silent = 2, refresh = 0 ) <pre>[brmspy][worker_main] Fitting model with brms (backend: cmdstanr)...\n[brmspy][worker_main] Fit done!\n</pre> <p>Again, we summarize the model and look at some posterior-predictive checks.</p> In\u00a0[15]: Copied! <pre>for var in fit3.idata.posterior_predictive.data_vars:\n    print(var)\n    print(az.loo(fit3.idata, var_name=var))\n    print(\"\\n\")\n</pre> for var in fit3.idata.posterior_predictive.data_vars:     print(var)     print(az.loo(fit3.idata, var_name=var))     print(\"\\n\") <pre>tarsus\n</pre> <pre>/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.70 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n</pre> <pre>Computed from 2000 posterior samples and 828 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo -2861.20    14.56\np_loo     2066.41        -\n\nThere has been a warning during the calculation. Please check the results.\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.70]   (good)        0    0.0%\n   (0.70, 1]   (bad)         0    0.0%\n   (1, Inf)   (very bad)  828  100.0%\n\n\n\nback\nComputed from 2000 posterior samples and 828 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo -1508.62     1.91\np_loo      543.52        -\n\nThere has been a warning during the calculation. Please check the results.\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.70]   (good)       57    6.9%\n   (0.70, 1]   (bad)       736   88.9%\n   (1, Inf)   (very bad)   35    4.2%\n\n\n\n</pre> <pre>/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.70 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n</pre> In\u00a0[16]: Copied! <pre>brms.summary(fit3)\n</pre> brms.summary(fit3) Out[16]: <pre> Family: MV(skew_normal, gaussian) \n  Links: mu = identity; sigma = log\n         mu = identity \nFormula: tarsus ~ sex + (1 | p | fosternest) + (1 | q | dam) \n         sigma ~ 0 + sex\n         back ~ s(hatchdate) + (1 | p | fosternest) + (1 | q | dam) \n   Data: structure(list(tarsus = c(-1.89229718155107, 1.136 (Number of observations: 828) \n  Draws: 2 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 2000\n\nSmoothing Spline Hyperparameters:\n                       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS\nsds(back_shatchdate_1)     2.15      1.09     0.50     4.69 1.00      628\n                       Tail_ESS\nsds(back_shatchdate_1)      694\n\nMultilevel Hyperparameters:\n~dam (Number of levels: 106) \n                                     Estimate Est.Error l-95% CI u-95% CI Rhat\nsd(tarsus_Intercept)                     0.47      0.05     0.38     0.57 1.00\nsd(back_Intercept)                       0.23      0.07     0.09     0.37 1.01\ncor(tarsus_Intercept,back_Intercept)    -0.52      0.24    -0.94    -0.03 1.01\n                                     Bulk_ESS Tail_ESS\nsd(tarsus_Intercept)                      595      998\nsd(back_Intercept)                        219      511\ncor(tarsus_Intercept,back_Intercept)      295      413\n\n~fosternest (Number of levels: 104) \n                                     Estimate Est.Error l-95% CI u-95% CI Rhat\nsd(tarsus_Intercept)                     0.26      0.05     0.16     0.37 1.00\nsd(back_Intercept)                       0.31      0.06     0.20     0.42 1.00\ncor(tarsus_Intercept,back_Intercept)     0.65      0.22     0.14     0.98 1.00\n                                     Bulk_ESS Tail_ESS\nsd(tarsus_Intercept)                      404      938\nsd(back_Intercept)                        489      825\ncor(tarsus_Intercept,back_Intercept)      223      514\n\nRegression Coefficients:\n                     Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS\ntarsus_Intercept        -0.42      0.07    -0.55    -0.28 1.00      797\nback_Intercept           0.00      0.05    -0.10     0.10 1.00     1561\ntarsus_sexMale           0.77      0.05     0.67     0.88 1.00     3109\ntarsus_sexUNK            0.22      0.12    -0.02     0.45 1.00     2631\nsigma_tarsus_sexFem     -0.30      0.04    -0.38    -0.22 1.00     2566\nsigma_tarsus_sexMale    -0.25      0.04    -0.32    -0.17 1.00     2316\nsigma_tarsus_sexUNK     -0.40      0.13    -0.65    -0.14 1.00     1858\nback_shatchdate_1       -0.27      3.44    -6.08     7.62 1.00      833\n                     Tail_ESS\ntarsus_Intercept         1151\nback_Intercept           1676\ntarsus_sexMale           1672\ntarsus_sexUNK            1556\nsigma_tarsus_sexFem      1583\nsigma_tarsus_sexMale     1540\nsigma_tarsus_sexUNK      1613\nback_shatchdate_1        1025\n\nFurther Distributional Parameters:\n             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma_back       0.90      0.02     0.85     0.95 1.00     1997     1479\nalpha_tarsus    -1.24      0.41    -1.91    -0.06 1.00     1009      296\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).</pre> <p>We see that the (log) residual standard deviation of tarsus is somewhat larger for chicks whose sex could not be identified as compared to male or female chicks. Further, we see from the negative alpha (skewness) parameter of tarsus that the residuals are indeed slightly left-skewed. Lastly, running</p> In\u00a0[17]: Copied! <pre>result = brms.call(\"conditional_effects\", fit3, \"hatchdate\", resp=\"back\")\ndf_result = result['back.back_hatchdate']\n\ndf_plot = df_result.sort_values(\"hatchdate\")\n\nfig, ax = plt.subplots()\n\nax.plot(\n    df_plot[\"hatchdate\"],\n    df_plot[\"estimate__\"],\n    color=\"blue\"\n)\n\nax.fill_between(\n    df_plot[\"hatchdate\"],\n    df_plot[\"lower__\"],\n    df_plot[\"upper__\"],\n    alpha=0.3,\n    color=\"blue\"\n)\n\nax.set_xlabel(\"hatchdate\")\nax.set_ylabel(\"back\")\nax.set_title(\"Conditional effect of hatchdate on back\")\n\nplt.show()\n</pre> result = brms.call(\"conditional_effects\", fit3, \"hatchdate\", resp=\"back\") df_result = result['back.back_hatchdate']  df_plot = df_result.sort_values(\"hatchdate\")  fig, ax = plt.subplots()  ax.plot(     df_plot[\"hatchdate\"],     df_plot[\"estimate__\"],     color=\"blue\" )  ax.fill_between(     df_plot[\"hatchdate\"],     df_plot[\"lower__\"],     df_plot[\"upper__\"],     alpha=0.3,     color=\"blue\" )  ax.set_xlabel(\"hatchdate\") ax.set_ylabel(\"back\") ax.set_title(\"Conditional effect of hatchdate on back\")  plt.show() <p>reveals a non-linear relationship of hatchdate on the back color, which seems to change in waves over the course of the hatch dates.</p> <p>There are many more modeling options for multivariate models, which are not discussed in this vignette. Examples include autocorrelation structures, Gaussian processes, or explicit non-linear predictors (e.g., see help(\"brmsformula\") or vignette(\"brms_multilevel\")). In fact, nearly all the flexibility of univariate models is retained in multivariate models.</p>"},{"location":"examples/brmspy-estimating-multivariate-models/#brmspy-estimating-multivariate-models","title":"brmspy - Estimating Multivariate Models\u00b6","text":"<p>Example adapted from: HERE</p>"},{"location":"examples/brmspy-estimating-multivariate-models/#introduction","title":"Introduction\u00b6","text":"<p>In the present example, we want to discuss how to specify multivariate multilevel models using brms. We call a model multivariate if it contains multiple response variables, each being predicted by its own set of predictors. Consider an example from biology. Hadfield, Nutall, Osorio, and Owens (2007) analyzed data of the Eurasian blue tit (https://en.wikipedia.org/wiki/Eurasian_blue_tit). They predicted the tarsus length as well as the back color of chicks. Half of the brood were put into another fosternest, while the other half stayed in the fosternest of their own dam. This allows to separate genetic from environmental factors. Additionally, we have information about the hatchdate and sex of the chicks (the latter being known for 94% of the animals).</p>"},{"location":"examples/brmspy-estimating-multivariate-models/#basic-multivariate-models","title":"Basic Multivariate Models\u00b6","text":"<p>We begin with a relatively simple multivariate normal model.</p>"},{"location":"examples/brmspy-estimating-multivariate-models/#more-complex-multivariate-models","title":"More Complex Multivariate Models\u00b6","text":"<p>Now, suppose we only want to control for sex in tarsus but not in back and vice versa for hatchdate. Not that this is particular reasonable for the present example, but it allows us to illustrate how to specify different formulas for different response variables. We can no longer use mvbind syntax and so we have to use a more verbose approach:</p>"},{"location":"examples/brmspy-estimating-multivariate-models/#references","title":"References\u00b6","text":"<p>Hadfield JD, Nutall A, Osorio D, Owens IPF (2007). Testing the phenotypic gambit: phenotypic, genetic and environmental correlations of colour. Journal of Evolutionary Biology, 20(2), 549-557.</p>"},{"location":"examples/brmspy-google-colab/","title":"brmspy - google colab","text":"In\u00a0[1]: Copied! <pre>import sys, os # for running from repo\nsys.path.insert(0, os.path.abspath(\"../../\"))\n\ntry: from brmspy import brms\nexcept ImportError:\n    %pip install -q brmspy\n    from brmspy import brms\n</pre> import sys, os # for running from repo sys.path.insert(0, os.path.abspath(\"../../\"))  try: from brmspy import brms except ImportError:     %pip install -q brmspy     from brmspy import brms <pre>[brmspy][_call_with_frames_removed] Running autoload!\n[brmspy][_autoload] Activating runtime /Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0\n[brmspy][_autoload] lib paths are ['/Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/library', '/Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0/Rlib']\n[brmspy][_autoload] Setting cmdstan path to /Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0/cmdstan\n</pre> In\u00a0[2]: Copied! <pre>with brms.manage() as ctx:\n    ctx.install_brms(use_prebuilt=True)\n</pre> with brms.manage() as ctx:     ctx.install_brms(use_prebuilt=True) <pre>[brmspy][install_brms] Activating runtime /Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0\n[brmspy][install_brms] lib paths are ['/Users/sebastian/.brmspy/environment/default/Rlib', '/Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/library', '/Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0/Rlib']\n[brmspy][install_brms] Setting cmdstan path to /Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0/cmdstan\n</pre> In\u00a0[3]: Copied! <pre>epilepsy = brms.get_brms_data(\"epilepsy\")\nformula = \"count ~ zAge + zBase * Trt + (1|patient)\"\nfamily = \"poisson\"\nbrms.default_prior(formula, data=epilepsy, family=family)\n</pre> epilepsy = brms.get_brms_data(\"epilepsy\") formula = \"count ~ zAge + zBase * Trt + (1|patient)\" family = \"poisson\" brms.default_prior(formula, data=epilepsy, family=family) Out[3]: prior class coef group resp dpar nlpar lb ub tag source 1 b default 2 b Trt1 default 3 b zAge default 4 b zBase default 5 b zBase:Trt1 default 6 student_t(3, 1.4, 2.5) Intercept default 7 student_t(3, 0, 2.5) sd 0 default 8 sd patient default 9 sd Intercept patient default In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[4]: Copied! <pre>model = brms.brm(\n    formula=formula,\n    data=epilepsy,\n    family=family,\n    warmup=500,\n    iter=1000,\n    chains=4\n)\nidata = model.idata\n</pre> model = brms.brm(     formula=formula,     data=epilepsy,     family=family,     warmup=500,     iter=1000,     chains=4 ) idata = model.idata <pre>[brmspy][worker_main] Fitting model with brms (backend: cmdstanr)...\nRunning MCMC with 4 chains, at most 2 in parallel...\n\nChain 1 Iteration:   1 / 1000 [  0%]  (Warmup) \nChain 2 Iteration:   1 / 1000 [  0%]  (Warmup) \nChain 1 Iteration: 100 / 1000 [ 10%]  (Warmup) \nChain 2 Iteration: 100 / 1000 [ 10%]  (Warmup) \nChain 1 Iteration: 200 / 1000 [ 20%]  (Warmup) \nChain 1 Iteration: 300 / 1000 [ 30%]  (Warmup) \nChain 2 Iteration: 200 / 1000 [ 20%]  (Warmup) \nChain 1 Iteration: 400 / 1000 [ 40%]  (Warmup) \nChain 2 Iteration: 300 / 1000 [ 30%]  (Warmup) \nChain 1 Iteration: 500 / 1000 [ 50%]  (Warmup) \nChain 1 Iteration: 501 / 1000 [ 50%]  (Sampling) \nChain 2 Iteration: 400 / 1000 [ 40%]  (Warmup) \nChain 1 Iteration: 600 / 1000 [ 60%]  (Sampling) \nChain 1 Iteration: 700 / 1000 [ 70%]  (Sampling) \nChain 2 Iteration: 500 / 1000 [ 50%]  (Warmup) \nChain 2 Iteration: 501 / 1000 [ 50%]  (Sampling) \nChain 2 Iteration: 600 / 1000 [ 60%]  (Sampling) \nChain 1 Iteration: 800 / 1000 [ 80%]  (Sampling) \nChain 2 Iteration: 700 / 1000 [ 70%]  (Sampling) \nChain 1 Iteration: 900 / 1000 [ 90%]  (Sampling) \nChain 2 Iteration: 800 / 1000 [ 80%]  (Sampling) \nChain 1 Iteration: 1000 / 1000 [100%]  (Sampling) \nChain 2 Iteration: 900 / 1000 [ 90%]  (Sampling) \nChain 1 finished in 1.0 seconds.\nChain 2 Iteration: 1000 / 1000 [100%]  (Sampling) \nChain 3 Iteration:   1 / 1000 [  0%]  (Warmup) \nChain 2 finished in 1.1 seconds.\nChain 4 Iteration:   1 / 1000 [  0%]  (Warmup) \nChain 3 Iteration: 100 / 1000 [ 10%]  (Warmup) \nChain 3 Iteration: 200 / 1000 [ 20%]  (Warmup) \nChain 4 Iteration: 100 / 1000 [ 10%]  (Warmup) \nChain 3 Iteration: 300 / 1000 [ 30%]  (Warmup) \nChain 4 Iteration: 200 / 1000 [ 20%]  (Warmup) \nChain 3 Iteration: 400 / 1000 [ 40%]  (Warmup) \nChain 4 Iteration: 300 / 1000 [ 30%]  (Warmup) \nChain 3 Iteration: 500 / 1000 [ 50%]  (Warmup) \nChain 3 Iteration: 501 / 1000 [ 50%]  (Sampling) \nChain 3 Iteration: 600 / 1000 [ 60%]  (Sampling) \nChain 4 Iteration: 400 / 1000 [ 40%]  (Warmup) \nChain 3 Iteration: 700 / 1000 [ 70%]  (Sampling) \nChain 4 Iteration: 500 / 1000 [ 50%]  (Warmup) \nChain 4 Iteration: 501 / 1000 [ 50%]  (Sampling) \nChain 3 Iteration: 800 / 1000 [ 80%]  (Sampling) \nChain 4 Iteration: 600 / 1000 [ 60%]  (Sampling) \nChain 3 Iteration: 900 / 1000 [ 90%]  (Sampling) \nChain 3 Iteration: 1000 / 1000 [100%]  (Sampling) \nChain 4 Iteration: 700 / 1000 [ 70%]  (Sampling) \nChain 3 finished in 1.1 seconds.\nChain 4 Iteration: 800 / 1000 [ 80%]  (Sampling) \nChain 4 Iteration: 900 / 1000 [ 90%]  (Sampling) \nChain 4 Iteration: 1000 / 1000 [100%]  (Sampling) \nChain 4 finished in 1.1 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 1.1 seconds.\nTotal execution time: 2.5 seconds.\n\n[brmspy][worker_main] Fit done!\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[5]: Copied! <pre>brms.save_rds(model, \"epilepsy_fixed_effects.rds\")\n# load later using: model = brms.load_rds_fit(\"epilepsy_fixed_effects.rds\")\n</pre> brms.save_rds(model, \"epilepsy_fixed_effects.rds\") # load later using: model = brms.load_rds_fit(\"epilepsy_fixed_effects.rds\") In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[6]: Copied! <pre>epilepsy\n</pre> epilepsy Out[6]: Age Base Trt patient visit count obs zAge zBase 1 31.0 11.0 0 1 1 5.0 1 0.424995 -0.757173 2 30.0 11.0 0 2 1 3.0 2 0.265284 -0.757173 3 25.0 6.0 0 3 1 2.0 3 -0.533274 -0.944403 4 36.0 8.0 0 4 1 4.0 4 1.223553 -0.869511 5 22.0 66.0 0 5 1 7.0 5 -1.012408 1.302363 ... ... ... ... ... ... ... ... ... ... 232 32.0 16.0 1 55 4 3.0 232 0.584707 -0.569942 233 26.0 22.0 1 56 4 8.0 233 -0.373562 -0.345266 234 21.0 25.0 1 57 4 1.0 234 -1.172120 -0.232927 235 36.0 13.0 1 58 4 0.0 235 1.223553 -0.682281 236 37.0 12.0 1 59 4 2.0 236 1.383264 -0.719727 <p>236 rows \u00d7 9 columns</p> In\u00a0[7]: Copied! <pre>c = brms.call(\"as.data.frame\", epilepsy)\nc\n</pre> c = brms.call(\"as.data.frame\", epilepsy) c Out[7]: Age Base Trt patient visit count obs zAge zBase _obs_id_ 1 31.0 11.0 0 1 1 5.0 1 0.424995 -0.757173 2 30.0 11.0 0 2 1 3.0 2 0.265284 -0.757173 3 25.0 6.0 0 3 1 2.0 3 -0.533274 -0.944403 4 36.0 8.0 0 4 1 4.0 4 1.223553 -0.869511 5 22.0 66.0 0 5 1 7.0 5 -1.012408 1.302363 ... ... ... ... ... ... ... ... ... ... 232 32.0 16.0 1 55 4 3.0 232 0.584707 -0.569942 233 26.0 22.0 1 56 4 8.0 233 -0.373562 -0.345266 234 21.0 25.0 1 57 4 1.0 234 -1.172120 -0.232927 235 36.0 13.0 1 58 4 0.0 235 1.223553 -0.682281 236 37.0 12.0 1 59 4 2.0 236 1.383264 -0.719727 <p>236 rows \u00d7 9 columns</p> In\u00a0[8]: Copied! <pre>import arviz as az\nsummary = az.summary(\n    idata,\n    hdi_prob=0.95,\n    kind=\"stats\",\n    round_to=3\n)\n\nprint(\"Posterior Summary\")\nprint(\"=\"*60)\nprint(summary)\n</pre> import arviz as az summary = az.summary(     idata,     hdi_prob=0.95,     kind=\"stats\",     round_to=3 )  print(\"Posterior Summary\") print(\"=\"*60) print(summary) <pre>Posterior Summary\n============================================================\n                            mean     sd  hdi_2.5%  hdi_97.5%\nb_Intercept                1.775  0.115     1.573      2.009\nb_zAge                     0.089  0.085    -0.076      0.254\nb_zBase                    0.702  0.119     0.447      0.921\nb_Trt1                    -0.264  0.166    -0.590      0.052\nb_zBase:Trt1               0.047  0.166    -0.257      0.385\n...                          ...    ...       ...        ...\nr_patient[57,Intercept]   -0.610  0.331    -1.289      0.011\nr_patient[58,Intercept]   -1.233  0.423    -2.032     -0.378\nr_patient[59,Intercept]   -0.170  0.296    -0.751      0.399\nlprior                    -3.184  0.009    -3.202     -3.167\nlp__                    -701.308  7.887  -716.139   -686.145\n\n[68 rows x 4 columns]\n</pre> In\u00a0[9]: Copied! <pre>import matplotlib.pyplot as plt\nimport seaborn as sns\n\nfig = az.plot_posterior(\n    idata,\n    var_names=['b_Intercept', 'b_zAge', 'b_zBase', 'b_Trt1', 'b_zBase:Trt1'],\n    figsize=(12, 8),\n    textsize=10\n)\nplt.suptitle('Posterior Distributions - Fixed Effects', y=1.02, fontsize=14, fontweight='bold')\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt import seaborn as sns  fig = az.plot_posterior(     idata,     var_names=['b_Intercept', 'b_zAge', 'b_zBase', 'b_Trt1', 'b_zBase:Trt1'],     figsize=(12, 8),     textsize=10 ) plt.suptitle('Posterior Distributions - Fixed Effects', y=1.02, fontsize=14, fontweight='bold') plt.tight_layout() plt.show()  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/brmspy-google-colab/#brmspy-google-colab","title":"brmspy - google colab\u00b6","text":""},{"location":"examples/brmspy-vi-sampling/","title":"brmspy - Variational Inference","text":"In\u00a0[1]: Copied! <pre>import os\nimport sys\n\nimport sys, os # for running from repo\nsys.path.insert(0, os.path.abspath(\"..\"))\n\ntry: from brmspy import brms\nexcept ImportError:\n    %pip install -q brmspy\n    from brmspy import brms\n\nimport pandas as pd\nimport arviz as az\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set_style(\"darkgrid\")\n</pre>  import os import sys  import sys, os # for running from repo sys.path.insert(0, os.path.abspath(\"..\"))  try: from brmspy import brms except ImportError:     %pip install -q brmspy     from brmspy import brms  import pandas as pd import arviz as az import numpy as np import matplotlib.pyplot as plt import seaborn as sns  sns.set_style(\"darkgrid\") <pre>[brmspy][_call_with_frames_removed] Running autoload!\n[brmspy][_autoload] Activating runtime /Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0\n[brmspy][_autoload] lib paths are ['/Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/library', '/Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0/Rlib']\n[brmspy][_autoload] Setting cmdstan path to /Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0/cmdstan\n</pre> In\u00a0[2]: Copied! <pre>with brms.manage() as ctx:\n    ctx.install_brms(use_prebuilt=True)\n</pre> with brms.manage() as ctx:     ctx.install_brms(use_prebuilt=True) <pre>[brmspy][install_brms] Activating runtime /Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0\n[brmspy][install_brms] lib paths are ['/Users/sebastian/.brmspy/environment/default/Rlib', '/Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/library', '/Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0/Rlib']\n[brmspy][install_brms] Setting cmdstan path to /Users/sebastian/.brmspy/runtime/macos-arm64-r4.5-0.2.0/cmdstan\n</pre> In\u00a0[3]: Copied! <pre>df = brms.get_brms_data(\"epilepsy\")\n</pre> df = brms.get_brms_data(\"epilepsy\") In\u00a0[4]: Copied! <pre>model = brms.brm(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    family=\"negbinomial\", \n    data=df,\n    \n    # 1. ALGORITHM\n    algorithm=\"meanfield\",\n    \n    # 2. OPTIMIZATION LOOP\n    iter=30000,\n    eta=0.1,\n    adapt_engaged=True,\n    \n    # 3. GRADIENT ESTIMATION (Reducing Noise)\n    grad_samples=5,\n    elbo_samples=100,\n    \n    # 4. CONVERGENCE CRITERIA\n    eval_elbo=200,\n    tol_rel_obj=0.0001,\n    \n    seed=42,\n\n    refresh=0, silent=2\n)\n</pre> model = brms.brm(     formula=\"count ~ zAge + zBase * Trt + (1|patient)\",     family=\"negbinomial\",      data=df,          # 1. ALGORITHM     algorithm=\"meanfield\",          # 2. OPTIMIZATION LOOP     iter=30000,     eta=0.1,     adapt_engaged=True,          # 3. GRADIENT ESTIMATION (Reducing Noise)     grad_samples=5,     elbo_samples=100,          # 4. CONVERGENCE CRITERIA     eval_elbo=200,     tol_rel_obj=0.0001,          seed=42,      refresh=0, silent=2 ) <pre>[brmspy][worker_main] Fitting model with brms (backend: cmdstanr)...\n------------------------------------------------------------ \nEXPERIMENTAL ALGORITHM: \n  This procedure has not been thoroughly tested and may be unstable \n  or buggy. The interface is subject to change. \n------------------------------------------------------------ \nGradient evaluation took 6.5e-05 seconds \n1000 transitions using 10 leapfrog steps per transition would take 0.65 seconds. \nAdjust your expectations accordingly! \nBegin eta adaptation. \nIteration:   1 / 250 [  0%]  (Adaptation) \nIteration:  50 / 250 [ 20%]  (Adaptation) \nIteration: 100 / 250 [ 40%]  (Adaptation) \nIteration: 150 / 250 [ 60%]  (Adaptation) \nIteration: 200 / 250 [ 80%]  (Adaptation) \nSuccess! Found best value [eta = 1] earlier than expected. \nBegin stochastic gradient ascent. \n  iter             ELBO   delta_ELBO_mean   delta_ELBO_med   notes  \n   200         -652.394             1.000            1.000 \n   400         -652.970             0.500            1.000 \n   600         -650.120             0.335            0.004 \n   800         -652.771             0.252            0.004 \n  1000         -650.305             0.203            0.004 \n  1200         -649.219             0.169            0.004 \n  1400         -651.298             0.145            0.004 \n  1600         -650.483             0.127            0.004 \n  1800         -652.597             0.114            0.003 \n  2000         -650.026             0.103            0.004 \n  2200         -650.406             0.093            0.003 \n  2400         -650.830             0.086            0.003 \n  2600         -650.437             0.079            0.003 \n  2800         -648.942             0.074            0.003 \n  3000         -650.946             0.069            0.003 \n  3200         -650.071             0.002            0.002 \n  3400         -649.236             0.002            0.002 \n  3600         -651.772             0.002            0.002 \n  3800         -650.013             0.002            0.002 \n  4000         -649.779             0.002            0.002 \n  4200         -650.599             0.002            0.001 \n  4400         -649.986             0.002            0.001 \n  4600         -649.596             0.002            0.001 \n  4800         -650.784             0.002            0.001 \n  5000         -651.083             0.001            0.001 \n  5200         -648.887             0.002            0.001 \n  5400         -649.172             0.002            0.001 \n  5600         -649.446             0.002            0.001 \n  5800         -648.973             0.002            0.001 \n  6000         -648.896             0.001            0.001 \n  6200         -649.314             0.001            0.001 \n  6400         -649.089             0.001            0.001 \n  6600         -649.375             0.001            0.001 \n  6800         -649.641             0.001            0.000 \n  7000         -649.083             0.001            0.001 \n  7200         -648.838             0.001            0.000 \n  7400         -648.887             0.001            0.000 \n  7600         -648.659             0.001            0.000 \n  7800         -648.117             0.001            0.000 \n  8000         -650.031             0.001            0.000 \n  8200         -649.920             0.001            0.000 \n  8400         -649.288             0.001            0.000 \n  8600         -648.947             0.001            0.000 \n  8800         -647.518             0.001            0.000 \n  9000         -649.226             0.001            0.001 \n  9200         -650.370             0.001            0.001 \n  9400         -648.902             0.001            0.001 \n  9600         -648.854             0.001            0.001 \n  9800         -650.103             0.001            0.001 \n  10000         -649.133             0.001            0.001 \n  10200         -648.926             0.001            0.001 \n  10400         -648.198             0.001            0.001 \n  10600         -650.328             0.002            0.001 \n  10800         -648.939             0.002            0.002 \n  11000         -649.499             0.001            0.001 \n  11200         -648.618             0.002            0.001 \n  11400         -648.918             0.001            0.001 \n  11600         -648.060             0.002            0.001 \n  11800         -649.188             0.002            0.001 \n  12000         -649.402             0.001            0.001 \n  12200         -649.857             0.001            0.001 \n  12400         -650.381             0.001            0.001 \n  12600         -649.190             0.001            0.001 \n  12800         -649.261             0.001            0.001 \n  13000         -649.857             0.001            0.001 \n  13200         -649.480             0.001            0.001 \n  13400         -648.946             0.001            0.001 \n  13600         -647.745             0.001            0.001 \n  13800         -649.635             0.001            0.001 \n  14000         -649.332             0.001            0.001 \n  14200         -649.666             0.001            0.001 \n  14400         -649.317             0.001            0.001 \n  14600         -649.858             0.001            0.001 \n  14800         -649.478             0.001            0.001 \n  15000         -650.213             0.001            0.001 \n  15200         -649.809             0.001            0.001 \n  15400         -649.419             0.001            0.001 \n  15600         -650.002             0.001            0.001 \n  15800         -647.672             0.001            0.001 \n  16000         -649.595             0.001            0.001 \n  16200         -649.908             0.001            0.001 \n  16400         -650.165             0.001            0.001 \n  16600         -649.076             0.001            0.001 \n  16800         -649.755             0.001            0.001 \n  17000         -649.846             0.001            0.001 \n  17200         -648.930             0.001            0.001 \n  17400         -649.366             0.001            0.001 \n  17600         -649.002             0.001            0.001 \n  17800         -650.382             0.001            0.001 \n  18000         -650.079             0.001            0.001 \n  18200         -650.501             0.001            0.001 \n  18400         -648.699             0.001            0.001 \n  18600         -647.671             0.001            0.001 \n  18800         -649.414             0.001            0.001 \n  19000         -648.623             0.001            0.001 \n  19200         -649.478             0.001            0.001 \n  19400         -649.675             0.001            0.001 \n  19600         -648.411             0.001            0.001 \n  19800         -648.159             0.001            0.001 \n  20000         -649.112             0.001            0.001 \n  20200         -649.459             0.001            0.001 \n  20400         -647.534             0.001            0.001 \n  20600         -649.228             0.002            0.001 \n  20800         -649.454             0.001            0.001 \n  21000         -649.684             0.001            0.001 \n  21200         -648.718             0.001            0.001 \n  21400         -650.052             0.001            0.001 \n  21600         -649.061             0.001            0.001 \n  21800         -649.027             0.001            0.001 \n  22000         -649.068             0.001            0.001 \n  22200         -648.792             0.001            0.001 \n  22400         -649.876             0.001            0.001 \n  22600         -649.991             0.001            0.001 \n  22800         -649.223             0.001            0.001 \n  23000         -649.077             0.001            0.001 \n  23200         -648.953             0.001            0.000 \n  23400         -649.894             0.001            0.000 \n  23600         -648.379             0.001            0.000 \n  23800         -648.999             0.001            0.001 \n  24000         -650.932             0.001            0.001 \n  24200         -648.653             0.001            0.001 \n  24400         -649.225             0.001            0.001 \n  24600         -649.829             0.001            0.001 \n  24800         -649.086             0.001            0.001 \n  25000         -648.186             0.001            0.001 \n  25200         -649.377             0.001            0.001 \n  25400         -647.628             0.001            0.001 \n  25600         -649.409             0.002            0.001 \n  25800         -649.125             0.002            0.001 \n  26000         -648.632             0.002            0.001 \n  26200         -648.135             0.002            0.001 \n  26400         -649.139             0.002            0.001 \n  26600         -649.310             0.002            0.001 \n  26800         -649.611             0.001            0.001 \n  27000         -648.477             0.001            0.001 \n  27200         -650.008             0.001            0.001 \n  27400         -648.483             0.001            0.001 \n  27600         -648.559             0.001            0.001 \n  27800         -649.814             0.001            0.002 \n  28000         -648.641             0.001            0.002 \n  28200         -649.483             0.001            0.002 \n  28400         -648.510             0.001            0.002 \n  28600         -649.441             0.001            0.001 \n  28800         -649.177             0.001            0.001 \n  29000         -649.217             0.001            0.001 \n  29200         -649.179             0.001            0.001 \n  29400         -648.250             0.001            0.001 \n  29600         -649.271             0.001            0.001 \n  29800         -648.726             0.001            0.001 \n  30000         -649.375             0.001            0.001 \nInformational Message: The maximum number of iterations is reached! The algorithm may not have converged. \nThis variational approximation is not guaranteed to be meaningful. \nDrawing a sample of size 1000 from the approximate posterior...  \nCOMPLETED. \nFinished in  3.3 seconds.\n[brmspy][worker_main] Fit done!\n</pre> In\u00a0[5]: Copied! <pre>loo_res = az.loo(model.idata, pointwise=True)\nprint(loo_res)\n\n# Visualize the k-hats\naz.plot_khat(loo_res)\nplt.show()\n</pre> loo_res = az.loo(model.idata, pointwise=True) print(loo_res)  # Visualize the k-hats az.plot_khat(loo_res) plt.show() <pre>Computed from 1000 posterior samples and 236 observations log-likelihood matrix.\n\n         Estimate       SE\nelpd_loo  -623.39    17.86\np_loo       45.52        -\n\nThere has been a warning during the calculation. Please check the results.\n------\n\nPareto k diagnostic values:\n                         Count   Pct.\n(-Inf, 0.67]   (good)      227   96.2%\n   (0.67, 1]   (bad)         7    3.0%\n   (1, Inf)   (very bad)    2    0.8%\n\n</pre> <pre>/Users/sebastian/PycharmProjects/pybrms/.venv/lib/python3.12/site-packages/arviz/stats/stats.py:797: UserWarning: Estimated shape parameter of Pareto distribution is greater than 0.67 for one or more samples. You should consider using a more robust model, this is because importance sampling is less likely to work well if the marginal posterior and LOO posterior are very different. This is more likely to happen with a non-robust model and highly influential observations.\n  warnings.warn(\n</pre> In\u00a0[6]: Copied! <pre>az.plot_ppc(model.idata, num_pp_samples=100)\nplt.title(\"Posterior Predictive Check\")\nplt.xlim(0, 100)\nplt.show()\n</pre> az.plot_ppc(model.idata, num_pp_samples=100) plt.title(\"Posterior Predictive Check\") plt.xlim(0, 100) plt.show() In\u00a0[7]: Copied! <pre>pred = brms.posterior_predict(model)\n</pre> pred = brms.posterior_predict(model) In\u00a0[8]: Copied! <pre>summary = brms.summary(model)\nsummary\n</pre> summary = brms.summary(model) summary <pre>[brmspy][iterate_robject_to_dataclass][WARNING] Type of param 'iter' &lt;class 'int'&gt; does not match expected '&lt;class 'float'&gt;'\n</pre> Out[8]: <pre> Family: negbinomial \n  Links: mu = log \nFormula: count ~ zAge + zBase * Trt + (1 | patient) \n   Data: structure(list(Age = c(31, 30, 25, 36, 22, 29, 31, (Number of observations: 236) \n  Draws: 1 chains, each with iter = 1000; warmup = 0; thin = 1;\n         total post-warmup draws = 1000\n\nMultilevel Hyperparameters:\n~patient (Number of levels: 59) \n              Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(Intercept)     0.49      0.04     0.43     0.57 1.00      882      981\n\nRegression Coefficients:\n          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept     2.04      0.12     1.81     2.29 1.00     1114     1022\nzAge          0.10      0.04     0.02     0.18 1.00     1164      979\nzBase         0.65      0.03     0.58     0.71 1.00      926      908\nTrt          -0.25      0.07    -0.40    -0.10 1.00     1065      980\nzBase:Trt     0.04      0.02     0.00     0.08 1.00      948      940\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nshape     6.34      1.25     4.32     9.01 1.00     1093      975\n\nDraws were sampled using variational(meanfield). </pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/brmspy-vi-sampling/#brmspy-variational-inference","title":"brmspy - Variational Inference\u00b6","text":""},{"location":"examples/quickstart/","title":"Examples: Quickstart","text":""},{"location":"examples/quickstart/#notebooks","title":"Notebooks","text":"<ul> <li>Getting started (Google Colab)</li> <li>Estimating multivariate models</li> <li>Variational Inference sampling</li> </ul>"},{"location":"internals/_brms_functions/brm/","title":"brm","text":"<p>Model fitting wrappers.</p> <p>This module contains the <code>brms::brm()</code> wrapper used by <code>brmspy.brms.fit()</code> / <code>brmspy.brms.brm()</code>.</p> Notes <p>This code executes inside the worker process (the process that hosts the embedded R session).</p>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FitResult","title":"<code>FitResult = IDResult[IDBrm]</code>  <code>module-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.ProxyListSexpVector","title":"<code>ProxyListSexpVector = Union[SexpWrapper, ListSexpVector, None]</code>  <code>module-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm-classes","title":"Classes","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.SexpWrapper","title":"<code>SexpWrapper</code>  <code>dataclass</code>","text":"<p>Lightweight handle for an R object stored in the worker.</p> <p>The worker keeps the real rpy2 <code>Sexp</code> in an internal cache and replaces it in results with this wrapper. When passed back to the worker, the wrapper is resolved to the original <code>Sexp</code> again.</p> Notes <ul> <li><code>SexpWrapper</code> instances are only meaningful within the lifetime of the   worker process that produced them. After a worker restart, previously   returned wrappers can no longer be reattached.</li> <li>This type exists to keep the main process free of rpy2 / embedded-R state.</li> </ul> Source code in <code>brmspy/types/session.py</code> <pre><code>@dataclass\nclass SexpWrapper:\n    \"\"\"\n    Lightweight handle for an R object stored in the worker.\n\n    The worker keeps the real rpy2 `Sexp` in an internal cache and replaces it in\n    results with this wrapper. When passed back to the worker, the wrapper is\n    resolved to the original `Sexp` again.\n\n    Notes\n    -----\n    - `SexpWrapper` instances are only meaningful within the lifetime of the\n      worker process that produced them. After a worker restart, previously\n      returned wrappers can no longer be reattached.\n    - This type exists to keep the main process free of rpy2 / embedded-R state.\n    \"\"\"\n\n    _rid: int\n    _repr: str\n\n    def __str__(self) -&gt; str:\n        return self._repr\n\n    def __repr__(self) -&gt; str:\n        return self._repr\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.SexpWrapper-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.SexpWrapper._rid","title":"<code>_rid</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.SexpWrapper._repr","title":"<code>_repr</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.SexpWrapper-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.SexpWrapper.__str__","title":"<code>__str__()</code>","text":"Source code in <code>brmspy/types/session.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self._repr\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.SexpWrapper.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/session.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self._repr\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.SexpWrapper.__init__","title":"<code>__init__(_rid, _repr)</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.IDBrm","title":"<code>IDBrm</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed <code>arviz.InferenceData</code> for fitted brms models.</p> <p>Extends <code>arviz.InferenceData</code> with type hints for IDE autocomplete. In brmspy, the fitted model result typically exposes an <code>.idata</code> attribute of this type.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Posterior samples of model parameters.</p> <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (with observation noise).</p> <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation.</p> <code>observed_data</code> <code>Dataset</code> <p>Original observed response data.</p> <code>coords</code> <code>dict</code> <p>Coordinate mappings for dimensions (inherited from <code>arviz.InferenceData</code>).</p> <code>dims</code> <code>dict</code> <p>Dimension specifications for variables (inherited from <code>arviz.InferenceData</code>).</p> See Also <p>brmspy.brms.brm : Creates fitted model results (alias: <code>brmspy.brms.fit</code>). arviz.InferenceData : Base class documentation.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.brm(\"y ~ x\", data=df, chains=4)\n\n# Type checking and autocomplete\nassert isinstance(model.idata, IDFit)\nprint(model.idata.posterior)\n</code></pre> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDBrm(IDConstantData):\n    \"\"\"\n    Typed `arviz.InferenceData` for fitted brms models.\n\n    Extends `arviz.InferenceData` with type hints for IDE autocomplete. In brmspy,\n    the fitted model result typically exposes an `.idata` attribute of this type.\n\n    Attributes\n    ----------\n    posterior : xr.Dataset\n        Posterior samples of model parameters.\n    posterior_predictive : xr.Dataset\n        Posterior predictive samples (with observation noise).\n    log_likelihood : xr.Dataset\n        Log-likelihood values for each observation.\n    observed_data : xr.Dataset\n        Original observed response data.\n    coords : dict\n        Coordinate mappings for dimensions (inherited from `arviz.InferenceData`).\n    dims : dict\n        Dimension specifications for variables (inherited from `arviz.InferenceData`).\n\n    See Also\n    --------\n    brmspy.brms.brm : Creates fitted model results (alias: `brmspy.brms.fit`).\n    arviz.InferenceData : Base class documentation.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    model = brms.brm(\"y ~ x\", data=df, chains=4)\n\n    # Type checking and autocomplete\n    assert isinstance(model.idata, IDFit)\n    print(model.idata.posterior)\n    ```\n    \"\"\"\n\n    posterior: xr.Dataset\n    posterior_predictive: xr.Dataset\n    log_likelihood: xr.Dataset\n    observed_data: xr.Dataset\n    coords: xr.Dataset\n    dims: xr.Dataset\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.IDBrm-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.IDBrm.posterior","title":"<code>posterior</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.IDBrm.posterior_predictive","title":"<code>posterior_predictive</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.IDBrm.log_likelihood","title":"<code>log_likelihood</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.IDBrm.observed_data","title":"<code>observed_data</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.IDBrm.coords","title":"<code>coords</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.IDBrm.dims","title":"<code>dims</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec","title":"<code>PriorSpec</code>  <code>dataclass</code>","text":"<p>Python representation of a brms prior specification.</p> <p>This dataclass provides a typed interface to <code>brms::prior_string()</code> arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the <code>prior()</code> factory function to create instances.</p> <p>Attributes:</p> Name Type Description <code>prior</code> <code>str</code> <p>Prior distribution as string (e.g., <code>\"normal(0, 1)\"</code>, <code>\"exponential(2)\"</code>).</p> <code>class_</code> <code>(str, optional)</code> <p>Parameter class: <code>\"b\"</code> (fixed effects), <code>\"sd\"</code> (group SD), <code>\"Intercept\"</code>, <code>\"sigma\"</code>, <code>\"cor\"</code>, etc.</p> <code>coef</code> <code>(str, optional)</code> <p>Specific coefficient name for class-level priors.</p> <code>group</code> <code>(str, optional)</code> <p>Grouping variable for hierarchical effects.</p> <code>dpar</code> <code>(str, optional)</code> <p>Distributional parameter (e.g., <code>\"sigma\"</code>, <code>\"phi\"</code>, <code>\"zi\"</code>).</p> <code>resp</code> <code>(str, optional)</code> <p>Response variable for multivariate models.</p> <code>nlpar</code> <code>(str, optional)</code> <p>Non-linear parameter name.</p> <code>lb</code> <code>(float, optional)</code> <p>Lower bound for truncated priors.</p> <code>ub</code> <code>(float, optional)</code> <p>Upper bound for truncated priors.</p> See Also <p>prior : Factory function to create <code>PriorSpec</code> instances. brms::prior_string : R documentation</p> <p>Examples:</p> <p>Create prior specifications (prefer using <code>prior()</code>):</p> <pre><code>from brmspy.types import PriorSpec\n\n# Fixed effect prior\np1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n# Group-level SD prior\np2 = PriorSpec(prior=\"exponential(2)\", class_=\"sd\", group=\"patient\")\n\n# Coefficient-specific prior with bounds\np3 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\", coef=\"age\", lb=0)\n</code></pre> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass(frozen=True)\nclass PriorSpec:\n    \"\"\"\n    Python representation of a brms prior specification.\n\n    This dataclass provides a typed interface to `brms::prior_string()` arguments,\n    allowing Python developers to specify priors with IDE autocomplete and type\n    checking. Use the [`prior()`][brmspy.brms.prior] factory function to create\n    instances.\n\n    Attributes\n    ----------\n    prior : str\n        Prior distribution as string (e.g., ``\"normal(0, 1)\"``, ``\"exponential(2)\"``).\n    class_ : str, optional\n        Parameter class: ``\"b\"`` (fixed effects), ``\"sd\"`` (group SD),\n        ``\"Intercept\"``, ``\"sigma\"``, ``\"cor\"``, etc.\n    coef : str, optional\n        Specific coefficient name for class-level priors.\n    group : str, optional\n        Grouping variable for hierarchical effects.\n    dpar : str, optional\n        Distributional parameter (e.g., ``\"sigma\"``, ``\"phi\"``, ``\"zi\"``).\n    resp : str, optional\n        Response variable for multivariate models.\n    nlpar : str, optional\n        Non-linear parameter name.\n    lb : float, optional\n        Lower bound for truncated priors.\n    ub : float, optional\n        Upper bound for truncated priors.\n\n    See Also\n    --------\n    prior : Factory function to create `PriorSpec` instances.\n    brms::prior_string : [R documentation](https://paulbuerkner.com/brms/reference/prior_string.html)\n\n    Examples\n    --------\n    Create prior specifications (prefer using [`prior()`][brmspy.brms.prior]):\n\n    ```python\n    from brmspy.types import PriorSpec\n\n    # Fixed effect prior\n    p1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n    # Group-level SD prior\n    p2 = PriorSpec(prior=\"exponential(2)\", class_=\"sd\", group=\"patient\")\n\n    # Coefficient-specific prior with bounds\n    p3 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\", coef=\"age\", lb=0)\n    ```\n    \"\"\"\n\n    prior: str\n    class_: str | None = None\n    coef: str | None = None\n    group: str | None = None\n    dpar: str | None = None\n    resp: str | None = None\n    nlpar: str | None = None\n    lb: float | None = None\n    ub: float | None = None\n\n    def to_brms_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Convert PriorSpec to keyword arguments for brms::prior_string().\n\n        Maps Python dataclass fields to R function arguments, handling\n        the `class_` -&gt; `class` parameter name conversion.\n\n        Returns\n        -------\n        dict\n            Keyword arguments ready for brms::prior_string()\n\n        Examples\n        --------\n        ```python\n        from brmspy import prior\n        p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n        kwargs = p.to_brms_kwargs()\n        print(kwargs)\n        # {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n        ```\n        \"\"\"\n        out: dict[str, Any] = {\"prior\": self.prior}\n        if self.class_ is not None:\n            out[\"class\"] = self.class_\n        if self.coef is not None:\n            out[\"coef\"] = self.coef\n        if self.group is not None:\n            out[\"group\"] = self.group\n        if self.dpar is not None:\n            out[\"dpar\"] = self.dpar\n        if self.resp is not None:\n            out[\"resp\"] = self.resp\n        if self.nlpar is not None:\n            out[\"nlpar\"] = self.nlpar\n        if self.lb is not None:\n            out[\"lb\"] = self.lb\n        if self.ub is not None:\n            out[\"ub\"] = self.ub\n        return out\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec.prior","title":"<code>prior</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec.class_","title":"<code>class_ = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec.coef","title":"<code>coef = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec.group","title":"<code>group = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec.dpar","title":"<code>dpar = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec.resp","title":"<code>resp = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec.nlpar","title":"<code>nlpar = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec.lb","title":"<code>lb = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec.ub","title":"<code>ub = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec.to_brms_kwargs","title":"<code>to_brms_kwargs()</code>","text":"<p>Convert PriorSpec to keyword arguments for brms::prior_string().</p> <p>Maps Python dataclass fields to R function arguments, handling the <code>class_</code> -&gt; <code>class</code> parameter name conversion.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keyword arguments ready for brms::prior_string()</p> <p>Examples:</p> <pre><code>from brmspy import prior\np = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\nkwargs = p.to_brms_kwargs()\nprint(kwargs)\n# {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n</code></pre> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>def to_brms_kwargs(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert PriorSpec to keyword arguments for brms::prior_string().\n\n    Maps Python dataclass fields to R function arguments, handling\n    the `class_` -&gt; `class` parameter name conversion.\n\n    Returns\n    -------\n    dict\n        Keyword arguments ready for brms::prior_string()\n\n    Examples\n    --------\n    ```python\n    from brmspy import prior\n    p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n    kwargs = p.to_brms_kwargs()\n    print(kwargs)\n    # {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n    ```\n    \"\"\"\n    out: dict[str, Any] = {\"prior\": self.prior}\n    if self.class_ is not None:\n        out[\"class\"] = self.class_\n    if self.coef is not None:\n        out[\"coef\"] = self.coef\n    if self.group is not None:\n        out[\"group\"] = self.group\n    if self.dpar is not None:\n        out[\"dpar\"] = self.dpar\n    if self.resp is not None:\n        out[\"resp\"] = self.resp\n    if self.nlpar is not None:\n        out[\"nlpar\"] = self.nlpar\n    if self.lb is not None:\n        out[\"lb\"] = self.lb\n    if self.ub is not None:\n        out[\"ub\"] = self.ub\n    return out\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.PriorSpec.__init__","title":"<code>__init__(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None)</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct","title":"<code>FormulaConstruct</code>  <code>dataclass</code>","text":"<p>A composite formula expression built from parts.</p> <p><code>FormulaConstruct</code> stores a tree of nodes (<code>FormulaPart</code> and/or R objects) representing expressions combined with <code>+</code>. It is primarily created by calling the public formula helpers exposed by <code>brmspy.brms</code>.</p> Notes <p>The <code>+</code> operator supports grouping:</p> <ul> <li><code>a + b + c</code> becomes a single summand (one \u201cgroup\u201d)</li> <li><code>(a + b) + (a + b)</code> becomes two summands (two \u201cgroups\u201d)</li> </ul> <p>Use <code>iter_summands()</code> to iterate over these groups in a deterministic way.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@dataclass\nclass FormulaConstruct:\n    \"\"\"\n    A composite formula expression built from parts.\n\n    `FormulaConstruct` stores a tree of nodes (`FormulaPart` and/or R objects)\n    representing expressions combined with `+`. It is primarily created by\n    calling the public formula helpers exposed by [`brmspy.brms`][brmspy.brms].\n\n    Notes\n    -----\n    The `+` operator supports grouping:\n\n    - `a + b + c` becomes a single summand (one \u201cgroup\u201d)\n    - `(a + b) + (a + b)` becomes two summands (two \u201cgroups\u201d)\n\n    Use [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands]\n    to iterate over these groups in a deterministic way.\n    \"\"\"\n\n    _parts: list[Node]\n\n    @classmethod\n    def _formula_parse(cls, obj: Other) -&gt; \"FormulaConstruct\":\n        \"\"\"\n        Convert a supported value into a `FormulaConstruct`.\n\n        Parameters\n        ----------\n        obj\n            One of: `FormulaConstruct`, `FormulaPart`, string (interpreted as `bf(&lt;string&gt;)`),\n            or `ProxyListSexpVector`.\n\n        Returns\n        -------\n        FormulaConstruct\n        \"\"\"\n        if isinstance(obj, FormulaConstruct):\n            return obj\n        if isinstance(obj, ProxyListSexpVector):\n            return FormulaConstruct(_parts=[obj])\n        if isinstance(obj, FormulaPart):\n            return FormulaConstruct(_parts=[obj])\n        if isinstance(obj, str):\n            part = FormulaPart(_fun=\"bf\", _args=[obj], _kwargs={})\n            return FormulaConstruct(_parts=[part])\n        raise TypeError(\n            f\"Cannot parse object of type {type(obj)!r} into FormulaConstruct\"\n        )\n\n    def __add__(self, other: Other):\n        \"\"\"\n        Combine two formula expressions with `+`.\n\n        Parameters\n        ----------\n        other\n            Value to add. Strings are treated as `bf(&lt;string&gt;)`.\n\n        Returns\n        -------\n        FormulaConstruct\n            New combined expression.\n        \"\"\"\n        if isinstance(other, (FormulaPart, str, ProxyListSexpVector)):\n            other = FormulaConstruct._formula_parse(other)\n\n        if not isinstance(other, FormulaConstruct):\n            raise ArithmeticError(\n                \"When adding values to formula, they must be FormulaConstruct or parseable to FormulaConstruct\"\n            )\n\n        if len(other._parts) &lt;= 1:\n            return FormulaConstruct(_parts=self._parts + other._parts)\n        else:\n            return FormulaConstruct(_parts=[self._parts, other._parts])\n\n    def __radd__(self, other: Other) -&gt; \"FormulaConstruct\":\n        \"\"\"Support `\"y ~ x\" + bf(\"z ~ 1\")` by coercing the left operand.\"\"\"\n        return self._formula_parse(other) + self\n\n    def iter_summands(self) -&gt; Iterator[Summand]:\n        \"\"\"\n        Iterate over arithmetic groups (summands).\n\n        Returns\n        -------\n        Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]\n            Each yielded tuple represents one summand/group.\n\n        Examples\n        --------\n        ```python\n        from brmspy.brms import bf, gaussian, set_rescor\n\n        f = bf(\"y ~ x\") + gaussian() + set_rescor(True)\n        for summand in f.iter_summands():\n            print(summand)\n        ```\n        \"\"\"\n\n        def _groups(node: Node) -&gt; Iterator[list[FormulaPart | ProxyListSexpVector]]:\n            # Leaf node: single bf/family/etc\n            if isinstance(node, (FormulaPart, ProxyListSexpVector)):\n                return ([node],)  # one group with one element\n\n            if isinstance(node, list):\n                # If any child is a list, this node represents a \"+\"\n                # between sub-expressions, so recurse into each child.\n                if any(isinstance(child, list) for child in node):\n                    for child in node:\n                        yield from _groups(child)\n                else:\n                    # All children are leaves -&gt; one summand\n                    out: list[FormulaPart | ProxyListSexpVector] = []\n                    for child in node:\n                        if isinstance(child, (FormulaPart, ProxyListSexpVector, Sexp)):\n                            child = cast(FormulaPart | ProxyListSexpVector, child)\n                            out.append(child)\n                        else:\n                            raise TypeError(\n                                f\"Unexpected leaf node type in FormulaConstruct: {type(child)!r}\"\n                            )\n                    yield out\n                return\n\n            raise TypeError(f\"Unexpected node type in FormulaConstruct: {type(node)!r}\")\n\n        # self._parts is always a list[Node]\n        for group in _groups(self._parts):\n            yield tuple(group)\n\n    # Make __iter__ return summands by default\n    def __iter__(self) -&gt; Iterator[Summand]:\n        \"\"\"Alias for [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands].\"\"\"\n        return self.iter_summands()\n\n    def iterate(self) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n        \"\"\"\n        Iterate over all leaf nodes in left-to-right order.\n\n        This flattens the expression tree, unlike\n        [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands], which\n        respects grouping.\n\n        Returns\n        -------\n        Iterator[FormulaPart | ProxyListSexpVector]\n        \"\"\"\n\n        def _walk(node: Node) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n            if isinstance(node, FormulaPart):\n                yield node\n            elif isinstance(node, ProxyListSexpVector):\n                yield node\n            elif isinstance(node, list):\n                for child in node:\n                    yield from _walk(child)\n            else:\n                raise TypeError(\n                    f\"Unexpected node type in FormulaConstruct: {type(node)!r}\"\n                )\n\n        for root in self._parts:\n            yield from _walk(root)\n\n    def __str__(self) -&gt; str:\n        return self._pretty(self._parts)\n\n    def _pretty(self, node, _outer=True) -&gt; str:\n        if isinstance(node, FormulaPart):\n            return str(node)\n\n        if isinstance(node, (ProxyListSexpVector, Sexp)):\n            return _sexp_to_str(node)\n\n        if isinstance(node, list):\n            # Pretty-print each child\n            rendered = [self._pretty(child, _outer=False) for child in node]\n\n            # If only one child, no parentheses needed\n            if len(rendered) == 1:\n                return rendered[0]\n\n            # Multiple children \u2192 join with \" + \"\n            inner = \" + \".join(rendered)\n            if _outer:\n                return inner\n            else:\n                return f\"({inner})\"\n\n        raise TypeError(f\"Unexpected node type {type(node)!r} in pretty-printer\")\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct._parts","title":"<code>_parts</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct._formula_parse","title":"<code>_formula_parse(obj)</code>  <code>classmethod</code>","text":"<p>Convert a supported value into a <code>FormulaConstruct</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Other</code> <p>One of: <code>FormulaConstruct</code>, <code>FormulaPart</code>, string (interpreted as <code>bf(&lt;string&gt;)</code>), or <code>ProxyListSexpVector</code>.</p> required <p>Returns:</p> Type Description <code>FormulaConstruct</code> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@classmethod\ndef _formula_parse(cls, obj: Other) -&gt; \"FormulaConstruct\":\n    \"\"\"\n    Convert a supported value into a `FormulaConstruct`.\n\n    Parameters\n    ----------\n    obj\n        One of: `FormulaConstruct`, `FormulaPart`, string (interpreted as `bf(&lt;string&gt;)`),\n        or `ProxyListSexpVector`.\n\n    Returns\n    -------\n    FormulaConstruct\n    \"\"\"\n    if isinstance(obj, FormulaConstruct):\n        return obj\n    if isinstance(obj, ProxyListSexpVector):\n        return FormulaConstruct(_parts=[obj])\n    if isinstance(obj, FormulaPart):\n        return FormulaConstruct(_parts=[obj])\n    if isinstance(obj, str):\n        part = FormulaPart(_fun=\"bf\", _args=[obj], _kwargs={})\n        return FormulaConstruct(_parts=[part])\n    raise TypeError(\n        f\"Cannot parse object of type {type(obj)!r} into FormulaConstruct\"\n    )\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct.__add__","title":"<code>__add__(other)</code>","text":"<p>Combine two formula expressions with <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Other</code> <p>Value to add. Strings are treated as <code>bf(&lt;string&gt;)</code>.</p> required <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>New combined expression.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __add__(self, other: Other):\n    \"\"\"\n    Combine two formula expressions with `+`.\n\n    Parameters\n    ----------\n    other\n        Value to add. Strings are treated as `bf(&lt;string&gt;)`.\n\n    Returns\n    -------\n    FormulaConstruct\n        New combined expression.\n    \"\"\"\n    if isinstance(other, (FormulaPart, str, ProxyListSexpVector)):\n        other = FormulaConstruct._formula_parse(other)\n\n    if not isinstance(other, FormulaConstruct):\n        raise ArithmeticError(\n            \"When adding values to formula, they must be FormulaConstruct or parseable to FormulaConstruct\"\n        )\n\n    if len(other._parts) &lt;= 1:\n        return FormulaConstruct(_parts=self._parts + other._parts)\n    else:\n        return FormulaConstruct(_parts=[self._parts, other._parts])\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Support <code>\"y ~ x\" + bf(\"z ~ 1\")</code> by coercing the left operand.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __radd__(self, other: Other) -&gt; \"FormulaConstruct\":\n    \"\"\"Support `\"y ~ x\" + bf(\"z ~ 1\")` by coercing the left operand.\"\"\"\n    return self._formula_parse(other) + self\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct.iter_summands","title":"<code>iter_summands()</code>","text":"<p>Iterate over arithmetic groups (summands).</p> <p>Returns:</p> Type Description <code>Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]</code> <p>Each yielded tuple represents one summand/group.</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, gaussian, set_rescor\n\nf = bf(\"y ~ x\") + gaussian() + set_rescor(True)\nfor summand in f.iter_summands():\n    print(summand)\n</code></pre> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def iter_summands(self) -&gt; Iterator[Summand]:\n    \"\"\"\n    Iterate over arithmetic groups (summands).\n\n    Returns\n    -------\n    Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]\n        Each yielded tuple represents one summand/group.\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, gaussian, set_rescor\n\n    f = bf(\"y ~ x\") + gaussian() + set_rescor(True)\n    for summand in f.iter_summands():\n        print(summand)\n    ```\n    \"\"\"\n\n    def _groups(node: Node) -&gt; Iterator[list[FormulaPart | ProxyListSexpVector]]:\n        # Leaf node: single bf/family/etc\n        if isinstance(node, (FormulaPart, ProxyListSexpVector)):\n            return ([node],)  # one group with one element\n\n        if isinstance(node, list):\n            # If any child is a list, this node represents a \"+\"\n            # between sub-expressions, so recurse into each child.\n            if any(isinstance(child, list) for child in node):\n                for child in node:\n                    yield from _groups(child)\n            else:\n                # All children are leaves -&gt; one summand\n                out: list[FormulaPart | ProxyListSexpVector] = []\n                for child in node:\n                    if isinstance(child, (FormulaPart, ProxyListSexpVector, Sexp)):\n                        child = cast(FormulaPart | ProxyListSexpVector, child)\n                        out.append(child)\n                    else:\n                        raise TypeError(\n                            f\"Unexpected leaf node type in FormulaConstruct: {type(child)!r}\"\n                        )\n                yield out\n            return\n\n        raise TypeError(f\"Unexpected node type in FormulaConstruct: {type(node)!r}\")\n\n    # self._parts is always a list[Node]\n    for group in _groups(self._parts):\n        yield tuple(group)\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct.__iter__","title":"<code>__iter__()</code>","text":"<p>Alias for <code>iter_summands()</code>.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Summand]:\n    \"\"\"Alias for [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands].\"\"\"\n    return self.iter_summands()\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct.iterate","title":"<code>iterate()</code>","text":"<p>Iterate over all leaf nodes in left-to-right order.</p> <p>This flattens the expression tree, unlike <code>iter_summands()</code>, which respects grouping.</p> <p>Returns:</p> Type Description <code>Iterator[FormulaPart | ProxyListSexpVector]</code> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def iterate(self) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n    \"\"\"\n    Iterate over all leaf nodes in left-to-right order.\n\n    This flattens the expression tree, unlike\n    [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands], which\n    respects grouping.\n\n    Returns\n    -------\n    Iterator[FormulaPart | ProxyListSexpVector]\n    \"\"\"\n\n    def _walk(node: Node) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n        if isinstance(node, FormulaPart):\n            yield node\n        elif isinstance(node, ProxyListSexpVector):\n            yield node\n        elif isinstance(node, list):\n            for child in node:\n                yield from _walk(child)\n        else:\n            raise TypeError(\n                f\"Unexpected node type in FormulaConstruct: {type(node)!r}\"\n            )\n\n    for root in self._parts:\n        yield from _walk(root)\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct.__str__","title":"<code>__str__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self._pretty(self._parts)\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct._pretty","title":"<code>_pretty(node, _outer=True)</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def _pretty(self, node, _outer=True) -&gt; str:\n    if isinstance(node, FormulaPart):\n        return str(node)\n\n    if isinstance(node, (ProxyListSexpVector, Sexp)):\n        return _sexp_to_str(node)\n\n    if isinstance(node, list):\n        # Pretty-print each child\n        rendered = [self._pretty(child, _outer=False) for child in node]\n\n        # If only one child, no parentheses needed\n        if len(rendered) == 1:\n            return rendered[0]\n\n        # Multiple children \u2192 join with \" + \"\n        inner = \" + \".join(rendered)\n        if _outer:\n            return inner\n        else:\n            return f\"({inner})\"\n\n    raise TypeError(f\"Unexpected node type {type(node)!r} in pretty-printer\")\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.FormulaConstruct.__init__","title":"<code>__init__(_parts)</code>","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.log","title":"<code>log(*msg, method_name=None, level=logging.INFO)</code>","text":"<p>Log a message with automatic method name detection.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log</p> <code>()</code> <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> <code>level</code> <code>int</code> <p>Logging level (default: logging.INFO)</p> <code>INFO</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log(*msg: str, method_name: str | None = None, level: int = logging.INFO):\n    \"\"\"\n    Log a message with automatic method name detection.\n\n    Parameters\n    ----------\n    msg : str\n        The message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n    level : int, optional\n        Logging level (default: logging.INFO)\n    \"\"\"\n    if method_name is None:\n        method_name = _get_caller_name()\n\n    msg_str = \" \".join(str(v) for v in msg)\n\n    logger = get_logger()\n    logger.log(level, msg_str, extra={\"method_name\": method_name})\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.brmsfit_to_idata","title":"<code>brmsfit_to_idata(brmsfit_obj, model_data=None)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def brmsfit_to_idata(brmsfit_obj, model_data=None) -&gt; IDBrm:\n    posterior_dict, _ = _brmsfit_get_posterior(brmsfit_obj)\n    resp_names = _brmsfit_get_response_names(brmsfit_obj)\n    dims, coords = _brmsfit_get_dims_and_coords(brmsfit_obj, resp_names=resp_names)\n    observed_data_dict = _brmsfit_get_observed_data(brmsfit_obj, resp_names)\n    post_pred_dict, _ = _brmsfit_get_predict_generic(\n        brmsfit_obj, function=\"brms::posterior_predict\", resp_names=resp_names\n    )\n    log_lik_dict, _ = _brmsfit_get_predict_generic(\n        brmsfit_obj, function=\"brms::log_lik\", resp_names=resp_names\n    )\n    constant_data_dict = _brmsfit_get_constant_data(\n        brmsfit_obj, newdata=None, resp_names=resp_names\n    )\n    for name in constant_data_dict:\n        if name not in dims:\n            dims[name] = [\"obs_id\"]\n\n    idata = az.from_dict(\n        posterior=posterior_dict,\n        posterior_predictive=post_pred_dict or None,\n        log_likelihood=log_lik_dict or None,\n        observed_data=observed_data_dict or None,\n        coords=coords or None,\n        constant_data=constant_data_dict or None,\n        dims=dims or None,\n    )\n\n    return cast(IDBrm, idata)\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.kwargs_r","title":"<code>kwargs_r(kwargs)</code>","text":"<p>Convert Python keyword arguments to R-compatible format.</p> <p>Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict or None</code> <p>Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with same keys but R-compatible values, or empty dict if None</p> Notes <p>This is a thin wrapper around <code>py_to_r()</code> that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import kwargs_r\nimport pandas as pd\nimport numpy as np\n\n# Prepare kwargs for R function\npy_kwargs = {\n    'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n    'prior': {'b': [0, 1]},\n    'chains': 4,\n    'iter': 2000\n}\n\nr_kwargs = kwargs_r(py_kwargs)\n# All values converted to R objects\n# Can now call: r_function(**r_kwargs)\n</code></pre> See Also <p>py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def kwargs_r(kwargs: dict | None) -&gt; dict:\n    \"\"\"\n    Convert Python keyword arguments to R-compatible format.\n\n    Convenience function that applies py_to_r() to all values in a\n    keyword arguments dictionary, preparing them for R function calls.\n\n    Parameters\n    ----------\n    kwargs : dict or None\n        Dictionary of keyword arguments where values may be Python objects\n        (dicts, lists, DataFrames, arrays, etc.)\n\n    Returns\n    -------\n    dict\n        Dictionary with same keys but R-compatible values, or empty dict if None\n\n    Notes\n    -----\n    This is a thin wrapper around `py_to_r()` that operates on dictionaries.\n    It's commonly used to prepare keyword arguments for R function calls via rpy2.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import kwargs_r\n    import pandas as pd\n    import numpy as np\n\n    # Prepare kwargs for R function\n    py_kwargs = {\n        'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n        'prior': {'b': [0, 1]},\n        'chains': 4,\n        'iter': 2000\n    }\n\n    r_kwargs = kwargs_r(py_kwargs)\n    # All values converted to R objects\n    # Can now call: r_function(**r_kwargs)\n    ```\n\n    See Also\n    --------\n    py_to_r : Underlying conversion function for individual values\n    brmspy.brms.fit : Uses this to prepare user kwargs for R\n    \"\"\"\n    if kwargs is None:\n        return {}\n    return {k: py_to_r(v) for k, v in kwargs.items()}\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def py_to_r(obj: PyObject) -&gt; Sexp:\n    \"\"\"\n    Convert arbitrary Python objects to R objects via rpy2.\n\n    Comprehensive converter that handles nested structures (dicts, lists),\n    DataFrames, arrays, and scalars. Uses rpy2's converters with special\n    handling for dictionaries (\u2192 R named lists) and lists of dicts.\n\n    Parameters\n    ----------\n    obj : any\n        Python object to convert. Supported types:\n        - None \u2192 R NULL\n        - dict \u2192 R named list (ListVector), recursively\n        - list/tuple of dicts \u2192 R list of named lists\n        - list/tuple (other) \u2192 R vector or list\n        - pd.DataFrame \u2192 R data.frame\n        - np.ndarray \u2192 R vector/matrix\n        - scalars (int, float, str, bool) \u2192 R atomic types\n\n    Returns\n    -------\n    rpy2 R object\n        R representation of the Python object\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **None**: \u2192 R NULL\n    2. **DataFrames**: \u2192 R data.frame (via pandas2ri)\n    3. **Dictionaries**: \u2192 R named list (ListVector), recursively converting values\n    4. **Lists of dicts**: \u2192 R list with 1-based indexed names containing named lists\n    5. **Other lists/tuples**: \u2192 R vectors or lists (via rpy2 default)\n    6. **NumPy arrays**: \u2192 R vectors/matrices (via numpy2ri)\n    7. **Scalars**: \u2192 R atomic values\n\n    **Recursive Conversion:**\n\n    Dictionary values are recursively converted, allowing nested structures:\n    ```python\n    {'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n    ```\n\n    **List of Dicts:**\n\n    Lists containing only dicts are converted to R lists with 1-based indexing:\n    ```python\n    [{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n    ```\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import py_to_r\n    import numpy as np\n    import pandas as pd\n\n    # Scalars\n    py_to_r(5)        # R: 5\n    py_to_r(\"hello\")  # R: \"hello\"\n    py_to_r(None)     # R: NULL\n\n    # Arrays\n    py_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n    # DataFrames\n    df = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\n    py_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n    ```\n\n    See Also\n    --------\n    r_to_py : Convert R objects back to Python\n    kwargs_r : Convert keyword arguments dict for R function calls\n    brmspy.brms.fit : Uses this for converting data to R\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if obj is None:\n        return ro.NULL\n\n    if isinstance(obj, ro.Sexp):\n        return obj\n\n    if isinstance(obj, RListVectorExtension) and isinstance(obj.r, ro.Sexp):\n        return obj.r\n\n    _type = type(obj)\n    converter = None\n\n    if _type in _registry._PY2R_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._PY2R_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._PY2R_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._PY2R_CONVERTERS) &gt; 0, \"NO PY2R CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj)\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm._build_priors","title":"<code>_build_priors(priors=None)</code>","text":"<p>Build R brms prior object from Python PriorSpec specifications.</p> <p>Converts a sequence of PriorSpec objects to a single combined R brms prior object by calling brms::prior_string() for each spec and combining with <code>+</code>. Used internally by fit() to translate Python prior specifications to R.</p> <p>Parameters:</p> Name Type Description Default <code>priors</code> <code>sequence of PriorSpec</code> <p>List of prior specifications. Each PriorSpec contains: - prior: Prior distribution string (e.g., \"normal(0, 1)\") - class_: Parameter class (e.g., \"b\", \"Intercept\", \"sigma\") - coef: Specific coefficient name (optional) - group: Group-level effects (optional)</p> <p>If None or empty, returns empty list (brms uses default priors)</p> <code>None</code> <p>Returns:</p> Type Description <code>R brmsprior object or list</code> <p>Combined R brms prior object if priors provided, empty list otherwise</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If combined result is not a valid brmsprior object</p> Notes <p>Prior Combination:</p> <p>Multiple priors are combined using R's <code>+</code> operator: <pre><code>prior1 + prior2 + prior3\n</code></pre></p> <p>This creates a single brmsprior object containing all specifications.</p> <p>brms Prior Classes:</p> <p>Common parameter classes: - b: Population-level effects (regression coefficients) - Intercept: Model intercept - sigma: Residual standard deviation (for gaussian family) - sd: Standard deviation of group-level effects - cor: Correlation of group-level effects</p> <p>Prior String Format:</p> <p>brms uses Stan-style prior specifications: - Normal: \"normal(mean, sd)\" - Student-t: \"student_t(df, location, scale)\" - Cauchy: \"cauchy(location, scale)\" - Exponential: \"exponential(rate)\" - Uniform: \"uniform(lower, upper)\"</p> <p>Examples:</p> <pre><code>from brmspy.types import PriorSpec\nfrom brmspy.helpers.priors import _build_priors\n\n# Single prior for regression coefficients\npriors = [\n    PriorSpec(\n        prior=\"normal(0, 1)\",\n        class_=\"b\"\n    )\n]\nbrms_prior = _build_priors(priors)\n</code></pre> See Also <p>brmspy.types.PriorSpec : Prior specification class brmspy.brms.fit : Uses this to convert priors for model fitting brms::prior : R brms prior specification brms::set_prior : R function for setting priors</p> References <p>.. [1] brms prior documentation: https://paul-buerkner.github.io/brms/reference/set_prior.html .. [2] Stan prior choice recommendations: https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations</p> Source code in <code>brmspy/helpers/_rpy2/_priors.py</code> <pre><code>def _build_priors(\n    priors: None | Sequence[PriorSpec] = None,\n) -&gt; list[Sexp]:\n    \"\"\"\n    Build R brms prior object from Python PriorSpec specifications.\n\n    Converts a sequence of PriorSpec objects to a single combined R brms prior\n    object by calling brms::prior_string() for each spec and combining with `+`.\n    Used internally by fit() to translate Python prior specifications to R.\n\n    Parameters\n    ----------\n    priors : sequence of PriorSpec, optional\n        List of prior specifications. Each PriorSpec contains:\n        - prior: Prior distribution string (e.g., \"normal(0, 1)\")\n        - class_: Parameter class (e.g., \"b\", \"Intercept\", \"sigma\")\n        - coef: Specific coefficient name (optional)\n        - group: Group-level effects (optional)\n\n        If None or empty, returns empty list (brms uses default priors)\n\n    Returns\n    -------\n    R brmsprior object or list\n        Combined R brms prior object if priors provided, empty list otherwise\n\n    Raises\n    ------\n    AssertionError\n        If combined result is not a valid brmsprior object\n\n    Notes\n    -----\n    **Prior Combination:**\n\n    Multiple priors are combined using R's `+` operator:\n    ```R\n    prior1 + prior2 + prior3\n    ```\n\n    This creates a single brmsprior object containing all specifications.\n\n    **brms Prior Classes:**\n\n    Common parameter classes:\n    - **b**: Population-level effects (regression coefficients)\n    - **Intercept**: Model intercept\n    - **sigma**: Residual standard deviation (for gaussian family)\n    - **sd**: Standard deviation of group-level effects\n    - **cor**: Correlation of group-level effects\n\n    **Prior String Format:**\n\n    brms uses Stan-style prior specifications:\n    - Normal: \"normal(mean, sd)\"\n    - Student-t: \"student_t(df, location, scale)\"\n    - Cauchy: \"cauchy(location, scale)\"\n    - Exponential: \"exponential(rate)\"\n    - Uniform: \"uniform(lower, upper)\"\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.types import PriorSpec\n    from brmspy.helpers.priors import _build_priors\n\n    # Single prior for regression coefficients\n    priors = [\n        PriorSpec(\n            prior=\"normal(0, 1)\",\n            class_=\"b\"\n        )\n    ]\n    brms_prior = _build_priors(priors)\n    ```\n\n    See Also\n    --------\n    brmspy.types.PriorSpec : Prior specification class\n    brmspy.brms.fit : Uses this to convert priors for model fitting\n    brms::prior : R brms prior specification\n    brms::set_prior : R function for setting priors\n\n    References\n    ----------\n    .. [1] brms prior documentation: https://paul-buerkner.github.io/brms/reference/set_prior.html\n    .. [2] Stan prior choice recommendations: https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations\n    \"\"\"\n    if not priors:\n        return []\n    import rpy2.robjects as ro\n\n    from brmspy.helpers._rpy2._converters import r_to_py\n\n    fun_prior_string = cast(Callable, ro.r(\"brms::prior_string\"))\n\n    prior_objs = []\n    for p in priors:\n        kwargs = p.to_brms_kwargs()\n        # first argument is the prior string\n        prior_str = kwargs.pop(\"prior\")\n        prior_obj = fun_prior_string(prior_str, **kwargs)\n        prior_objs.append(prior_obj)\n\n    brms_prior = prior_objs[0]\n    for p in prior_objs[1:]:\n        brms_prior = brms_prior + p\n\n    return brms_prior\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm._execute_formula","title":"<code>_execute_formula(formula)</code>","text":"Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def _execute_formula(formula: FormulaConstruct | Sexp | str) -&gt; Sexp:\n    import rpy2.robjects as ro\n\n    if isinstance(formula, Sexp):\n        return formula\n    if isinstance(formula, str):\n        formula = FormulaConstruct._formula_parse(formula)\n\n    # Must run for formula functions, e.g me() to register\n    ro.r(\"library(brms)\")\n\n    fun_add = cast(Callable[[Sexp, Sexp], Sexp], ro.r(\"function (a, b) a + b\"))\n\n    result: Sexp | None = None\n    for summand in formula:\n        subresult: Sexp = py_to_r(summand[0])\n        for part in summand[1:]:\n            subresult = fun_add(subresult, py_to_r(part))\n\n        if result is None:\n            result = subresult\n        else:\n            result = fun_add(result, subresult)\n\n    assert result is not None\n    return result\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.bf","title":"<code>bf(*formulas, **formula_args)</code>","text":"<p>Build a brms model formula.</p> <p>This is the primary entrypoint for specifying the mean model and can be combined with other formula parts (e.g. <code>lf</code>, <code>nlf</code>, <code>acformula</code>) using <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str</code> <p>One or more brms formula strings (e.g. <code>\"y ~ x + (1|group)\"</code>). Multiple formulas are commonly used for multivariate models.</p> <code>()</code> <code>**formula_args</code> <p>Keyword arguments forwarded to R <code>brms::brmsformula()</code> (for example <code>decomp=\"QR\"</code>, <code>center=True</code>, <code>sparse=True</code>, <code>nl=True</code>, <code>loop=True</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::brmsformula : R documentation</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>QR decomposition (often helps with collinearity):</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"reaction ~ days + (days|subject)\", decomp=\"QR\")\n</code></pre> <p>Multivariate formula + residual correlation:</p> <pre><code>from brmspy.brms import bf, set_rescor\n\nf = bf(\"mvbind(y1, y2) ~ x\") + set_rescor(True)\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def bf(*formulas: str, **formula_args) -&gt; FormulaConstruct:\n    \"\"\"\n    Build a brms model formula.\n\n    This is the primary entrypoint for specifying the mean model and can be\n    combined with other formula parts (e.g. `lf`, `nlf`, `acformula`) using ``+``.\n\n    Parameters\n    ----------\n    *formulas : str\n        One or more brms formula strings (e.g. ``\"y ~ x + (1|group)\"``). Multiple\n        formulas are commonly used for multivariate models.\n    **formula_args\n        Keyword arguments forwarded to R ``brms::brmsformula()`` (for example\n        ``decomp=\"QR\"``, ``center=True``, ``sparse=True``, ``nl=True``, ``loop=True``).\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::brmsformula : [R documentation](https://paulbuerkner.com/brms/reference/brmsformula.html)\n\n    Examples\n    --------\n    Basic formula:\n\n    ```python\n    from brmspy.brms import bf\n\n    f = bf(\"y ~ x1 + x2 + (1|group)\")\n    ```\n\n    QR decomposition (often helps with collinearity):\n\n    ```python\n    from brmspy.brms import bf\n\n    f = bf(\"reaction ~ days + (days|subject)\", decomp=\"QR\")\n    ```\n\n    Multivariate formula + residual correlation:\n\n    ```python\n    from brmspy.brms import bf, set_rescor\n\n    f = bf(\"mvbind(y1, y2) ~ x\") + set_rescor(True)\n    ```\n    \"\"\"\n    part = FormulaPart(_fun=\"bf\", _args=list(formulas), _kwargs=formula_args)\n    return FormulaConstruct._formula_parse(part)\n</code></pre>"},{"location":"internals/_brms_functions/brm/#brmspy._brms_functions.brm.brm","title":"<code>brm(formula, data, priors=None, family='gaussian', sample_prior='no', sample=True, backend='cmdstanr', formula_args=None, cores=2, *, return_idata=True, **brm_args)</code>","text":"<pre><code>brm(formula: FormulaConstruct | ProxyListSexpVector | str, data: dict | pd.DataFrame, priors: Sequence[PriorSpec] | None = ..., family: str | ListSexpVector | None = ..., sample_prior: str = ..., sample: bool = ..., backend: str = ..., formula_args: dict | None = ..., cores: int | None = ..., *, return_idata: Literal[True] = True, **brm_args: Any) -&gt; FitResult\n</code></pre><pre><code>brm(formula: FormulaConstruct | ProxyListSexpVector | str, data: dict | pd.DataFrame, priors: Sequence[PriorSpec] | None = ..., family: str | ListSexpVector | None = ..., sample_prior: str = ..., sample: bool = ..., backend: str = ..., formula_args: dict | None = ..., cores: int | None = ..., *, return_idata: Literal[False], **brm_args: Any) -&gt; ProxyListSexpVector\n</code></pre> <p>Fit a Bayesian regression model with brms.</p> <p>This is a thin wrapper around R <code>brms::brm()</code> that returns a structured <code>FitResult</code> (including an ArviZ <code>InferenceData</code>).</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula. Accepts a plain brms formula string (e.g. <code>\"y ~ x + (1|g)\"</code>) or a composed formula created via <code>brmspy.brms.bf()</code> / <code>brmspy.brms.lf()</code> (typically imported as <code>from brmspy.brms import bf, lf</code>).</p> required <code>data</code> <code>dict or DataFrame</code> <p>Model data.</p> required <code>priors</code> <code>Sequence[PriorSpec] or None</code> <p>Optional prior specifications created via <code>brmspy.brms.prior()</code>.</p> <code>None</code> <code>family</code> <code>str or ListSexpVector or None</code> <p>brms family specification (e.g. <code>\"gaussian\"</code>, <code>\"poisson\"</code>).</p> <code>\"gaussian\"</code> <code>sample_prior</code> <code>str</code> <p>Passed to brms. Common values: <code>\"no\"</code>, <code>\"yes\"</code>, <code>\"only\"</code>.</p> <code>\"no\"</code> <code>sample</code> <code>bool</code> <p>If <code>False</code>, compile the model without sampling (brms <code>empty=TRUE</code>).</p> <code>True</code> <code>backend</code> <code>str</code> <p>Stan backend. Common values: <code>\"cmdstanr\"</code> or <code>\"rstan\"</code>.</p> <code>\"cmdstanr\"</code> <code>formula_args</code> <code>dict or None</code> <p>Reserved for future use. Currently ignored.</p> <code>None</code> <code>cores</code> <code>int or None</code> <p>Number of cores for brms/cmdstanr.</p> <code>2</code> <code>return_idata</code> <code>bool</code> <p>When working with large datasets, you might not want the full idata. when False, you get the R object proxy which can be forwarded to posterior_epred or other functions</p> <code>True</code> <code>**brm_args</code> <p>Additional keyword arguments passed to R <code>brms::brm()</code> (e.g. <code>chains</code>, <code>iter</code>, <code>warmup</code>, <code>seed</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Result object with <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::brm : R documentation</p> Warnings <p>Using <code>cores &lt;= 1</code> can be unstable in embedded R sessions and may crash the worker process. Prefer <code>cores &gt;= 2</code>.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x + (1|g)\", data=df, family=\"gaussian\", chains=4, cores=4)\n\nfit.idata.posterior\n</code></pre> Source code in <code>brmspy/_brms_functions/brm.py</code> <pre><code>def brm(\n    formula: FormulaConstruct | ProxyListSexpVector | str,\n    data: dict | pd.DataFrame,\n    priors: Sequence[PriorSpec] | None = None,\n    family: str | ListSexpVector | None = \"gaussian\",\n    sample_prior: str = \"no\",\n    sample: bool = True,\n    backend: str = \"cmdstanr\",\n    formula_args: dict | None = None,\n    cores: int | None = 2,\n    *,\n    return_idata: bool = True,\n    **brm_args,\n) -&gt; FitResult | ProxyListSexpVector:\n    \"\"\"\n    Fit a Bayesian regression model with brms.\n\n    This is a thin wrapper around R ``brms::brm()`` that returns a structured\n    `FitResult` (including an ArviZ `InferenceData`).\n\n    Parameters\n    ----------\n    formula : str or FormulaConstruct\n        Model formula. Accepts a plain brms formula string (e.g. ``\"y ~ x + (1|g)\"``)\n        or a composed formula created via `brmspy.brms.bf()` / `brmspy.brms.lf()`\n        (typically imported as ``from brmspy.brms import bf, lf``).\n    data : dict or pandas.DataFrame\n        Model data.\n    priors : Sequence[PriorSpec] or None, default=None\n        Optional prior specifications created via `brmspy.brms.prior()`.\n    family : str or rpy2.rinterface.ListSexpVector or None, default=\"gaussian\"\n        brms family specification (e.g. ``\"gaussian\"``, ``\"poisson\"``).\n    sample_prior : str, default=\"no\"\n        Passed to brms. Common values: ``\"no\"``, ``\"yes\"``, ``\"only\"``.\n    sample : bool, default=True\n        If ``False``, compile the model without sampling (brms ``empty=TRUE``).\n    backend : str, default=\"cmdstanr\"\n        Stan backend. Common values: ``\"cmdstanr\"`` or ``\"rstan\"``.\n    formula_args : dict or None, default=None\n        Reserved for future use. Currently ignored.\n    cores : int or None, default=2\n        Number of cores for brms/cmdstanr.\n    return_idata : bool, default True\n        When working with large datasets, you might not want the full idata.\n        when False, you get the R object proxy which can be forwarded to posterior_epred\n        or other functions\n    **brm_args\n        Additional keyword arguments passed to R ``brms::brm()`` (e.g. ``chains``,\n        ``iter``, ``warmup``, ``seed``).\n\n    Returns\n    -------\n    FitResult\n        Result object with `idata` (ArviZ `InferenceData`) and an underlying R handle.\n\n    See Also\n    --------\n    brms::brm : [R documentation](https://paulbuerkner.com/brms/reference/brm.html)\n\n    Warnings\n    --------\n    Using ``cores &lt;= 1`` can be unstable in embedded R sessions and may crash the\n    worker process. Prefer ``cores &gt;= 2``.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    fit = brms.brm(\"y ~ x + (1|g)\", data=df, family=\"gaussian\", chains=4, cores=4)\n\n    fit.idata.posterior\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n    import rpy2.robjects.packages as packages\n\n    fun_brm = cast(Callable, ro.r(\"brms::brm\"))\n\n    if backend == \"cmdstanr\":\n        try:\n            cmdstanr = packages.importr(\"cmdstanr\")\n        except:\n            cmdstanr = None\n        if cmdstanr is None:\n            raise RuntimeError(\n                \"cmdstanr backend is not installed! Please run install_brms(install_cmdstanr=True)\"\n            )\n\n    if backend == \"rstan\":\n        try:\n            rstan = packages.importr(\"rstan\")\n        except:\n            rstan = None\n        if rstan is None:\n            raise RuntimeError(\n                \"rstan backend is not installed! Please run install_brms(install_rstan=True)\"\n            )\n\n    # Formula checks. These should never be reached in the first place\n    # if they are, the library is calling brm() from main directly without remote call\n    assert not isinstance(formula, SexpWrapper)\n    assert formula is not None\n    if formula_args and isinstance(formula, str):\n        formula = bf(formula, **formula_args)\n\n    formula_obj = _execute_formula(formula)\n\n    # Convert data to R format\n    data_r = py_to_r(data)\n\n    # Setup priors\n    brms_prior = _build_priors(priors)\n\n    # Prepare brm() arguments\n    brm_kwargs: dict[str, Any] = {\n        \"formula\": formula_obj,\n        \"data\": data_r,\n        \"family\": family,\n        \"sample_prior\": sample_prior,\n        \"backend\": backend,\n        \"cores\": cores,\n    }\n\n    # Add priors if specified\n    if len(brms_prior) &gt; 0:\n        brm_kwargs[\"prior\"] = brms_prior\n\n    # Add user-specified arguments\n    brm_kwargs.update(brm_args)\n\n    brm_kwargs = kwargs_r(brm_kwargs)\n\n    # Set empty=TRUE if not sampling\n    if not sample:\n        brm_kwargs[\"empty\"] = True\n        log(\"Creating empty r object (no sampling)...\")\n    else:\n        log(f\"Fitting model with brms (backend: {backend})...\")\n\n    # Call brms::brm() with all arguments\n    fit = fun_brm(**brm_kwargs)\n\n    log(\"Fit done!\")\n\n    # Handle return type conversion\n    if not return_idata:\n        return fit\n\n    if not sample:\n        return FitResult(idata=IDBrm(), r=fit)\n\n    idata = brmsfit_to_idata(fit)\n    return FitResult(idata=idata, r=fit)\n</code></pre>"},{"location":"internals/_brms_functions/diagnostics/","title":"diagnostics","text":"<p>Diagnostic functions for brms models with ArviZ integration.</p> <p>This module provides diagnostic functions for analyzing fitted brms models. All fitted models return <code>arviz.InferenceData</code> objects by default through the <code>.idata</code> attribute, enabling seamless integration with ArviZ's diagnostic toolkit.</p> ArviZ Integration <p>brmspy models work directly with ArviZ functions without conversion:</p> <ul> <li>Summary &amp; Convergence: <code>az.summary()</code>, <code>az.rhat()</code>, <code>az.ess()</code></li> <li>Visualization: <code>az.plot_trace()</code>, <code>az.plot_posterior()</code>, <code>az.plot_pair()</code></li> <li>Model Comparison: <code>az.loo()</code>, <code>az.waic()</code>, <code>az.compare()</code></li> <li>Predictive Checks: <code>az.plot_ppc()</code></li> </ul> <p>For multivariate models, use the <code>var_name</code> parameter in ArviZ functions to specify which response variable to analyze (e.g., <code>az.loo(model.idata, var_name=\"y1\")</code>).</p> Quick Example <pre><code>import brmspy\nimport arviz as az\n\n# Fit model\nmodel = brmspy.fit(\"count ~ zAge + (1|patient)\", data=data, family=\"poisson\")\n\n# Diagnostics\nprint(az.summary(model.idata))  # Parameter estimates with Rhat, ESS\naz.plot_trace(model.idata)       # MCMC trace plots\naz.plot_ppc(model.idata)         # Posterior predictive check\n\n# Model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre> See Also <p>Diagnostics with ArviZ : Complete guide with examples     https://kaitumisuuringute-keskus.github.io/brmspy/api/diagnostics-arviz/</p> Notes <p>The InferenceData structure contains:</p> <ul> <li>posterior: All parameter samples with brms naming (e.g., <code>b_Intercept</code>, <code>sd_patient__Intercept</code>)</li> <li>posterior_predictive: Posterior predictive samples for each response</li> <li>log_likelihood: Pointwise log-likelihood for LOO/WAIC</li> <li>observed_data: Original response values</li> </ul>"},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.FitResult","title":"<code>FitResult = IDResult[IDBrm]</code>  <code>module-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics-classes","title":"Classes","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult","title":"<code>SummaryResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Parsed summary output for a fitted model.</p> <p>This is a convenience container that holds both:</p> <ul> <li>structured Python data (mostly pandas DataFrames)</li> <li>the underlying R object reference in <code>.r</code> (as a worker-side handle)</li> </ul> <p>Attributes:</p> Name Type Description <code>formula</code> <code>str</code> <p>Model formula string as reported by brms.</p> <code>data_name</code> <code>str</code> <p>Data name as reported by brms (may be an internal label).</p> <code>nobs</code> <code>int</code> <p>Number of observations.</p> <code>prior</code> <code>DataFrame</code> <p>Prior summary table.</p> <code>fixed</code> <code>DataFrame</code> <p>Fixed effects summary table.</p> <code>random</code> <code>dict[str, DataFrame] or None</code> <p>Random effects summary tables (if present).</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass\nclass SummaryResult(RListVectorExtension):\n    \"\"\"\n    Parsed summary output for a fitted model.\n\n    This is a convenience container that holds both:\n\n    - structured Python data (mostly pandas DataFrames)\n    - the underlying R object reference in `.r` (as a worker-side handle)\n\n    Attributes\n    ----------\n    formula : str\n        Model formula string as reported by brms.\n    data_name : str\n        Data name as reported by brms (may be an internal label).\n    nobs : int\n        Number of observations.\n    prior : pandas.DataFrame\n        Prior summary table.\n    fixed : pandas.DataFrame\n        Fixed effects summary table.\n    random : dict[str, pandas.DataFrame] or None\n        Random effects summary tables (if present).\n    \"\"\"\n\n    formula: str\n    data_name: str\n    group: str | list[str]\n    nobs: int\n    prior: pd.DataFrame\n    algorithm: str\n    sampler: str\n    total_ndraws: int\n    chains: float\n    iter: float\n    warmup: float\n    thin: float\n    has_rhat: bool\n    fixed: pd.DataFrame\n    spec_pars: pd.DataFrame | None = None\n    cor_pars: pd.DataFrame | None = None\n    rescor_pars: pd.DataFrame | None = None\n    ngrps: dict[str, int] | None = None\n    autocor: dict | None = None\n    random: dict[str, pd.DataFrame] | None = None\n    _str: str | None = None\n\n    def __str__(self) -&gt; str:\n        if self._str:\n            return self._str\n        return \"MISSING REPR\"\n\n    def __repr__(self) -&gt; str:\n        # For interactive use, repr == pretty summary\n        return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.formula","title":"<code>formula</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.data_name","title":"<code>data_name</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.group","title":"<code>group</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.nobs","title":"<code>nobs</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.prior","title":"<code>prior</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.algorithm","title":"<code>algorithm</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.sampler","title":"<code>sampler</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.total_ndraws","title":"<code>total_ndraws</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.chains","title":"<code>chains</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.iter","title":"<code>iter</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.warmup","title":"<code>warmup</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.thin","title":"<code>thin</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.has_rhat","title":"<code>has_rhat</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.fixed","title":"<code>fixed</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.spec_pars","title":"<code>spec_pars = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.cor_pars","title":"<code>cor_pars = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.rescor_pars","title":"<code>rescor_pars = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.ngrps","title":"<code>ngrps = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.autocor","title":"<code>autocor = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.random","title":"<code>random = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult._str","title":"<code>_str = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.__str__","title":"<code>__str__()</code>","text":"Source code in <code>brmspy/types/brms_results.py</code> <pre><code>def __str__(self) -&gt; str:\n    if self._str:\n        return self._str\n    return \"MISSING REPR\"\n</code></pre>"},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/brms_results.py</code> <pre><code>def __repr__(self) -&gt; str:\n    # For interactive use, repr == pretty summary\n    return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.SummaryResult.__init__","title":"<code>__init__(r, formula, data_name, group, nobs, prior, algorithm, sampler, total_ndraws, chains, iter, warmup, thin, has_rhat, fixed, spec_pars=None, cor_pars=None, rescor_pars=None, ngrps=None, autocor=None, random=None, _str=None)</code>","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.iterate_robject_to_dataclass","title":"<code>iterate_robject_to_dataclass(names, get, target_dataclass, r, iteration_params=None)</code>","text":"<p>Generic helper to iterate over R summary-like objects and convert them into a Python dataclass instance.</p> <ul> <li><code>names</code> is e.g. summary_r.names</li> <li><code>get(param)</code> should return the R slot already converted via rpy2 (or raw)</li> <li><code>target_dataclass</code> is a @dataclass whose field names mirror the params</li> </ul> Source code in <code>brmspy/helpers/_rpy2/_robject_iter.py</code> <pre><code>def iterate_robject_to_dataclass(\n    names: list[str],\n    get: Callable[[str], Any],\n    target_dataclass: type[Any],\n    r: ListSexpVector | None,\n    iteration_params: dict[str, IterConf] | None = None\n):\n    \"\"\"\n    Generic helper to iterate over R summary-like objects and convert them\n    into a Python dataclass instance.\n\n    - `names` is e.g. summary_r.names\n    - `get(param)` should return the R slot already converted via rpy2 (or raw)\n    - `target_dataclass` is a @dataclass whose field names mirror the params\n    \"\"\"\n    import rpy2.robjects as ro\n    _fun_repr = cast(Callable, ro.r('function(x) paste(capture.output(x), collapse = \"\\\\n\")'))\n\n    if target_dataclass is None:\n        raise ValueError(\"target_dataclass must be specified\")\n\n    if not is_dataclass(target_dataclass):\n        raise TypeError(\"target_dataclass must be a dataclass type\")\n\n    if iteration_params is None:\n        iteration_params = _build_iterconf_from_dataclass(target_dataclass)\n\n    out: dict[str, Any] = {}\n\n    for param, iterconf in iteration_params.items():\n        if param == \"_str\" and r:\n            try:\n                repr = cast(list[str], _fun_repr(r))\n                repr = str(repr[0])\n            except:\n                repr = None\n            out['_str'] = repr\n            continue\n\n        if param not in names:\n            continue\n\n        try:\n            data = get(param)\n\n            if data is None:\n                if not iterconf.optional:\n                    log_warning(\n                        f\"Param '{param}' is None, but IterConf does not mark it as optional. Skipping.\"\n                    )\n                    continue\n            else:\n                # Special handling for DataFrame fields\n                if iterconf.cls is pd.DataFrame and not isinstance(data, pd.DataFrame):\n                    try:\n                        data = pd.DataFrame(data)\n                    except Exception as e:\n                        log_warning(\n                            f\"Failed to convert '{param}' object to pd.DataFrame. \"\n                            f\"Passing default. {e}\"\n                        )\n\n                if not _matches_iterconf(data, iterconf):\n                    log_warning(\n                        f\"Type of param '{param}' {type(data)} does not match \"\n                        f\"expected '{iterconf.cls}'\"\n                    )\n\n            out[param] = data\n\n        except Exception as e:\n            log_warning(f\"Failed to parse {param} into python object: {e}\")\n\n    if r:\n        out['r'] = r\n\n    # Build the dataclass instance\n    return target_dataclass(**out)\n</code></pre>"},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.kwargs_r","title":"<code>kwargs_r(kwargs)</code>","text":"<p>Convert Python keyword arguments to R-compatible format.</p> <p>Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict or None</code> <p>Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with same keys but R-compatible values, or empty dict if None</p> Notes <p>This is a thin wrapper around <code>py_to_r()</code> that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import kwargs_r\nimport pandas as pd\nimport numpy as np\n\n# Prepare kwargs for R function\npy_kwargs = {\n    'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n    'prior': {'b': [0, 1]},\n    'chains': 4,\n    'iter': 2000\n}\n\nr_kwargs = kwargs_r(py_kwargs)\n# All values converted to R objects\n# Can now call: r_function(**r_kwargs)\n</code></pre> See Also <p>py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def kwargs_r(kwargs: dict | None) -&gt; dict:\n    \"\"\"\n    Convert Python keyword arguments to R-compatible format.\n\n    Convenience function that applies py_to_r() to all values in a\n    keyword arguments dictionary, preparing them for R function calls.\n\n    Parameters\n    ----------\n    kwargs : dict or None\n        Dictionary of keyword arguments where values may be Python objects\n        (dicts, lists, DataFrames, arrays, etc.)\n\n    Returns\n    -------\n    dict\n        Dictionary with same keys but R-compatible values, or empty dict if None\n\n    Notes\n    -----\n    This is a thin wrapper around `py_to_r()` that operates on dictionaries.\n    It's commonly used to prepare keyword arguments for R function calls via rpy2.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import kwargs_r\n    import pandas as pd\n    import numpy as np\n\n    # Prepare kwargs for R function\n    py_kwargs = {\n        'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n        'prior': {'b': [0, 1]},\n        'chains': 4,\n        'iter': 2000\n    }\n\n    r_kwargs = kwargs_r(py_kwargs)\n    # All values converted to R objects\n    # Can now call: r_function(**r_kwargs)\n    ```\n\n    See Also\n    --------\n    py_to_r : Underlying conversion function for individual values\n    brmspy.brms.fit : Uses this to prepare user kwargs for R\n    \"\"\"\n    if kwargs is None:\n        return {}\n    return {k: py_to_r(v) for k, v in kwargs.items()}\n</code></pre>"},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def py_to_r(obj: PyObject) -&gt; Sexp:\n    \"\"\"\n    Convert arbitrary Python objects to R objects via rpy2.\n\n    Comprehensive converter that handles nested structures (dicts, lists),\n    DataFrames, arrays, and scalars. Uses rpy2's converters with special\n    handling for dictionaries (\u2192 R named lists) and lists of dicts.\n\n    Parameters\n    ----------\n    obj : any\n        Python object to convert. Supported types:\n        - None \u2192 R NULL\n        - dict \u2192 R named list (ListVector), recursively\n        - list/tuple of dicts \u2192 R list of named lists\n        - list/tuple (other) \u2192 R vector or list\n        - pd.DataFrame \u2192 R data.frame\n        - np.ndarray \u2192 R vector/matrix\n        - scalars (int, float, str, bool) \u2192 R atomic types\n\n    Returns\n    -------\n    rpy2 R object\n        R representation of the Python object\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **None**: \u2192 R NULL\n    2. **DataFrames**: \u2192 R data.frame (via pandas2ri)\n    3. **Dictionaries**: \u2192 R named list (ListVector), recursively converting values\n    4. **Lists of dicts**: \u2192 R list with 1-based indexed names containing named lists\n    5. **Other lists/tuples**: \u2192 R vectors or lists (via rpy2 default)\n    6. **NumPy arrays**: \u2192 R vectors/matrices (via numpy2ri)\n    7. **Scalars**: \u2192 R atomic values\n\n    **Recursive Conversion:**\n\n    Dictionary values are recursively converted, allowing nested structures:\n    ```python\n    {'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n    ```\n\n    **List of Dicts:**\n\n    Lists containing only dicts are converted to R lists with 1-based indexing:\n    ```python\n    [{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n    ```\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import py_to_r\n    import numpy as np\n    import pandas as pd\n\n    # Scalars\n    py_to_r(5)        # R: 5\n    py_to_r(\"hello\")  # R: \"hello\"\n    py_to_r(None)     # R: NULL\n\n    # Arrays\n    py_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n    # DataFrames\n    df = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\n    py_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n    ```\n\n    See Also\n    --------\n    r_to_py : Convert R objects back to Python\n    kwargs_r : Convert keyword arguments dict for R function calls\n    brmspy.brms.fit : Uses this for converting data to R\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if obj is None:\n        return ro.NULL\n\n    if isinstance(obj, ro.Sexp):\n        return obj\n\n    if isinstance(obj, RListVectorExtension) and isinstance(obj.r, ro.Sexp):\n        return obj.r\n\n    _type = type(obj)\n    converter = None\n\n    if _type in _registry._PY2R_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._PY2R_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._PY2R_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._PY2R_CONVERTERS) &gt; 0, \"NO PY2R CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj)\n</code></pre>"},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.r_to_py","title":"<code>r_to_py(obj, shm=None)</code>","text":"<p>Convert R objects to Python objects via rpy2.</p> <p>Comprehensive converter that handles R lists (named/unnamed), vectors, formulas, and language objects. Provides sensible Python equivalents for all R types with special handling for edge cases.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>rpy2 R object</code> <p>R object to convert to Python</p> required <p>Returns:</p> Type Description <code>any</code> <p>Python representation of the R object: - R NULL \u2192 None - Named list \u2192 dict (recursively) - Unnamed list \u2192 list (recursively) - Length-1 vector \u2192 scalar (int, float, str, bool) - Length-N vector \u2192 list of scalars - Formula/Language object \u2192 str (descriptive representation) - Other objects \u2192 default rpy2 conversion or str fallback</p> Notes <p>Conversion Rules:</p> <ol> <li>R NULL: \u2192 Python None</li> <li>Atomic vectors (numeric, character, logical):</li> <li>Length 1: \u2192 Python scalar (int, float, str, bool)</li> <li>Length &gt;1: \u2192 Python list of scalars</li> <li>Named lists (ListVector with names): \u2192 Python dict, recursively</li> <li>Unnamed lists: \u2192 Python list, recursively</li> <li>Formulas (e.g., <code>y ~ x</code>): \u2192 String representation</li> <li>Language objects (calls, expressions): \u2192 String representation</li> <li>Functions: \u2192 String representation</li> <li>Everything else: Try default rpy2 conversion, fallback to string</li> </ol> <p>Recursive Conversion:</p> <p>List elements and dictionary values are recursively converted: <pre><code>list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n</code></pre></p> <p>Safe Fallback:</p> <p>R language objects, formulas, and functions are converted to descriptive strings rather than attempting complex conversions that might fail.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import r_to_py\nimport rpy2.robjects as ro\n\n# R NULL\nr_to_py(ro.NULL)  # None\n\n# Scalars\nr_to_py(ro.IntVector([5]))    # 5\nr_to_py(ro.FloatVector([3.14]))  # 3.14\nr_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n# Vectors\nr_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n</code></pre> See Also <p>py_to_r : Convert Python objects to R brmspy.brms.summary : Returns Python-friendly summary dict</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def r_to_py(obj: Sexp, shm: ShmPool | None = None) -&gt; PyObject:\n    \"\"\"\n    Convert R objects to Python objects via rpy2.\n\n    Comprehensive converter that handles R lists (named/unnamed), vectors,\n    formulas, and language objects. Provides sensible Python equivalents\n    for all R types with special handling for edge cases.\n\n    Parameters\n    ----------\n    obj : rpy2 R object\n        R object to convert to Python\n\n    Returns\n    -------\n    any\n        Python representation of the R object:\n        - R NULL \u2192 None\n        - Named list \u2192 dict (recursively)\n        - Unnamed list \u2192 list (recursively)\n        - Length-1 vector \u2192 scalar (int, float, str, bool)\n        - Length-N vector \u2192 list of scalars\n        - Formula/Language object \u2192 str (descriptive representation)\n        - Other objects \u2192 default rpy2 conversion or str fallback\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **R NULL**: \u2192 Python None\n    2. **Atomic vectors** (numeric, character, logical):\n       - Length 1: \u2192 Python scalar (int, float, str, bool)\n       - Length &gt;1: \u2192 Python list of scalars\n    3. **Named lists** (ListVector with names): \u2192 Python dict, recursively\n    4. **Unnamed lists**: \u2192 Python list, recursively\n    5. **Formulas** (e.g., `y ~ x`): \u2192 String representation\n    6. **Language objects** (calls, expressions): \u2192 String representation\n    7. **Functions**: \u2192 String representation\n    8. **Everything else**: Try default rpy2 conversion, fallback to string\n\n    **Recursive Conversion:**\n\n    List elements and dictionary values are recursively converted:\n    ```R\n    list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n    ```\n\n    **Safe Fallback:**\n\n    R language objects, formulas, and functions are converted to descriptive\n    strings rather than attempting complex conversions that might fail.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import r_to_py\n    import rpy2.robjects as ro\n\n    # R NULL\n    r_to_py(ro.NULL)  # None\n\n    # Scalars\n    r_to_py(ro.IntVector([5]))    # 5\n    r_to_py(ro.FloatVector([3.14]))  # 3.14\n    r_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n    # Vectors\n    r_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n    ```\n\n    See Also\n    --------\n    py_to_r : Convert Python objects to R\n    brmspy.brms.summary : Returns Python-friendly summary dict\n    \"\"\"\n    import rpy2.robjects as ro\n\n    from brmspy._singleton._shm_singleton import _get_shm\n\n    if obj is ro.NULL:\n        return None\n\n    _type = type(obj)\n    converter = None\n\n    if shm is None:\n        shm = _get_shm()\n\n    if _type in _registry._R2PY_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._R2PY_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._R2PY_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._R2PY_CONVERTERS) &gt; 0, \"NO R2PY CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj, shm)\n</code></pre>"},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.summary","title":"<code>summary(model, **kwargs)</code>","text":"<p>Generate comprehensive summary statistics for a fitted brms model.</p> <p>Returns a <code>SummaryResult</code> dataclass containing model information, parameter estimates, and diagnostic information. The SummaryResult object provides pretty printing via <code>str()</code> or <code>print()</code> and structured access to all components.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code>.</p> required <code>**kwargs</code> <p>Additional arguments passed to brms::summary(), such as: - probs: Quantiles for credible intervals, e.g., <code>probs=(0.025, 0.975)</code> - robust: Use robust estimates (median, MAD), default False</p> <code>{}</code> <p>Returns:</p> Type Description <code>SummaryResult</code> <p>A dataclass containing:</p> <ul> <li>formula (str): Model formula as string</li> <li>data_name (str): Name of the data object used</li> <li>group (str): Grouping structure information</li> <li>nobs (int): Number of observations</li> <li>ngrps (Dict[str, int]): Number of groups per grouping variable</li> <li>autocor (Optional[dict]): Autocorrelation structure if present</li> <li>prior (pd.DataFrame): Prior specifications used</li> <li>algorithm (str): Sampling algorithm (e.g., \"sampling\")</li> <li>sampler (str): Sampler specification (e.g., \"sample(hmc)\")</li> <li>total_ndraws (int): Total number of post-warmup draws</li> <li>chains (float): Number of chains</li> <li>iter (float): Iterations per chain</li> <li>warmup (float): Warmup iterations per chain</li> <li>thin (float): Thinning interval</li> <li>has_rhat (bool): Whether Rhat diagnostics are reported</li> <li>fixed (pd.DataFrame): Population-level (fixed) effects estimates</li> <li>spec_pars (pd.DataFrame): Family-specific parameters (e.g., sigma)</li> <li>cor_pars (pd.DataFrame): Correlation parameters if present</li> <li>random (dict): Group-level (random) effects by grouping variable</li> </ul> See Also <p>brms::summary.brmsfit : R documentation</p> <p>Examples:</p> <p>Basic usage with pretty printing:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x\", data=data, chains=4)\nsummary = brmspy.summary(model)\n\n# Pretty print full summary\nprint(summary)\n</code></pre> <p>Access specific components:</p> <pre><code># Get population-level effects as DataFrame\nfixed_effects = summary.fixed\nprint(fixed_effects)\n\n# Get family-specific parameters (e.g., sigma)\nspec_params = summary.spec_pars\nprint(spec_params)\n\n# Access random effects (if present)\nrandom_effects = summary.random\nfor group_name, group_df in random_effects.items():\n    print(f\"Random effects for {group_name}:\")\n    print(group_df)\n\n# Check model metadata\nprint(f\"Formula: {summary.formula}\")\nprint(f\"Total draws: {summary.total_ndraws}\")\nprint(f\"Rhat reported: {summary.has_rhat}\")\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Use 90% credible intervals instead of default 95%\nsummary_90 = brmspy.summary(model, probs=(0.05, 0.95))\nprint(summary_90.fixed)\n</code></pre> Source code in <code>brmspy/_brms_functions/diagnostics.py</code> <pre><code>def summary(model: FitResult, **kwargs) -&gt; SummaryResult:\n    \"\"\"\n    Generate comprehensive summary statistics for a fitted brms model.\n\n    Returns a `SummaryResult` dataclass containing model information,\n    parameter estimates, and diagnostic information. The SummaryResult object provides\n    pretty printing via `str()` or `print()` and structured access to all components.\n\n    [BRMS documentation and parameters](https://paulbuerkner.com/brms/reference/summary.brmsfit.html)\n\n    Parameters\n    ----------\n    model : FitResult\n        Fitted model returned by `brmspy.brms.brm()`.\n    **kwargs\n        Additional arguments passed to brms::summary(), such as:\n        - probs: Quantiles for credible intervals, e.g., `probs=(0.025, 0.975)`\n        - robust: Use robust estimates (median, MAD), default False\n\n    Returns\n    -------\n    SummaryResult\n        A dataclass containing:\n\n        - **formula** (str): Model formula as string\n        - **data_name** (str): Name of the data object used\n        - **group** (str): Grouping structure information\n        - **nobs** (int): Number of observations\n        - **ngrps** (Dict[str, int]): Number of groups per grouping variable\n        - **autocor** (Optional[dict]): Autocorrelation structure if present\n        - **prior** (pd.DataFrame): Prior specifications used\n        - **algorithm** (str): Sampling algorithm (e.g., \"sampling\")\n        - **sampler** (str): Sampler specification (e.g., \"sample(hmc)\")\n        - **total_ndraws** (int): Total number of post-warmup draws\n        - **chains** (float): Number of chains\n        - **iter** (float): Iterations per chain\n        - **warmup** (float): Warmup iterations per chain\n        - **thin** (float): Thinning interval\n        - **has_rhat** (bool): Whether Rhat diagnostics are reported\n        - **fixed** (pd.DataFrame): Population-level (fixed) effects estimates\n        - **spec_pars** (pd.DataFrame): Family-specific parameters (e.g., sigma)\n        - **cor_pars** (pd.DataFrame): Correlation parameters if present\n        - **random** (dict): Group-level (random) effects by grouping variable\n\n    See Also\n    --------\n    brms::summary.brmsfit : [R documentation](https://paulbuerkner.com/brms/reference/summary.brmsfit.html)\n\n    Examples\n    --------\n    Basic usage with pretty printing:\n\n    ```python\n    import brmspy\n\n    model = brmspy.fit(\"y ~ x\", data=data, chains=4)\n    summary = brmspy.summary(model)\n\n    # Pretty print full summary\n    print(summary)\n    ```\n\n    Access specific components:\n\n    ```python\n    # Get population-level effects as DataFrame\n    fixed_effects = summary.fixed\n    print(fixed_effects)\n\n    # Get family-specific parameters (e.g., sigma)\n    spec_params = summary.spec_pars\n    print(spec_params)\n\n    # Access random effects (if present)\n    random_effects = summary.random\n    for group_name, group_df in random_effects.items():\n        print(f\"Random effects for {group_name}:\")\n        print(group_df)\n\n    # Check model metadata\n    print(f\"Formula: {summary.formula}\")\n    print(f\"Total draws: {summary.total_ndraws}\")\n    print(f\"Rhat reported: {summary.has_rhat}\")\n    ```\n\n    Custom credible intervals:\n\n    ```python\n    # Use 90% credible intervals instead of default 95%\n    summary_90 = brmspy.summary(model, probs=(0.05, 0.95))\n    print(summary_90.fixed)\n    ```\n    \"\"\"\n\n    import rpy2.robjects as ro\n\n    kwargs = kwargs_r(kwargs)\n    r_summary = cast(Callable, ro.r(\"summary\"))\n    summary_r = r_summary(model.r, **kwargs)\n\n    _default_get_r = lambda param: f\"function(x) x${param}\"\n    _get_methods_r: dict[str, Callable[[str], str]] = {\n        # Extract a clean formula string: \"y ~ x1 + x2 + ...\"\n        \"formula\": lambda param: (\n            \"function(x) { paste(deparse(x$formula$formula), collapse = ' ') }\"\n        ),\n    }\n\n    names = summary_r.names\n    get = lambda param: r_to_py(\n        cast(Callable, ro.r(_get_methods_r.get(param, _default_get_r)(param)))(\n            summary_r\n        )\n    )\n    out = iterate_robject_to_dataclass(\n        names=names, get=get, target_dataclass=SummaryResult, r=summary_r\n    )\n\n    return cast(SummaryResult, out)\n</code></pre>"},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.fixef","title":"<code>fixef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, **kwargs)</code>","text":"<p>Extract population-level (fixed) effects estimates from a fitted brms model.</p> <p>Returns a pandas DataFrame containing estimates and uncertainty intervals for all population-level parameters (fixed effects). By default, returns summary statistics (mean, standard error, credible intervals). Can also return raw posterior samples when <code>summary=False</code>.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListSexpVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>summary</code> <code>bool</code> <p>If True, return summary statistics (mean/median, SE/MAD, credible intervals). If False, return matrix of posterior samples (iterations \u00d7 parameters).</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics. Only used when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>list of str</code> <p>Specific parameter names to extract. If None, returns all fixed effects. Useful for subsetting when you only need specific coefficients.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::fixef()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>When <code>summary=True</code> (default):     DataFrame with parameters as rows and columns for Estimate, Est.Error,     Q2.5, Q97.5 (or other quantiles specified in <code>probs</code>), and optionally     Rhat and Bulk_ESS/Tail_ESS diagnostics.</p> <p>When <code>summary=False</code>:     DataFrame with posterior samples where rows are iterations and columns     are parameters. Shape is (n_iterations \u00d7 n_parameters).</p> See Also <p>brms::fixef.brmsfit : R documentation summary() : Full model summary with all parameter types</p> <p>Examples:</p> <p>Basic usage with summary statistics:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=data, chains=4)\n\n# Get fixed effects summary\nfixed_effects = brmspy.fixef(model)\nprint(fixed_effects)\n#             Estimate  Est.Error      Q2.5     Q97.5\n# Intercept  10.234567   0.123456  9.992345  10.47689\n# x1          0.456789   0.098765  0.263456   0.65012\n# x2         -0.234567   0.087654 -0.406789  -0.06234\n</code></pre> <p>Get specific parameters only:</p> <pre><code># Extract only specific coefficients\nx1_x2_effects = brmspy.fixef(model, pars=[\"x1\", \"x2\"])\nprint(x1_x2_effects)\n</code></pre> <p>Use robust estimates (median and MAD):</p> <pre><code># Use median and MAD instead of mean and SD\nrobust_effects = brmspy.fixef(model, robust=True)\nprint(robust_effects)\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Get 90% credible intervals\neffects_90 = brmspy.fixef(model, probs=(0.05, 0.95))\nprint(effects_90)\n</code></pre> <p>Get raw posterior samples:</p> <pre><code># Get full posterior samples matrix\nsamples = brmspy.fixef(model, summary=False)\nprint(samples.shape)  # (n_iterations, n_parameters)\n\n# Can then compute custom statistics\nimport numpy as np\ncustom_quantile = np.percentile(samples[\"x1\"], 90)\n</code></pre> Source code in <code>brmspy/_brms_functions/diagnostics.py</code> <pre><code>def fixef(\n    object: FitResult | ListSexpVector,\n    summary=True,\n    robust=False,\n    probs=(0.025, 0.975),\n    pars=None,\n    **kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Extract population-level (fixed) effects estimates from a fitted brms model.\n\n    Returns a pandas DataFrame containing estimates and uncertainty intervals for\n    all population-level parameters (fixed effects). By default, returns summary\n    statistics (mean, standard error, credible intervals). Can also return raw\n    posterior samples when `summary=False`.\n\n    [BRMS documentation](https://paulbuerkner.com/brms/reference/fixef.brmsfit.html)\n\n    Parameters\n    ----------\n    object : FitResult or ListSexpVector\n        Fitted model returned by `brmspy.brms.brm()` or an R brmsfit object.\n    summary : bool, default=True\n        If True, return summary statistics (mean/median, SE/MAD, credible intervals).\n        If False, return matrix of posterior samples (iterations \u00d7 parameters).\n    robust : bool, default=False\n        If True, use median and MAD instead of mean and SD for summary statistics.\n        Only used when `summary=True`.\n    probs : tuple of float, default=(0.025, 0.975)\n        Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals.\n        Only used when `summary=True`.\n    pars : list of str, optional\n        Specific parameter names to extract. If None, returns all fixed effects.\n        Useful for subsetting when you only need specific coefficients.\n    **kwargs\n        Additional arguments passed to brms::fixef()\n\n    Returns\n    -------\n    pd.DataFrame\n        When `summary=True` (default):\n            DataFrame with parameters as rows and columns for Estimate, Est.Error,\n            Q2.5, Q97.5 (or other quantiles specified in `probs`), and optionally\n            Rhat and Bulk_ESS/Tail_ESS diagnostics.\n\n        When `summary=False`:\n            DataFrame with posterior samples where rows are iterations and columns\n            are parameters. Shape is (n_iterations \u00d7 n_parameters).\n\n    See Also\n    --------\n    brms::fixef.brmsfit : [R documentation](https://paulbuerkner.com/brms/reference/fixef.brmsfit.html)\n    summary() : Full model summary with all parameter types\n\n    Examples\n    --------\n    Basic usage with summary statistics:\n\n    ```python\n    import brmspy\n\n    model = brmspy.fit(\"y ~ x1 + x2\", data=data, chains=4)\n\n    # Get fixed effects summary\n    fixed_effects = brmspy.fixef(model)\n    print(fixed_effects)\n    #             Estimate  Est.Error      Q2.5     Q97.5\n    # Intercept  10.234567   0.123456  9.992345  10.47689\n    # x1          0.456789   0.098765  0.263456   0.65012\n    # x2         -0.234567   0.087654 -0.406789  -0.06234\n    ```\n\n    Get specific parameters only:\n\n    ```python\n    # Extract only specific coefficients\n    x1_x2_effects = brmspy.fixef(model, pars=[\"x1\", \"x2\"])\n    print(x1_x2_effects)\n    ```\n\n    Use robust estimates (median and MAD):\n\n    ```python\n    # Use median and MAD instead of mean and SD\n    robust_effects = brmspy.fixef(model, robust=True)\n    print(robust_effects)\n    ```\n\n    Custom credible intervals:\n\n    ```python\n    # Get 90% credible intervals\n    effects_90 = brmspy.fixef(model, probs=(0.05, 0.95))\n    print(effects_90)\n    ```\n\n    Get raw posterior samples:\n\n    ```python\n    # Get full posterior samples matrix\n    samples = brmspy.fixef(model, summary=False)\n    print(samples.shape)  # (n_iterations, n_parameters)\n\n    # Can then compute custom statistics\n    import numpy as np\n    custom_quantile = np.percentile(samples[\"x1\"], 90)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    obj_r = py_to_r(object)\n    kwargs = kwargs_r(\n        {\"summary\": summary, \"robust\": robust, \"probs\": probs, \"pars\": pars, **kwargs}\n    )\n    r_fixef = cast(Callable, ro.r(\"brms::fixef\"))\n    r_df = r_fixef(obj_r, **kwargs)\n    return cast(pd.DataFrame, r_to_py(r_df))\n</code></pre>"},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.ranef","title":"<code>ranef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, groups=None, **kwargs)</code>","text":"<p>Extract group-level (random) effects as xarray DataArrays.</p> <p>This is a wrapper around <code>brms::ranef()</code>. For <code>summary=True</code> (default), each grouping factor is returned as a 3D array with dimensions <code>(\"group\", \"stat\", \"coef\")</code>. For <code>summary=False</code>, each factor is returned as <code>(\"draw\", \"group\", \"coef\")</code> with one slice per posterior draw.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model returned by :func:<code>brmspy.brms.fit</code> or an R <code>brmsfit</code> object / summary list.</p> required <code>summary</code> <code>bool</code> <p>If True, return posterior summaries for the group-level effects (means, errors, intervals). If False, return per-draw random effects.</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use robust summaries (median and MAD) instead of mean and SD. Passed through to <code>brms::ranef()</code> when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Central posterior interval probabilities, as in <code>brms::ranef()</code>. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>str or sequence of str</code> <p>Subset of group-level parameters to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>groups</code> <code>str or sequence of str</code> <p>Subset of grouping factors to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments forwarded to <code>brms::ranef()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, DataArray]</code> <p>Mapping from grouping-factor name (e.g. <code>\"patient\"</code>) to a <code>DataArray</code>:</p> <ul> <li><code>summary=True</code>: dims <code>(\"group\", \"stat\", \"coef\")</code>,   with <code>stat</code> typically containing   <code>[\"Estimate\", \"Est.Error\", \"Q2.5\", \"Q97.5\"]</code>.</li> <li><code>summary=False</code>: dims <code>(\"draw\", \"group\", \"coef\")</code>,   where <code>draw</code> indexes posterior samples.</li> </ul> <p>Examples:</p> <p>Compute summary random effects and inspect all coefficients for a single group level:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms import ranef\n\nfit = brms.fit(\"count ~ zAge + zBase * Trt + (1 + zBase + Trt | patient)\",\n               data=data, family=\"poisson\")\n\nre = ranef(fit)  # summary=True by default\npatient_re = re[\"patient\"].sel(group=\"1\", stat=\"Estimate\")\n</code></pre> <p>Extract per-draw random effects for downstream MCMC analysis:</p> <pre><code>re_draws = ranef(fit, summary=False)\npatient_draws = re_draws[\"patient\"]       # dims: (\"draw\", \"group\", \"coef\")\nfirst_draw = patient_draws.sel(draw=0)\n</code></pre> Source code in <code>brmspy/_brms_functions/diagnostics.py</code> <pre><code>def ranef(\n    object: FitResult | ListSexpVector,\n    summary: bool = True,\n    robust: bool = False,\n    probs=(0.025, 0.975),\n    pars=None,\n    groups=None,\n    **kwargs,\n) -&gt; dict[str, xr.DataArray]:\n    \"\"\"\n    Extract group-level (random) effects as xarray DataArrays.\n\n    This is a wrapper around ``brms::ranef()``. For ``summary=True`` (default),\n    each grouping factor is returned as a 3D array with dimensions\n    ``(\"group\", \"stat\", \"coef\")``. For ``summary=False``, each factor is\n    returned as ``(\"draw\", \"group\", \"coef\")`` with one slice per posterior draw.\n\n    Parameters\n    ----------\n    object : FitResult or rpy2.robjects.ListVector\n        Fitted model returned by :func:`brmspy.brms.fit` or an R ``brmsfit``\n        object / summary list.\n    summary : bool, default True\n        If True, return posterior summaries for the group-level effects\n        (means, errors, intervals). If False, return per-draw random effects.\n    robust : bool, default False\n        If True, use robust summaries (median and MAD) instead of mean and SD.\n        Passed through to ``brms::ranef()`` when ``summary=True``.\n    probs : tuple of float, default (0.025, 0.975)\n        Central posterior interval probabilities, as in ``brms::ranef()``.\n        Only used when ``summary=True``.\n    pars : str or sequence of str, optional\n        Subset of group-level parameters to include. Passed to ``brms::ranef()``.\n    groups : str or sequence of str, optional\n        Subset of grouping factors to include. Passed to ``brms::ranef()``.\n    **kwargs\n        Additional keyword arguments forwarded to ``brms::ranef()``.\n\n    Returns\n    -------\n    dict[str, xarray.DataArray]\n        Mapping from grouping-factor name (e.g. ``\"patient\"``) to a\n        ``DataArray``:\n\n        * ``summary=True``: dims ``(\"group\", \"stat\", \"coef\")``,\n          with ``stat`` typically containing\n          ``[\"Estimate\", \"Est.Error\", \"Q2.5\", \"Q97.5\"]``.\n        * ``summary=False``: dims ``(\"draw\", \"group\", \"coef\")``,\n          where ``draw`` indexes posterior samples.\n\n    Examples\n    --------\n    Compute summary random effects and inspect all coefficients for a single\n    group level:\n\n    ```python\n    from brmspy import brms\n    from brmspy.brms import ranef\n\n    fit = brms.fit(\"count ~ zAge + zBase * Trt + (1 + zBase + Trt | patient)\",\n                   data=data, family=\"poisson\")\n\n    re = ranef(fit)  # summary=True by default\n    patient_re = re[\"patient\"].sel(group=\"1\", stat=\"Estimate\")\n    ```\n\n    Extract per-draw random effects for downstream MCMC analysis:\n\n    ```python\n    re_draws = ranef(fit, summary=False)\n    patient_draws = re_draws[\"patient\"]       # dims: (\"draw\", \"group\", \"coef\")\n    first_draw = patient_draws.sel(draw=0)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    obj_r = py_to_r(object)\n    kwargs = kwargs_r(\n        {\"summary\": summary, \"robust\": robust, \"probs\": probs, \"pars\": pars, **kwargs}\n    )\n\n    r_ranef = cast(Callable, ro.r(\"brms::ranef\"))\n    r_list = r_ranef(obj_r, **kwargs)\n\n    out: dict[str, xr.DataArray] = {}\n\n    for name in r_list.names:\n        # R 3D array for this grouping factor\n        r_arr = cast(Callable, ro.r(f\"function(x) x${name}\"))(r_list)\n        dims = list(r_arr.do_slot(\"dim\"))  # length-3\n\n        # dimnames is a list of length 3, some entries may be NULL\n        dimnames_r = r_arr.do_slot(\"dimnames\")\n        dimnames: list[list[str] | None] = []\n        for dn in dimnames_r:\n            if dn == ro.NULL:\n                dimnames.append(None)\n            else:\n                dimnames.append(list(cast(Iterable, r_to_py(dn))))\n\n        p_arr = np.asarray(r_arr).reshape(dims)\n\n        if summary:\n            # brms: 1=group levels, 2=stats, 3=coefs\n            groups_dn, stats_dn, coefs_dn = dimnames\n\n            da = xr.DataArray(\n                p_arr,\n                dims=(\"group\", \"stat\", \"coef\"),\n                coords={\n                    \"group\": groups_dn,\n                    \"stat\": stats_dn,\n                    \"coef\": coefs_dn,\n                },\n            )\n        else:\n            # brms: 1=draws, 2=group levels, 3=coefs\n            draws_dn, groups_dn, coefs_dn = dimnames\n            n_draws = dims[0]\n            if draws_dn is None:\n                # brms does not name draws, so create a simple index\n                draws_dn = list(range(n_draws))\n\n            da = xr.DataArray(\n                p_arr,\n                dims=(\"draw\", \"group\", \"coef\"),\n                coords={\n                    \"draw\": draws_dn,\n                    \"group\": groups_dn,\n                    \"coef\": coefs_dn,\n                },\n            )\n\n        out[name] = da\n    return out\n</code></pre>"},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.posterior_summary","title":"<code>posterior_summary(object, variable=None, probs=(0.025, 0.975), robust=False, **kwargs)</code>","text":"<p>Extract posterior summary statistics for all or selected model parameters.</p> <p>Provides a DataFrame with estimates, standard errors, and credible intervals for all parameters in a brms model, including fixed effects, random effects, and auxiliary parameters. More comprehensive than <code>fixef()</code> or <code>ranef()</code> as it covers all parameter types.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListSexpVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>variable</code> <code>str or list of str</code> <p>Specific variable name(s) to extract. If None, returns all parameters. Supports regex patterns for flexible selection.</p> <code>None</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals.</p> <code>(0.025, 0.975)</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments passed to brms::posterior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with parameters as rows and columns for Estimate, Est.Error, and quantiles (e.g., Q2.5, Q97.5). Includes all model parameters: population-level effects, group-level effects, and auxiliary parameters.</p> See Also <p>brms::posterior_summary : R documentation     https://paulbuerkner.com/brms/reference/posterior_summary.brmsfit.html fixef() : Extract only population-level effects ranef() : Extract only group-level effects</p> <p>Examples:</p> <p>Get summary for all parameters:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + (1|group)\", data=data, chains=4)\n\n# Get all parameter summaries\nall_params = brmspy.posterior_summary(model)\nprint(all_params)\n</code></pre> <p>Extract specific parameters:</p> <pre><code># Get summary for specific parameters\nintercept = brmspy.posterior_summary(model, variable=\"b_Intercept\")\nprint(intercept)\n\n# Multiple parameters\nfixed_only = brmspy.posterior_summary(model, variable=[\"b_Intercept\", \"b_x1\"])\nprint(fixed_only)\n</code></pre> <p>Custom credible intervals with robust estimates:</p> <pre><code># 90% intervals with median/MAD\nrobust_summary = brmspy.posterior_summary(\n    model,\n    probs=(0.05, 0.95),\n    robust=True\n)\nprint(robust_summary)\n</code></pre> Source code in <code>brmspy/_brms_functions/diagnostics.py</code> <pre><code>def posterior_summary(\n    object: FitResult | ListSexpVector,\n    variable=None,\n    probs=(0.025, 0.975),\n    robust=False,\n    **kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Extract posterior summary statistics for all or selected model parameters.\n\n    Provides a DataFrame with estimates, standard errors, and credible intervals\n    for all parameters in a brms model, including fixed effects, random effects,\n    and auxiliary parameters. More comprehensive than `fixef()` or `ranef()` as it covers all\n    parameter types.\n\n    [BRMS documentation](https://paulbuerkner.com/brms/reference/posterior_summary.brmsfit.html)\n\n    Parameters\n    ----------\n    object : FitResult or ListSexpVector\n        Fitted model returned by `brmspy.brms.brm()` or an R brmsfit object.\n    variable : str or list of str, optional\n        Specific variable name(s) to extract. If None, returns all parameters.\n        Supports regex patterns for flexible selection.\n    probs : tuple of float, default=(0.025, 0.975)\n        Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals.\n    robust : bool, default=False\n        If True, use median and MAD instead of mean and SD for summary statistics.\n    **kwargs\n        Additional arguments passed to brms::posterior_summary()\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with parameters as rows and columns for Estimate, Est.Error,\n        and quantiles (e.g., Q2.5, Q97.5). Includes all model parameters:\n        population-level effects, group-level effects, and auxiliary parameters.\n\n    See Also\n    --------\n    brms::posterior_summary : R documentation\n        https://paulbuerkner.com/brms/reference/posterior_summary.brmsfit.html\n    fixef() : Extract only population-level effects\n    ranef() : Extract only group-level effects\n\n    Examples\n    --------\n    Get summary for all parameters:\n\n    ```python\n    import brmspy\n\n    model = brmspy.fit(\"y ~ x1 + (1|group)\", data=data, chains=4)\n\n    # Get all parameter summaries\n    all_params = brmspy.posterior_summary(model)\n    print(all_params)\n    ```\n\n    Extract specific parameters:\n\n    ```python\n    # Get summary for specific parameters\n    intercept = brmspy.posterior_summary(model, variable=\"b_Intercept\")\n    print(intercept)\n\n    # Multiple parameters\n    fixed_only = brmspy.posterior_summary(model, variable=[\"b_Intercept\", \"b_x1\"])\n    print(fixed_only)\n    ```\n\n    Custom credible intervals with robust estimates:\n\n    ```python\n    # 90% intervals with median/MAD\n    robust_summary = brmspy.posterior_summary(\n        model,\n        probs=(0.05, 0.95),\n        robust=True\n    )\n    print(robust_summary)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    obj_r = py_to_r(object)\n    kwargs = kwargs_r(\n        {\"variable\": variable, \"probs\": probs, \"robust\": robust, **kwargs}\n    )\n\n    r_fun = cast(Callable, ro.r(\"brms::posterior_summary\"))\n    r_df = r_fun(obj_r, **kwargs)\n    return cast(pd.DataFrame, r_to_py(r_df))\n</code></pre>"},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.prior_summary","title":"<code>prior_summary(object, all=True, **kwargs)</code>","text":"<p>Extract prior specifications used in a fitted brms model.</p> <p>Returns a DataFrame containing all prior distributions that were used (either explicitly set or defaults) when fitting the model. Useful for documenting model specifications and understanding which priors were applied.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>all</code> <code>bool</code> <p>If True, return all priors including default priors. If False, return only explicitly set priors.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to brms::prior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns describing prior specifications: - prior: Prior distribution formula - class: Parameter class (b, sd, Intercept, etc.) - coef: Specific coefficient (if applicable) - group: Grouping factor (if applicable) - resp: Response variable (for multivariate models) - dpar: Distributional parameter (if applicable) - nlpar: Non-linear parameter (if applicable) - lb/ub: Bounds for truncated priors - source: Origin of prior (default, user, etc.)</p> See Also <p>brms::prior_summary : R documentation     https://paulbuerkner.com/brms/reference/prior_summary.brmsfit.html get_prior() : Get prior structure before fitting default_prior() : Get default priors for a model</p> <p>Examples:</p> <p>Get all priors used in a model:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\n    \"y ~ x1 + (1|group)\",\n    data=data,\n    priors=[brmspy.prior(\"normal(0, 1)\", \"b\")],\n    chains=4\n)\n\n# Get all priors (including defaults)\npriors = brmspy.prior_summary(model)\nprint(priors)\n</code></pre> <p>Get only explicitly set priors:</p> <pre><code># Get only user-specified priors\nuser_priors = brmspy.prior_summary(model, all=False)\nprint(user_priors)\n</code></pre> <p>Compare with what would be used before fitting:</p> <pre><code># Before fitting - check default priors\ndefault_priors = brmspy.get_prior(\"y ~ x1\", data=data)\n\n# After fitting - see what was actually used\nused_priors = brmspy.prior_summary(model)\n</code></pre> Source code in <code>brmspy/_brms_functions/diagnostics.py</code> <pre><code>def prior_summary(\n    object: FitResult | ListSexpVector, all=True, **kwargs\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Extract prior specifications used in a fitted brms model.\n\n    Returns a DataFrame containing all prior distributions that were used\n    (either explicitly set or defaults) when fitting the model. Useful for\n    documenting model specifications and understanding which priors were applied.\n\n    [BRMS documentation](https://paulbuerkner.com/brms/reference/prior_summary.brmsfit.html)\n\n    Parameters\n    ----------\n    object : FitResult or ListVector\n        Fitted model returned by `brmspy.brms.brm()` or an R brmsfit object.\n    all : bool, default=True\n        If True, return all priors including default priors.\n        If False, return only explicitly set priors.\n    **kwargs\n        Additional arguments passed to brms::prior_summary()\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with columns describing prior specifications:\n        - prior: Prior distribution formula\n        - class: Parameter class (b, sd, Intercept, etc.)\n        - coef: Specific coefficient (if applicable)\n        - group: Grouping factor (if applicable)\n        - resp: Response variable (for multivariate models)\n        - dpar: Distributional parameter (if applicable)\n        - nlpar: Non-linear parameter (if applicable)\n        - lb/ub: Bounds for truncated priors\n        - source: Origin of prior (default, user, etc.)\n\n    See Also\n    --------\n    brms::prior_summary : R documentation\n        https://paulbuerkner.com/brms/reference/prior_summary.brmsfit.html\n    get_prior() : Get prior structure before fitting\n    default_prior() : Get default priors for a model\n\n    Examples\n    --------\n    Get all priors used in a model:\n\n    ```python\n    import brmspy\n\n    model = brmspy.fit(\n        \"y ~ x1 + (1|group)\",\n        data=data,\n        priors=[brmspy.prior(\"normal(0, 1)\", \"b\")],\n        chains=4\n    )\n\n    # Get all priors (including defaults)\n    priors = brmspy.prior_summary(model)\n    print(priors)\n    ```\n\n    Get only explicitly set priors:\n\n    ```python\n    # Get only user-specified priors\n    user_priors = brmspy.prior_summary(model, all=False)\n    print(user_priors)\n    ```\n\n    Compare with what would be used before fitting:\n\n    ```python\n    # Before fitting - check default priors\n    default_priors = brmspy.get_prior(\"y ~ x1\", data=data)\n\n    # After fitting - see what was actually used\n    used_priors = brmspy.prior_summary(model)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    obj_r = py_to_r(object)\n    kwargs = kwargs_r({\"all\": all, **kwargs})\n\n    r_fun = cast(Callable, ro.r(\"brms::prior_summary\"))\n    r_df = r_fun(obj_r, **kwargs)\n    return cast(pd.DataFrame, r_to_py(r_df))\n</code></pre>"},{"location":"internals/_brms_functions/diagnostics/#brmspy._brms_functions.diagnostics.validate_newdata","title":"<code>validate_newdata(newdata, object, re_formula=None, allow_new_levels=False, newdata2=None, resp=None, check_response=True, incl_autocor=True, group_vars=None, req_vars=None, **kwargs)</code>","text":"<p>Validate new data for predictions from a fitted brms model.</p> <p>Ensures that new data contains all required variables and has the correct structure for making predictions. Checks variable types, factor levels, grouping variables, and autocorrelation structures. This function is primarily used internally by prediction methods but can be called directly for debugging or validation purposes.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>DataFrame</code> <p>DataFrame containing new data to be validated against the model. Must include all predictor variables used in the model formula.</p> required <code>object</code> <code>FitResult or ListSexpVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>re_formula</code> <code>str</code> <p>Formula string specifying group-level effects to include in validation. If None (default), include all group-level effects. If NA, include no group-level effects.</p> <code>None</code> <code>allow_new_levels</code> <code>bool</code> <p>Whether to allow new levels of grouping variables not present in the original training data. If False, raises an error for new levels.</p> <code>False</code> <code>newdata2</code> <code>DataFrame</code> <p>Additional data that cannot be passed via <code>newdata</code>, such as objects used in autocorrelation structures or stanvars.</p> <code>None</code> <code>resp</code> <code>str or list of str</code> <p>Names of response variables to validate. If specified, validation is performed only for the specified responses (relevant for multivariate models).</p> <code>None</code> <code>check_response</code> <code>bool</code> <p>Whether to check if response variables are present in newdata. Set to False when making predictions where response is not needed.</p> <code>True</code> <code>incl_autocor</code> <code>bool</code> <p>Whether to include autocorrelation structures originally specified in the model. If True, validates autocorrelation-related variables.</p> <code>True</code> <code>group_vars</code> <code>list of str</code> <p>Names of specific grouping variables to validate. If None (default), validates all grouping variables present in the model.</p> <code>None</code> <code>req_vars</code> <code>list of str</code> <p>Names of specific variables required in newdata. If None (default), all variables from the original training data are required (unless excluded by other parameters).</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::validate_newdata()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Validated DataFrame based on newdata, potentially with added or modified columns to ensure compatibility with the model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If newdata is missing required variables</p> <code>ValueError</code> <p>If factor levels in newdata don't match those in training data (when allow_new_levels=False)</p> <code>ValueError</code> <p>If grouping variables have invalid structure</p> See Also <p>brms::validate_newdata : R documentation     https://paulbuerkner.com/brms/reference/validate_newdata.html posterior_predict() : Uses validate_newdata internally posterior_epred() : Uses validate_newdata internally</p> <p>Examples:</p> <p>Basic validation for prediction data:</p> <pre><code>import brmspy\nimport pandas as pd\n\n# Fit model\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=train_data, chains=4)\n\n# Prepare new data\nnew_data = pd.DataFrame({\n    'x1': [1.0, 2.0, 3.0],\n    'x2': [0.5, 1.0, 1.5]\n})\n\n# Validate before prediction\nvalidated_data = brmspy.validate_newdata(new_data, model)\nprint(validated_data)\n</code></pre> <p>Validate with group-level effects:</p> <pre><code># Model with random effects\nmodel = brmspy.fit(\"y ~ x + (1|group)\", data=train_data, chains=4)\n\n# New data with grouping variable\nnew_data = pd.DataFrame({\n    'x': [1.0, 2.0],\n    'group': ['A', 'B']  # Must match training data groups\n})\n\n# Validate - will error if groups A or B weren't in training\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    allow_new_levels=False\n)\n</code></pre> <p>Allow new levels for population-level predictions:</p> <pre><code># Allow new group levels (makes population-level predictions only)\nnew_data_with_new_groups = pd.DataFrame({\n    'x': [3.0, 4.0],\n    'group': ['C', 'D']  # New groups not in training\n})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data_with_new_groups,\n    model,\n    allow_new_levels=True\n)\n</code></pre> <p>Skip response variable checking:</p> <pre><code># When making predictions, response not needed\nnew_data = pd.DataFrame({'x1': [1.0, 2.0]})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    check_response=False\n)\n</code></pre> Source code in <code>brmspy/_brms_functions/diagnostics.py</code> <pre><code>def validate_newdata(\n    newdata: pd.DataFrame,\n    object: ListSexpVector | FitResult,\n    re_formula: str | None = None,\n    allow_new_levels: bool = False,\n    newdata2: pd.DataFrame | None = None,\n    resp=None,\n    check_response=True,\n    incl_autocor=True,\n    group_vars=None,\n    req_vars=None,\n    **kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Validate new data for predictions from a fitted brms model.\n\n    Ensures that new data contains all required variables and has the correct\n    structure for making predictions. Checks variable types, factor levels,\n    grouping variables, and autocorrelation structures. This function is primarily\n    used internally by prediction methods but can be called directly for debugging\n    or validation purposes.\n\n    [BRMS documentation](https://paulbuerkner.com/brms/reference/validate_newdata.html)\n\n    Parameters\n    ----------\n    newdata : pd.DataFrame\n        DataFrame containing new data to be validated against the model.\n        Must include all predictor variables used in the model formula.\n    object : FitResult or ListSexpVector\n        Fitted model returned by `brmspy.brms.brm()` or an R brmsfit object.\n    re_formula : str, optional\n        Formula string specifying group-level effects to include in validation.\n        If None (default), include all group-level effects.\n        If NA, include no group-level effects.\n    allow_new_levels : bool, default=False\n        Whether to allow new levels of grouping variables not present in\n        the original training data. If False, raises an error for new levels.\n    newdata2 : pd.DataFrame, optional\n        Additional data that cannot be passed via `newdata`, such as objects\n        used in autocorrelation structures or stanvars.\n    resp : str or list of str, optional\n        Names of response variables to validate. If specified, validation\n        is performed only for the specified responses (relevant for multivariate models).\n    check_response : bool, default=True\n        Whether to check if response variables are present in newdata.\n        Set to False when making predictions where response is not needed.\n    incl_autocor : bool, default=True\n        Whether to include autocorrelation structures originally specified\n        in the model. If True, validates autocorrelation-related variables.\n    group_vars : list of str, optional\n        Names of specific grouping variables to validate. If None (default),\n        validates all grouping variables present in the model.\n    req_vars : list of str, optional\n        Names of specific variables required in newdata. If None (default),\n        all variables from the original training data are required (unless\n        excluded by other parameters).\n    **kwargs\n        Additional arguments passed to brms::validate_newdata()\n\n    Returns\n    -------\n    pd.DataFrame\n        Validated DataFrame based on newdata, potentially with added or\n        modified columns to ensure compatibility with the model.\n\n    Raises\n    ------\n    ValueError\n        If newdata is missing required variables\n    ValueError\n        If factor levels in newdata don't match those in training data\n        (when allow_new_levels=False)\n    ValueError\n        If grouping variables have invalid structure\n\n    See Also\n    --------\n    brms::validate_newdata : R documentation\n        https://paulbuerkner.com/brms/reference/validate_newdata.html\n    posterior_predict() : Uses validate_newdata internally\n    posterior_epred() : Uses validate_newdata internally\n\n    Examples\n    --------\n    Basic validation for prediction data:\n\n    ```python\n    import brmspy\n    import pandas as pd\n\n    # Fit model\n    model = brmspy.fit(\"y ~ x1 + x2\", data=train_data, chains=4)\n\n    # Prepare new data\n    new_data = pd.DataFrame({\n        'x1': [1.0, 2.0, 3.0],\n        'x2': [0.5, 1.0, 1.5]\n    })\n\n    # Validate before prediction\n    validated_data = brmspy.validate_newdata(new_data, model)\n    print(validated_data)\n    ```\n\n    Validate with group-level effects:\n\n    ```python\n    # Model with random effects\n    model = brmspy.fit(\"y ~ x + (1|group)\", data=train_data, chains=4)\n\n    # New data with grouping variable\n    new_data = pd.DataFrame({\n        'x': [1.0, 2.0],\n        'group': ['A', 'B']  # Must match training data groups\n    })\n\n    # Validate - will error if groups A or B weren't in training\n    validated_data = brmspy.validate_newdata(\n        new_data,\n        model,\n        allow_new_levels=False\n    )\n    ```\n\n    Allow new levels for population-level predictions:\n\n    ```python\n    # Allow new group levels (makes population-level predictions only)\n    new_data_with_new_groups = pd.DataFrame({\n        'x': [3.0, 4.0],\n        'group': ['C', 'D']  # New groups not in training\n    })\n\n    validated_data = brmspy.validate_newdata(\n        new_data_with_new_groups,\n        model,\n        allow_new_levels=True\n    )\n    ```\n\n    Skip response variable checking:\n\n    ```python\n    # When making predictions, response not needed\n    new_data = pd.DataFrame({'x1': [1.0, 2.0]})\n\n    validated_data = brmspy.validate_newdata(\n        new_data,\n        model,\n        check_response=False\n    )\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    r_validate_newdata = cast(Callable, ro.r(\"brms::validate_newdata\"))\n    kwargs = kwargs_r(\n        {\n            \"newdata\": newdata,\n            \"object\": object,\n            \"re_formula\": re_formula,\n            \"allow_new_levels\": allow_new_levels,\n            \"newdata2\": newdata2,\n            \"resp\": resp,\n            \"check_response\": check_response,\n            \"incl_autocor\": incl_autocor,\n            \"group_vars\": group_vars,\n            \"req_vars\": req_vars,\n            **kwargs,\n        }\n    )\n    res_r = r_validate_newdata(**kwargs)\n    return cast(pd.DataFrame, r_to_py(res_r))\n</code></pre>"},{"location":"internals/_brms_functions/families/","title":"families","text":"<p>Reference: https://paulbuerkner.com/brms/reference/brmsfamily.html</p>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.FitResult","title":"<code>FitResult = IDResult[IDBrm]</code>  <code>module-attribute</code>","text":""},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families-classes","title":"Classes","text":""},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.IDResult","title":"<code>IDResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T_idata]</code>, <code>RListVectorExtension</code></p> <p>Generic result container with arviz and R objects.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData object</p> <code>r</code> <code>ListVector</code> <p>R object from brms</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass\nclass IDResult(Generic[T_idata], RListVectorExtension):\n    \"\"\"Generic result container with arviz and R objects.\n\n    Attributes\n    ----------\n    idata : arviz.InferenceData\n        arviz InferenceData object\n    r : robjects.ListVector\n        R object from brms\n    \"\"\"\n\n    idata: T_idata\n\n    def __repr__(self) -&gt; str:\n        return repr(self.idata)\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.IDResult-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.IDResult.idata","title":"<code>idata</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.IDResult-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.IDResult.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/brms_results.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return repr(self.idata)\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.IDResult.__init__","title":"<code>__init__(r, idata)</code>","text":""},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.kwargs_r","title":"<code>kwargs_r(kwargs)</code>","text":"<p>Convert Python keyword arguments to R-compatible format.</p> <p>Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict or None</code> <p>Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with same keys but R-compatible values, or empty dict if None</p> Notes <p>This is a thin wrapper around <code>py_to_r()</code> that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import kwargs_r\nimport pandas as pd\nimport numpy as np\n\n# Prepare kwargs for R function\npy_kwargs = {\n    'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n    'prior': {'b': [0, 1]},\n    'chains': 4,\n    'iter': 2000\n}\n\nr_kwargs = kwargs_r(py_kwargs)\n# All values converted to R objects\n# Can now call: r_function(**r_kwargs)\n</code></pre> See Also <p>py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def kwargs_r(kwargs: dict | None) -&gt; dict:\n    \"\"\"\n    Convert Python keyword arguments to R-compatible format.\n\n    Convenience function that applies py_to_r() to all values in a\n    keyword arguments dictionary, preparing them for R function calls.\n\n    Parameters\n    ----------\n    kwargs : dict or None\n        Dictionary of keyword arguments where values may be Python objects\n        (dicts, lists, DataFrames, arrays, etc.)\n\n    Returns\n    -------\n    dict\n        Dictionary with same keys but R-compatible values, or empty dict if None\n\n    Notes\n    -----\n    This is a thin wrapper around `py_to_r()` that operates on dictionaries.\n    It's commonly used to prepare keyword arguments for R function calls via rpy2.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import kwargs_r\n    import pandas as pd\n    import numpy as np\n\n    # Prepare kwargs for R function\n    py_kwargs = {\n        'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n        'prior': {'b': [0, 1]},\n        'chains': 4,\n        'iter': 2000\n    }\n\n    r_kwargs = kwargs_r(py_kwargs)\n    # All values converted to R objects\n    # Can now call: r_function(**r_kwargs)\n    ```\n\n    See Also\n    --------\n    py_to_r : Underlying conversion function for individual values\n    brmspy.brms.fit : Uses this to prepare user kwargs for R\n    \"\"\"\n    if kwargs is None:\n        return {}\n    return {k: py_to_r(v) for k, v in kwargs.items()}\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.brmsfamily","title":"<code>brmsfamily(family, link=None, link_sigma='log', link_shape='log', link_nu='logm1', link_phi='log', link_kappa='log', link_beta='log', link_zi='logit', link_hu='logit', link_zoi='logit', link_coi='logit', link_disc='log', link_bs='log', link_ndt='log', link_bias='logit', link_xi='log1p', link_alpha='identity', link_quantile='logit', threshold='flexible', refcat=None, **kwargs)</code>","text":"<p>Family objects provide a convenient way to specify the details of the models used by many model fitting functions. The family functions presented here are for use with brms only and will not work with other model fitting functions such as glm or glmer. However, the standard family functions as described in family will work with brms.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <p>A character string naming the distribution family of the response variable to be used in the model. Currently, the following families are supported: gaussian, student, binomial, bernoulli, beta-binomial, poisson, negbinomial, geometric, Gamma, skew_normal, lognormal, shifted_lognormal, exgaussian, wiener, inverse.gaussian, exponential, weibull, frechet, Beta, dirichlet, von_mises, asym_laplace, gen_extreme_value, categorical, multinomial, cumulative, cratio, sratio, acat, hurdle_poisson, hurdle_negbinomial, hurdle_gamma, hurdle_lognormal, hurdle_cumulative, zero_inflated_binomial, zero_inflated_beta_binomial, zero_inflated_beta, zero_inflated_negbinomial, zero_inflated_poisson, and zero_one_inflated_beta.</p> required <code>link</code> <code>str | None</code> <p>A specification for the model link function. This can be a name/expression or character string. See the 'Details' section for more information on link functions supported by each family.</p> <code>None</code> <code>link_sigma</code> <code>str</code> <p>Link of auxiliary parameter sigma if being predicted.</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link of auxiliary parameter shape if being predicted.</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link of auxiliary parameter nu if being predicted.</p> <code>'logm1'</code> <code>link_phi</code> <code>str</code> <p>Link of auxiliary parameter phi if being predicted.</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link of auxiliary parameter kappa if being predicted.</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link of auxiliary parameter beta if being predicted.</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link of auxiliary parameter zi if being predicted.</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link of auxiliary parameter hu if being predicted.</p> <code>'logit'</code> <code>link_zoi</code> <code>str</code> <p>Link of auxiliary parameter zoi if being predicted.</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link of auxiliary parameter coi if being predicted.</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link of auxiliary parameter disc if being predicted.</p> <code>'log'</code> <code>link_bs</code> <code>str</code> <p>Link of auxiliary parameter bs if being predicted.</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link of auxiliary parameter ndt if being predicted.</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link of auxiliary parameter bias if being predicted.</p> <code>'logit'</code> <code>link_xi</code> <code>str</code> <p>Link of auxiliary parameter xi if being predicted.</p> <code>'log1p'</code> <code>link_alpha</code> <code>str</code> <p>Link of auxiliary parameter alpha if being predicted.</p> <code>'identity'</code> <code>link_quantile</code> <code>str</code> <p>Link of auxiliary parameter quantile if being predicted.</p> <code>'logit'</code> <code>threshold</code> <code>str</code> <p>A character string indicating the type of thresholds (i.e. intercepts) used in an ordinal model. \"flexible\" provides the standard unstructured thresholds, \"equidistant\" restricts the distance between consecutive thresholds to the same value, and \"sum_to_zero\" ensures the thresholds sum to zero.</p> <code>'flexible'</code> <code>refcat</code> <code>str | None</code> <p>Optional name of the reference response category used in categorical, multinomial, dirichlet and logistic_normal models. If NULL (the default), the first category is used as the reference. If NA, all categories will be predicted, which requires strong priors or carefully specified predictor terms in order to lead to an identified model.</p> <code>None</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def brmsfamily(\n    family,\n    link: str | None = None,\n    link_sigma: str = \"log\",\n    link_shape: str = \"log\",\n    link_nu: str = \"logm1\",\n    link_phi: str = \"log\",\n    link_kappa: str = \"log\",\n    link_beta: str = \"log\",\n    link_zi: str = \"logit\",\n    link_hu: str = \"logit\",\n    link_zoi: str = \"logit\",\n    link_coi: str = \"logit\",\n    link_disc: str = \"log\",\n    link_bs: str = \"log\",\n    link_ndt: str = \"log\",\n    link_bias: str = \"logit\",\n    link_xi: str = \"log1p\",\n    link_alpha: str = \"identity\",\n    link_quantile: str = \"logit\",\n    threshold: str = \"flexible\",\n    refcat: str | None = None,\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"\n    Family objects provide a convenient way to specify the details of the models used by many model fitting functions. The family functions presented here are for use with brms only and will **not** work with other model fitting functions such as glm or glmer. However, the standard family functions as described in family will work with brms.\n\n    Parameters\n    ----------\n    family\n        A character string naming the distribution family of the response variable to be used in the model. Currently, the following families are supported: gaussian, student, binomial, bernoulli, beta-binomial, poisson, negbinomial, geometric, Gamma, skew_normal, lognormal, shifted_lognormal, exgaussian, wiener, inverse.gaussian, exponential, weibull, frechet, Beta, dirichlet, von_mises, asym_laplace, gen_extreme_value, categorical, multinomial, cumulative, cratio, sratio, acat, hurdle_poisson, hurdle_negbinomial, hurdle_gamma, hurdle_lognormal, hurdle_cumulative, zero_inflated_binomial, zero_inflated_beta_binomial, zero_inflated_beta, zero_inflated_negbinomial, zero_inflated_poisson, and zero_one_inflated_beta.\n    link\n        A specification for the model link function. This can be a name/expression or character string. See the 'Details' section for more information on link functions supported by each family.\n    link_sigma\n        Link of auxiliary parameter sigma if being predicted.\n    link_shape\n        Link of auxiliary parameter shape if being predicted.\n    link_nu\n        Link of auxiliary parameter nu if being predicted.\n    link_phi\n        Link of auxiliary parameter phi if being predicted.\n    link_kappa\n        Link of auxiliary parameter kappa if being predicted.\n    link_beta\n        Link of auxiliary parameter beta if being predicted.\n    link_zi\n        Link of auxiliary parameter zi if being predicted.\n    link_hu\n        Link of auxiliary parameter hu if being predicted.\n    link_zoi\n        Link of auxiliary parameter zoi if being predicted.\n    link_coi\n        Link of auxiliary parameter coi if being predicted.\n    link_disc\n        Link of auxiliary parameter disc if being predicted.\n    link_bs\n        Link of auxiliary parameter bs if being predicted.\n    link_ndt\n        Link of auxiliary parameter ndt if being predicted.\n    link_bias\n        Link of auxiliary parameter bias if being predicted.\n    link_xi\n        Link of auxiliary parameter xi if being predicted.\n    link_alpha\n        Link of auxiliary parameter alpha if being predicted.\n    link_quantile\n        Link of auxiliary parameter quantile if being predicted.\n    threshold\n        A character string indicating the type of thresholds (i.e. intercepts) used in an ordinal model. \"flexible\" provides the standard unstructured thresholds, \"equidistant\" restricts the distance between consecutive thresholds to the same value, and \"sum_to_zero\" ensures the thresholds sum to zero.\n    refcat\n        Optional name of the reference response category used in categorical, multinomial, dirichlet and logistic_normal models. If NULL (the default), the first category is used as the reference. If NA, all categories will be predicted, which requires strong priors or carefully specified predictor terms in order to lead to an identified model.\n\n    \"\"\"\n    import rpy2.robjects as ro\n\n    r_brmsfamily = cast(Callable, ro.r(\"brms::brmsfamily\"))\n\n    collected_args = {\n        \"family\": family,\n        \"link\": link,\n        \"link_sigma\": link_sigma,\n        \"link_shape\": link_shape,\n        \"link_nu\": link_nu,\n        \"link_phi\": link_phi,\n        \"link_kappa\": link_kappa,\n        \"link_beta\": link_beta,\n        \"link_zi\": link_zi,\n        \"link_hu\": link_hu,\n        \"link_zoi\": link_zoi,\n        \"link_coi\": link_coi,\n        \"link_disc\": link_disc,\n        \"link_bs\": link_bs,\n        \"link_ndt\": link_ndt,\n        \"link_bias\": link_bias,\n        \"link_xi\": link_xi,\n        \"link_alpha\": link_alpha,\n        \"link_quantile\": link_quantile,\n        \"threshold\": threshold,\n        \"refcat\": refcat,\n        **kwargs,\n    }\n    collected_args = kwargs_r(collected_args)\n\n    return r_brmsfamily(**collected_args)\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.family","title":"<code>family(fit, **kwargs)</code>","text":"<p>Extract family object from a fitted model.</p> <p>Parameters:</p> Name Type Description Default <code>fit</code> <code>FitResult or ListSexpVector</code> <p>Fitted brms model</p> required Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def family(fit: FitResult | ListSexpVector, **kwargs) -&gt; ListSexpVector:\n    \"\"\"Extract family object from a fitted model.\n\n    Parameters\n    ----------\n    fit : FitResult or ListSexpVector\n        Fitted brms model\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if isinstance(fit, IDResult):\n        r_fit = fit.r\n    else:\n        r_fit = fit\n\n    r_family = cast(Callable, ro.r(\"family\"))\n    kwargs = kwargs_r(kwargs)\n\n    return r_family(r_fit, **kwargs)\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.student","title":"<code>student(link='identity', link_sigma='log', link_nu='logm1', **kwargs)</code>","text":"<p>Student's t distribution for robust regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for degrees of freedom parameter</p> <code>'logm1'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def student(\n    link: str = \"identity\", link_sigma: str = \"log\", link_nu: str = \"logm1\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Student's t distribution for robust regression.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for sigma parameter\n    link_nu : str\n        Link function for degrees of freedom parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"student\",\n        link=link,\n        link_sigma=link_sigma,\n        link_nu=link_nu,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.bernoulli","title":"<code>bernoulli(link='logit', **kwargs)</code>","text":"<p>Bernoulli distribution for binary 0/1 outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def bernoulli(link: str = \"logit\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Bernoulli distribution for binary 0/1 outcomes.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the probability parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"bernoulli\",\n        link=link,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.beta_binomial","title":"<code>beta_binomial(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta-binomial distribution for overdispersed binomial data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def beta_binomial(\n    link: str = \"logit\", link_phi: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Beta-binomial distribution for overdispersed binomial data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the probability parameter\n    link_phi : str\n        Link function for the precision parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"beta_binomial\",\n        link=link,\n        link_phi=link_phi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.negbinomial","title":"<code>negbinomial(link='log', link_shape='log', **kwargs)</code>","text":"<p>Negative binomial distribution for overdispersed count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def negbinomial(link: str = \"log\", link_shape: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Negative binomial distribution for overdispersed count data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_shape : str\n        Link function for the shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"negbinomial\",\n        link=link,\n        link_shape=link_shape,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.negbinomial2","title":"<code>negbinomial2(link='log', link_sigma='log', **kwargs)</code>","text":"Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def negbinomial2(\n    link: str = \"log\", link_sigma: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    return brmsfamily(\n        family=\"negbinomial2\",\n        link=link,\n        link_sigma=link_sigma,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.geometric","title":"<code>geometric(link='log', **kwargs)</code>","text":"<p>Geometric distribution for count data (negative binomial with shape=1).</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def geometric(link: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Geometric distribution for count data (negative binomial with shape=1).\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    \"\"\"\n    return brmsfamily(\n        family=\"geometric\",\n        link=link,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.discrete_weibull","title":"<code>discrete_weibull(link='logit', link_shape='log', **kwargs)</code>","text":"Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def discrete_weibull(\n    link: str = \"logit\", link_shape: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    return brmsfamily(\n        family=\"discrete_weibull\",\n        link=link,\n        link_shape=link_shape,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.com_poisson","title":"<code>com_poisson(link='log', link_shape='log', **kwargs)</code>","text":"Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def com_poisson(link: str = \"log\", link_shape: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    return brmsfamily(\n        family=\"com_poisson\",\n        link=link,\n        link_shape=link_shape,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.lognormal","title":"<code>lognormal(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Lognormal distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean on log scale</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def lognormal(\n    link: str = \"identity\", link_sigma: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Lognormal distribution for positive continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean on log scale\n    link_sigma : str\n        Link function for sigma parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"lognormal\",\n        link=link,\n        link_sigma=link_sigma,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.shifted_lognormal","title":"<code>shifted_lognormal(link='identity', link_sigma='log', link_ndt='log', **kwargs)</code>","text":"<p>Shifted lognormal distribution with non-decision time parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def shifted_lognormal(\n    link: str = \"identity\", link_sigma: str = \"log\", link_ndt: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Shifted lognormal distribution with non-decision time parameter.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for sigma parameter\n    link_ndt : str\n        Link function for non-decision time parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"shifted_lognormal\",\n        link=link,\n        link_sigma=link_sigma,\n        link_ndt=link_ndt,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.skew_normal","title":"<code>skew_normal(link='identity', link_sigma='log', link_alpha='identity', **kwargs)</code>","text":"<p>Skew normal distribution for asymmetric continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_alpha</code> <code>str</code> <p>Link function for skewness parameter</p> <code>'identity'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def skew_normal(\n    link: str = \"identity\",\n    link_sigma: str = \"log\",\n    link_alpha: str = \"identity\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Skew normal distribution for asymmetric continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for sigma parameter\n    link_alpha : str\n        Link function for skewness parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"skew_normal\",\n        link=link,\n        link_sigma=link_sigma,\n        link_alpha=link_alpha,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.exponential","title":"<code>exponential(link='log', **kwargs)</code>","text":"<p>Exponential distribution for time-to-event data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def exponential(link: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Exponential distribution for time-to-event data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the rate parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"exponential\",\n        link=link,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.weibull","title":"<code>weibull(link='log', link_shape='log', **kwargs)</code>","text":"<p>Weibull distribution for survival and reliability analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def weibull(link: str = \"log\", link_shape: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Weibull distribution for survival and reliability analysis.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the scale parameter\n    link_shape : str\n        Link function for the shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"weibull\",\n        link=link,\n        link_shape=link_shape,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.frechet","title":"<code>frechet(link='log', link_nu='logm1', **kwargs)</code>","text":"<p>Frechet distribution for extreme value analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'logm1'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def frechet(link: str = \"log\", link_nu: str = \"logm1\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Frechet distribution for extreme value analysis.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the scale parameter\n    link_nu : str\n        Link function for the shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"frechet\",\n        link=link,\n        link_nu=link_nu,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.gen_extreme_value","title":"<code>gen_extreme_value(link='identity', link_sigma='log', link_xi='log1p', **kwargs)</code>","text":"<p>Generalized extreme value distribution for extreme events.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location parameter</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_xi</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log1p'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def gen_extreme_value(\n    link: str = \"identity\", link_sigma: str = \"log\", link_xi: str = \"log1p\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Generalized extreme value distribution for extreme events.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the location parameter\n    link_sigma : str\n        Link function for the scale parameter\n    link_xi : str\n        Link function for the shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"gen_extreme_value\",\n        link=link,\n        link_sigma=link_sigma,\n        link_xi=link_xi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.exgaussian","title":"<code>exgaussian(link='identity', link_sigma='log', link_beta='log', **kwargs)</code>","text":"<p>Ex-Gaussian distribution for reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for Gaussian SD parameter</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link function for exponential rate parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def exgaussian(\n    link: str = \"identity\", link_sigma: str = \"log\", link_beta: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Ex-Gaussian distribution for reaction time data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for Gaussian SD parameter\n    link_beta : str\n        Link function for exponential rate parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"exgaussian\",\n        link=link,\n        link_sigma=link_sigma,\n        link_beta=link_beta,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.wiener","title":"<code>wiener(link='identity', link_bs='log', link_ndt='log', link_bias='logit', **kwargs)</code>","text":"<p>Wiener diffusion model for two-choice reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for drift rate</p> <code>'identity'</code> <code>link_bs</code> <code>str</code> <p>Link function for boundary separation</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link function for initial bias</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def wiener(\n    link: str = \"identity\",\n    link_bs: str = \"log\",\n    link_ndt: str = \"log\",\n    link_bias: str = \"logit\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Wiener diffusion model for two-choice reaction time data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for drift rate\n    link_bs : str\n        Link function for boundary separation\n    link_ndt : str\n        Link function for non-decision time\n    link_bias : str\n        Link function for initial bias\n    \"\"\"\n    return brmsfamily(\n        family=\"wiener\",\n        link=link,\n        link_bs=link_bs,\n        link_ndt=link_ndt,\n        link_bias=link_bias,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.Beta","title":"<code>Beta(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta distribution for data between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def Beta(link: str = \"logit\", link_phi: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Beta distribution for data between 0 and 1.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_phi : str\n        Link function for the precision parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"beta\",\n        link=link,\n        link_phi=link_phi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.xbeta","title":"<code>xbeta(link='logit', link_phi='log', link_kappa='log', **kwargs)</code>","text":"<p>Extended beta distribution with additional shape parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link function for kappa shape parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def xbeta(\n    link: str = \"logit\", link_phi: str = \"log\", link_kappa: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Extended beta distribution with additional shape parameter.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_phi : str\n        Link function for precision parameter\n    link_kappa : str\n        Link function for kappa shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"xbeta\",\n        link=link,\n        link_phi=link_phi,\n        link_kappa=link_kappa,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.dirichlet","title":"<code>dirichlet(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def dirichlet(\n    link: str = \"logit\", link_phi: str = \"log\", refcat: str | None = None, **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Dirichlet distribution for compositional data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_phi : str\n        Link function for the precision parameter\n    refcat : str, optional\n        Reference category\n    \"\"\"\n    return brmsfamily(\n        family=\"dirichlet\",\n        link=link,\n        link_phi=link_phi,\n        refcat=refcat,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.dirichlet2","title":"<code>dirichlet2(link='log', refcat=None, **kwargs)</code>","text":"Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def dirichlet2(\n    link: str = \"log\",\n    # NOTE: R version uses refcat = NA; here default None\n    refcat: str | None = None,\n    **kwargs,\n) -&gt; ListSexpVector:\n    return brmsfamily(\n        family=\"dirichlet2\",\n        link=link,\n        refcat=refcat,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.logistic_normal","title":"<code>logistic_normal(link='identity', link_sigma='log', refcat=None, **kwargs)</code>","text":"<p>Logistic-normal distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def logistic_normal(\n    link: str = \"identity\",\n    link_sigma: str = \"log\",\n    refcat: str | None = None,\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Logistic-normal distribution for compositional data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for sigma parameter\n    refcat : str, optional\n        Reference category\n    \"\"\"\n    return brmsfamily(\n        family=\"logistic_normal\",\n        link=link,\n        link_sigma=link_sigma,\n        refcat=refcat,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.von_mises","title":"<code>von_mises(link='tan_half', link_kappa='log', **kwargs)</code>","text":"<p>Von Mises distribution for circular/directional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean direction</p> <code>'tan_half'</code> <code>link_kappa</code> <code>str</code> <p>Link function for concentration parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def von_mises(\n    link: str = \"tan_half\", link_kappa: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Von Mises distribution for circular/directional data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean direction\n    link_kappa : str\n        Link function for concentration parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"von_mises\",\n        link=link,\n        link_kappa=link_kappa,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.asym_laplace","title":"<code>asym_laplace(link='identity', link_sigma='log', link_quantile='logit', **kwargs)</code>","text":"<p>Asymmetric Laplace distribution for quantile regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_quantile</code> <code>str</code> <p>Link function for the quantile parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def asym_laplace(\n    link: str = \"identity\",\n    link_sigma: str = \"log\",\n    link_quantile: str = \"logit\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Asymmetric Laplace distribution for quantile regression.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the location\n    link_sigma : str\n        Link function for sigma parameter\n    link_quantile : str\n        Link function for the quantile parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"asym_laplace\",\n        link=link,\n        link_sigma=link_sigma,\n        link_quantile=link_quantile,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.zero_inflated_asym_laplace","title":"<code>zero_inflated_asym_laplace(link='identity', link_sigma='log', link_quantile='logit', link_zi='logit', **kwargs)</code>","text":"Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_inflated_asym_laplace(\n    link: str = \"identity\",\n    link_sigma: str = \"log\",\n    link_quantile: str = \"logit\",\n    link_zi: str = \"logit\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    return brmsfamily(\n        family=\"zero_inflated_asym_laplace\",\n        link=link,\n        link_sigma=link_sigma,\n        link_quantile=link_quantile,\n        link_zi=link_zi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.cox","title":"<code>cox(link='log', **kwargs)</code>","text":"<p>Cox proportional hazards model for survival data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the hazard rate</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def cox(link: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Cox proportional hazards model for survival data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the hazard rate\n    \"\"\"\n    # original R wrapper doesn't pass slink; brmsfamily doesn't need it\n    return brmsfamily(\n        family=\"cox\",\n        link=link,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.hurdle_poisson","title":"<code>hurdle_poisson(link='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Poisson distribution for zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def hurdle_poisson(\n    link: str = \"log\", link_hu: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Hurdle Poisson distribution for zero-inflated count data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_hu : str\n        Link function for hurdle parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"hurdle_poisson\",\n        link=link,\n        link_hu=link_hu,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.hurdle_negbinomial","title":"<code>hurdle_negbinomial(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle negative binomial for overdispersed zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def hurdle_negbinomial(\n    link: str = \"log\", link_shape: str = \"log\", link_hu: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Hurdle negative binomial for overdispersed zero-inflated count data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_shape : str\n        Link function for shape parameter\n    link_hu : str\n        Link function for hurdle parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"hurdle_negbinomial\",\n        link=link,\n        link_shape=link_shape,\n        link_hu=link_hu,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.hurdle_gamma","title":"<code>hurdle_gamma(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Gamma distribution for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def hurdle_gamma(\n    link: str = \"log\", link_shape: str = \"log\", link_hu: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Hurdle Gamma distribution for zero-inflated positive continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_shape : str\n        Link function for shape parameter\n    link_hu : str\n        Link function for hurdle parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"hurdle_gamma\",\n        link=link,\n        link_shape=link_shape,\n        link_hu=link_hu,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.hurdle_lognormal","title":"<code>hurdle_lognormal(link='identity', link_sigma='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle lognormal for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def hurdle_lognormal(\n    link: str = \"identity\", link_sigma: str = \"log\", link_hu: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Hurdle lognormal for zero-inflated positive continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for sigma parameter\n    link_hu : str\n        Link function for hurdle parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"hurdle_lognormal\",\n        link=link,\n        link_sigma=link_sigma,\n        link_hu=link_hu,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.hurdle_cumulative","title":"<code>hurdle_cumulative(link='logit', link_hu='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Hurdle cumulative for zero-inflated ordinal data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the ordinal response</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def hurdle_cumulative(\n    link: str = \"logit\",\n    link_hu: str = \"logit\",\n    link_disc: str = \"log\",\n    threshold: str = \"flexible\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Hurdle cumulative for zero-inflated ordinal data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the ordinal response\n    link_hu : str\n        Link function for hurdle parameter\n    link_disc : str\n        Link function for discrimination parameter\n    threshold : str\n        Type of threshold structure\n    \"\"\"\n    return brmsfamily(\n        family=\"hurdle_cumulative\",\n        link=link,\n        link_hu=link_hu,\n        link_disc=link_disc,\n        threshold=threshold,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.zero_inflated_beta","title":"<code>zero_inflated_beta(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta for data between 0 and 1 with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_inflated_beta(\n    link: str = \"logit\", link_phi: str = \"log\", link_zi: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Zero-inflated beta for data between 0 and 1 with excess zeros.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_phi : str\n        Link function for precision parameter\n    link_zi : str\n        Link function for zero-inflation parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"zero_inflated_beta\",\n        link=link,\n        link_phi=link_phi,\n        link_zi=link_zi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.zero_one_inflated_beta","title":"<code>zero_one_inflated_beta(link='logit', link_phi='log', link_zoi='logit', link_coi='logit', **kwargs)</code>","text":"<p>Zero-one-inflated beta for data between 0 and 1 with excess zeros and ones.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zoi</code> <code>str</code> <p>Link function for zero-or-one inflation parameter</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link function for conditional one inflation parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_one_inflated_beta(\n    link: str = \"logit\",\n    link_phi: str = \"log\",\n    link_zoi: str = \"logit\",\n    link_coi: str = \"logit\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Zero-one-inflated beta for data between 0 and 1 with excess zeros and ones.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_phi : str\n        Link function for precision parameter\n    link_zoi : str\n        Link function for zero-or-one inflation parameter\n    link_coi : str\n        Link function for conditional one inflation parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"zero_one_inflated_beta\",\n        link=link,\n        link_phi=link_phi,\n        link_zoi=link_zoi,\n        link_coi=link_coi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.zero_inflated_poisson","title":"<code>zero_inflated_poisson(link='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated Poisson for count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_inflated_poisson(\n    link: str = \"log\", link_zi: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Zero-inflated Poisson for count data with excess zeros.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_zi : str\n        Link function for zero-inflation parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"zero_inflated_poisson\",\n        link=link,\n        link_zi=link_zi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.zero_inflated_negbinomial","title":"<code>zero_inflated_negbinomial(link='log', link_shape='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated negative binomial for overdispersed count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_inflated_negbinomial(\n    link: str = \"log\", link_shape: str = \"log\", link_zi: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Zero-inflated negative binomial for overdispersed count data with excess zeros.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_shape : str\n        Link function for shape parameter\n    link_zi : str\n        Link function for zero-inflation parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"zero_inflated_negbinomial\",\n        link=link,\n        link_shape=link_shape,\n        link_zi=link_zi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.zero_inflated_binomial","title":"<code>zero_inflated_binomial(link='logit', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated binomial for binary count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_inflated_binomial(\n    link: str = \"logit\", link_zi: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Zero-inflated binomial for binary count data with excess zeros.\n\n    Parameters\n    ----------\n    link : str\n        Link function for probability parameter\n    link_zi : str\n        Link function for zero-inflation parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"zero_inflated_binomial\",\n        link=link,\n        link_zi=link_zi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.zero_inflated_beta_binomial","title":"<code>zero_inflated_beta_binomial(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta-binomial for overdispersed binomial data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_inflated_beta_binomial(\n    link: str = \"logit\", link_phi: str = \"log\", link_zi: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Zero-inflated beta-binomial for overdispersed binomial data with excess zeros.\n\n    Parameters\n    ----------\n    link : str\n        Link function for probability parameter\n    link_phi : str\n        Link function for precision parameter\n    link_zi : str\n        Link function for zero-inflation parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"zero_inflated_beta_binomial\",\n        link=link,\n        link_phi=link_phi,\n        link_zi=link_zi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.categorical","title":"<code>categorical(link='logit', refcat=None, **kwargs)</code>","text":"<p>Categorical distribution for unordered multi-category outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def categorical(\n    link: str = \"logit\", refcat: str | None = None, **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Categorical distribution for unordered multi-category outcomes.\n\n    Parameters\n    ----------\n    link : str\n        Link function for category probabilities\n    refcat : str, optional\n        Reference category\n    \"\"\"\n    return brmsfamily(\n        family=\"categorical\",\n        link=link,\n        refcat=refcat,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.multinomial","title":"<code>multinomial(link='logit', refcat=None, **kwargs)</code>","text":"<p>Multinomial distribution for count data across multiple categories.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def multinomial(\n    link: str = \"logit\", refcat: str | None = None, **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Multinomial distribution for count data across multiple categories.\n\n    Parameters\n    ----------\n    link : str\n        Link function for category probabilities\n    refcat : str, optional\n        Reference category\n    \"\"\"\n    return brmsfamily(\n        family=\"multinomial\",\n        link=link,\n        refcat=refcat,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.dirichlet_multinomial","title":"<code>dirichlet_multinomial(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet-multinomial for overdispersed categorical count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def dirichlet_multinomial(\n    link: str = \"logit\", link_phi: str = \"log\", refcat: str | None = None, **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Dirichlet-multinomial for overdispersed categorical count data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for category probabilities\n    link_phi : str\n        Link function for precision parameter\n    refcat : str, optional\n        Reference category\n    \"\"\"\n    return brmsfamily(\n        family=\"dirichlet_multinomial\",\n        link=link,\n        link_phi=link_phi,\n        refcat=refcat,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.cumulative","title":"<code>cumulative(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Cumulative (proportional odds) model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for cumulative probabilities</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def cumulative(\n    link: str = \"logit\", link_disc: str = \"log\", threshold: str = \"flexible\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Cumulative (proportional odds) model for ordinal outcomes.\n\n    Parameters\n    ----------\n    link : str\n        Link function for cumulative probabilities\n    link_disc : str\n        Link function for discrimination parameter\n    threshold : str\n        Type of threshold structure\n    \"\"\"\n    return brmsfamily(\n        family=\"cumulative\",\n        link=link,\n        link_disc=link_disc,\n        threshold=threshold,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.sratio","title":"<code>sratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Sequential (stopping) ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for sequential ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def sratio(\n    link: str = \"logit\", link_disc: str = \"log\", threshold: str = \"flexible\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Sequential (stopping) ratio model for ordinal outcomes.\n\n    Parameters\n    ----------\n    link : str\n        Link function for sequential ratios\n    link_disc : str\n        Link function for discrimination parameter\n    threshold : str\n        Type of threshold structure\n    \"\"\"\n    return brmsfamily(\n        family=\"sratio\",\n        link=link,\n        link_disc=link_disc,\n        threshold=threshold,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.cratio","title":"<code>cratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Continuation ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for continuation ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def cratio(\n    link: str = \"logit\", link_disc: str = \"log\", threshold: str = \"flexible\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Continuation ratio model for ordinal outcomes.\n\n    Parameters\n    ----------\n    link : str\n        Link function for continuation ratios\n    link_disc : str\n        Link function for discrimination parameter\n    threshold : str\n        Type of threshold structure\n    \"\"\"\n    return brmsfamily(\n        family=\"cratio\",\n        link=link,\n        link_disc=link_disc,\n        threshold=threshold,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.acat","title":"<code>acat(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Adjacent category model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for adjacent category ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def acat(\n    link: str = \"logit\", link_disc: str = \"log\", threshold: str = \"flexible\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Adjacent category model for ordinal outcomes.\n\n    Parameters\n    ----------\n    link : str\n        Link function for adjacent category ratios\n    link_disc : str\n        Link function for discrimination parameter\n    threshold : str\n        Type of threshold structure\n    \"\"\"\n    return brmsfamily(\n        family=\"acat\",\n        link=link,\n        link_disc=link_disc,\n        threshold=threshold,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.gaussian","title":"<code>gaussian(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Gaussian (normal) distribution for continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the standard deviation</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def gaussian(\n    link: str = \"identity\",\n    link_sigma: str = \"log\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Gaussian (normal) distribution for continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for the standard deviation\n    \"\"\"\n    return brmsfamily(\n        family=\"gaussian\",\n        link=link,\n        link_sigma=link_sigma,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.poisson","title":"<code>poisson(link='log', **kwargs)</code>","text":"<p>Poisson distribution for count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def poisson(\n    link: str = \"log\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Poisson distribution for count data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the rate parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"poisson\",\n        link=link,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.binomial","title":"<code>binomial(link='logit', **kwargs)</code>","text":"<p>Binomial distribution for binary count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def binomial(\n    link: str = \"logit\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Binomial distribution for binary count data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the probability parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"binomial\",\n        link=link,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.Gamma","title":"<code>Gamma(link='log', link_shape='log', **kwargs)</code>","text":"<p>Gamma distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def Gamma(\n    link: str = \"log\",\n    link_shape: str = \"log\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Gamma distribution for positive continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_shape : str\n        Link function for the shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"Gamma\",\n        link=link,\n        link_shape=link_shape,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/families/#brmspy._brms_functions.families.inverse_gaussian","title":"<code>inverse_gaussian(link='1/mu^2', link_shape='log', **kwargs)</code>","text":"<p>Inverse Gaussian distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'1/mu^2'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def inverse_gaussian(\n    link: str = \"1/mu^2\",\n    link_shape: str = \"log\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Inverse Gaussian distribution for positive continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_shape : str\n        Link function for the shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"inverse.gaussian\",\n        link=link,\n        link_shape=link_shape,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/formula/","title":"formula","text":"<p>Formula helpers and DSL.</p> <p>This module provides a small Pythonic DSL for composing brms formulas. The public functions (<code>bf</code>, <code>lf</code>, <code>nlf</code>, <code>acformula</code>, <code>set_rescor</code>, <code>set_mecor</code>, <code>set_nl</code>) build a <code>FormulaConstruct</code> that can be passed to <code>brmspy.brms.brm()</code> or combined using the <code>+</code> operator.</p> Notes <ul> <li>The returned objects are lightweight formula specifications; the actual R brms   formula object is built in the worker when fitting / generating Stan code.</li> <li>This module is part of the public API documented under docs/api/brms_functions/formula.md.</li> </ul>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula._FORMULA_FUNCTION_WHITELIST","title":"<code>_FORMULA_FUNCTION_WHITELIST = Literal['bf', 'lf', 'nlf', 'acformula', 'set_rescor', 'set_mecor', 'set_nl']</code>  <code>module-attribute</code>","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.ProxyListSexpVector","title":"<code>ProxyListSexpVector = Union[SexpWrapper, ListSexpVector, None]</code>  <code>module-attribute</code>","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula-classes","title":"Classes","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.SexpWrapper","title":"<code>SexpWrapper</code>  <code>dataclass</code>","text":"<p>Lightweight handle for an R object stored in the worker.</p> <p>The worker keeps the real rpy2 <code>Sexp</code> in an internal cache and replaces it in results with this wrapper. When passed back to the worker, the wrapper is resolved to the original <code>Sexp</code> again.</p> Notes <ul> <li><code>SexpWrapper</code> instances are only meaningful within the lifetime of the   worker process that produced them. After a worker restart, previously   returned wrappers can no longer be reattached.</li> <li>This type exists to keep the main process free of rpy2 / embedded-R state.</li> </ul> Source code in <code>brmspy/types/session.py</code> <pre><code>@dataclass\nclass SexpWrapper:\n    \"\"\"\n    Lightweight handle for an R object stored in the worker.\n\n    The worker keeps the real rpy2 `Sexp` in an internal cache and replaces it in\n    results with this wrapper. When passed back to the worker, the wrapper is\n    resolved to the original `Sexp` again.\n\n    Notes\n    -----\n    - `SexpWrapper` instances are only meaningful within the lifetime of the\n      worker process that produced them. After a worker restart, previously\n      returned wrappers can no longer be reattached.\n    - This type exists to keep the main process free of rpy2 / embedded-R state.\n    \"\"\"\n\n    _rid: int\n    _repr: str\n\n    def __str__(self) -&gt; str:\n        return self._repr\n\n    def __repr__(self) -&gt; str:\n        return self._repr\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.SexpWrapper-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.SexpWrapper._rid","title":"<code>_rid</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.SexpWrapper._repr","title":"<code>_repr</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.SexpWrapper-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.SexpWrapper.__str__","title":"<code>__str__()</code>","text":"Source code in <code>brmspy/types/session.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self._repr\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.SexpWrapper.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/session.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self._repr\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.SexpWrapper.__init__","title":"<code>__init__(_rid, _repr)</code>","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct","title":"<code>FormulaConstruct</code>  <code>dataclass</code>","text":"<p>A composite formula expression built from parts.</p> <p><code>FormulaConstruct</code> stores a tree of nodes (<code>FormulaPart</code> and/or R objects) representing expressions combined with <code>+</code>. It is primarily created by calling the public formula helpers exposed by <code>brmspy.brms</code>.</p> Notes <p>The <code>+</code> operator supports grouping:</p> <ul> <li><code>a + b + c</code> becomes a single summand (one \u201cgroup\u201d)</li> <li><code>(a + b) + (a + b)</code> becomes two summands (two \u201cgroups\u201d)</li> </ul> <p>Use <code>iter_summands()</code> to iterate over these groups in a deterministic way.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@dataclass\nclass FormulaConstruct:\n    \"\"\"\n    A composite formula expression built from parts.\n\n    `FormulaConstruct` stores a tree of nodes (`FormulaPart` and/or R objects)\n    representing expressions combined with `+`. It is primarily created by\n    calling the public formula helpers exposed by [`brmspy.brms`][brmspy.brms].\n\n    Notes\n    -----\n    The `+` operator supports grouping:\n\n    - `a + b + c` becomes a single summand (one \u201cgroup\u201d)\n    - `(a + b) + (a + b)` becomes two summands (two \u201cgroups\u201d)\n\n    Use [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands]\n    to iterate over these groups in a deterministic way.\n    \"\"\"\n\n    _parts: list[Node]\n\n    @classmethod\n    def _formula_parse(cls, obj: Other) -&gt; \"FormulaConstruct\":\n        \"\"\"\n        Convert a supported value into a `FormulaConstruct`.\n\n        Parameters\n        ----------\n        obj\n            One of: `FormulaConstruct`, `FormulaPart`, string (interpreted as `bf(&lt;string&gt;)`),\n            or `ProxyListSexpVector`.\n\n        Returns\n        -------\n        FormulaConstruct\n        \"\"\"\n        if isinstance(obj, FormulaConstruct):\n            return obj\n        if isinstance(obj, ProxyListSexpVector):\n            return FormulaConstruct(_parts=[obj])\n        if isinstance(obj, FormulaPart):\n            return FormulaConstruct(_parts=[obj])\n        if isinstance(obj, str):\n            part = FormulaPart(_fun=\"bf\", _args=[obj], _kwargs={})\n            return FormulaConstruct(_parts=[part])\n        raise TypeError(\n            f\"Cannot parse object of type {type(obj)!r} into FormulaConstruct\"\n        )\n\n    def __add__(self, other: Other):\n        \"\"\"\n        Combine two formula expressions with `+`.\n\n        Parameters\n        ----------\n        other\n            Value to add. Strings are treated as `bf(&lt;string&gt;)`.\n\n        Returns\n        -------\n        FormulaConstruct\n            New combined expression.\n        \"\"\"\n        if isinstance(other, (FormulaPart, str, ProxyListSexpVector)):\n            other = FormulaConstruct._formula_parse(other)\n\n        if not isinstance(other, FormulaConstruct):\n            raise ArithmeticError(\n                \"When adding values to formula, they must be FormulaConstruct or parseable to FormulaConstruct\"\n            )\n\n        if len(other._parts) &lt;= 1:\n            return FormulaConstruct(_parts=self._parts + other._parts)\n        else:\n            return FormulaConstruct(_parts=[self._parts, other._parts])\n\n    def __radd__(self, other: Other) -&gt; \"FormulaConstruct\":\n        \"\"\"Support `\"y ~ x\" + bf(\"z ~ 1\")` by coercing the left operand.\"\"\"\n        return self._formula_parse(other) + self\n\n    def iter_summands(self) -&gt; Iterator[Summand]:\n        \"\"\"\n        Iterate over arithmetic groups (summands).\n\n        Returns\n        -------\n        Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]\n            Each yielded tuple represents one summand/group.\n\n        Examples\n        --------\n        ```python\n        from brmspy.brms import bf, gaussian, set_rescor\n\n        f = bf(\"y ~ x\") + gaussian() + set_rescor(True)\n        for summand in f.iter_summands():\n            print(summand)\n        ```\n        \"\"\"\n\n        def _groups(node: Node) -&gt; Iterator[list[FormulaPart | ProxyListSexpVector]]:\n            # Leaf node: single bf/family/etc\n            if isinstance(node, (FormulaPart, ProxyListSexpVector)):\n                return ([node],)  # one group with one element\n\n            if isinstance(node, list):\n                # If any child is a list, this node represents a \"+\"\n                # between sub-expressions, so recurse into each child.\n                if any(isinstance(child, list) for child in node):\n                    for child in node:\n                        yield from _groups(child)\n                else:\n                    # All children are leaves -&gt; one summand\n                    out: list[FormulaPart | ProxyListSexpVector] = []\n                    for child in node:\n                        if isinstance(child, (FormulaPart, ProxyListSexpVector, Sexp)):\n                            child = cast(FormulaPart | ProxyListSexpVector, child)\n                            out.append(child)\n                        else:\n                            raise TypeError(\n                                f\"Unexpected leaf node type in FormulaConstruct: {type(child)!r}\"\n                            )\n                    yield out\n                return\n\n            raise TypeError(f\"Unexpected node type in FormulaConstruct: {type(node)!r}\")\n\n        # self._parts is always a list[Node]\n        for group in _groups(self._parts):\n            yield tuple(group)\n\n    # Make __iter__ return summands by default\n    def __iter__(self) -&gt; Iterator[Summand]:\n        \"\"\"Alias for [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands].\"\"\"\n        return self.iter_summands()\n\n    def iterate(self) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n        \"\"\"\n        Iterate over all leaf nodes in left-to-right order.\n\n        This flattens the expression tree, unlike\n        [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands], which\n        respects grouping.\n\n        Returns\n        -------\n        Iterator[FormulaPart | ProxyListSexpVector]\n        \"\"\"\n\n        def _walk(node: Node) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n            if isinstance(node, FormulaPart):\n                yield node\n            elif isinstance(node, ProxyListSexpVector):\n                yield node\n            elif isinstance(node, list):\n                for child in node:\n                    yield from _walk(child)\n            else:\n                raise TypeError(\n                    f\"Unexpected node type in FormulaConstruct: {type(node)!r}\"\n                )\n\n        for root in self._parts:\n            yield from _walk(root)\n\n    def __str__(self) -&gt; str:\n        return self._pretty(self._parts)\n\n    def _pretty(self, node, _outer=True) -&gt; str:\n        if isinstance(node, FormulaPart):\n            return str(node)\n\n        if isinstance(node, (ProxyListSexpVector, Sexp)):\n            return _sexp_to_str(node)\n\n        if isinstance(node, list):\n            # Pretty-print each child\n            rendered = [self._pretty(child, _outer=False) for child in node]\n\n            # If only one child, no parentheses needed\n            if len(rendered) == 1:\n                return rendered[0]\n\n            # Multiple children \u2192 join with \" + \"\n            inner = \" + \".join(rendered)\n            if _outer:\n                return inner\n            else:\n                return f\"({inner})\"\n\n        raise TypeError(f\"Unexpected node type {type(node)!r} in pretty-printer\")\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct._parts","title":"<code>_parts</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct._formula_parse","title":"<code>_formula_parse(obj)</code>  <code>classmethod</code>","text":"<p>Convert a supported value into a <code>FormulaConstruct</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Other</code> <p>One of: <code>FormulaConstruct</code>, <code>FormulaPart</code>, string (interpreted as <code>bf(&lt;string&gt;)</code>), or <code>ProxyListSexpVector</code>.</p> required <p>Returns:</p> Type Description <code>FormulaConstruct</code> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@classmethod\ndef _formula_parse(cls, obj: Other) -&gt; \"FormulaConstruct\":\n    \"\"\"\n    Convert a supported value into a `FormulaConstruct`.\n\n    Parameters\n    ----------\n    obj\n        One of: `FormulaConstruct`, `FormulaPart`, string (interpreted as `bf(&lt;string&gt;)`),\n        or `ProxyListSexpVector`.\n\n    Returns\n    -------\n    FormulaConstruct\n    \"\"\"\n    if isinstance(obj, FormulaConstruct):\n        return obj\n    if isinstance(obj, ProxyListSexpVector):\n        return FormulaConstruct(_parts=[obj])\n    if isinstance(obj, FormulaPart):\n        return FormulaConstruct(_parts=[obj])\n    if isinstance(obj, str):\n        part = FormulaPart(_fun=\"bf\", _args=[obj], _kwargs={})\n        return FormulaConstruct(_parts=[part])\n    raise TypeError(\n        f\"Cannot parse object of type {type(obj)!r} into FormulaConstruct\"\n    )\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct.__add__","title":"<code>__add__(other)</code>","text":"<p>Combine two formula expressions with <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Other</code> <p>Value to add. Strings are treated as <code>bf(&lt;string&gt;)</code>.</p> required <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>New combined expression.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __add__(self, other: Other):\n    \"\"\"\n    Combine two formula expressions with `+`.\n\n    Parameters\n    ----------\n    other\n        Value to add. Strings are treated as `bf(&lt;string&gt;)`.\n\n    Returns\n    -------\n    FormulaConstruct\n        New combined expression.\n    \"\"\"\n    if isinstance(other, (FormulaPart, str, ProxyListSexpVector)):\n        other = FormulaConstruct._formula_parse(other)\n\n    if not isinstance(other, FormulaConstruct):\n        raise ArithmeticError(\n            \"When adding values to formula, they must be FormulaConstruct or parseable to FormulaConstruct\"\n        )\n\n    if len(other._parts) &lt;= 1:\n        return FormulaConstruct(_parts=self._parts + other._parts)\n    else:\n        return FormulaConstruct(_parts=[self._parts, other._parts])\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Support <code>\"y ~ x\" + bf(\"z ~ 1\")</code> by coercing the left operand.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __radd__(self, other: Other) -&gt; \"FormulaConstruct\":\n    \"\"\"Support `\"y ~ x\" + bf(\"z ~ 1\")` by coercing the left operand.\"\"\"\n    return self._formula_parse(other) + self\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct.iter_summands","title":"<code>iter_summands()</code>","text":"<p>Iterate over arithmetic groups (summands).</p> <p>Returns:</p> Type Description <code>Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]</code> <p>Each yielded tuple represents one summand/group.</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, gaussian, set_rescor\n\nf = bf(\"y ~ x\") + gaussian() + set_rescor(True)\nfor summand in f.iter_summands():\n    print(summand)\n</code></pre> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def iter_summands(self) -&gt; Iterator[Summand]:\n    \"\"\"\n    Iterate over arithmetic groups (summands).\n\n    Returns\n    -------\n    Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]\n        Each yielded tuple represents one summand/group.\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, gaussian, set_rescor\n\n    f = bf(\"y ~ x\") + gaussian() + set_rescor(True)\n    for summand in f.iter_summands():\n        print(summand)\n    ```\n    \"\"\"\n\n    def _groups(node: Node) -&gt; Iterator[list[FormulaPart | ProxyListSexpVector]]:\n        # Leaf node: single bf/family/etc\n        if isinstance(node, (FormulaPart, ProxyListSexpVector)):\n            return ([node],)  # one group with one element\n\n        if isinstance(node, list):\n            # If any child is a list, this node represents a \"+\"\n            # between sub-expressions, so recurse into each child.\n            if any(isinstance(child, list) for child in node):\n                for child in node:\n                    yield from _groups(child)\n            else:\n                # All children are leaves -&gt; one summand\n                out: list[FormulaPart | ProxyListSexpVector] = []\n                for child in node:\n                    if isinstance(child, (FormulaPart, ProxyListSexpVector, Sexp)):\n                        child = cast(FormulaPart | ProxyListSexpVector, child)\n                        out.append(child)\n                    else:\n                        raise TypeError(\n                            f\"Unexpected leaf node type in FormulaConstruct: {type(child)!r}\"\n                        )\n                yield out\n            return\n\n        raise TypeError(f\"Unexpected node type in FormulaConstruct: {type(node)!r}\")\n\n    # self._parts is always a list[Node]\n    for group in _groups(self._parts):\n        yield tuple(group)\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct.__iter__","title":"<code>__iter__()</code>","text":"<p>Alias for <code>iter_summands()</code>.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Summand]:\n    \"\"\"Alias for [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands].\"\"\"\n    return self.iter_summands()\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct.iterate","title":"<code>iterate()</code>","text":"<p>Iterate over all leaf nodes in left-to-right order.</p> <p>This flattens the expression tree, unlike <code>iter_summands()</code>, which respects grouping.</p> <p>Returns:</p> Type Description <code>Iterator[FormulaPart | ProxyListSexpVector]</code> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def iterate(self) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n    \"\"\"\n    Iterate over all leaf nodes in left-to-right order.\n\n    This flattens the expression tree, unlike\n    [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands], which\n    respects grouping.\n\n    Returns\n    -------\n    Iterator[FormulaPart | ProxyListSexpVector]\n    \"\"\"\n\n    def _walk(node: Node) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n        if isinstance(node, FormulaPart):\n            yield node\n        elif isinstance(node, ProxyListSexpVector):\n            yield node\n        elif isinstance(node, list):\n            for child in node:\n                yield from _walk(child)\n        else:\n            raise TypeError(\n                f\"Unexpected node type in FormulaConstruct: {type(node)!r}\"\n            )\n\n    for root in self._parts:\n        yield from _walk(root)\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct.__str__","title":"<code>__str__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self._pretty(self._parts)\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct._pretty","title":"<code>_pretty(node, _outer=True)</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def _pretty(self, node, _outer=True) -&gt; str:\n    if isinstance(node, FormulaPart):\n        return str(node)\n\n    if isinstance(node, (ProxyListSexpVector, Sexp)):\n        return _sexp_to_str(node)\n\n    if isinstance(node, list):\n        # Pretty-print each child\n        rendered = [self._pretty(child, _outer=False) for child in node]\n\n        # If only one child, no parentheses needed\n        if len(rendered) == 1:\n            return rendered[0]\n\n        # Multiple children \u2192 join with \" + \"\n        inner = \" + \".join(rendered)\n        if _outer:\n            return inner\n        else:\n            return f\"({inner})\"\n\n    raise TypeError(f\"Unexpected node type {type(node)!r} in pretty-printer\")\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaConstruct.__init__","title":"<code>__init__(_parts)</code>","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaPart","title":"<code>FormulaPart</code>  <code>dataclass</code>","text":"<p>A single formula helper invocation.</p> <p>Instances of this type represent a call like <code>bf(\"y ~ x\")</code> or <code>set_rescor(True)</code> without executing anything. They are primarily used as nodes inside a <code>FormulaConstruct</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_fun</code> <code>Literal[...]</code> <p>Whitelisted formula helper name.</p> required <code>_args</code> <code>Sequence[Primitive]</code> <p>Positional arguments for the helper.</p> required <code>_kwargs</code> <code>Mapping[str, Primitive]</code> <p>Keyword arguments for the helper.</p> required Notes <p>This is a low-level type. Most users should construct these via the public helper functions in <code>brmspy.brms</code>.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@dataclass\nclass FormulaPart:\n    \"\"\"\n    A single formula helper invocation.\n\n    Instances of this type represent a call like `bf(\"y ~ x\")` or `set_rescor(True)`\n    without executing anything. They are primarily used as nodes inside a\n    [`FormulaConstruct`][brmspy.types.formula_dsl.FormulaConstruct].\n\n    Parameters\n    ----------\n    _fun : Literal[...]\n        Whitelisted formula helper name.\n    _args : Sequence[Primitive]\n        Positional arguments for the helper.\n    _kwargs : Mapping[str, Primitive]\n        Keyword arguments for the helper.\n\n    Notes\n    -----\n    This is a low-level type. Most users should construct these via the public\n    helper functions in [`brmspy.brms`][brmspy.brms].\n    \"\"\"\n\n    _fun: _FORMULA_FUNCTION_WHITELIST\n    _args: Sequence[Primitive]\n    _kwargs: Mapping[str, Primitive]\n\n    def __post_init__(self):\n        \"\"\"Validate `_fun`, `_args`, and `_kwargs` types after construction.\"\"\"\n        # Validate function name first\n        if self._fun not in get_args(_FORMULA_FUNCTION_WHITELIST):\n            raise ValueError(\n                f\"FormulaPart._fun must be one of {_FORMULA_FUNCTION_WHITELIST!r}, \"\n                f\"got {self._fun!r}\"\n            )\n\n        # Enforce _args is a list\n        if not isinstance(self._args, Sequence):\n            raise TypeError(\n                f\"FormulaPart._args must be a Sequence, got {type(self._args).__name__}\"\n            )\n\n        # Enforce _kwargs is a dict\n        if not isinstance(self._kwargs, Mapping):\n            raise TypeError(\n                f\"FormulaPart._kwargs must be a Mapping, got {type(self._kwargs).__name__}\"\n            )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Render a readable `fun(arg1, ..., kw=...)` representation.\"\"\"\n        args = \", \".join(repr(a) for a in self._args)\n        kwargs = \", \".join(f\"{k}={v!r}\" for k, v in self._kwargs.items())\n        inner = \", \".join(x for x in (args, kwargs) if x)\n        return f\"{self._fun}({inner})\"\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaPart-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaPart._fun","title":"<code>_fun</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaPart._args","title":"<code>_args</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaPart._kwargs","title":"<code>_kwargs</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaPart-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaPart.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate <code>_fun</code>, <code>_args</code>, and <code>_kwargs</code> types after construction.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validate `_fun`, `_args`, and `_kwargs` types after construction.\"\"\"\n    # Validate function name first\n    if self._fun not in get_args(_FORMULA_FUNCTION_WHITELIST):\n        raise ValueError(\n            f\"FormulaPart._fun must be one of {_FORMULA_FUNCTION_WHITELIST!r}, \"\n            f\"got {self._fun!r}\"\n        )\n\n    # Enforce _args is a list\n    if not isinstance(self._args, Sequence):\n        raise TypeError(\n            f\"FormulaPart._args must be a Sequence, got {type(self._args).__name__}\"\n        )\n\n    # Enforce _kwargs is a dict\n    if not isinstance(self._kwargs, Mapping):\n        raise TypeError(\n            f\"FormulaPart._kwargs must be a Mapping, got {type(self._kwargs).__name__}\"\n        )\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaPart.__str__","title":"<code>__str__()</code>","text":"<p>Render a readable <code>fun(arg1, ..., kw=...)</code> representation.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Render a readable `fun(arg1, ..., kw=...)` representation.\"\"\"\n    args = \", \".join(repr(a) for a in self._args)\n    kwargs = \", \".join(f\"{k}={v!r}\" for k, v in self._kwargs.items())\n    inner = \", \".join(x for x in (args, kwargs) if x)\n    return f\"{self._fun}({inner})\"\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaPart.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.FormulaPart.__init__","title":"<code>__init__(_fun, _args, _kwargs)</code>","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.log","title":"<code>log(*msg, method_name=None, level=logging.INFO)</code>","text":"<p>Log a message with automatic method name detection.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log</p> <code>()</code> <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> <code>level</code> <code>int</code> <p>Logging level (default: logging.INFO)</p> <code>INFO</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log(*msg: str, method_name: str | None = None, level: int = logging.INFO):\n    \"\"\"\n    Log a message with automatic method name detection.\n\n    Parameters\n    ----------\n    msg : str\n        The message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n    level : int, optional\n        Logging level (default: logging.INFO)\n    \"\"\"\n    if method_name is None:\n        method_name = _get_caller_name()\n\n    msg_str = \" \".join(str(v) for v in msg)\n\n    logger = get_logger()\n    logger.log(level, msg_str, extra={\"method_name\": method_name})\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.kwargs_r","title":"<code>kwargs_r(kwargs)</code>","text":"<p>Convert Python keyword arguments to R-compatible format.</p> <p>Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict or None</code> <p>Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with same keys but R-compatible values, or empty dict if None</p> Notes <p>This is a thin wrapper around <code>py_to_r()</code> that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import kwargs_r\nimport pandas as pd\nimport numpy as np\n\n# Prepare kwargs for R function\npy_kwargs = {\n    'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n    'prior': {'b': [0, 1]},\n    'chains': 4,\n    'iter': 2000\n}\n\nr_kwargs = kwargs_r(py_kwargs)\n# All values converted to R objects\n# Can now call: r_function(**r_kwargs)\n</code></pre> See Also <p>py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def kwargs_r(kwargs: dict | None) -&gt; dict:\n    \"\"\"\n    Convert Python keyword arguments to R-compatible format.\n\n    Convenience function that applies py_to_r() to all values in a\n    keyword arguments dictionary, preparing them for R function calls.\n\n    Parameters\n    ----------\n    kwargs : dict or None\n        Dictionary of keyword arguments where values may be Python objects\n        (dicts, lists, DataFrames, arrays, etc.)\n\n    Returns\n    -------\n    dict\n        Dictionary with same keys but R-compatible values, or empty dict if None\n\n    Notes\n    -----\n    This is a thin wrapper around `py_to_r()` that operates on dictionaries.\n    It's commonly used to prepare keyword arguments for R function calls via rpy2.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import kwargs_r\n    import pandas as pd\n    import numpy as np\n\n    # Prepare kwargs for R function\n    py_kwargs = {\n        'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n        'prior': {'b': [0, 1]},\n        'chains': 4,\n        'iter': 2000\n    }\n\n    r_kwargs = kwargs_r(py_kwargs)\n    # All values converted to R objects\n    # Can now call: r_function(**r_kwargs)\n    ```\n\n    See Also\n    --------\n    py_to_r : Underlying conversion function for individual values\n    brmspy.brms.fit : Uses this to prepare user kwargs for R\n    \"\"\"\n    if kwargs is None:\n        return {}\n    return {k: py_to_r(v) for k, v in kwargs.items()}\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def py_to_r(obj: PyObject) -&gt; Sexp:\n    \"\"\"\n    Convert arbitrary Python objects to R objects via rpy2.\n\n    Comprehensive converter that handles nested structures (dicts, lists),\n    DataFrames, arrays, and scalars. Uses rpy2's converters with special\n    handling for dictionaries (\u2192 R named lists) and lists of dicts.\n\n    Parameters\n    ----------\n    obj : any\n        Python object to convert. Supported types:\n        - None \u2192 R NULL\n        - dict \u2192 R named list (ListVector), recursively\n        - list/tuple of dicts \u2192 R list of named lists\n        - list/tuple (other) \u2192 R vector or list\n        - pd.DataFrame \u2192 R data.frame\n        - np.ndarray \u2192 R vector/matrix\n        - scalars (int, float, str, bool) \u2192 R atomic types\n\n    Returns\n    -------\n    rpy2 R object\n        R representation of the Python object\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **None**: \u2192 R NULL\n    2. **DataFrames**: \u2192 R data.frame (via pandas2ri)\n    3. **Dictionaries**: \u2192 R named list (ListVector), recursively converting values\n    4. **Lists of dicts**: \u2192 R list with 1-based indexed names containing named lists\n    5. **Other lists/tuples**: \u2192 R vectors or lists (via rpy2 default)\n    6. **NumPy arrays**: \u2192 R vectors/matrices (via numpy2ri)\n    7. **Scalars**: \u2192 R atomic values\n\n    **Recursive Conversion:**\n\n    Dictionary values are recursively converted, allowing nested structures:\n    ```python\n    {'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n    ```\n\n    **List of Dicts:**\n\n    Lists containing only dicts are converted to R lists with 1-based indexing:\n    ```python\n    [{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n    ```\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import py_to_r\n    import numpy as np\n    import pandas as pd\n\n    # Scalars\n    py_to_r(5)        # R: 5\n    py_to_r(\"hello\")  # R: \"hello\"\n    py_to_r(None)     # R: NULL\n\n    # Arrays\n    py_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n    # DataFrames\n    df = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\n    py_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n    ```\n\n    See Also\n    --------\n    r_to_py : Convert R objects back to Python\n    kwargs_r : Convert keyword arguments dict for R function calls\n    brmspy.brms.fit : Uses this for converting data to R\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if obj is None:\n        return ro.NULL\n\n    if isinstance(obj, ro.Sexp):\n        return obj\n\n    if isinstance(obj, RListVectorExtension) and isinstance(obj.r, ro.Sexp):\n        return obj.r\n\n    _type = type(obj)\n    converter = None\n\n    if _type in _registry._PY2R_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._PY2R_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._PY2R_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._PY2R_CONVERTERS) &gt; 0, \"NO PY2R CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj)\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.bf","title":"<code>bf(*formulas, **formula_args)</code>","text":"<p>Build a brms model formula.</p> <p>This is the primary entrypoint for specifying the mean model and can be combined with other formula parts (e.g. <code>lf</code>, <code>nlf</code>, <code>acformula</code>) using <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str</code> <p>One or more brms formula strings (e.g. <code>\"y ~ x + (1|group)\"</code>). Multiple formulas are commonly used for multivariate models.</p> <code>()</code> <code>**formula_args</code> <p>Keyword arguments forwarded to R <code>brms::brmsformula()</code> (for example <code>decomp=\"QR\"</code>, <code>center=True</code>, <code>sparse=True</code>, <code>nl=True</code>, <code>loop=True</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::brmsformula : R documentation</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>QR decomposition (often helps with collinearity):</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"reaction ~ days + (days|subject)\", decomp=\"QR\")\n</code></pre> <p>Multivariate formula + residual correlation:</p> <pre><code>from brmspy.brms import bf, set_rescor\n\nf = bf(\"mvbind(y1, y2) ~ x\") + set_rescor(True)\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def bf(*formulas: str, **formula_args) -&gt; FormulaConstruct:\n    \"\"\"\n    Build a brms model formula.\n\n    This is the primary entrypoint for specifying the mean model and can be\n    combined with other formula parts (e.g. `lf`, `nlf`, `acformula`) using ``+``.\n\n    Parameters\n    ----------\n    *formulas : str\n        One or more brms formula strings (e.g. ``\"y ~ x + (1|group)\"``). Multiple\n        formulas are commonly used for multivariate models.\n    **formula_args\n        Keyword arguments forwarded to R ``brms::brmsformula()`` (for example\n        ``decomp=\"QR\"``, ``center=True``, ``sparse=True``, ``nl=True``, ``loop=True``).\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::brmsformula : [R documentation](https://paulbuerkner.com/brms/reference/brmsformula.html)\n\n    Examples\n    --------\n    Basic formula:\n\n    ```python\n    from brmspy.brms import bf\n\n    f = bf(\"y ~ x1 + x2 + (1|group)\")\n    ```\n\n    QR decomposition (often helps with collinearity):\n\n    ```python\n    from brmspy.brms import bf\n\n    f = bf(\"reaction ~ days + (days|subject)\", decomp=\"QR\")\n    ```\n\n    Multivariate formula + residual correlation:\n\n    ```python\n    from brmspy.brms import bf, set_rescor\n\n    f = bf(\"mvbind(y1, y2) ~ x\") + set_rescor(True)\n    ```\n    \"\"\"\n    part = FormulaPart(_fun=\"bf\", _args=list(formulas), _kwargs=formula_args)\n    return FormulaConstruct._formula_parse(part)\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.lf","title":"<code>lf(*formulas, flist=None, dpar=None, resp=None, center=None, cmc=None, sparse=None, decomp=None)</code>","text":"<p>Add linear formulas for distributional / non-linear parameters.</p> <p>This wraps R <code>brms::lf()</code> and is typically used to model distributional parameters such as <code>sigma</code> (heteroskedasticity) or to specify predictors for non-linear parameters.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str | FormulaConstruct | FormulaPart | ProxyListSexpVector</code> <p>One or more formulas such as <code>\"sigma ~ x\"</code>.</p> <code>()</code> <code>flist</code> <p>Optional list of formulas (advanced; mirrors brms).</p> <code>None</code> <code>dpar</code> <code>str or None</code> <p>Distributional parameter name (e.g. <code>\"sigma\"</code>, <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <code>center</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <code>cmc</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <code>sparse</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <code>decomp</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification that can be combined using <code>+</code>.</p> See Also <p>brms::lf : R documentation</p> <p>Examples:</p> <p>Model mean + sigma:</p> <pre><code>from brmspy.brms import bf, lf\n\nf = bf(\"y ~ x\") + lf(\"sigma ~ x\", dpar=\"sigma\")\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def lf(\n    *formulas: str | FormulaConstruct | FormulaPart | ProxyListSexpVector,\n    flist=None,\n    dpar: str | None = None,\n    resp: str | None = None,\n    center: bool | None = None,\n    cmc: bool | None = None,\n    sparse: bool | None = None,\n    decomp: str | None = None,\n) -&gt; FormulaConstruct:\n    \"\"\"\n    Add linear formulas for distributional / non-linear parameters.\n\n    This wraps R ``brms::lf()`` and is typically used to model distributional\n    parameters such as ``sigma`` (heteroskedasticity) or to specify predictors\n    for non-linear parameters.\n\n    Parameters\n    ----------\n    *formulas\n        One or more formulas such as ``\"sigma ~ x\"``.\n    flist\n        Optional list of formulas (advanced; mirrors brms).\n    dpar : str or None, default=None\n        Distributional parameter name (e.g. ``\"sigma\"``, ``\"phi\"``).\n    resp : str or None, default=None\n        Response name for multivariate models.\n    center, cmc, sparse, decomp\n        Forwarded to R ``brms::lf()``.\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification that can be combined using ``+``.\n\n    See Also\n    --------\n    brms::lf : [R documentation](https://paulbuerkner.com/brms/reference/lf.html)\n\n    Examples\n    --------\n    Model mean + sigma:\n\n    ```python\n    from brmspy.brms import bf, lf\n\n    f = bf(\"y ~ x\") + lf(\"sigma ~ x\", dpar=\"sigma\")\n    ```\n    \"\"\"\n    formula_args = {\n        \"flist\": flist,\n        \"dpar\": dpar,\n        \"resp\": resp,\n        \"center\": center,\n        \"cmc\": cmc,\n        \"sparse\": sparse,\n        \"decomp\": decomp,\n    }\n    result = FormulaConstruct._formula_parse(\n        FormulaPart(\"lf\", list(formulas), formula_args)\n    )\n    return result\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.nlf","title":"<code>nlf(*formulas, flist=None, dpar=None, resp=None, loop=None)</code>","text":"<p>Add non-linear formulas.</p> <p>Wraps R <code>brms::nlf()</code>. This is used together with <code>set_nl()</code> and parameter definitions in <code>lf()</code> to specify non-linear models.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str | FormulaConstruct | FormulaPart | ProxyListSexpVector</code> <p>One or more non-linear formulas (e.g. <code>\"y ~ a * exp(b * x)\"</code>).</p> <code>()</code> <code>flist</code> <p>Optional list of formulas (advanced; mirrors brms).</p> <code>None</code> <code>dpar</code> <code>str or None</code> <p>Distributional parameter name (optional).</p> <code>None</code> <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <code>loop</code> <code>bool or None</code> <p>Forwarded to R <code>brms::nlf(loop=...)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::nlf : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, nlf, set_nl\n\nf = bf(\"y ~ 1\") + nlf(\"y ~ a * exp(b * x)\") + set_nl()\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def nlf(\n    *formulas: str | FormulaConstruct | FormulaPart | ProxyListSexpVector,\n    flist=None,\n    dpar: str | None = None,\n    resp: str | None = None,\n    loop: bool | None = None,\n) -&gt; FormulaConstruct:\n    \"\"\"\n    Add non-linear formulas.\n\n    Wraps R ``brms::nlf()``. This is used together with `set_nl()` and parameter\n    definitions in `lf()` to specify non-linear models.\n\n    Parameters\n    ----------\n    *formulas\n        One or more non-linear formulas (e.g. ``\"y ~ a * exp(b * x)\"``).\n    flist\n        Optional list of formulas (advanced; mirrors brms).\n    dpar : str or None, default=None\n        Distributional parameter name (optional).\n    resp : str or None, default=None\n        Response name for multivariate models.\n    loop : bool or None, default=None\n        Forwarded to R ``brms::nlf(loop=...)``.\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::nlf : [R documentation](https://paulbuerkner.com/brms/reference/nlf.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, nlf, set_nl\n\n    f = bf(\"y ~ 1\") + nlf(\"y ~ a * exp(b * x)\") + set_nl()\n    ```\n    \"\"\"\n    formula_args = {\n        \"flist\": flist,\n        \"dpar\": dpar,\n        \"resp\": resp,\n        \"loop\": loop,\n    }\n    return FormulaConstruct._formula_parse(FormulaPart(\"nlf\", formulas, formula_args))\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.acformula","title":"<code>acformula(autocor, resp=None)</code>","text":"<p>Add an autocorrelation structure.</p> <p>Wraps R <code>brms::acformula()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>autocor</code> <code>str</code> <p>One-sided autocorrelation formula (e.g. <code>\"~ arma(p = 1, q = 1)\"</code>).</p> required <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::acformula : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, acformula\n\nf = bf(\"y ~ x\") + acformula(\"~ arma(p = 1, q = 1)\")\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def acformula(\n    autocor: str,\n    resp: str | None = None,\n) -&gt; FormulaConstruct:\n    \"\"\"\n    Add an autocorrelation structure.\n\n    Wraps R ``brms::acformula()``.\n\n    Parameters\n    ----------\n    autocor : str\n        One-sided autocorrelation formula (e.g. ``\"~ arma(p = 1, q = 1)\"``).\n    resp : str or None, default=None\n        Response name for multivariate models.\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::acformula : [R documentation](https://paulbuerkner.com/brms/reference/acformula.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, acformula\n\n    f = bf(\"y ~ x\") + acformula(\"~ arma(p = 1, q = 1)\")\n    ```\n    \"\"\"\n    formula_args = {\"resp\": resp}\n    return FormulaConstruct._formula_parse(\n        FormulaPart(\"acformula\", [autocor], formula_args)\n    )\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.set_rescor","title":"<code>set_rescor(rescor=True)</code>","text":"<p>Control residual correlations in multivariate models.</p> <p>Wraps R <code>brms::set_rescor()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rescor</code> <code>bool</code> <p>Whether to model residual correlations.</p> <code>True</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::set_rescor : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, set_rescor\n\nf = bf(\"y1 ~ x\") + bf(\"y2 ~ z\") + set_rescor(True)\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def set_rescor(rescor: bool = True) -&gt; FormulaConstruct:\n    \"\"\"\n    Control residual correlations in multivariate models.\n\n    Wraps R ``brms::set_rescor()``.\n\n    Parameters\n    ----------\n    rescor : bool, default=True\n        Whether to model residual correlations.\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::set_rescor : [R documentation](https://paulbuerkner.com/brms/reference/set_rescor.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, set_rescor\n\n    f = bf(\"y1 ~ x\") + bf(\"y2 ~ z\") + set_rescor(True)\n    ```\n    \"\"\"\n    formula_args = {\n        \"rescor\": rescor,\n    }\n    return FormulaConstruct._formula_parse(FormulaPart(\"set_rescor\", [], formula_args))\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.set_mecor","title":"<code>set_mecor(mecor=True)</code>","text":"<p>Control correlations between latent <code>me()</code> terms.</p> <p>Wraps R <code>brms::set_mecor()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mecor</code> <code>bool</code> <p>Whether to model correlations between latent variables introduced by <code>me()</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::set_mecor : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, set_mecor\n\nf = bf(\"y ~ me(x, sdx)\") + set_mecor(True)\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def set_mecor(mecor: bool = True) -&gt; FormulaConstruct:\n    \"\"\"\n    Control correlations between latent ``me()`` terms.\n\n    Wraps R ``brms::set_mecor()``.\n\n    Parameters\n    ----------\n    mecor : bool, default=True\n        Whether to model correlations between latent variables introduced by ``me()``.\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::set_mecor : [R documentation](https://paulbuerkner.com/brms/reference/set_mecor.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, set_mecor\n\n    f = bf(\"y ~ me(x, sdx)\") + set_mecor(True)\n    ```\n    \"\"\"\n    formula_args = {\n        \"mecor\": mecor,\n    }\n    return FormulaConstruct._formula_parse(FormulaPart(\"set_mecor\", [], formula_args))\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula.set_nl","title":"<code>set_nl(dpar=None, resp=None)</code>","text":"<p>Mark a model (or part of it) as non-linear.</p> <p>Wraps R <code>brms::set_nl()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dpar</code> <code>str or None</code> <p>Distributional parameter name (if only part of the model is non-linear).</p> <code>None</code> <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::set_nl : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, lf, set_nl\n\nf = bf(\"y ~ a * inv_logit(x * b)\") + lf(\"a + b ~ z\") + set_nl()\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def set_nl(\n    dpar: str | None = None,\n    resp: str | None = None,\n) -&gt; FormulaConstruct:\n    \"\"\"\n    Mark a model (or part of it) as non-linear.\n\n    Wraps R ``brms::set_nl()``.\n\n    Parameters\n    ----------\n    dpar : str or None, default=None\n        Distributional parameter name (if only part of the model is non-linear).\n    resp : str or None, default=None\n        Response name for multivariate models.\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::set_nl : [R documentation](https://paulbuerkner.com/brms/reference/set_nl.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, lf, set_nl\n\n    f = bf(\"y ~ a * inv_logit(x * b)\") + lf(\"a + b ~ z\") + set_nl()\n    ```\n    \"\"\"\n    formula_args = {\n        \"dpar\": dpar,\n        \"resp\": resp,\n    }\n    return FormulaConstruct._formula_parse(FormulaPart(\"set_nl\", [], formula_args))\n</code></pre>"},{"location":"internals/_brms_functions/formula/#brmspy._brms_functions.formula._execute_formula","title":"<code>_execute_formula(formula)</code>","text":"Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def _execute_formula(formula: FormulaConstruct | Sexp | str) -&gt; Sexp:\n    import rpy2.robjects as ro\n\n    if isinstance(formula, Sexp):\n        return formula\n    if isinstance(formula, str):\n        formula = FormulaConstruct._formula_parse(formula)\n\n    # Must run for formula functions, e.g me() to register\n    ro.r(\"library(brms)\")\n\n    fun_add = cast(Callable[[Sexp, Sexp], Sexp], ro.r(\"function (a, b) a + b\"))\n\n    result: Sexp | None = None\n    for summand in formula:\n        subresult: Sexp = py_to_r(summand[0])\n        for part in summand[1:]:\n            subresult = fun_add(subresult, py_to_r(part))\n\n        if result is None:\n            result = subresult\n        else:\n            result = fun_add(result, subresult)\n\n    assert result is not None\n    return result\n</code></pre>"},{"location":"internals/_brms_functions/generic/","title":"generic","text":"<p>Generic R function caller.</p> <p>Use <code>call()</code> to invoke R functions by name (including brms functions) when there is no dedicated wrapper in <code>brmspy.brms</code>.</p> Notes <p>Executed inside the worker process that hosts the embedded R session.</p>"},{"location":"internals/_brms_functions/generic/#brmspy._brms_functions.generic-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/generic/#brmspy._brms_functions.generic.kwargs_r","title":"<code>kwargs_r(kwargs)</code>","text":"<p>Convert Python keyword arguments to R-compatible format.</p> <p>Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict or None</code> <p>Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with same keys but R-compatible values, or empty dict if None</p> Notes <p>This is a thin wrapper around <code>py_to_r()</code> that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import kwargs_r\nimport pandas as pd\nimport numpy as np\n\n# Prepare kwargs for R function\npy_kwargs = {\n    'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n    'prior': {'b': [0, 1]},\n    'chains': 4,\n    'iter': 2000\n}\n\nr_kwargs = kwargs_r(py_kwargs)\n# All values converted to R objects\n# Can now call: r_function(**r_kwargs)\n</code></pre> See Also <p>py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def kwargs_r(kwargs: dict | None) -&gt; dict:\n    \"\"\"\n    Convert Python keyword arguments to R-compatible format.\n\n    Convenience function that applies py_to_r() to all values in a\n    keyword arguments dictionary, preparing them for R function calls.\n\n    Parameters\n    ----------\n    kwargs : dict or None\n        Dictionary of keyword arguments where values may be Python objects\n        (dicts, lists, DataFrames, arrays, etc.)\n\n    Returns\n    -------\n    dict\n        Dictionary with same keys but R-compatible values, or empty dict if None\n\n    Notes\n    -----\n    This is a thin wrapper around `py_to_r()` that operates on dictionaries.\n    It's commonly used to prepare keyword arguments for R function calls via rpy2.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import kwargs_r\n    import pandas as pd\n    import numpy as np\n\n    # Prepare kwargs for R function\n    py_kwargs = {\n        'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n        'prior': {'b': [0, 1]},\n        'chains': 4,\n        'iter': 2000\n    }\n\n    r_kwargs = kwargs_r(py_kwargs)\n    # All values converted to R objects\n    # Can now call: r_function(**r_kwargs)\n    ```\n\n    See Also\n    --------\n    py_to_r : Underlying conversion function for individual values\n    brmspy.brms.fit : Uses this to prepare user kwargs for R\n    \"\"\"\n    if kwargs is None:\n        return {}\n    return {k: py_to_r(v) for k, v in kwargs.items()}\n</code></pre>"},{"location":"internals/_brms_functions/generic/#brmspy._brms_functions.generic.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def py_to_r(obj: PyObject) -&gt; Sexp:\n    \"\"\"\n    Convert arbitrary Python objects to R objects via rpy2.\n\n    Comprehensive converter that handles nested structures (dicts, lists),\n    DataFrames, arrays, and scalars. Uses rpy2's converters with special\n    handling for dictionaries (\u2192 R named lists) and lists of dicts.\n\n    Parameters\n    ----------\n    obj : any\n        Python object to convert. Supported types:\n        - None \u2192 R NULL\n        - dict \u2192 R named list (ListVector), recursively\n        - list/tuple of dicts \u2192 R list of named lists\n        - list/tuple (other) \u2192 R vector or list\n        - pd.DataFrame \u2192 R data.frame\n        - np.ndarray \u2192 R vector/matrix\n        - scalars (int, float, str, bool) \u2192 R atomic types\n\n    Returns\n    -------\n    rpy2 R object\n        R representation of the Python object\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **None**: \u2192 R NULL\n    2. **DataFrames**: \u2192 R data.frame (via pandas2ri)\n    3. **Dictionaries**: \u2192 R named list (ListVector), recursively converting values\n    4. **Lists of dicts**: \u2192 R list with 1-based indexed names containing named lists\n    5. **Other lists/tuples**: \u2192 R vectors or lists (via rpy2 default)\n    6. **NumPy arrays**: \u2192 R vectors/matrices (via numpy2ri)\n    7. **Scalars**: \u2192 R atomic values\n\n    **Recursive Conversion:**\n\n    Dictionary values are recursively converted, allowing nested structures:\n    ```python\n    {'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n    ```\n\n    **List of Dicts:**\n\n    Lists containing only dicts are converted to R lists with 1-based indexing:\n    ```python\n    [{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n    ```\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import py_to_r\n    import numpy as np\n    import pandas as pd\n\n    # Scalars\n    py_to_r(5)        # R: 5\n    py_to_r(\"hello\")  # R: \"hello\"\n    py_to_r(None)     # R: NULL\n\n    # Arrays\n    py_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n    # DataFrames\n    df = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\n    py_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n    ```\n\n    See Also\n    --------\n    r_to_py : Convert R objects back to Python\n    kwargs_r : Convert keyword arguments dict for R function calls\n    brmspy.brms.fit : Uses this for converting data to R\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if obj is None:\n        return ro.NULL\n\n    if isinstance(obj, ro.Sexp):\n        return obj\n\n    if isinstance(obj, RListVectorExtension) and isinstance(obj.r, ro.Sexp):\n        return obj.r\n\n    _type = type(obj)\n    converter = None\n\n    if _type in _registry._PY2R_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._PY2R_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._PY2R_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._PY2R_CONVERTERS) &gt; 0, \"NO PY2R CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj)\n</code></pre>"},{"location":"internals/_brms_functions/generic/#brmspy._brms_functions.generic.r_to_py","title":"<code>r_to_py(obj, shm=None)</code>","text":"<p>Convert R objects to Python objects via rpy2.</p> <p>Comprehensive converter that handles R lists (named/unnamed), vectors, formulas, and language objects. Provides sensible Python equivalents for all R types with special handling for edge cases.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>rpy2 R object</code> <p>R object to convert to Python</p> required <p>Returns:</p> Type Description <code>any</code> <p>Python representation of the R object: - R NULL \u2192 None - Named list \u2192 dict (recursively) - Unnamed list \u2192 list (recursively) - Length-1 vector \u2192 scalar (int, float, str, bool) - Length-N vector \u2192 list of scalars - Formula/Language object \u2192 str (descriptive representation) - Other objects \u2192 default rpy2 conversion or str fallback</p> Notes <p>Conversion Rules:</p> <ol> <li>R NULL: \u2192 Python None</li> <li>Atomic vectors (numeric, character, logical):</li> <li>Length 1: \u2192 Python scalar (int, float, str, bool)</li> <li>Length &gt;1: \u2192 Python list of scalars</li> <li>Named lists (ListVector with names): \u2192 Python dict, recursively</li> <li>Unnamed lists: \u2192 Python list, recursively</li> <li>Formulas (e.g., <code>y ~ x</code>): \u2192 String representation</li> <li>Language objects (calls, expressions): \u2192 String representation</li> <li>Functions: \u2192 String representation</li> <li>Everything else: Try default rpy2 conversion, fallback to string</li> </ol> <p>Recursive Conversion:</p> <p>List elements and dictionary values are recursively converted: <pre><code>list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n</code></pre></p> <p>Safe Fallback:</p> <p>R language objects, formulas, and functions are converted to descriptive strings rather than attempting complex conversions that might fail.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import r_to_py\nimport rpy2.robjects as ro\n\n# R NULL\nr_to_py(ro.NULL)  # None\n\n# Scalars\nr_to_py(ro.IntVector([5]))    # 5\nr_to_py(ro.FloatVector([3.14]))  # 3.14\nr_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n# Vectors\nr_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n</code></pre> See Also <p>py_to_r : Convert Python objects to R brmspy.brms.summary : Returns Python-friendly summary dict</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def r_to_py(obj: Sexp, shm: ShmPool | None = None) -&gt; PyObject:\n    \"\"\"\n    Convert R objects to Python objects via rpy2.\n\n    Comprehensive converter that handles R lists (named/unnamed), vectors,\n    formulas, and language objects. Provides sensible Python equivalents\n    for all R types with special handling for edge cases.\n\n    Parameters\n    ----------\n    obj : rpy2 R object\n        R object to convert to Python\n\n    Returns\n    -------\n    any\n        Python representation of the R object:\n        - R NULL \u2192 None\n        - Named list \u2192 dict (recursively)\n        - Unnamed list \u2192 list (recursively)\n        - Length-1 vector \u2192 scalar (int, float, str, bool)\n        - Length-N vector \u2192 list of scalars\n        - Formula/Language object \u2192 str (descriptive representation)\n        - Other objects \u2192 default rpy2 conversion or str fallback\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **R NULL**: \u2192 Python None\n    2. **Atomic vectors** (numeric, character, logical):\n       - Length 1: \u2192 Python scalar (int, float, str, bool)\n       - Length &gt;1: \u2192 Python list of scalars\n    3. **Named lists** (ListVector with names): \u2192 Python dict, recursively\n    4. **Unnamed lists**: \u2192 Python list, recursively\n    5. **Formulas** (e.g., `y ~ x`): \u2192 String representation\n    6. **Language objects** (calls, expressions): \u2192 String representation\n    7. **Functions**: \u2192 String representation\n    8. **Everything else**: Try default rpy2 conversion, fallback to string\n\n    **Recursive Conversion:**\n\n    List elements and dictionary values are recursively converted:\n    ```R\n    list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n    ```\n\n    **Safe Fallback:**\n\n    R language objects, formulas, and functions are converted to descriptive\n    strings rather than attempting complex conversions that might fail.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import r_to_py\n    import rpy2.robjects as ro\n\n    # R NULL\n    r_to_py(ro.NULL)  # None\n\n    # Scalars\n    r_to_py(ro.IntVector([5]))    # 5\n    r_to_py(ro.FloatVector([3.14]))  # 3.14\n    r_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n    # Vectors\n    r_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n    ```\n\n    See Also\n    --------\n    py_to_r : Convert Python objects to R\n    brmspy.brms.summary : Returns Python-friendly summary dict\n    \"\"\"\n    import rpy2.robjects as ro\n\n    from brmspy._singleton._shm_singleton import _get_shm\n\n    if obj is ro.NULL:\n        return None\n\n    _type = type(obj)\n    converter = None\n\n    if shm is None:\n        shm = _get_shm()\n\n    if _type in _registry._R2PY_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._R2PY_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._R2PY_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._R2PY_CONVERTERS) &gt; 0, \"NO R2PY CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj, shm)\n</code></pre>"},{"location":"internals/_brms_functions/generic/#brmspy._brms_functions.generic.sanitised_name","title":"<code>sanitised_name(function)</code>","text":"<p>Sanitize a function name for safe R execution.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Function name (optionally namespaced, e.g. <code>\"brms::loo\"</code>).</p> required <p>Returns:</p> Type Description <code>str</code> <p>A sanitized name where invalid characters are replaced with underscores, and where leading digits are avoided (except after a namespace).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sanitised_name(\"my-function\")\n'my_function'\n&gt;&gt;&gt; sanitised_name(\"123func\")\n'_123func'\n</code></pre> Source code in <code>brmspy/_brms_functions/generic.py</code> <pre><code>def sanitised_name(function: str) -&gt; str:\n    \"\"\"\n    Sanitize a function name for safe R execution.\n\n    Parameters\n    ----------\n    function : str\n        Function name (optionally namespaced, e.g. ``\"brms::loo\"``).\n\n    Returns\n    -------\n    str\n        A sanitized name where invalid characters are replaced with underscores,\n        and where leading digits are avoided (except after a namespace).\n\n    Examples\n    --------\n    &gt;&gt;&gt; sanitised_name(\"my-function\")\n    'my_function'\n    &gt;&gt;&gt; sanitised_name(\"123func\")\n    '_123func'\n    \"\"\"\n    # Replace invalid characters with underscores (except ::)\n    sanitized = re.sub(r\"[^a-zA-Z0-9_:.]\", \"_\", function)\n\n    # Ensure doesn't start with a number (unless it's after ::)\n    parts = sanitized.split(\"::\")\n    parts = [(\"_\" + part if part and part[0].isdigit() else part) for part in parts]\n\n    return \"::\".join(parts)\n</code></pre>"},{"location":"internals/_brms_functions/generic/#brmspy._brms_functions.generic.call","title":"<code>call(function, *args, **kwargs)</code>","text":"<p>Call an R function by name with brmspy type conversion.</p> <p>This is intended as an escape hatch for R/brms functionality that does not yet have a dedicated wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Function name. If not namespaced, brmspy tries <code>brms::&lt;function&gt;</code> first, then falls back to evaluating the name directly (e.g. <code>\"stats::AIC\"</code>).</p> required <code>*args</code> <p>Positional arguments.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Converted return value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; fit = brms.brm(\"y ~ x\", data=df, chains=4)\n&gt;&gt;&gt; aic = brms.call(\"stats::AIC\", fit)\n</code></pre> Source code in <code>brmspy/_brms_functions/generic.py</code> <pre><code>def call(function: str, *args, **kwargs) -&gt; Any:\n    \"\"\"\n    Call an R function by name with brmspy type conversion.\n\n    This is intended as an escape hatch for R/brms functionality that does not\n    yet have a dedicated wrapper.\n\n    Parameters\n    ----------\n    function : str\n        Function name. If not namespaced, brmspy tries ``brms::&lt;function&gt;`` first,\n        then falls back to evaluating the name directly (e.g. ``\"stats::AIC\"``).\n    *args\n        Positional arguments.\n    **kwargs\n        Keyword arguments.\n\n    Returns\n    -------\n    Any\n        Converted return value.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from brmspy import brms\n    &gt;&gt;&gt; fit = brms.brm(\"y ~ x\", data=df, chains=4)\n    &gt;&gt;&gt; aic = brms.call(\"stats::AIC\", fit)\n    \"\"\"\n    import rpy2.robjects as ro\n\n    func_name = sanitised_name(function)\n    args = [py_to_r(arg) for arg in args]\n    kwargs = kwargs_r({**kwargs})\n    try:\n        r_fun = cast(\n            Callable, ro.r(f\"suppressWarnings(suppressMessages(brms::{func_name}))\")\n        )\n    except Exception:\n        r_fun = cast(Callable, ro.r(func_name))\n\n    r_result = r_fun(*args, **kwargs)\n    return r_to_py(r_result)\n</code></pre>"},{"location":"internals/_brms_functions/io/","title":"io","text":"<p>I/O helpers for brmspy.</p> <p>This module contains helpers for: - loading example datasets from R packages - saving/loading R objects via <code>saveRDS</code> / <code>readRDS</code></p> Notes <p>These functions are executed inside the worker process that hosts the embedded R session.</p>"},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.FitResult","title":"<code>FitResult = IDResult[IDBrm]</code>  <code>module-attribute</code>","text":""},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.ProxyListSexpVector","title":"<code>ProxyListSexpVector = Union[SexpWrapper, ListSexpVector, None]</code>  <code>module-attribute</code>","text":""},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io-classes","title":"Classes","text":""},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.RListVectorExtension","title":"<code>RListVectorExtension</code>  <code>dataclass</code>","text":"<p>Generic result container with R objects.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R object from brms</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass\nclass RListVectorExtension:\n    \"\"\"Generic result container with R objects.\n\n    Attributes\n    ----------\n    r : robjects.ListVector\n        R object from brms\n    \"\"\"\n\n    r: ProxyListSexpVector\n</code></pre>"},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.RListVectorExtension-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.RListVectorExtension.r","title":"<code>r</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.RListVectorExtension-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.RListVectorExtension.__init__","title":"<code>__init__(r)</code>","text":""},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.brmsfit_to_idata","title":"<code>brmsfit_to_idata(brmsfit_obj, model_data=None)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def brmsfit_to_idata(brmsfit_obj, model_data=None) -&gt; IDBrm:\n    posterior_dict, _ = _brmsfit_get_posterior(brmsfit_obj)\n    resp_names = _brmsfit_get_response_names(brmsfit_obj)\n    dims, coords = _brmsfit_get_dims_and_coords(brmsfit_obj, resp_names=resp_names)\n    observed_data_dict = _brmsfit_get_observed_data(brmsfit_obj, resp_names)\n    post_pred_dict, _ = _brmsfit_get_predict_generic(\n        brmsfit_obj, function=\"brms::posterior_predict\", resp_names=resp_names\n    )\n    log_lik_dict, _ = _brmsfit_get_predict_generic(\n        brmsfit_obj, function=\"brms::log_lik\", resp_names=resp_names\n    )\n    constant_data_dict = _brmsfit_get_constant_data(\n        brmsfit_obj, newdata=None, resp_names=resp_names\n    )\n    for name in constant_data_dict:\n        if name not in dims:\n            dims[name] = [\"obs_id\"]\n\n    idata = az.from_dict(\n        posterior=posterior_dict,\n        posterior_predictive=post_pred_dict or None,\n        log_likelihood=log_lik_dict or None,\n        observed_data=observed_data_dict or None,\n        coords=coords or None,\n        constant_data=constant_data_dict or None,\n        dims=dims or None,\n    )\n\n    return cast(IDBrm, idata)\n</code></pre>"},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.kwargs_r","title":"<code>kwargs_r(kwargs)</code>","text":"<p>Convert Python keyword arguments to R-compatible format.</p> <p>Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict or None</code> <p>Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with same keys but R-compatible values, or empty dict if None</p> Notes <p>This is a thin wrapper around <code>py_to_r()</code> that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import kwargs_r\nimport pandas as pd\nimport numpy as np\n\n# Prepare kwargs for R function\npy_kwargs = {\n    'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n    'prior': {'b': [0, 1]},\n    'chains': 4,\n    'iter': 2000\n}\n\nr_kwargs = kwargs_r(py_kwargs)\n# All values converted to R objects\n# Can now call: r_function(**r_kwargs)\n</code></pre> See Also <p>py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def kwargs_r(kwargs: dict | None) -&gt; dict:\n    \"\"\"\n    Convert Python keyword arguments to R-compatible format.\n\n    Convenience function that applies py_to_r() to all values in a\n    keyword arguments dictionary, preparing them for R function calls.\n\n    Parameters\n    ----------\n    kwargs : dict or None\n        Dictionary of keyword arguments where values may be Python objects\n        (dicts, lists, DataFrames, arrays, etc.)\n\n    Returns\n    -------\n    dict\n        Dictionary with same keys but R-compatible values, or empty dict if None\n\n    Notes\n    -----\n    This is a thin wrapper around `py_to_r()` that operates on dictionaries.\n    It's commonly used to prepare keyword arguments for R function calls via rpy2.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import kwargs_r\n    import pandas as pd\n    import numpy as np\n\n    # Prepare kwargs for R function\n    py_kwargs = {\n        'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n        'prior': {'b': [0, 1]},\n        'chains': 4,\n        'iter': 2000\n    }\n\n    r_kwargs = kwargs_r(py_kwargs)\n    # All values converted to R objects\n    # Can now call: r_function(**r_kwargs)\n    ```\n\n    See Also\n    --------\n    py_to_r : Underlying conversion function for individual values\n    brmspy.brms.fit : Uses this to prepare user kwargs for R\n    \"\"\"\n    if kwargs is None:\n        return {}\n    return {k: py_to_r(v) for k, v in kwargs.items()}\n</code></pre>"},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.r_to_py","title":"<code>r_to_py(obj, shm=None)</code>","text":"<p>Convert R objects to Python objects via rpy2.</p> <p>Comprehensive converter that handles R lists (named/unnamed), vectors, formulas, and language objects. Provides sensible Python equivalents for all R types with special handling for edge cases.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>rpy2 R object</code> <p>R object to convert to Python</p> required <p>Returns:</p> Type Description <code>any</code> <p>Python representation of the R object: - R NULL \u2192 None - Named list \u2192 dict (recursively) - Unnamed list \u2192 list (recursively) - Length-1 vector \u2192 scalar (int, float, str, bool) - Length-N vector \u2192 list of scalars - Formula/Language object \u2192 str (descriptive representation) - Other objects \u2192 default rpy2 conversion or str fallback</p> Notes <p>Conversion Rules:</p> <ol> <li>R NULL: \u2192 Python None</li> <li>Atomic vectors (numeric, character, logical):</li> <li>Length 1: \u2192 Python scalar (int, float, str, bool)</li> <li>Length &gt;1: \u2192 Python list of scalars</li> <li>Named lists (ListVector with names): \u2192 Python dict, recursively</li> <li>Unnamed lists: \u2192 Python list, recursively</li> <li>Formulas (e.g., <code>y ~ x</code>): \u2192 String representation</li> <li>Language objects (calls, expressions): \u2192 String representation</li> <li>Functions: \u2192 String representation</li> <li>Everything else: Try default rpy2 conversion, fallback to string</li> </ol> <p>Recursive Conversion:</p> <p>List elements and dictionary values are recursively converted: <pre><code>list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n</code></pre></p> <p>Safe Fallback:</p> <p>R language objects, formulas, and functions are converted to descriptive strings rather than attempting complex conversions that might fail.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import r_to_py\nimport rpy2.robjects as ro\n\n# R NULL\nr_to_py(ro.NULL)  # None\n\n# Scalars\nr_to_py(ro.IntVector([5]))    # 5\nr_to_py(ro.FloatVector([3.14]))  # 3.14\nr_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n# Vectors\nr_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n</code></pre> See Also <p>py_to_r : Convert Python objects to R brmspy.brms.summary : Returns Python-friendly summary dict</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def r_to_py(obj: Sexp, shm: ShmPool | None = None) -&gt; PyObject:\n    \"\"\"\n    Convert R objects to Python objects via rpy2.\n\n    Comprehensive converter that handles R lists (named/unnamed), vectors,\n    formulas, and language objects. Provides sensible Python equivalents\n    for all R types with special handling for edge cases.\n\n    Parameters\n    ----------\n    obj : rpy2 R object\n        R object to convert to Python\n\n    Returns\n    -------\n    any\n        Python representation of the R object:\n        - R NULL \u2192 None\n        - Named list \u2192 dict (recursively)\n        - Unnamed list \u2192 list (recursively)\n        - Length-1 vector \u2192 scalar (int, float, str, bool)\n        - Length-N vector \u2192 list of scalars\n        - Formula/Language object \u2192 str (descriptive representation)\n        - Other objects \u2192 default rpy2 conversion or str fallback\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **R NULL**: \u2192 Python None\n    2. **Atomic vectors** (numeric, character, logical):\n       - Length 1: \u2192 Python scalar (int, float, str, bool)\n       - Length &gt;1: \u2192 Python list of scalars\n    3. **Named lists** (ListVector with names): \u2192 Python dict, recursively\n    4. **Unnamed lists**: \u2192 Python list, recursively\n    5. **Formulas** (e.g., `y ~ x`): \u2192 String representation\n    6. **Language objects** (calls, expressions): \u2192 String representation\n    7. **Functions**: \u2192 String representation\n    8. **Everything else**: Try default rpy2 conversion, fallback to string\n\n    **Recursive Conversion:**\n\n    List elements and dictionary values are recursively converted:\n    ```R\n    list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n    ```\n\n    **Safe Fallback:**\n\n    R language objects, formulas, and functions are converted to descriptive\n    strings rather than attempting complex conversions that might fail.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import r_to_py\n    import rpy2.robjects as ro\n\n    # R NULL\n    r_to_py(ro.NULL)  # None\n\n    # Scalars\n    r_to_py(ro.IntVector([5]))    # 5\n    r_to_py(ro.FloatVector([3.14]))  # 3.14\n    r_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n    # Vectors\n    r_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n    ```\n\n    See Also\n    --------\n    py_to_r : Convert Python objects to R\n    brmspy.brms.summary : Returns Python-friendly summary dict\n    \"\"\"\n    import rpy2.robjects as ro\n\n    from brmspy._singleton._shm_singleton import _get_shm\n\n    if obj is ro.NULL:\n        return None\n\n    _type = type(obj)\n    converter = None\n\n    if shm is None:\n        shm = _get_shm()\n\n    if _type in _registry._R2PY_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._R2PY_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._R2PY_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._R2PY_CONVERTERS) &gt; 0, \"NO R2PY CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj, shm)\n</code></pre>"},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.get_data","title":"<code>get_data(dataset_name, **kwargs)</code>","text":"<p>Load an R dataset and return it as a pandas DataFrame.</p> <p>This is a thin wrapper around R's <code>data()</code> that loads the object into the R global environment and converts it to a :class:<code>pandas.DataFrame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Name of the dataset as used in R (e.g. <code>\"BTdata\"</code>).</p> required <code>**kwargs</code> <p>Additional keyword arguments forwarded to R's <code>data()</code> function, for example <code>package=\"MCMCglmm\"</code> or other arguments supported by <code>utils::data()</code> in R.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset converted to a pandas DataFrame.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the dataset is not found in the R global environment after calling <code>data()</code>.</p> <code>RuntimeError</code> <p>If conversion from the R object to a pandas DataFrame fails.</p> See Also <p>get_brms_data     Convenience wrapper for datasets from the <code>brms</code> package.</p> Source code in <code>brmspy/_brms_functions/io.py</code> <pre><code>def get_data(dataset_name: str, **kwargs) -&gt; pd.DataFrame:\n    \"\"\"\n    Load an R dataset and return it as a pandas DataFrame.\n\n    This is a thin wrapper around R's ``data()`` that loads the object\n    into the R global environment and converts it to a\n    :class:`pandas.DataFrame`.\n\n    Parameters\n    ----------\n    dataset_name : str\n        Name of the dataset as used in R (e.g. ``\"BTdata\"``).\n    **kwargs\n        Additional keyword arguments forwarded to R's ``data()`` function,\n        for example ``package=\"MCMCglmm\"`` or other arguments supported\n        by ``utils::data()`` in R.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataset converted to a pandas DataFrame.\n\n    Raises\n    ------\n    KeyError\n        If the dataset is not found in the R global environment after\n        calling ``data()``.\n    RuntimeError\n        If conversion from the R object to a pandas DataFrame fails.\n\n    See Also\n    --------\n    get_brms_data\n        Convenience wrapper for datasets from the ``brms`` package.\n    \"\"\"\n    import rpy2.robjects as ro\n\n    r_kwargs = kwargs_r(kwargs)\n\n    r_data = typing.cast(typing.Callable, ro.r[\"data\"])\n    r_data(dataset_name, **r_kwargs)\n    r_obj = ro.globalenv[dataset_name]\n\n    return typing.cast(pd.DataFrame, r_to_py(r_obj))\n</code></pre>"},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.get_brms_data","title":"<code>get_brms_data(dataset_name, **kwargs)</code>","text":"<p>Load an example dataset from the R <code>brms</code> package.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Dataset name (for example <code>\"epilepsy\"</code> or <code>\"kidney\"</code>).</p> required <code>**kwargs</code> <p>Forwarded to R <code>utils::data()</code> via <code>get_data()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset converted to a DataFrame.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nassert epilepsy.shape[0] &gt; 0\n</code></pre> Source code in <code>brmspy/_brms_functions/io.py</code> <pre><code>def get_brms_data(dataset_name: str, **kwargs) -&gt; pd.DataFrame:\n    \"\"\"\n    Load an example dataset from the R ``brms`` package.\n\n    Parameters\n    ----------\n    dataset_name : str\n        Dataset name (for example ``\"epilepsy\"`` or ``\"kidney\"``).\n    **kwargs\n        Forwarded to R ``utils::data()`` via `get_data()`.\n\n    Returns\n    -------\n    pandas.DataFrame\n        Dataset converted to a DataFrame.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    epilepsy = brms.get_brms_data(\"epilepsy\")\n    assert epilepsy.shape[0] &gt; 0\n    ```\n    \"\"\"\n    return get_data(dataset_name, package=\"brms\", **kwargs)\n</code></pre>"},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.save_rds","title":"<code>save_rds(object, file, **kwargs)</code>","text":"<p>Save an R object to an <code>.rds</code> file via R <code>saveRDS()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>RListVectorExtension or ProxyListSexpVector</code> <p>Object to save. If you pass a <code>FitResult</code>, the underlying brmsfit is saved.</p> required <code>file</code> <code>str</code> <p>Output path.</p> required <code>**kwargs</code> <p>Forwarded to R <code>saveRDS()</code> (for example <code>compress=\"xz\"</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.brm(\"y ~ x\", data=df, chains=4)\nbrms.save_rds(model, \"model.rds\")\n</code></pre> Source code in <code>brmspy/_brms_functions/io.py</code> <pre><code>def save_rds(\n    object: RListVectorExtension | ProxyListSexpVector, file: str, **kwargs\n) -&gt; None:\n    \"\"\"\n    Save an R object to an ``.rds`` file via R ``saveRDS()``.\n\n    Parameters\n    ----------\n    object : RListVectorExtension or ProxyListSexpVector\n        Object to save. If you pass a `FitResult`, the underlying brmsfit is saved.\n    file : str\n        Output path.\n    **kwargs\n        Forwarded to R ``saveRDS()`` (for example ``compress=\"xz\"``).\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    model = brms.brm(\"y ~ x\", data=df, chains=4)\n    brms.save_rds(model, \"model.rds\")\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if isinstance(object, RListVectorExtension):\n        brmsfit = object.r\n    else:\n        brmsfit = object\n\n    kwargs = kwargs_r(kwargs)\n\n    r_save_rds = typing.cast(typing.Callable, ro.r(\"saveRDS\"))\n    r_save_rds(brmsfit, file, **kwargs)\n</code></pre>"},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.read_rds_raw","title":"<code>read_rds_raw(file, **kwargs)</code>","text":"<p>Load an R object from an <code>.rds</code> file via R <code>readRDS()</code>.</p> <p>This returns the raw R object handle.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Input path.</p> required <code>**kwargs</code> <p>Forwarded to R <code>readRDS()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ListSexpVector</code> <p>Raw R object.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nobj = brms.read_rds_raw(\"model.rds\")\n</code></pre> Source code in <code>brmspy/_brms_functions/io.py</code> <pre><code>def read_rds_raw(file: str, **kwargs) -&gt; ListSexpVector:\n    \"\"\"\n    Load an R object from an ``.rds`` file via R ``readRDS()``.\n\n    This returns the raw R object handle.\n\n    Parameters\n    ----------\n    file : str\n        Input path.\n    **kwargs\n        Forwarded to R ``readRDS()``.\n\n    Returns\n    -------\n    rpy2.rinterface.ListSexpVector\n        Raw R object.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    obj = brms.read_rds_raw(\"model.rds\")\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    r_read_rds = typing.cast(typing.Callable, ro.r(\"readRDS\"))\n\n    kwargs = kwargs_r(kwargs)\n    brmsobject = r_read_rds(file, **kwargs)\n    return brmsobject\n</code></pre>"},{"location":"internals/_brms_functions/io/#brmspy._brms_functions.io.read_rds_fit","title":"<code>read_rds_fit(file, **kwargs)</code>","text":"<p>Load a saved brms model from an <code>.rds</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Input path containing a saved brmsfit.</p> required <code>**kwargs</code> <p>Forwarded to R <code>readRDS()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p><code>FitResult</code> containing ArviZ <code>InferenceData</code> and an underlying R handle.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.read_rds_fit(\"model.rds\")\nfit.idata.posterior\n</code></pre> Source code in <code>brmspy/_brms_functions/io.py</code> <pre><code>def read_rds_fit(file: str, **kwargs) -&gt; FitResult:\n    \"\"\"\n    Load a saved brms model from an ``.rds`` file.\n\n    Parameters\n    ----------\n    file : str\n        Input path containing a saved brmsfit.\n    **kwargs\n        Forwarded to R ``readRDS()``.\n\n    Returns\n    -------\n    FitResult\n        `FitResult` containing ArviZ `InferenceData` and an underlying R handle.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    fit = brms.read_rds_fit(\"model.rds\")\n    fit.idata.posterior\n    ```\n    \"\"\"\n    brmsfit = read_rds_raw(file, **kwargs)\n    idata = brmsfit_to_idata(brmsfit)\n\n    return FitResult(idata=idata, r=brmsfit)\n</code></pre>"},{"location":"internals/_brms_functions/prediction/","title":"prediction","text":"<p>Prediction helpers for brms models.</p> <p>This module wraps brms prediction utilities and returns typed result objects that contain both an ArviZ <code>InferenceData</code> view and the underlying R result.</p> Notes <p>Executed inside the worker process that hosts the embedded R session.</p>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.FitResult","title":"<code>FitResult = IDResult[IDBrm]</code>  <code>module-attribute</code>","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.ProxyListSexpVector","title":"<code>ProxyListSexpVector = Union[SexpWrapper, ListSexpVector, None]</code>  <code>module-attribute</code>","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction-classes","title":"Classes","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDLogLikelihoodInsample","title":"<code>IDLogLikelihoodInsample</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .log_likelihood extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDLogLikelihoodInsample(IDConstantData):\n    \"\"\"Typed .log_likelihood extension to idata\"\"\"\n\n    log_likelihood: xr.Dataset\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDLogLikelihoodInsample-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDLogLikelihoodInsample.log_likelihood","title":"<code>log_likelihood</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDLogLikelihoodOutsample","title":"<code>IDLogLikelihoodOutsample</code>","text":"<p>               Bases: <code>IDPredictionsConstantData</code></p> <p>Typed .log_likelihood extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDLogLikelihoodOutsample(IDPredictionsConstantData):\n    \"\"\"Typed .log_likelihood extension to idata\"\"\"\n\n    log_likelihood: xr.Dataset\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDLogLikelihoodOutsample-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDLogLikelihoodOutsample.log_likelihood","title":"<code>log_likelihood</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDObservedData","title":"<code>IDObservedData</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .posterior extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDObservedData(IDConstantData):\n    \"\"\"Typed .posterior extension to idata\"\"\"\n\n    observed_data: xr.Dataset\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDObservedData-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDObservedData.observed_data","title":"<code>observed_data</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDPosteriorPredictive","title":"<code>IDPosteriorPredictive</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .posterior_predictive extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDPosteriorPredictive(IDConstantData):\n    \"\"\"Typed .posterior_predictive extension to idata\"\"\"\n\n    posterior_predictive: xr.Dataset\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDPosteriorPredictive-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDPosteriorPredictive.posterior_predictive","title":"<code>posterior_predictive</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDPredictions","title":"<code>IDPredictions</code>","text":"<p>               Bases: <code>IDPredictionsConstantData</code></p> <p>Typed .predictions extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDPredictions(IDPredictionsConstantData):\n    \"\"\"Typed .predictions extension to idata\"\"\"\n\n    predictions: xr.Dataset\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDPredictions-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDPredictions.predictions","title":"<code>predictions</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDResult","title":"<code>IDResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T_idata]</code>, <code>RListVectorExtension</code></p> <p>Generic result container with arviz and R objects.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData object</p> <code>r</code> <code>ListVector</code> <p>R object from brms</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass\nclass IDResult(Generic[T_idata], RListVectorExtension):\n    \"\"\"Generic result container with arviz and R objects.\n\n    Attributes\n    ----------\n    idata : arviz.InferenceData\n        arviz InferenceData object\n    r : robjects.ListVector\n        R object from brms\n    \"\"\"\n\n    idata: T_idata\n\n    def __repr__(self) -&gt; str:\n        return repr(self.idata)\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDResult-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDResult.idata","title":"<code>idata</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDResult-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDResult.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/brms_results.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return repr(self.idata)\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDResult.__init__","title":"<code>__init__(r, idata)</code>","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDPosterior","title":"<code>IDPosterior</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .posterior extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDPosterior(IDConstantData):\n    \"\"\"Typed .posterior extension to idata\"\"\"\n\n    posterior: xr.Dataset\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDPosterior-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.IDPosterior.posterior","title":"<code>posterior</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction._arviz_add_constant_data","title":"<code>_arviz_add_constant_data(idata, constant_data_dict, group_name='constant_data', obs_id=None)</code>","text":"<p>Add a non-draw group (constant_data or predictions_constant_data) to an idata.</p> <p>Extracts obs_id coords directly from the existing idata. This avoids ArviZ's auto (chain, draw) dims and keeps the group purely 1D along obs_id.</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _arviz_add_constant_data(\n    idata: az.InferenceData,\n    constant_data_dict: dict[str, np.ndarray],\n    group_name: Literal[\"constant_data\", \"predictions_constant_data\"] = \"constant_data\",\n    obs_id: None | list[str] | np.ndarray = None,\n) -&gt; az.InferenceData:\n    \"\"\"\n    Add a non-draw group (constant_data or predictions_constant_data) to an idata.\n\n    Extracts obs_id coords directly from the existing idata. This avoids ArviZ's\n    auto (chain, draw) dims and keeps the group purely 1D along obs_id.\n    \"\"\"\n    if not constant_data_dict:\n        return idata\n\n    # ---- 1) Extract obs_id coords from any existing group ----\n    if obs_id is None:\n        for group in idata.groups():\n            ds = idata[group]\n            if ds is not None and \"obs_id\" in ds.coords:\n                obs_id = ds.coords[\"obs_id\"].values\n                break\n\n        if obs_id is None:\n            raise ValueError(\n                \"Could not locate 'obs_id' in any existing idata group; \"\n                \"cannot attach constant_data.\"\n            )\n\n    # ---- 2) Build dims &amp; coords for the new constant group ----\n    const_dims = {name: [\"obs_id\"] for name in constant_data_dict.keys()}\n    const_coords = {\"obs_id\": obs_id}\n\n    # ---- 3) Build a small InferenceData and extend ----\n    if group_name == \"constant_data\":\n        const_idata = az.from_dict(\n            constant_data=constant_data_dict, coords=const_coords, dims=const_dims\n        )\n    else:\n        const_idata = az.from_dict(\n            predictions_constant_data=constant_data_dict,\n            coords=const_coords,\n            dims=const_dims,\n        )\n\n    idata.extend(const_idata)\n    return idata\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction._brmsfit_get_constant_data","title":"<code>_brmsfit_get_constant_data(brmsfit_obj, newdata=None, resp_names=None)</code>","text":"<p>Extract constant_data for ArviZ.</p> <ul> <li>If newdata is None: use brmsfit$data.</li> <li>Else: use the provided newdata.</li> <li>Drop response columns and 'obs_id' (responses go to observed_data,   obs_id is handled as a coord).</li> <li>Return a dict[var_name -&gt; np.ndarray] with length N (N = number of rows).</li> </ul> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _brmsfit_get_constant_data(\n    brmsfit_obj,\n    newdata: None | pd.DataFrame = None,\n    resp_names: None | list[str] = None,\n) -&gt; dict[str, np.ndarray]:\n    \"\"\"\n    Extract constant_data for ArviZ.\n\n    - If newdata is None: use brmsfit$data.\n    - Else: use the provided newdata.\n    - Drop response columns and 'obs_id' (responses go to observed_data,\n      obs_id is handled as a coord).\n    - Return a dict[var_name -&gt; np.ndarray] with length N (N = number of rows).\n    \"\"\"\n    import rpy2.robjects as ro\n    from rpy2.robjects import pandas2ri\n    from rpy2.robjects.conversion import localconverter\n\n    if resp_names is None:\n        resp_names = _brmsfit_get_response_names(brmsfit_obj)\n\n    if newdata is None:\n        # in-sample: use brmsfit$data (R data.frame) -&gt; pandas.DataFrame\n        r_data = brmsfit_obj.rx2(\"data\")\n        with localconverter(ro.default_converter + pandas2ri.converter):\n            df = pandas2ri.rpy2py(r_data)\n        if not isinstance(df, pd.DataFrame):\n            df = pd.DataFrame(df)\n    else:\n        # out-of-sample: use newdata as given\n        df = newdata.copy()\n\n    # Ensure we don't accidentally mutate caller's frame\n    df = df.copy()\n\n    # Drop response variables if present\n    drop_cols: set[str] = set(resp_names or [])\n\n    # Drop obs_id column if present; obs_id is handled as a coord\n    if \"_obs_id_\" in df.columns:\n        df = df.set_index(\"_obs_id_\", drop=True)\n\n    keep_cols = [c for c in df.columns if c not in drop_cols]\n\n    constant_data: dict[str, np.ndarray] = {}\n    for col in keep_cols:\n        # Just pass through whatever dtype it has; xarray can handle object too\n        constant_data[col] = df[col].to_numpy()\n\n    return constant_data\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction._brmsfit_get_dims_and_coords","title":"<code>_brmsfit_get_dims_and_coords(brmsfit_obj, newdata=None, resp_names=None)</code>","text":"<p>Infer dims/coords for ArviZ from a brmsfit object and optional newdata.</p> <p>Rules for obs_id: - If newdata is None:     1) If <code>obs_id</code> column exists in <code>fit$data</code> and is unique: use that.     2) Else, if rownames of <code>fit$data</code> are unique: use those.     3) Else: use a sequential integer range [0, N). - If newdata is not None:     1) If <code>obs_id</code> column exists in newdata and is unique: use that.     2) Else: use newdata.index (with a warning if not unique).</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _brmsfit_get_dims_and_coords(\n    brmsfit_obj,\n    newdata: None | pd.DataFrame = None,\n    resp_names: None | list[str] = None,\n) -&gt; tuple[TypeDims, TypeCoords]:\n    \"\"\"\n    Infer dims/coords for ArviZ from a brmsfit object and optional newdata.\n\n    Rules for obs_id:\n    - If newdata is None:\n        1) If `obs_id` column exists in `fit$data` and is unique: use that.\n        2) Else, if rownames of `fit$data` are unique: use those.\n        3) Else: use a sequential integer range [0, N).\n    - If newdata is not None:\n        1) If `obs_id` column exists in newdata and is unique: use that.\n        2) Else: use newdata.index (with a warning if not unique).\n    \"\"\"\n    import rpy2.robjects as ro\n\n    fun_nrow = cast(Callable, ro.r(\"nrow\"))\n\n    if resp_names is None:\n        resp_names = _brmsfit_get_response_names(brmsfit_obj)\n\n    if newdata is None:\n        # in-sample: look at brmsfit$data\n        r_data = brmsfit_obj.rx2(\"data\")\n        n_obs = int(fun_nrow(r_data)[0])\n\n        obs_id = _get_obs_id_from_r_data(r_data, n_obs)\n\n    else:\n        # out-of-sample: look at newdata\n        n_obs = int(len(newdata))\n        obs_id = _get_obs_id_from_newdata(newdata, n_obs)\n\n    obs_id_arr = np.asarray(obs_id)\n\n    dims: TypeDims = {}\n    coords: TypeCoords = {}\n\n    coords[\"obs_id\"] = obs_id_arr\n\n    for resp in resp_names:\n        dims[resp] = [\"obs_id\"]\n\n    # you can add more dims/coords for responses here later\n    # e.g. multi-response mapping, etc.\n\n    return dims, coords\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction._brmsfit_get_observed_data","title":"<code>_brmsfit_get_observed_data(brmsfit_obj, resp_names=None)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _brmsfit_get_observed_data(\n    brmsfit_obj, resp_names: None | list[str] = None\n) -&gt; dict[str, np.ndarray]:\n    import rpy2.robjects as ro\n    from rpy2.robjects import pandas2ri\n    from rpy2.robjects.conversion import localconverter\n\n    if resp_names is None:\n        resp_names = _brmsfit_get_response_names(brmsfit_obj)\n\n    observed_data_dict: dict[str, np.ndarray] = {}\n    n_obs = 0\n\n    try:\n        r_get_y = cast(Callable, ro.r(\"brms::get_y\"))\n        y_r = r_get_y(brmsfit_obj)\n\n        with localconverter(ro.default_converter + pandas2ri.converter):\n            y_py = pandas2ri.rpy2py(y_r)\n\n        if isinstance(y_py, pd.DataFrame):\n            n_obs = y_py.shape[0]\n            if not resp_names:\n                resp_names = list(y_py.columns)\n            for resp in resp_names:\n                if resp in y_py.columns:\n                    observed_data_dict[resp] = y_py[resp].to_numpy()\n\n        elif isinstance(y_py, pd.Series):\n            n_obs = y_py.shape[0]\n            if not resp_names:\n                resp_names = [str(y_py.name) or \"y\"]\n            observed_data_dict[resp_names[0]] = y_py.to_numpy()\n\n        else:\n            arr = np.asarray(y_py)\n            if arr.ndim == 1:\n                n_obs = arr.shape[0]\n                if not resp_names:\n                    resp_names = [\"y\"]\n                observed_data_dict[resp_names[0]] = arr\n            elif arr.ndim == 2:\n                n_obs, k = arr.shape\n                if not resp_names:\n                    resp_names = [f\"y_{j}\" for j in range(k)]\n                for j, resp in enumerate(resp_names):\n                    observed_data_dict[resp] = arr[:, j]\n\n    except Exception as e:\n        log_warning(f\"[brmsfit_to_idata] Could not extract observed data: {e}\")\n\n    return observed_data_dict\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction._brmsfit_get_posterior","title":"<code>_brmsfit_get_posterior(brmsfit_obj, **kwargs)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _brmsfit_get_posterior(\n    brmsfit_obj: Sexp, **kwargs\n) -&gt; tuple[dict[str, np.ndarray], Sexp]:\n    import rpy2.robjects as ro\n    from rpy2.robjects import pandas2ri\n    from rpy2.robjects.conversion import localconverter\n\n    # -------------------------------------------------\n    # POSTERIOR (parameters) via posterior::as_draws_df\n    # -------------------------------------------------\n    as_draws_df = cast(Callable, ro.r(\"posterior::as_draws_df\"))\n    draws_r = as_draws_df(brmsfit_obj, **kwargs)\n\n    with localconverter(ro.default_converter + pandas2ri.converter):\n        df = pandas2ri.rpy2py(draws_r)\n\n    chain_col = \".chain\" if \".chain\" in df.columns else \"chain\"\n    draw_col = \".draw\" if \".draw\" in df.columns else \"draw\"\n\n    df[\"draw_idx\"] = df.groupby(chain_col)[draw_col].transform(\n        lambda x: np.arange(len(x), dtype=int)\n    )\n\n    chains = np.sort(df[chain_col].unique())\n    n_chains = len(chains)\n    n_draws = int(df[\"draw_idx\"].max()) + 1\n\n    posterior_dict: dict[str, np.ndarray] = {}\n\n    for col in df.columns:\n        if col in (chain_col, draw_col, \".iteration\", \"draw_idx\"):\n            continue\n\n        mat = (\n            df.pivot(index=\"draw_idx\", columns=chain_col, values=col)\n            .sort_index(axis=0)\n            .reindex(columns=chains)\n            .to_numpy()\n            .T\n        )\n        posterior_dict[col] = mat\n\n    return posterior_dict, draws_r\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction._brmsfit_get_predict_generic","title":"<code>_brmsfit_get_predict_generic(brmsfit_obj, function='brms::posterior_predict', resp_names=None, **kwargs)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _brmsfit_get_predict_generic(\n    brmsfit_obj,\n    function: Literal[\n        \"brms::posterior_predict\",\n        \"brms::log_lik\",\n        \"brms::posterior_linpred\",\n        \"brms::posterior_epred\",\n    ] = \"brms::posterior_predict\",\n    resp_names: None | list[str] = None,\n    **kwargs,\n) -&gt; tuple[dict[str, np.ndarray], Sexp | dict[str, Sexp]]:\n    import rpy2.robjects as ro\n\n    if resp_names is None:\n        resp_names = _brmsfit_get_response_names(brmsfit_obj)\n\n    nchains, ndraws = _brmsfit_get_counts(brmsfit_obj)\n\n    post_pred_dict: dict[str, np.ndarray] = {}\n\n    r: dict[str, Sexp] | Sexp = ro.NULL\n    try:\n        r_pp_wrapper = cast(Callable, ro.r(function))\n\n        if not resp_names:\n            # No response names found - univariate default\n            pp_r = r_pp_wrapper(brmsfit_obj, **kwargs)\n            r = pp_r\n            post_pred_dict[\"y\"] = _reshape_to_arviz(np.asarray(pp_r), nchains, ndraws)\n\n        elif len(resp_names) == 1:\n            # Single response\n            resp = resp_names[0]\n            pp_r = r_pp_wrapper(\n                brmsfit_obj, **kwargs, resp=resp\n            )  # Pass as plain string\n            r = pp_r\n            post_pred_dict[resp] = _reshape_to_arviz(np.asarray(pp_r), nchains, ndraws)\n\n        else:\n            # Multivariate: loop over response names\n            r = {}\n            for resp in resp_names:\n                pp_r = r_pp_wrapper(\n                    brmsfit_obj, **kwargs, resp=resp\n                )  # Pass as plain string!\n                post_pred_dict[resp] = _reshape_to_arviz(\n                    np.asarray(pp_r), nchains, ndraws\n                )\n                r[resp] = pp_r\n\n    except Exception as e:\n        log_warning(\n            f\"[brmsfit_to_idata] Could not extract posterior predictive/log_lik: {e}\"\n        )\n        import traceback\n\n        traceback.print_exc()\n\n    return post_pred_dict, r\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction._brmsfit_get_response_names","title":"<code>_brmsfit_get_response_names(brmsfit_obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _brmsfit_get_response_names(brmsfit_obj) -&gt; list[str]:\n    import rpy2.robjects as ro\n\n    # ------------------------------\n    # RESPONSE NAMES via brmsterms()\n    # ------------------------------\n    resp_names: list[str] = []\n    try:\n        # Method 1: Use brmsterms to get response variable names\n        r_code = \"\"\"\n        function(fit) {\n            bterms &lt;- brms::brmsterms(fit$formula)\n            if (inherits(bterms, \"mvbrmsterms\")) {\n                # Multivariate: extract response names from each term\n                names(bterms$terms)\n            } else {\n                # Univariate: get the single response\n                resp &lt;- bterms$respform\n                if (!is.null(resp)) {\n                    all.vars(resp)[1]\n                } else {\n                    # Fallback: parse from formula\n                    all.vars(fit$formula$formula)[1]\n                }\n            }\n        }\n        \"\"\"\n        get_resp_names = cast(Callable, ro.r(r_code))\n        resp_r = get_resp_names(brmsfit_obj)\n        resp_names = list(resp_r)\n    except Exception as e:\n        log_warning(\n            f\"[brmsfit_to_idata] Could not get response names via brmsterms: {e}\"\n        )\n\n        # Fallback: try to extract from model formula directly\n        try:\n            r_fallback = \"\"\"\n            function(fit) {\n                # Try to get response names from the model's data\n                y &lt;- brms::get_y(fit)\n                if (is.matrix(y) || is.data.frame(y)) {\n                    colnames(y)\n                } else if (!is.null(names(y))) {\n                    unique(names(y))[1]\n                } else {\n                    \"y\"\n                }\n            }\n            \"\"\"\n            get_resp_fallback = cast(Callable, ro.r(r_fallback))\n            resp_r = get_resp_fallback(brmsfit_obj)\n            if hasattr(resp_r, \"__iter__\") and not isinstance(resp_r, str):\n                resp_names = [str(r) for r in resp_r if r is not None]\n            else:\n                resp_names = [str(resp_r)]\n        except Exception as e2:\n            log_warning(f\"[brmsfit_to_idata] Fallback also failed: {e2}\")\n\n    return resp_names\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction._idata_add_resp_names_suffix","title":"<code>_idata_add_resp_names_suffix(idata, suffix, resp_names)</code>","text":"<p>In-place: append <code>suffix</code> to all variables in <code>resp_names</code> across all applicable InferenceData groups.</p> <p>Mutates <code>idata</code> directly.</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _idata_add_resp_names_suffix(\n    idata: az.InferenceData,\n    suffix: str,\n    resp_names: list[str],\n) -&gt; None:\n    \"\"\"\n    In-place: append `suffix` to all variables in `resp_names` across all\n    applicable InferenceData groups.\n\n    Mutates `idata` directly.\n    \"\"\"\n    if not suffix or not resp_names:\n        return\n\n    for group in idata.groups():\n        ds = getattr(idata, group, None)\n        if ds is None:\n            continue\n\n        rename_map = {\n            resp: f\"{resp}{suffix}\" for resp in resp_names if resp in ds.data_vars\n        }\n\n        if rename_map:\n            ds = ds.rename(rename_map)\n            setattr(idata, group, ds)\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.kwargs_r","title":"<code>kwargs_r(kwargs)</code>","text":"<p>Convert Python keyword arguments to R-compatible format.</p> <p>Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict or None</code> <p>Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with same keys but R-compatible values, or empty dict if None</p> Notes <p>This is a thin wrapper around <code>py_to_r()</code> that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import kwargs_r\nimport pandas as pd\nimport numpy as np\n\n# Prepare kwargs for R function\npy_kwargs = {\n    'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n    'prior': {'b': [0, 1]},\n    'chains': 4,\n    'iter': 2000\n}\n\nr_kwargs = kwargs_r(py_kwargs)\n# All values converted to R objects\n# Can now call: r_function(**r_kwargs)\n</code></pre> See Also <p>py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def kwargs_r(kwargs: dict | None) -&gt; dict:\n    \"\"\"\n    Convert Python keyword arguments to R-compatible format.\n\n    Convenience function that applies py_to_r() to all values in a\n    keyword arguments dictionary, preparing them for R function calls.\n\n    Parameters\n    ----------\n    kwargs : dict or None\n        Dictionary of keyword arguments where values may be Python objects\n        (dicts, lists, DataFrames, arrays, etc.)\n\n    Returns\n    -------\n    dict\n        Dictionary with same keys but R-compatible values, or empty dict if None\n\n    Notes\n    -----\n    This is a thin wrapper around `py_to_r()` that operates on dictionaries.\n    It's commonly used to prepare keyword arguments for R function calls via rpy2.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import kwargs_r\n    import pandas as pd\n    import numpy as np\n\n    # Prepare kwargs for R function\n    py_kwargs = {\n        'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n        'prior': {'b': [0, 1]},\n        'chains': 4,\n        'iter': 2000\n    }\n\n    r_kwargs = kwargs_r(py_kwargs)\n    # All values converted to R objects\n    # Can now call: r_function(**r_kwargs)\n    ```\n\n    See Also\n    --------\n    py_to_r : Underlying conversion function for individual values\n    brmspy.brms.fit : Uses this to prepare user kwargs for R\n    \"\"\"\n    if kwargs is None:\n        return {}\n    return {k: py_to_r(v) for k, v in kwargs.items()}\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def py_to_r(obj: PyObject) -&gt; Sexp:\n    \"\"\"\n    Convert arbitrary Python objects to R objects via rpy2.\n\n    Comprehensive converter that handles nested structures (dicts, lists),\n    DataFrames, arrays, and scalars. Uses rpy2's converters with special\n    handling for dictionaries (\u2192 R named lists) and lists of dicts.\n\n    Parameters\n    ----------\n    obj : any\n        Python object to convert. Supported types:\n        - None \u2192 R NULL\n        - dict \u2192 R named list (ListVector), recursively\n        - list/tuple of dicts \u2192 R list of named lists\n        - list/tuple (other) \u2192 R vector or list\n        - pd.DataFrame \u2192 R data.frame\n        - np.ndarray \u2192 R vector/matrix\n        - scalars (int, float, str, bool) \u2192 R atomic types\n\n    Returns\n    -------\n    rpy2 R object\n        R representation of the Python object\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **None**: \u2192 R NULL\n    2. **DataFrames**: \u2192 R data.frame (via pandas2ri)\n    3. **Dictionaries**: \u2192 R named list (ListVector), recursively converting values\n    4. **Lists of dicts**: \u2192 R list with 1-based indexed names containing named lists\n    5. **Other lists/tuples**: \u2192 R vectors or lists (via rpy2 default)\n    6. **NumPy arrays**: \u2192 R vectors/matrices (via numpy2ri)\n    7. **Scalars**: \u2192 R atomic values\n\n    **Recursive Conversion:**\n\n    Dictionary values are recursively converted, allowing nested structures:\n    ```python\n    {'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n    ```\n\n    **List of Dicts:**\n\n    Lists containing only dicts are converted to R lists with 1-based indexing:\n    ```python\n    [{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n    ```\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import py_to_r\n    import numpy as np\n    import pandas as pd\n\n    # Scalars\n    py_to_r(5)        # R: 5\n    py_to_r(\"hello\")  # R: \"hello\"\n    py_to_r(None)     # R: NULL\n\n    # Arrays\n    py_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n    # DataFrames\n    df = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\n    py_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n    ```\n\n    See Also\n    --------\n    r_to_py : Convert R objects back to Python\n    kwargs_r : Convert keyword arguments dict for R function calls\n    brmspy.brms.fit : Uses this for converting data to R\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if obj is None:\n        return ro.NULL\n\n    if isinstance(obj, ro.Sexp):\n        return obj\n\n    if isinstance(obj, RListVectorExtension) and isinstance(obj.r, ro.Sexp):\n        return obj.r\n\n    _type = type(obj)\n    converter = None\n\n    if _type in _registry._PY2R_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._PY2R_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._PY2R_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._PY2R_CONVERTERS) &gt; 0, \"NO PY2R CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj)\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.posterior","title":"<code>posterior(model, **kwargs)</code>","text":"<p>Return posterior draws as idata.</p> <p>Wrapper around R <code>posterior::as_draws_df()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>**kwargs</code> <p>Forwarded to <code>posterior::as_draws_df()</code>. e.g inc_warmup, regex, variable</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorEpredResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nep = brms.posterior(fit)\n\nep.idata.posterior\n</code></pre> Source code in <code>brmspy/_brms_functions/prediction.py</code> <pre><code>def posterior(\n    model: FitResult | ProxyListSexpVector, **kwargs\n) -&gt; IDResult[IDPosterior]:\n    \"\"\"\n    Return posterior draws as idata.\n\n    Wrapper around R ``posterior::as_draws_df()``.\n\n    Parameters\n    ----------\n    model : FitResult\n        Fitted model.\n    **kwargs\n        Forwarded to ``posterior::as_draws_df()``. e.g inc_warmup, regex, variable\n\n    Returns\n    -------\n    PosteriorEpredResult\n        Result containing `idata` (ArviZ `InferenceData`) and an underlying R handle.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    fit = brms.brm(\"y ~ x\", data=df, chains=4)\n    ep = brms.posterior(fit)\n\n    ep.idata.posterior\n    ```\n    \"\"\"\n    model_r = py_to_r(model)\n    kwargs = kwargs_r(kwargs)\n\n    resp_names = _brmsfit_get_response_names(model_r)\n    dims, coords = _brmsfit_get_dims_and_coords(model_r, resp_names=resp_names)\n\n    result, r = _brmsfit_get_posterior(model_r, **kwargs)\n    idata = az.from_dict(posterior=result, dims=dims, coords=coords)\n\n    # Add constant data\n    constant_data_dict = _brmsfit_get_constant_data(\n        model_r, newdata=None, resp_names=resp_names\n    )\n    _arviz_add_constant_data(\n        idata, constant_data_dict, \"constant_data\", obs_id=coords[\"obs_id\"]\n    )\n\n    return IDResult(r=cast(ProxyListSexpVector, r), idata=cast(IDPosterior, idata))\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.observed_data","title":"<code>observed_data(model)</code>","text":"Source code in <code>brmspy/_brms_functions/prediction.py</code> <pre><code>def observed_data(model: FitResult | ProxyListSexpVector) -&gt; IDResult[IDObservedData]:\n    import rpy2.robjects as ro\n\n    model_r = py_to_r(model)\n\n    resp_names = _brmsfit_get_response_names(model_r)\n    dims, coords = _brmsfit_get_dims_and_coords(model_r, resp_names=resp_names)\n\n    result = _brmsfit_get_observed_data(model_r, resp_names=resp_names)\n    r = cast(Any, ro.NULL)\n\n    idata = az.from_dict(observed_data=result, coords=coords, dims=dims)\n    idata = cast(IDObservedData, idata)\n\n    # Add constant data\n    constant_data_dict = _brmsfit_get_constant_data(\n        model_r, newdata=None, resp_names=resp_names\n    )\n    _arviz_add_constant_data(idata, constant_data_dict, \"constant_data\")\n\n    return IDResult(r=r, idata=idata)\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.posterior_epred","title":"<code>posterior_epred(model, newdata=None, **kwargs)</code>","text":"<pre><code>posterior_epred(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None) -&gt; IDResult[IDPosterior]\n</code></pre><pre><code>posterior_epred(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame) -&gt; IDResult[IDPredictions]\n</code></pre> <p>Compute expected posterior predictions (noise-free).</p> <p>Wrapper around R <code>brms::posterior_epred()</code>. This returns draws of the expected value (typically on the response scale), without observation noise.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data for predictions. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::posterior_epred()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorEpredResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::posterior_epred : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nep = brms.posterior_epred(fit)\n\nep.idata.posterior\n</code></pre> Source code in <code>brmspy/_brms_functions/prediction.py</code> <pre><code>def posterior_epred(\n    model: FitResult | ProxyListSexpVector,\n    newdata: pd.DataFrame | None = None,\n    **kwargs,\n) -&gt; IDResult:\n    \"\"\"\n    Compute expected posterior predictions (noise-free).\n\n    Wrapper around R ``brms::posterior_epred()``. This returns draws of the\n    expected value (typically on the response scale), without observation noise.\n\n    Parameters\n    ----------\n    model : FitResult\n        Fitted model.\n    newdata : pandas.DataFrame or None, default=None\n        New data for predictions. If ``None``, uses the training data.\n    **kwargs\n        Forwarded to ``brms::posterior_epred()``.\n\n    Returns\n    -------\n    PosteriorEpredResult\n        Result containing `idata` (ArviZ `InferenceData`) and an underlying R handle.\n\n    See Also\n    --------\n    brms::posterior_epred : [R documentation](https://paulbuerkner.com/brms/reference/posterior_epred.brmsfit.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    fit = brms.brm(\"y ~ x\", data=df, chains=4)\n    ep = brms.posterior_epred(fit)\n\n    ep.idata.posterior\n    ```\n    \"\"\"\n    model_r = py_to_r(model)\n    data_r = py_to_r(newdata)\n    kwargs = kwargs_r(kwargs)\n\n    resp_names = _brmsfit_get_response_names(model_r)\n    dims, coords = _brmsfit_get_dims_and_coords(\n        model_r, resp_names=resp_names, newdata=newdata\n    )\n\n    result, r = _brmsfit_get_predict_generic(\n        model_r,\n        newdata=data_r,\n        function=\"brms::posterior_epred\",\n        resp_names=resp_names,\n        **kwargs,\n    )\n\n    if newdata is None:\n        idata = az.from_dict(posterior=result, coords=coords, dims=dims)\n        idata = cast(IDPosterior, idata)\n    else:\n        idata = az.from_dict(predictions=result, coords=coords, dims=dims)\n        idata = cast(IDPredictions, idata)\n\n    _idata_add_resp_names_suffix(idata, \"_mean\", resp_names)\n\n    # Add constant data\n    constant_data_dict = _brmsfit_get_constant_data(\n        model_r, newdata=newdata, resp_names=resp_names\n    )\n    group_name = \"constant_data\" if newdata is None else \"predictions_constant_data\"\n    _arviz_add_constant_data(idata, constant_data_dict, group_name)\n\n    return IDResult(r=cast(ProxyListSexpVector, r), idata=idata)\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.posterior_predict","title":"<code>posterior_predict(model, newdata=None, **kwargs)</code>","text":"<pre><code>posterior_predict(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None, **kwargs) -&gt; IDResult[IDPosteriorPredictive]\n</code></pre><pre><code>posterior_predict(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame, **kwargs) -&gt; IDResult[IDPredictions]\n</code></pre> <p>Draw from the posterior predictive distribution (includes observation noise).</p> <p>Wrapper around R <code>brms::posterior_predict()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data for predictions. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::posterior_predict()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorPredictResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::posterior_predict : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\npp = brms.posterior_predict(fit)\n\npp.idata.posterior_predictive\n</code></pre> Source code in <code>brmspy/_brms_functions/prediction.py</code> <pre><code>def posterior_predict(\n    model: FitResult | ProxyListSexpVector,\n    newdata: pd.DataFrame | None = None,\n    **kwargs,\n) -&gt; IDResult:\n    \"\"\"\n    Draw from the posterior predictive distribution (includes observation noise).\n\n    Wrapper around R ``brms::posterior_predict()``.\n\n    Parameters\n    ----------\n    model : FitResult\n        Fitted model.\n    newdata : pandas.DataFrame or None, default=None\n        New data for predictions. If ``None``, uses the training data.\n    **kwargs\n        Forwarded to ``brms::posterior_predict()``.\n\n    Returns\n    -------\n    PosteriorPredictResult\n        Result containing `idata` (ArviZ `InferenceData`) and an underlying R handle.\n\n    See Also\n    --------\n    brms::posterior_predict : [R documentation](https://paulbuerkner.com/brms/reference/posterior_predict.brmsfit.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    fit = brms.brm(\"y ~ x\", data=df, chains=4)\n    pp = brms.posterior_predict(fit)\n\n    pp.idata.posterior_predictive\n    ```\n    \"\"\"\n    model_r = py_to_r(model)\n    data_r = py_to_r(newdata)\n    kwargs = kwargs_r(kwargs)\n\n    resp_names = _brmsfit_get_response_names(model_r)\n    dims, coords = _brmsfit_get_dims_and_coords(\n        model_r, resp_names=resp_names, newdata=newdata\n    )\n\n    result, r = _brmsfit_get_predict_generic(\n        model_r,\n        newdata=data_r,\n        function=\"brms::posterior_predict\",\n        resp_names=resp_names,\n        **kwargs,\n    )\n\n    if newdata is None:\n        idata = az.from_dict(\n            posterior_predictive=result,\n            dims=dims,\n            coords=coords,\n        )\n        idata = cast(IDPosteriorPredictive, idata)\n    else:\n        idata = az.from_dict(\n            predictions=result,\n            dims=dims,\n            coords=coords,\n        )\n        idata = cast(IDPredictions, idata)\n\n    # Add constant data\n    constant_data_dict = _brmsfit_get_constant_data(\n        model_r, newdata=newdata, resp_names=resp_names\n    )\n    group_name = \"constant_data\" if newdata is None else \"predictions_constant_data\"\n    _arviz_add_constant_data(idata, constant_data_dict, group_name)\n\n    return IDResult(r=cast(ProxyListSexpVector, r), idata=idata)\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.posterior_linpred","title":"<code>posterior_linpred(model, newdata=None, **kwargs)</code>","text":"<pre><code>posterior_linpred(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None, **kwargs) -&gt; IDResult[IDPosterior]\n</code></pre><pre><code>posterior_linpred(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame, **kwargs) -&gt; IDResult[IDPredictions]\n</code></pre> <p>Draw from the linear predictor.</p> <p>Wrapper around R <code>brms::posterior_linpred()</code>. This typically returns draws on the link scale (before applying the inverse link), unless you pass <code>transform=True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data for predictions. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::posterior_linpred()</code> (commonly <code>transform</code> or <code>ndraws</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorLinpredResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::posterior_linpred : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nlp = brms.posterior_linpred(fit, transform=False)\n\nlp.idata.predictions\n</code></pre> Source code in <code>brmspy/_brms_functions/prediction.py</code> <pre><code>def posterior_linpred(\n    model: FitResult | ProxyListSexpVector,\n    newdata: pd.DataFrame | None = None,\n    **kwargs,\n) -&gt; IDResult:\n    \"\"\"\n    Draw from the linear predictor.\n\n    Wrapper around R ``brms::posterior_linpred()``. This typically returns draws\n    on the link scale (before applying the inverse link), unless you pass\n    ``transform=True``.\n\n    Parameters\n    ----------\n    model : FitResult\n        Fitted model.\n    newdata : pandas.DataFrame or None, default=None\n        New data for predictions. If ``None``, uses the training data.\n    **kwargs\n        Forwarded to ``brms::posterior_linpred()`` (commonly ``transform`` or ``ndraws``).\n\n    Returns\n    -------\n    PosteriorLinpredResult\n        Result containing `idata` (ArviZ `InferenceData`) and an underlying R handle.\n\n    See Also\n    --------\n    brms::posterior_linpred : [R documentation](https://paulbuerkner.com/brms/reference/posterior_linpred.brmsfit.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    fit = brms.brm(\"y ~ x\", data=df, chains=4)\n    lp = brms.posterior_linpred(fit, transform=False)\n\n    lp.idata.predictions\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    model_r = py_to_r(model)\n    data_r = py_to_r(newdata)\n    kwargs = kwargs_r(kwargs)\n\n    resp_names = _brmsfit_get_response_names(model_r)\n    dims, coords = _brmsfit_get_dims_and_coords(\n        model_r, resp_names=resp_names, newdata=newdata\n    )\n\n    result, r = _brmsfit_get_predict_generic(\n        model_r,\n        newdata=data_r,\n        function=\"brms::posterior_linpred\",\n        resp_names=resp_names,\n        **kwargs,\n    )\n\n    if newdata is None:\n        idata = az.from_dict(\n            posterior=result,\n            dims=dims,\n            coords=coords,\n        )\n        idata = cast(IDPosterior, idata)\n    else:\n        idata = az.from_dict(\n            predictions=result,\n            dims=dims,\n            coords=coords,\n        )\n        idata = cast(IDPredictions, idata)\n\n    _idata_add_resp_names_suffix(idata, \"_linpred\", resp_names)\n\n    # Add constant data\n    constant_data_dict = _brmsfit_get_constant_data(\n        model_r, newdata=newdata, resp_names=resp_names\n    )\n    group_name = \"constant_data\" if newdata is None else \"predictions_constant_data\"\n    _arviz_add_constant_data(idata, constant_data_dict, group_name)\n\n    return IDResult(r=cast(ProxyListSexpVector, r), idata=idata)\n</code></pre>"},{"location":"internals/_brms_functions/prediction/#brmspy._brms_functions.prediction.log_lik","title":"<code>log_lik(model, newdata=None, **kwargs)</code>","text":"<pre><code>log_lik(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None, **kwargs) -&gt; IDResult[IDLogLikelihoodInsample]\n</code></pre><pre><code>log_lik(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame, **kwargs) -&gt; IDResult[IDLogLikelihoodOutsample]\n</code></pre> <p>Compute pointwise log-likelihood draws.</p> <p>Wrapper around R <code>brms::log_lik()</code>. The result is useful for LOO/WAIC via ArviZ.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::log_lik()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>LogLikResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::log_lik : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nll = brms.log_lik(fit)\n\naz.loo(ll.idata)\n</code></pre> Source code in <code>brmspy/_brms_functions/prediction.py</code> <pre><code>def log_lik(\n    model: FitResult | ProxyListSexpVector,\n    newdata: pd.DataFrame | None = None,\n    **kwargs,\n) -&gt; IDResult:\n    \"\"\"\n    Compute pointwise log-likelihood draws.\n\n    Wrapper around R ``brms::log_lik()``. The result is useful for LOO/WAIC via ArviZ.\n\n    Parameters\n    ----------\n    model : FitResult\n        Fitted model.\n    newdata : pandas.DataFrame or None, default=None\n        New data. If ``None``, uses the training data.\n    **kwargs\n        Forwarded to ``brms::log_lik()``.\n\n    Returns\n    -------\n    LogLikResult\n        Result containing `idata` (ArviZ `InferenceData`) and an underlying R handle.\n\n    See Also\n    --------\n    brms::log_lik : [R documentation](https://paulbuerkner.com/brms/reference/log_lik.brmsfit.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n    import arviz as az\n\n    fit = brms.brm(\"y ~ x\", data=df, chains=4)\n    ll = brms.log_lik(fit)\n\n    az.loo(ll.idata)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    model_r = py_to_r(model)\n    data_r = py_to_r(newdata)\n    kwargs = kwargs_r(kwargs)\n\n    resp_names = _brmsfit_get_response_names(model_r)\n    dims, coords = _brmsfit_get_dims_and_coords(\n        model_r, resp_names=resp_names, newdata=newdata\n    )\n\n    result, r = _brmsfit_get_predict_generic(\n        model_r,\n        newdata=data_r,\n        function=\"brms::log_lik\",\n        resp_names=resp_names,\n        **kwargs,\n    )\n    if newdata is None:\n        idata = az.from_dict(log_likelihood=result, dims=dims, coords=coords)\n        idata = cast(IDLogLikelihoodInsample, idata)\n    else:\n        idata = az.from_dict(log_likelihood=result, dims=dims, coords=coords)\n        idata = cast(IDLogLikelihoodOutsample, idata)\n\n    # Add constant data\n    constant_data_dict = _brmsfit_get_constant_data(\n        model_r, newdata=newdata, resp_names=resp_names\n    )\n    group_name = \"constant_data\" if newdata is None else \"predictions_constant_data\"\n    _arviz_add_constant_data(idata, constant_data_dict, group_name)\n\n    return IDResult(r=cast(ProxyListSexpVector, r), idata=idata)\n</code></pre>"},{"location":"internals/_brms_functions/prior/","title":"prior","text":"<p>Prior specification helpers.</p> <p>This module provides helpers for constructing brms-compatible prior specifications and for querying the default priors implied by a model.</p> Notes <p>Executed inside the worker process that hosts the embedded R session.</p>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior-classes","title":"Classes","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec","title":"<code>PriorSpec</code>  <code>dataclass</code>","text":"<p>Python representation of a brms prior specification.</p> <p>This dataclass provides a typed interface to <code>brms::prior_string()</code> arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the <code>prior()</code> factory function to create instances.</p> <p>Attributes:</p> Name Type Description <code>prior</code> <code>str</code> <p>Prior distribution as string (e.g., <code>\"normal(0, 1)\"</code>, <code>\"exponential(2)\"</code>).</p> <code>class_</code> <code>(str, optional)</code> <p>Parameter class: <code>\"b\"</code> (fixed effects), <code>\"sd\"</code> (group SD), <code>\"Intercept\"</code>, <code>\"sigma\"</code>, <code>\"cor\"</code>, etc.</p> <code>coef</code> <code>(str, optional)</code> <p>Specific coefficient name for class-level priors.</p> <code>group</code> <code>(str, optional)</code> <p>Grouping variable for hierarchical effects.</p> <code>dpar</code> <code>(str, optional)</code> <p>Distributional parameter (e.g., <code>\"sigma\"</code>, <code>\"phi\"</code>, <code>\"zi\"</code>).</p> <code>resp</code> <code>(str, optional)</code> <p>Response variable for multivariate models.</p> <code>nlpar</code> <code>(str, optional)</code> <p>Non-linear parameter name.</p> <code>lb</code> <code>(float, optional)</code> <p>Lower bound for truncated priors.</p> <code>ub</code> <code>(float, optional)</code> <p>Upper bound for truncated priors.</p> See Also <p>prior : Factory function to create <code>PriorSpec</code> instances. brms::prior_string : R documentation</p> <p>Examples:</p> <p>Create prior specifications (prefer using <code>prior()</code>):</p> <pre><code>from brmspy.types import PriorSpec\n\n# Fixed effect prior\np1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n# Group-level SD prior\np2 = PriorSpec(prior=\"exponential(2)\", class_=\"sd\", group=\"patient\")\n\n# Coefficient-specific prior with bounds\np3 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\", coef=\"age\", lb=0)\n</code></pre> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass(frozen=True)\nclass PriorSpec:\n    \"\"\"\n    Python representation of a brms prior specification.\n\n    This dataclass provides a typed interface to `brms::prior_string()` arguments,\n    allowing Python developers to specify priors with IDE autocomplete and type\n    checking. Use the [`prior()`][brmspy.brms.prior] factory function to create\n    instances.\n\n    Attributes\n    ----------\n    prior : str\n        Prior distribution as string (e.g., ``\"normal(0, 1)\"``, ``\"exponential(2)\"``).\n    class_ : str, optional\n        Parameter class: ``\"b\"`` (fixed effects), ``\"sd\"`` (group SD),\n        ``\"Intercept\"``, ``\"sigma\"``, ``\"cor\"``, etc.\n    coef : str, optional\n        Specific coefficient name for class-level priors.\n    group : str, optional\n        Grouping variable for hierarchical effects.\n    dpar : str, optional\n        Distributional parameter (e.g., ``\"sigma\"``, ``\"phi\"``, ``\"zi\"``).\n    resp : str, optional\n        Response variable for multivariate models.\n    nlpar : str, optional\n        Non-linear parameter name.\n    lb : float, optional\n        Lower bound for truncated priors.\n    ub : float, optional\n        Upper bound for truncated priors.\n\n    See Also\n    --------\n    prior : Factory function to create `PriorSpec` instances.\n    brms::prior_string : [R documentation](https://paulbuerkner.com/brms/reference/prior_string.html)\n\n    Examples\n    --------\n    Create prior specifications (prefer using [`prior()`][brmspy.brms.prior]):\n\n    ```python\n    from brmspy.types import PriorSpec\n\n    # Fixed effect prior\n    p1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n    # Group-level SD prior\n    p2 = PriorSpec(prior=\"exponential(2)\", class_=\"sd\", group=\"patient\")\n\n    # Coefficient-specific prior with bounds\n    p3 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\", coef=\"age\", lb=0)\n    ```\n    \"\"\"\n\n    prior: str\n    class_: str | None = None\n    coef: str | None = None\n    group: str | None = None\n    dpar: str | None = None\n    resp: str | None = None\n    nlpar: str | None = None\n    lb: float | None = None\n    ub: float | None = None\n\n    def to_brms_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Convert PriorSpec to keyword arguments for brms::prior_string().\n\n        Maps Python dataclass fields to R function arguments, handling\n        the `class_` -&gt; `class` parameter name conversion.\n\n        Returns\n        -------\n        dict\n            Keyword arguments ready for brms::prior_string()\n\n        Examples\n        --------\n        ```python\n        from brmspy import prior\n        p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n        kwargs = p.to_brms_kwargs()\n        print(kwargs)\n        # {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n        ```\n        \"\"\"\n        out: dict[str, Any] = {\"prior\": self.prior}\n        if self.class_ is not None:\n            out[\"class\"] = self.class_\n        if self.coef is not None:\n            out[\"coef\"] = self.coef\n        if self.group is not None:\n            out[\"group\"] = self.group\n        if self.dpar is not None:\n            out[\"dpar\"] = self.dpar\n        if self.resp is not None:\n            out[\"resp\"] = self.resp\n        if self.nlpar is not None:\n            out[\"nlpar\"] = self.nlpar\n        if self.lb is not None:\n            out[\"lb\"] = self.lb\n        if self.ub is not None:\n            out[\"ub\"] = self.ub\n        return out\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec.prior","title":"<code>prior</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec.class_","title":"<code>class_ = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec.coef","title":"<code>coef = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec.group","title":"<code>group = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec.dpar","title":"<code>dpar = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec.resp","title":"<code>resp = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec.nlpar","title":"<code>nlpar = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec.lb","title":"<code>lb = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec.ub","title":"<code>ub = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec.to_brms_kwargs","title":"<code>to_brms_kwargs()</code>","text":"<p>Convert PriorSpec to keyword arguments for brms::prior_string().</p> <p>Maps Python dataclass fields to R function arguments, handling the <code>class_</code> -&gt; <code>class</code> parameter name conversion.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keyword arguments ready for brms::prior_string()</p> <p>Examples:</p> <pre><code>from brmspy import prior\np = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\nkwargs = p.to_brms_kwargs()\nprint(kwargs)\n# {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n</code></pre> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>def to_brms_kwargs(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert PriorSpec to keyword arguments for brms::prior_string().\n\n    Maps Python dataclass fields to R function arguments, handling\n    the `class_` -&gt; `class` parameter name conversion.\n\n    Returns\n    -------\n    dict\n        Keyword arguments ready for brms::prior_string()\n\n    Examples\n    --------\n    ```python\n    from brmspy import prior\n    p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n    kwargs = p.to_brms_kwargs()\n    print(kwargs)\n    # {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n    ```\n    \"\"\"\n    out: dict[str, Any] = {\"prior\": self.prior}\n    if self.class_ is not None:\n        out[\"class\"] = self.class_\n    if self.coef is not None:\n        out[\"coef\"] = self.coef\n    if self.group is not None:\n        out[\"group\"] = self.group\n    if self.dpar is not None:\n        out[\"dpar\"] = self.dpar\n    if self.resp is not None:\n        out[\"resp\"] = self.resp\n    if self.nlpar is not None:\n        out[\"nlpar\"] = self.nlpar\n    if self.lb is not None:\n        out[\"lb\"] = self.lb\n    if self.ub is not None:\n        out[\"ub\"] = self.ub\n    return out\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.PriorSpec.__init__","title":"<code>__init__(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None)</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.RListVectorExtension","title":"<code>RListVectorExtension</code>  <code>dataclass</code>","text":"<p>Generic result container with R objects.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R object from brms</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass\nclass RListVectorExtension:\n    \"\"\"Generic result container with R objects.\n\n    Attributes\n    ----------\n    r : robjects.ListVector\n        R object from brms\n    \"\"\"\n\n    r: ProxyListSexpVector\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.RListVectorExtension-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.RListVectorExtension.r","title":"<code>r</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.RListVectorExtension-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.RListVectorExtension.__init__","title":"<code>__init__(r)</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct","title":"<code>FormulaConstruct</code>  <code>dataclass</code>","text":"<p>A composite formula expression built from parts.</p> <p><code>FormulaConstruct</code> stores a tree of nodes (<code>FormulaPart</code> and/or R objects) representing expressions combined with <code>+</code>. It is primarily created by calling the public formula helpers exposed by <code>brmspy.brms</code>.</p> Notes <p>The <code>+</code> operator supports grouping:</p> <ul> <li><code>a + b + c</code> becomes a single summand (one \u201cgroup\u201d)</li> <li><code>(a + b) + (a + b)</code> becomes two summands (two \u201cgroups\u201d)</li> </ul> <p>Use <code>iter_summands()</code> to iterate over these groups in a deterministic way.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@dataclass\nclass FormulaConstruct:\n    \"\"\"\n    A composite formula expression built from parts.\n\n    `FormulaConstruct` stores a tree of nodes (`FormulaPart` and/or R objects)\n    representing expressions combined with `+`. It is primarily created by\n    calling the public formula helpers exposed by [`brmspy.brms`][brmspy.brms].\n\n    Notes\n    -----\n    The `+` operator supports grouping:\n\n    - `a + b + c` becomes a single summand (one \u201cgroup\u201d)\n    - `(a + b) + (a + b)` becomes two summands (two \u201cgroups\u201d)\n\n    Use [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands]\n    to iterate over these groups in a deterministic way.\n    \"\"\"\n\n    _parts: list[Node]\n\n    @classmethod\n    def _formula_parse(cls, obj: Other) -&gt; \"FormulaConstruct\":\n        \"\"\"\n        Convert a supported value into a `FormulaConstruct`.\n\n        Parameters\n        ----------\n        obj\n            One of: `FormulaConstruct`, `FormulaPart`, string (interpreted as `bf(&lt;string&gt;)`),\n            or `ProxyListSexpVector`.\n\n        Returns\n        -------\n        FormulaConstruct\n        \"\"\"\n        if isinstance(obj, FormulaConstruct):\n            return obj\n        if isinstance(obj, ProxyListSexpVector):\n            return FormulaConstruct(_parts=[obj])\n        if isinstance(obj, FormulaPart):\n            return FormulaConstruct(_parts=[obj])\n        if isinstance(obj, str):\n            part = FormulaPart(_fun=\"bf\", _args=[obj], _kwargs={})\n            return FormulaConstruct(_parts=[part])\n        raise TypeError(\n            f\"Cannot parse object of type {type(obj)!r} into FormulaConstruct\"\n        )\n\n    def __add__(self, other: Other):\n        \"\"\"\n        Combine two formula expressions with `+`.\n\n        Parameters\n        ----------\n        other\n            Value to add. Strings are treated as `bf(&lt;string&gt;)`.\n\n        Returns\n        -------\n        FormulaConstruct\n            New combined expression.\n        \"\"\"\n        if isinstance(other, (FormulaPart, str, ProxyListSexpVector)):\n            other = FormulaConstruct._formula_parse(other)\n\n        if not isinstance(other, FormulaConstruct):\n            raise ArithmeticError(\n                \"When adding values to formula, they must be FormulaConstruct or parseable to FormulaConstruct\"\n            )\n\n        if len(other._parts) &lt;= 1:\n            return FormulaConstruct(_parts=self._parts + other._parts)\n        else:\n            return FormulaConstruct(_parts=[self._parts, other._parts])\n\n    def __radd__(self, other: Other) -&gt; \"FormulaConstruct\":\n        \"\"\"Support `\"y ~ x\" + bf(\"z ~ 1\")` by coercing the left operand.\"\"\"\n        return self._formula_parse(other) + self\n\n    def iter_summands(self) -&gt; Iterator[Summand]:\n        \"\"\"\n        Iterate over arithmetic groups (summands).\n\n        Returns\n        -------\n        Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]\n            Each yielded tuple represents one summand/group.\n\n        Examples\n        --------\n        ```python\n        from brmspy.brms import bf, gaussian, set_rescor\n\n        f = bf(\"y ~ x\") + gaussian() + set_rescor(True)\n        for summand in f.iter_summands():\n            print(summand)\n        ```\n        \"\"\"\n\n        def _groups(node: Node) -&gt; Iterator[list[FormulaPart | ProxyListSexpVector]]:\n            # Leaf node: single bf/family/etc\n            if isinstance(node, (FormulaPart, ProxyListSexpVector)):\n                return ([node],)  # one group with one element\n\n            if isinstance(node, list):\n                # If any child is a list, this node represents a \"+\"\n                # between sub-expressions, so recurse into each child.\n                if any(isinstance(child, list) for child in node):\n                    for child in node:\n                        yield from _groups(child)\n                else:\n                    # All children are leaves -&gt; one summand\n                    out: list[FormulaPart | ProxyListSexpVector] = []\n                    for child in node:\n                        if isinstance(child, (FormulaPart, ProxyListSexpVector, Sexp)):\n                            child = cast(FormulaPart | ProxyListSexpVector, child)\n                            out.append(child)\n                        else:\n                            raise TypeError(\n                                f\"Unexpected leaf node type in FormulaConstruct: {type(child)!r}\"\n                            )\n                    yield out\n                return\n\n            raise TypeError(f\"Unexpected node type in FormulaConstruct: {type(node)!r}\")\n\n        # self._parts is always a list[Node]\n        for group in _groups(self._parts):\n            yield tuple(group)\n\n    # Make __iter__ return summands by default\n    def __iter__(self) -&gt; Iterator[Summand]:\n        \"\"\"Alias for [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands].\"\"\"\n        return self.iter_summands()\n\n    def iterate(self) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n        \"\"\"\n        Iterate over all leaf nodes in left-to-right order.\n\n        This flattens the expression tree, unlike\n        [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands], which\n        respects grouping.\n\n        Returns\n        -------\n        Iterator[FormulaPart | ProxyListSexpVector]\n        \"\"\"\n\n        def _walk(node: Node) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n            if isinstance(node, FormulaPart):\n                yield node\n            elif isinstance(node, ProxyListSexpVector):\n                yield node\n            elif isinstance(node, list):\n                for child in node:\n                    yield from _walk(child)\n            else:\n                raise TypeError(\n                    f\"Unexpected node type in FormulaConstruct: {type(node)!r}\"\n                )\n\n        for root in self._parts:\n            yield from _walk(root)\n\n    def __str__(self) -&gt; str:\n        return self._pretty(self._parts)\n\n    def _pretty(self, node, _outer=True) -&gt; str:\n        if isinstance(node, FormulaPart):\n            return str(node)\n\n        if isinstance(node, (ProxyListSexpVector, Sexp)):\n            return _sexp_to_str(node)\n\n        if isinstance(node, list):\n            # Pretty-print each child\n            rendered = [self._pretty(child, _outer=False) for child in node]\n\n            # If only one child, no parentheses needed\n            if len(rendered) == 1:\n                return rendered[0]\n\n            # Multiple children \u2192 join with \" + \"\n            inner = \" + \".join(rendered)\n            if _outer:\n                return inner\n            else:\n                return f\"({inner})\"\n\n        raise TypeError(f\"Unexpected node type {type(node)!r} in pretty-printer\")\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct._parts","title":"<code>_parts</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct._formula_parse","title":"<code>_formula_parse(obj)</code>  <code>classmethod</code>","text":"<p>Convert a supported value into a <code>FormulaConstruct</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Other</code> <p>One of: <code>FormulaConstruct</code>, <code>FormulaPart</code>, string (interpreted as <code>bf(&lt;string&gt;)</code>), or <code>ProxyListSexpVector</code>.</p> required <p>Returns:</p> Type Description <code>FormulaConstruct</code> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@classmethod\ndef _formula_parse(cls, obj: Other) -&gt; \"FormulaConstruct\":\n    \"\"\"\n    Convert a supported value into a `FormulaConstruct`.\n\n    Parameters\n    ----------\n    obj\n        One of: `FormulaConstruct`, `FormulaPart`, string (interpreted as `bf(&lt;string&gt;)`),\n        or `ProxyListSexpVector`.\n\n    Returns\n    -------\n    FormulaConstruct\n    \"\"\"\n    if isinstance(obj, FormulaConstruct):\n        return obj\n    if isinstance(obj, ProxyListSexpVector):\n        return FormulaConstruct(_parts=[obj])\n    if isinstance(obj, FormulaPart):\n        return FormulaConstruct(_parts=[obj])\n    if isinstance(obj, str):\n        part = FormulaPart(_fun=\"bf\", _args=[obj], _kwargs={})\n        return FormulaConstruct(_parts=[part])\n    raise TypeError(\n        f\"Cannot parse object of type {type(obj)!r} into FormulaConstruct\"\n    )\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct.__add__","title":"<code>__add__(other)</code>","text":"<p>Combine two formula expressions with <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Other</code> <p>Value to add. Strings are treated as <code>bf(&lt;string&gt;)</code>.</p> required <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>New combined expression.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __add__(self, other: Other):\n    \"\"\"\n    Combine two formula expressions with `+`.\n\n    Parameters\n    ----------\n    other\n        Value to add. Strings are treated as `bf(&lt;string&gt;)`.\n\n    Returns\n    -------\n    FormulaConstruct\n        New combined expression.\n    \"\"\"\n    if isinstance(other, (FormulaPart, str, ProxyListSexpVector)):\n        other = FormulaConstruct._formula_parse(other)\n\n    if not isinstance(other, FormulaConstruct):\n        raise ArithmeticError(\n            \"When adding values to formula, they must be FormulaConstruct or parseable to FormulaConstruct\"\n        )\n\n    if len(other._parts) &lt;= 1:\n        return FormulaConstruct(_parts=self._parts + other._parts)\n    else:\n        return FormulaConstruct(_parts=[self._parts, other._parts])\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Support <code>\"y ~ x\" + bf(\"z ~ 1\")</code> by coercing the left operand.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __radd__(self, other: Other) -&gt; \"FormulaConstruct\":\n    \"\"\"Support `\"y ~ x\" + bf(\"z ~ 1\")` by coercing the left operand.\"\"\"\n    return self._formula_parse(other) + self\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct.iter_summands","title":"<code>iter_summands()</code>","text":"<p>Iterate over arithmetic groups (summands).</p> <p>Returns:</p> Type Description <code>Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]</code> <p>Each yielded tuple represents one summand/group.</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, gaussian, set_rescor\n\nf = bf(\"y ~ x\") + gaussian() + set_rescor(True)\nfor summand in f.iter_summands():\n    print(summand)\n</code></pre> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def iter_summands(self) -&gt; Iterator[Summand]:\n    \"\"\"\n    Iterate over arithmetic groups (summands).\n\n    Returns\n    -------\n    Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]\n        Each yielded tuple represents one summand/group.\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, gaussian, set_rescor\n\n    f = bf(\"y ~ x\") + gaussian() + set_rescor(True)\n    for summand in f.iter_summands():\n        print(summand)\n    ```\n    \"\"\"\n\n    def _groups(node: Node) -&gt; Iterator[list[FormulaPart | ProxyListSexpVector]]:\n        # Leaf node: single bf/family/etc\n        if isinstance(node, (FormulaPart, ProxyListSexpVector)):\n            return ([node],)  # one group with one element\n\n        if isinstance(node, list):\n            # If any child is a list, this node represents a \"+\"\n            # between sub-expressions, so recurse into each child.\n            if any(isinstance(child, list) for child in node):\n                for child in node:\n                    yield from _groups(child)\n            else:\n                # All children are leaves -&gt; one summand\n                out: list[FormulaPart | ProxyListSexpVector] = []\n                for child in node:\n                    if isinstance(child, (FormulaPart, ProxyListSexpVector, Sexp)):\n                        child = cast(FormulaPart | ProxyListSexpVector, child)\n                        out.append(child)\n                    else:\n                        raise TypeError(\n                            f\"Unexpected leaf node type in FormulaConstruct: {type(child)!r}\"\n                        )\n                yield out\n            return\n\n        raise TypeError(f\"Unexpected node type in FormulaConstruct: {type(node)!r}\")\n\n    # self._parts is always a list[Node]\n    for group in _groups(self._parts):\n        yield tuple(group)\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct.__iter__","title":"<code>__iter__()</code>","text":"<p>Alias for <code>iter_summands()</code>.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Summand]:\n    \"\"\"Alias for [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands].\"\"\"\n    return self.iter_summands()\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct.iterate","title":"<code>iterate()</code>","text":"<p>Iterate over all leaf nodes in left-to-right order.</p> <p>This flattens the expression tree, unlike <code>iter_summands()</code>, which respects grouping.</p> <p>Returns:</p> Type Description <code>Iterator[FormulaPart | ProxyListSexpVector]</code> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def iterate(self) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n    \"\"\"\n    Iterate over all leaf nodes in left-to-right order.\n\n    This flattens the expression tree, unlike\n    [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands], which\n    respects grouping.\n\n    Returns\n    -------\n    Iterator[FormulaPart | ProxyListSexpVector]\n    \"\"\"\n\n    def _walk(node: Node) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n        if isinstance(node, FormulaPart):\n            yield node\n        elif isinstance(node, ProxyListSexpVector):\n            yield node\n        elif isinstance(node, list):\n            for child in node:\n                yield from _walk(child)\n        else:\n            raise TypeError(\n                f\"Unexpected node type in FormulaConstruct: {type(node)!r}\"\n            )\n\n    for root in self._parts:\n        yield from _walk(root)\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct.__str__","title":"<code>__str__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self._pretty(self._parts)\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct._pretty","title":"<code>_pretty(node, _outer=True)</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def _pretty(self, node, _outer=True) -&gt; str:\n    if isinstance(node, FormulaPart):\n        return str(node)\n\n    if isinstance(node, (ProxyListSexpVector, Sexp)):\n        return _sexp_to_str(node)\n\n    if isinstance(node, list):\n        # Pretty-print each child\n        rendered = [self._pretty(child, _outer=False) for child in node]\n\n        # If only one child, no parentheses needed\n        if len(rendered) == 1:\n            return rendered[0]\n\n        # Multiple children \u2192 join with \" + \"\n        inner = \" + \".join(rendered)\n        if _outer:\n            return inner\n        else:\n            return f\"({inner})\"\n\n    raise TypeError(f\"Unexpected node type {type(node)!r} in pretty-printer\")\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.FormulaConstruct.__init__","title":"<code>__init__(_parts)</code>","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior._execute_formula","title":"<code>_execute_formula(formula)</code>","text":"Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def _execute_formula(formula: FormulaConstruct | Sexp | str) -&gt; Sexp:\n    import rpy2.robjects as ro\n\n    if isinstance(formula, Sexp):\n        return formula\n    if isinstance(formula, str):\n        formula = FormulaConstruct._formula_parse(formula)\n\n    # Must run for formula functions, e.g me() to register\n    ro.r(\"library(brms)\")\n\n    fun_add = cast(Callable[[Sexp, Sexp], Sexp], ro.r(\"function (a, b) a + b\"))\n\n    result: Sexp | None = None\n    for summand in formula:\n        subresult: Sexp = py_to_r(summand[0])\n        for part in summand[1:]:\n            subresult = fun_add(subresult, py_to_r(part))\n\n        if result is None:\n            result = subresult\n        else:\n            result = fun_add(result, subresult)\n\n    assert result is not None\n    return result\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.kwargs_r","title":"<code>kwargs_r(kwargs)</code>","text":"<p>Convert Python keyword arguments to R-compatible format.</p> <p>Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict or None</code> <p>Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with same keys but R-compatible values, or empty dict if None</p> Notes <p>This is a thin wrapper around <code>py_to_r()</code> that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import kwargs_r\nimport pandas as pd\nimport numpy as np\n\n# Prepare kwargs for R function\npy_kwargs = {\n    'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n    'prior': {'b': [0, 1]},\n    'chains': 4,\n    'iter': 2000\n}\n\nr_kwargs = kwargs_r(py_kwargs)\n# All values converted to R objects\n# Can now call: r_function(**r_kwargs)\n</code></pre> See Also <p>py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def kwargs_r(kwargs: dict | None) -&gt; dict:\n    \"\"\"\n    Convert Python keyword arguments to R-compatible format.\n\n    Convenience function that applies py_to_r() to all values in a\n    keyword arguments dictionary, preparing them for R function calls.\n\n    Parameters\n    ----------\n    kwargs : dict or None\n        Dictionary of keyword arguments where values may be Python objects\n        (dicts, lists, DataFrames, arrays, etc.)\n\n    Returns\n    -------\n    dict\n        Dictionary with same keys but R-compatible values, or empty dict if None\n\n    Notes\n    -----\n    This is a thin wrapper around `py_to_r()` that operates on dictionaries.\n    It's commonly used to prepare keyword arguments for R function calls via rpy2.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import kwargs_r\n    import pandas as pd\n    import numpy as np\n\n    # Prepare kwargs for R function\n    py_kwargs = {\n        'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n        'prior': {'b': [0, 1]},\n        'chains': 4,\n        'iter': 2000\n    }\n\n    r_kwargs = kwargs_r(py_kwargs)\n    # All values converted to R objects\n    # Can now call: r_function(**r_kwargs)\n    ```\n\n    See Also\n    --------\n    py_to_r : Underlying conversion function for individual values\n    brmspy.brms.fit : Uses this to prepare user kwargs for R\n    \"\"\"\n    if kwargs is None:\n        return {}\n    return {k: py_to_r(v) for k, v in kwargs.items()}\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def py_to_r(obj: PyObject) -&gt; Sexp:\n    \"\"\"\n    Convert arbitrary Python objects to R objects via rpy2.\n\n    Comprehensive converter that handles nested structures (dicts, lists),\n    DataFrames, arrays, and scalars. Uses rpy2's converters with special\n    handling for dictionaries (\u2192 R named lists) and lists of dicts.\n\n    Parameters\n    ----------\n    obj : any\n        Python object to convert. Supported types:\n        - None \u2192 R NULL\n        - dict \u2192 R named list (ListVector), recursively\n        - list/tuple of dicts \u2192 R list of named lists\n        - list/tuple (other) \u2192 R vector or list\n        - pd.DataFrame \u2192 R data.frame\n        - np.ndarray \u2192 R vector/matrix\n        - scalars (int, float, str, bool) \u2192 R atomic types\n\n    Returns\n    -------\n    rpy2 R object\n        R representation of the Python object\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **None**: \u2192 R NULL\n    2. **DataFrames**: \u2192 R data.frame (via pandas2ri)\n    3. **Dictionaries**: \u2192 R named list (ListVector), recursively converting values\n    4. **Lists of dicts**: \u2192 R list with 1-based indexed names containing named lists\n    5. **Other lists/tuples**: \u2192 R vectors or lists (via rpy2 default)\n    6. **NumPy arrays**: \u2192 R vectors/matrices (via numpy2ri)\n    7. **Scalars**: \u2192 R atomic values\n\n    **Recursive Conversion:**\n\n    Dictionary values are recursively converted, allowing nested structures:\n    ```python\n    {'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n    ```\n\n    **List of Dicts:**\n\n    Lists containing only dicts are converted to R lists with 1-based indexing:\n    ```python\n    [{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n    ```\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import py_to_r\n    import numpy as np\n    import pandas as pd\n\n    # Scalars\n    py_to_r(5)        # R: 5\n    py_to_r(\"hello\")  # R: \"hello\"\n    py_to_r(None)     # R: NULL\n\n    # Arrays\n    py_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n    # DataFrames\n    df = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\n    py_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n    ```\n\n    See Also\n    --------\n    r_to_py : Convert R objects back to Python\n    kwargs_r : Convert keyword arguments dict for R function calls\n    brmspy.brms.fit : Uses this for converting data to R\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if obj is None:\n        return ro.NULL\n\n    if isinstance(obj, ro.Sexp):\n        return obj\n\n    if isinstance(obj, RListVectorExtension) and isinstance(obj.r, ro.Sexp):\n        return obj.r\n\n    _type = type(obj)\n    converter = None\n\n    if _type in _registry._PY2R_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._PY2R_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._PY2R_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._PY2R_CONVERTERS) &gt; 0, \"NO PY2R CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj)\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.r_to_py","title":"<code>r_to_py(obj, shm=None)</code>","text":"<p>Convert R objects to Python objects via rpy2.</p> <p>Comprehensive converter that handles R lists (named/unnamed), vectors, formulas, and language objects. Provides sensible Python equivalents for all R types with special handling for edge cases.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>rpy2 R object</code> <p>R object to convert to Python</p> required <p>Returns:</p> Type Description <code>any</code> <p>Python representation of the R object: - R NULL \u2192 None - Named list \u2192 dict (recursively) - Unnamed list \u2192 list (recursively) - Length-1 vector \u2192 scalar (int, float, str, bool) - Length-N vector \u2192 list of scalars - Formula/Language object \u2192 str (descriptive representation) - Other objects \u2192 default rpy2 conversion or str fallback</p> Notes <p>Conversion Rules:</p> <ol> <li>R NULL: \u2192 Python None</li> <li>Atomic vectors (numeric, character, logical):</li> <li>Length 1: \u2192 Python scalar (int, float, str, bool)</li> <li>Length &gt;1: \u2192 Python list of scalars</li> <li>Named lists (ListVector with names): \u2192 Python dict, recursively</li> <li>Unnamed lists: \u2192 Python list, recursively</li> <li>Formulas (e.g., <code>y ~ x</code>): \u2192 String representation</li> <li>Language objects (calls, expressions): \u2192 String representation</li> <li>Functions: \u2192 String representation</li> <li>Everything else: Try default rpy2 conversion, fallback to string</li> </ol> <p>Recursive Conversion:</p> <p>List elements and dictionary values are recursively converted: <pre><code>list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n</code></pre></p> <p>Safe Fallback:</p> <p>R language objects, formulas, and functions are converted to descriptive strings rather than attempting complex conversions that might fail.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import r_to_py\nimport rpy2.robjects as ro\n\n# R NULL\nr_to_py(ro.NULL)  # None\n\n# Scalars\nr_to_py(ro.IntVector([5]))    # 5\nr_to_py(ro.FloatVector([3.14]))  # 3.14\nr_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n# Vectors\nr_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n</code></pre> See Also <p>py_to_r : Convert Python objects to R brmspy.brms.summary : Returns Python-friendly summary dict</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def r_to_py(obj: Sexp, shm: ShmPool | None = None) -&gt; PyObject:\n    \"\"\"\n    Convert R objects to Python objects via rpy2.\n\n    Comprehensive converter that handles R lists (named/unnamed), vectors,\n    formulas, and language objects. Provides sensible Python equivalents\n    for all R types with special handling for edge cases.\n\n    Parameters\n    ----------\n    obj : rpy2 R object\n        R object to convert to Python\n\n    Returns\n    -------\n    any\n        Python representation of the R object:\n        - R NULL \u2192 None\n        - Named list \u2192 dict (recursively)\n        - Unnamed list \u2192 list (recursively)\n        - Length-1 vector \u2192 scalar (int, float, str, bool)\n        - Length-N vector \u2192 list of scalars\n        - Formula/Language object \u2192 str (descriptive representation)\n        - Other objects \u2192 default rpy2 conversion or str fallback\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **R NULL**: \u2192 Python None\n    2. **Atomic vectors** (numeric, character, logical):\n       - Length 1: \u2192 Python scalar (int, float, str, bool)\n       - Length &gt;1: \u2192 Python list of scalars\n    3. **Named lists** (ListVector with names): \u2192 Python dict, recursively\n    4. **Unnamed lists**: \u2192 Python list, recursively\n    5. **Formulas** (e.g., `y ~ x`): \u2192 String representation\n    6. **Language objects** (calls, expressions): \u2192 String representation\n    7. **Functions**: \u2192 String representation\n    8. **Everything else**: Try default rpy2 conversion, fallback to string\n\n    **Recursive Conversion:**\n\n    List elements and dictionary values are recursively converted:\n    ```R\n    list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n    ```\n\n    **Safe Fallback:**\n\n    R language objects, formulas, and functions are converted to descriptive\n    strings rather than attempting complex conversions that might fail.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import r_to_py\n    import rpy2.robjects as ro\n\n    # R NULL\n    r_to_py(ro.NULL)  # None\n\n    # Scalars\n    r_to_py(ro.IntVector([5]))    # 5\n    r_to_py(ro.FloatVector([3.14]))  # 3.14\n    r_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n    # Vectors\n    r_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n    ```\n\n    See Also\n    --------\n    py_to_r : Convert Python objects to R\n    brmspy.brms.summary : Returns Python-friendly summary dict\n    \"\"\"\n    import rpy2.robjects as ro\n\n    from brmspy._singleton._shm_singleton import _get_shm\n\n    if obj is ro.NULL:\n        return None\n\n    _type = type(obj)\n    converter = None\n\n    if shm is None:\n        shm = _get_shm()\n\n    if _type in _registry._R2PY_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._R2PY_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._R2PY_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._R2PY_CONVERTERS) &gt; 0, \"NO R2PY CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj, shm)\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.prior","title":"<code>prior(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None, **kwargs)</code>","text":"<p>Create a brms-style prior specification.</p> <p>This function mirrors the behavior of <code>brms::prior_string()</code> and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of <code>prior_string()</code> in brms.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>str</code> <p>The prior definition as a string, exactly as brms expects it. Examples include ::</p> <pre><code>\"normal(0, 1)\"\n\"student_t(3, 0, 1.5)\"\n\"exponential(2)\"\n\"lkj(2)\"\n</code></pre> required <code>class_</code> <code>str</code> <p>Parameter class (e.g. <code>\"b\"</code>, <code>\"sd\"</code>, <code>\"Intercept\"</code>). This corresponds to <code>class</code> in brms. <code>class</code> cannot be used as a parameter in Python (reserved keyword), so <code>class_</code> is used instead.</p> <code>None</code> <code>coef</code> <code>str</code> <p>Coefficient name for class-level effects.</p> <code>None</code> <code>group</code> <code>str</code> <p>Grouping variable for hierarchical/multilevel effects.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Distributional parameter (e.g. <code>\"sigma\"</code> or <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response variable name for multivariate models.</p> <code>None</code> <code>nlpar</code> <code>str</code> <p>Nonlinear parameter name if using nonlinear formulas.</p> <code>None</code> <code>lb</code> <code>float</code> <p>Lower bound for truncated priors.</p> <code>None</code> <code>ub</code> <code>float</code> <p>Upper bound for truncated priors.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Any additional keyword arguments supported by <code>brms::prior_string()</code>. These are forwarded unchanged.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriorSpec</code> <p>A typed prior specification object used by <code>brmspy.brms.brm()</code> and <code>brmspy.brms.make_stancode()</code>.</p> See Also <p>brms::prior_string : R documentation</p> Notes <p>This function does not validate the prior expression string itself \u2014 validation occurs inside brms.</p> <p>Examples:</p> <pre><code>from brmspy.brms import prior\n\np_intercept = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\")\np_slope = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\np_sd = prior(\"exponential(2)\", class_=\"sd\", group=\"region\")\np_trunc = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0)\n</code></pre> Source code in <code>brmspy/_brms_functions/prior.py</code> <pre><code>def prior(\n    prior: str,\n    class_: str | None = None,\n    coef: str | None = None,\n    group: str | None = None,\n    dpar: str | None = None,\n    resp: str | None = None,\n    nlpar: str | None = None,\n    lb: float | None = None,\n    ub: float | None = None,\n    **kwargs: Any,\n) -&gt; PriorSpec:\n    \"\"\"\n    Create a brms-style prior specification.\n\n    This function mirrors the behavior of ``brms::prior_string()`` and allows\n    specifying priors for regression parameters, group-level effects, nonlinear\n    parameters, distributional parameters, and more \u2014 using a typed Python\n    interface. All arguments correspond directly to the parameters of\n    ``prior_string()`` in brms.\n\n    Parameters\n    ----------\n    prior : str\n        The prior definition as a string, exactly as brms expects it.\n        Examples include ::\n\n            \"normal(0, 1)\"\n            \"student_t(3, 0, 1.5)\"\n            \"exponential(2)\"\n            \"lkj(2)\"\n\n    class_ : str, optional\n        Parameter class (e.g. ``\"b\"``, ``\"sd\"``, ``\"Intercept\"``).\n        This corresponds to ``class`` in brms. ``class`` cannot be used as a\n        parameter in Python (reserved keyword), so ``class_`` is used instead.\n\n    coef : str, optional\n        Coefficient name for class-level effects.\n\n    group : str, optional\n        Grouping variable for hierarchical/multilevel effects.\n\n    dpar : str, optional\n        Distributional parameter (e.g. ``\"sigma\"`` or ``\"phi\"``).\n\n    resp : str, optional\n        Response variable name for multivariate models.\n\n    nlpar : str, optional\n        Nonlinear parameter name if using nonlinear formulas.\n\n    lb : float, optional\n        Lower bound for truncated priors.\n\n    ub : float, optional\n        Upper bound for truncated priors.\n\n    **kwargs\n        Any additional keyword arguments supported by ``brms::prior_string()``.\n        These are forwarded unchanged.\n\n    Returns\n    -------\n    PriorSpec\n        A typed prior specification object used by `brmspy.brms.brm()` and\n        `brmspy.brms.make_stancode()`.\n\n    See Also\n    --------\n    brms::prior_string : [R documentation](https://paulbuerkner.com/brms/reference/prior_string.html)\n\n    Notes\n    -----\n    This function does **not** validate the prior expression string itself \u2014\n    validation occurs inside brms.\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import prior\n\n    p_intercept = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\")\n    p_slope = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n    p_sd = prior(\"exponential(2)\", class_=\"sd\", group=\"region\")\n    p_trunc = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0)\n    ```\n    \"\"\"\n    if \"class\" in kwargs:\n        kwargs[\"class_\"] = kwargs[\"class\"]\n\n    return PriorSpec(\n        prior=prior,\n        class_=class_,\n        coef=coef,\n        group=group,\n        dpar=dpar,\n        resp=resp,\n        nlpar=nlpar,\n        lb=lb,\n        ub=ub,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.get_prior","title":"<code>get_prior(formula, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for a model specification.</p> <p>Wrapper around R <code>brms::get_prior()</code>.</p> <p>Returns a DataFrame with default priors for each parameter class in the specified brms model. Useful for reviewing and customizing priors before fitting.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula (e.g. <code>\"y ~ x + (1|group)\"</code>) or a composed formula.</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListSexpVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\")</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row represents a parameter or parameter class that can have a custom prior.</p> See Also <p>default_prior : Generic function for getting default priors prior : Create custom prior specifications brms::get_prior : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms import prior\n\npriors_df = brms.get_prior(\"y ~ x\", data=df)\n\ncustom_priors = [\n    prior(\"normal(0, 0.5)\", class_=\"b\"),\n    prior(\"exponential(2)\", class_=\"sigma\"),\n]\n\nfit = brms.brm(\"y ~ x\", data=df, priors=custom_priors, chains=4)\n</code></pre> Source code in <code>brmspy/_brms_functions/prior.py</code> <pre><code>def get_prior(\n    formula: str | FormulaConstruct, data=None, family=\"gaussian\", **kwargs\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Get default priors for a model specification.\n\n    Wrapper around R ``brms::get_prior()``.\n\n    Returns a DataFrame with default priors for each parameter class in the specified\n    brms model. Useful for reviewing and customizing priors before fitting.\n\n    Parameters\n    ----------\n    formula : str or FormulaConstruct\n        Model formula (e.g. ``\"y ~ x + (1|group)\"``) or a composed formula.\n    data : pd.DataFrame or dict, optional\n        Dataset containing model variables. Required for data-dependent priors\n    family : str or ListSexpVector, default=\"gaussian\"\n        Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\")\n    **kwargs\n        Additional arguments passed to brms::get_prior()\n        (e.g., autocor, data2, knots, drop_unused_levels)\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source.\n        Each row represents a parameter or parameter class that can have a custom prior.\n\n    See Also\n    --------\n    default_prior : Generic function for getting default priors\n    prior : Create custom prior specifications\n    brms::get_prior : [R documentation](https://paulbuerkner.com/brms/reference/get_prior.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n    from brmspy.brms import prior\n\n    priors_df = brms.get_prior(\"y ~ x\", data=df)\n\n    custom_priors = [\n        prior(\"normal(0, 0.5)\", class_=\"b\"),\n        prior(\"exponential(2)\", class_=\"sigma\"),\n    ]\n\n    fit = brms.brm(\"y ~ x\", data=df, priors=custom_priors, chains=4)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    formula_obj = _execute_formula(formula)\n\n    r_get_prior = cast(Callable, ro.r(\"brms::get_prior\"))\n    collected_args = kwargs_r(\n        {\"formula\": formula_obj, \"data\": data, \"family\": family, **kwargs}\n    )\n\n    df_r = r_get_prior(**collected_args)\n    df = pd.DataFrame(cast(Any, r_to_py(df_r)))\n\n    return df\n</code></pre>"},{"location":"internals/_brms_functions/prior/#brmspy._brms_functions.prior.default_prior","title":"<code>default_prior(object, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for brms model parameters (generic function).</p> <p>Wrapper around R <code>brms::default_prior()</code>.</p> <p>Generic function to retrieve default prior specifications for all parameters in a brms model. Accepts formula objects, brmsformula objects, or other model specification objects. This is the generic version of get_prior().</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>str, FormulaResult, or ListSexpVector</code> <p>Model specification: formula string, brmsformula object, mvbrmsformula, or any object that can be coerced to these classes</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListSexpVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\"). Can be a list of families for multivariate models</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels, sparse)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row specifies a parameter class with its default prior. The 'prior' column is empty except for internal defaults.</p> See Also <p>get_prior : Convenience function with formula parameter prior : Create custom prior specifications brms::default_prior : R documentation</p> <p>Examples:</p> <p>Get default priors for a Poisson model:</p> <pre><code>from brmspy import brms\n\npriors = brms.default_prior(\n    object=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\nprint(priors)\n</code></pre> <p>Use with formula object:</p> <pre><code>from brmspy import brms\n\nf = brms.formula(\"y ~ x + (1|group)\")\npriors = brms.default_prior(f, data=df, family=\"gaussian\")\n</code></pre> Source code in <code>brmspy/_brms_functions/prior.py</code> <pre><code>def default_prior(\n    object: RListVectorExtension | ListSexpVector | FormulaConstruct | str,\n    data=None,\n    family=\"gaussian\",\n    **kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Get default priors for brms model parameters (generic function).\n\n    Wrapper around R ``brms::default_prior()``.\n\n    Generic function to retrieve default prior specifications for all parameters\n    in a brms model. Accepts formula objects, brmsformula objects, or other model\n    specification objects. This is the generic version of get_prior().\n\n    Parameters\n    ----------\n    object : str, FormulaResult, or ListSexpVector\n        Model specification: formula string, brmsformula object, mvbrmsformula,\n        or any object that can be coerced to these classes\n    data : pd.DataFrame or dict, optional\n        Dataset containing model variables. Required for data-dependent priors\n    family : str or ListSexpVector, default=\"gaussian\"\n        Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\").\n        Can be a list of families for multivariate models\n    **kwargs\n        Additional arguments passed to brms::get_prior()\n        (e.g., autocor, data2, knots, drop_unused_levels, sparse)\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source.\n        Each row specifies a parameter class with its default prior. The 'prior' column\n        is empty except for internal defaults.\n\n    See Also\n    --------\n    get_prior : Convenience function with formula parameter\n    prior : Create custom prior specifications\n    brms::default_prior : [R documentation](https://paulbuerkner.com/brms/reference/default_prior.html)\n\n    Examples\n    --------\n    Get default priors for a Poisson model:\n\n    ```python\n    from brmspy import brms\n\n    priors = brms.default_prior(\n        object=\"count ~ zAge + zBase * Trt + (1|patient)\",\n        data=epilepsy,\n        family=\"poisson\"\n    )\n    print(priors)\n    ```\n\n    Use with formula object:\n\n    ```python\n    from brmspy import brms\n\n    f = brms.formula(\"y ~ x + (1|group)\")\n    priors = brms.default_prior(f, data=df, family=\"gaussian\")\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    r_get_prior = cast(Callable, ro.r(\"brms::get_prior\"))\n    collected_args = kwargs_r({\"data\": data, \"family\": family, **kwargs})\n\n    obj_resolved = object\n    if isinstance(object, FormulaConstruct):\n        obj_resolved = _execute_formula(object)\n\n    df_r = r_get_prior(py_to_r(obj_resolved), **collected_args)\n    df = pd.DataFrame(cast(Any, r_to_py(df_r)))\n\n    return df\n</code></pre>"},{"location":"internals/_brms_functions/stan/","title":"stan","text":"<p>Stan code helpers.</p> <p>This module exposes wrappers for generating Stan code from brms models without running sampling.</p> Notes <p>Executed inside the worker process that hosts the embedded R session.</p>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan._formula_fn","title":"<code>_formula_fn = bf</code>  <code>module-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan-classes","title":"Classes","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct","title":"<code>FormulaConstruct</code>  <code>dataclass</code>","text":"<p>A composite formula expression built from parts.</p> <p><code>FormulaConstruct</code> stores a tree of nodes (<code>FormulaPart</code> and/or R objects) representing expressions combined with <code>+</code>. It is primarily created by calling the public formula helpers exposed by <code>brmspy.brms</code>.</p> Notes <p>The <code>+</code> operator supports grouping:</p> <ul> <li><code>a + b + c</code> becomes a single summand (one \u201cgroup\u201d)</li> <li><code>(a + b) + (a + b)</code> becomes two summands (two \u201cgroups\u201d)</li> </ul> <p>Use <code>iter_summands()</code> to iterate over these groups in a deterministic way.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@dataclass\nclass FormulaConstruct:\n    \"\"\"\n    A composite formula expression built from parts.\n\n    `FormulaConstruct` stores a tree of nodes (`FormulaPart` and/or R objects)\n    representing expressions combined with `+`. It is primarily created by\n    calling the public formula helpers exposed by [`brmspy.brms`][brmspy.brms].\n\n    Notes\n    -----\n    The `+` operator supports grouping:\n\n    - `a + b + c` becomes a single summand (one \u201cgroup\u201d)\n    - `(a + b) + (a + b)` becomes two summands (two \u201cgroups\u201d)\n\n    Use [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands]\n    to iterate over these groups in a deterministic way.\n    \"\"\"\n\n    _parts: list[Node]\n\n    @classmethod\n    def _formula_parse(cls, obj: Other) -&gt; \"FormulaConstruct\":\n        \"\"\"\n        Convert a supported value into a `FormulaConstruct`.\n\n        Parameters\n        ----------\n        obj\n            One of: `FormulaConstruct`, `FormulaPart`, string (interpreted as `bf(&lt;string&gt;)`),\n            or `ProxyListSexpVector`.\n\n        Returns\n        -------\n        FormulaConstruct\n        \"\"\"\n        if isinstance(obj, FormulaConstruct):\n            return obj\n        if isinstance(obj, ProxyListSexpVector):\n            return FormulaConstruct(_parts=[obj])\n        if isinstance(obj, FormulaPart):\n            return FormulaConstruct(_parts=[obj])\n        if isinstance(obj, str):\n            part = FormulaPart(_fun=\"bf\", _args=[obj], _kwargs={})\n            return FormulaConstruct(_parts=[part])\n        raise TypeError(\n            f\"Cannot parse object of type {type(obj)!r} into FormulaConstruct\"\n        )\n\n    def __add__(self, other: Other):\n        \"\"\"\n        Combine two formula expressions with `+`.\n\n        Parameters\n        ----------\n        other\n            Value to add. Strings are treated as `bf(&lt;string&gt;)`.\n\n        Returns\n        -------\n        FormulaConstruct\n            New combined expression.\n        \"\"\"\n        if isinstance(other, (FormulaPart, str, ProxyListSexpVector)):\n            other = FormulaConstruct._formula_parse(other)\n\n        if not isinstance(other, FormulaConstruct):\n            raise ArithmeticError(\n                \"When adding values to formula, they must be FormulaConstruct or parseable to FormulaConstruct\"\n            )\n\n        if len(other._parts) &lt;= 1:\n            return FormulaConstruct(_parts=self._parts + other._parts)\n        else:\n            return FormulaConstruct(_parts=[self._parts, other._parts])\n\n    def __radd__(self, other: Other) -&gt; \"FormulaConstruct\":\n        \"\"\"Support `\"y ~ x\" + bf(\"z ~ 1\")` by coercing the left operand.\"\"\"\n        return self._formula_parse(other) + self\n\n    def iter_summands(self) -&gt; Iterator[Summand]:\n        \"\"\"\n        Iterate over arithmetic groups (summands).\n\n        Returns\n        -------\n        Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]\n            Each yielded tuple represents one summand/group.\n\n        Examples\n        --------\n        ```python\n        from brmspy.brms import bf, gaussian, set_rescor\n\n        f = bf(\"y ~ x\") + gaussian() + set_rescor(True)\n        for summand in f.iter_summands():\n            print(summand)\n        ```\n        \"\"\"\n\n        def _groups(node: Node) -&gt; Iterator[list[FormulaPart | ProxyListSexpVector]]:\n            # Leaf node: single bf/family/etc\n            if isinstance(node, (FormulaPart, ProxyListSexpVector)):\n                return ([node],)  # one group with one element\n\n            if isinstance(node, list):\n                # If any child is a list, this node represents a \"+\"\n                # between sub-expressions, so recurse into each child.\n                if any(isinstance(child, list) for child in node):\n                    for child in node:\n                        yield from _groups(child)\n                else:\n                    # All children are leaves -&gt; one summand\n                    out: list[FormulaPart | ProxyListSexpVector] = []\n                    for child in node:\n                        if isinstance(child, (FormulaPart, ProxyListSexpVector, Sexp)):\n                            child = cast(FormulaPart | ProxyListSexpVector, child)\n                            out.append(child)\n                        else:\n                            raise TypeError(\n                                f\"Unexpected leaf node type in FormulaConstruct: {type(child)!r}\"\n                            )\n                    yield out\n                return\n\n            raise TypeError(f\"Unexpected node type in FormulaConstruct: {type(node)!r}\")\n\n        # self._parts is always a list[Node]\n        for group in _groups(self._parts):\n            yield tuple(group)\n\n    # Make __iter__ return summands by default\n    def __iter__(self) -&gt; Iterator[Summand]:\n        \"\"\"Alias for [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands].\"\"\"\n        return self.iter_summands()\n\n    def iterate(self) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n        \"\"\"\n        Iterate over all leaf nodes in left-to-right order.\n\n        This flattens the expression tree, unlike\n        [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands], which\n        respects grouping.\n\n        Returns\n        -------\n        Iterator[FormulaPart | ProxyListSexpVector]\n        \"\"\"\n\n        def _walk(node: Node) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n            if isinstance(node, FormulaPart):\n                yield node\n            elif isinstance(node, ProxyListSexpVector):\n                yield node\n            elif isinstance(node, list):\n                for child in node:\n                    yield from _walk(child)\n            else:\n                raise TypeError(\n                    f\"Unexpected node type in FormulaConstruct: {type(node)!r}\"\n                )\n\n        for root in self._parts:\n            yield from _walk(root)\n\n    def __str__(self) -&gt; str:\n        return self._pretty(self._parts)\n\n    def _pretty(self, node, _outer=True) -&gt; str:\n        if isinstance(node, FormulaPart):\n            return str(node)\n\n        if isinstance(node, (ProxyListSexpVector, Sexp)):\n            return _sexp_to_str(node)\n\n        if isinstance(node, list):\n            # Pretty-print each child\n            rendered = [self._pretty(child, _outer=False) for child in node]\n\n            # If only one child, no parentheses needed\n            if len(rendered) == 1:\n                return rendered[0]\n\n            # Multiple children \u2192 join with \" + \"\n            inner = \" + \".join(rendered)\n            if _outer:\n                return inner\n            else:\n                return f\"({inner})\"\n\n        raise TypeError(f\"Unexpected node type {type(node)!r} in pretty-printer\")\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct._parts","title":"<code>_parts</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct._formula_parse","title":"<code>_formula_parse(obj)</code>  <code>classmethod</code>","text":"<p>Convert a supported value into a <code>FormulaConstruct</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Other</code> <p>One of: <code>FormulaConstruct</code>, <code>FormulaPart</code>, string (interpreted as <code>bf(&lt;string&gt;)</code>), or <code>ProxyListSexpVector</code>.</p> required <p>Returns:</p> Type Description <code>FormulaConstruct</code> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@classmethod\ndef _formula_parse(cls, obj: Other) -&gt; \"FormulaConstruct\":\n    \"\"\"\n    Convert a supported value into a `FormulaConstruct`.\n\n    Parameters\n    ----------\n    obj\n        One of: `FormulaConstruct`, `FormulaPart`, string (interpreted as `bf(&lt;string&gt;)`),\n        or `ProxyListSexpVector`.\n\n    Returns\n    -------\n    FormulaConstruct\n    \"\"\"\n    if isinstance(obj, FormulaConstruct):\n        return obj\n    if isinstance(obj, ProxyListSexpVector):\n        return FormulaConstruct(_parts=[obj])\n    if isinstance(obj, FormulaPart):\n        return FormulaConstruct(_parts=[obj])\n    if isinstance(obj, str):\n        part = FormulaPart(_fun=\"bf\", _args=[obj], _kwargs={})\n        return FormulaConstruct(_parts=[part])\n    raise TypeError(\n        f\"Cannot parse object of type {type(obj)!r} into FormulaConstruct\"\n    )\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct.__add__","title":"<code>__add__(other)</code>","text":"<p>Combine two formula expressions with <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Other</code> <p>Value to add. Strings are treated as <code>bf(&lt;string&gt;)</code>.</p> required <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>New combined expression.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __add__(self, other: Other):\n    \"\"\"\n    Combine two formula expressions with `+`.\n\n    Parameters\n    ----------\n    other\n        Value to add. Strings are treated as `bf(&lt;string&gt;)`.\n\n    Returns\n    -------\n    FormulaConstruct\n        New combined expression.\n    \"\"\"\n    if isinstance(other, (FormulaPart, str, ProxyListSexpVector)):\n        other = FormulaConstruct._formula_parse(other)\n\n    if not isinstance(other, FormulaConstruct):\n        raise ArithmeticError(\n            \"When adding values to formula, they must be FormulaConstruct or parseable to FormulaConstruct\"\n        )\n\n    if len(other._parts) &lt;= 1:\n        return FormulaConstruct(_parts=self._parts + other._parts)\n    else:\n        return FormulaConstruct(_parts=[self._parts, other._parts])\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Support <code>\"y ~ x\" + bf(\"z ~ 1\")</code> by coercing the left operand.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __radd__(self, other: Other) -&gt; \"FormulaConstruct\":\n    \"\"\"Support `\"y ~ x\" + bf(\"z ~ 1\")` by coercing the left operand.\"\"\"\n    return self._formula_parse(other) + self\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct.iter_summands","title":"<code>iter_summands()</code>","text":"<p>Iterate over arithmetic groups (summands).</p> <p>Returns:</p> Type Description <code>Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]</code> <p>Each yielded tuple represents one summand/group.</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, gaussian, set_rescor\n\nf = bf(\"y ~ x\") + gaussian() + set_rescor(True)\nfor summand in f.iter_summands():\n    print(summand)\n</code></pre> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def iter_summands(self) -&gt; Iterator[Summand]:\n    \"\"\"\n    Iterate over arithmetic groups (summands).\n\n    Returns\n    -------\n    Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]\n        Each yielded tuple represents one summand/group.\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, gaussian, set_rescor\n\n    f = bf(\"y ~ x\") + gaussian() + set_rescor(True)\n    for summand in f.iter_summands():\n        print(summand)\n    ```\n    \"\"\"\n\n    def _groups(node: Node) -&gt; Iterator[list[FormulaPart | ProxyListSexpVector]]:\n        # Leaf node: single bf/family/etc\n        if isinstance(node, (FormulaPart, ProxyListSexpVector)):\n            return ([node],)  # one group with one element\n\n        if isinstance(node, list):\n            # If any child is a list, this node represents a \"+\"\n            # between sub-expressions, so recurse into each child.\n            if any(isinstance(child, list) for child in node):\n                for child in node:\n                    yield from _groups(child)\n            else:\n                # All children are leaves -&gt; one summand\n                out: list[FormulaPart | ProxyListSexpVector] = []\n                for child in node:\n                    if isinstance(child, (FormulaPart, ProxyListSexpVector, Sexp)):\n                        child = cast(FormulaPart | ProxyListSexpVector, child)\n                        out.append(child)\n                    else:\n                        raise TypeError(\n                            f\"Unexpected leaf node type in FormulaConstruct: {type(child)!r}\"\n                        )\n                yield out\n            return\n\n        raise TypeError(f\"Unexpected node type in FormulaConstruct: {type(node)!r}\")\n\n    # self._parts is always a list[Node]\n    for group in _groups(self._parts):\n        yield tuple(group)\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct.__iter__","title":"<code>__iter__()</code>","text":"<p>Alias for <code>iter_summands()</code>.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Summand]:\n    \"\"\"Alias for [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands].\"\"\"\n    return self.iter_summands()\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct.iterate","title":"<code>iterate()</code>","text":"<p>Iterate over all leaf nodes in left-to-right order.</p> <p>This flattens the expression tree, unlike <code>iter_summands()</code>, which respects grouping.</p> <p>Returns:</p> Type Description <code>Iterator[FormulaPart | ProxyListSexpVector]</code> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def iterate(self) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n    \"\"\"\n    Iterate over all leaf nodes in left-to-right order.\n\n    This flattens the expression tree, unlike\n    [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands], which\n    respects grouping.\n\n    Returns\n    -------\n    Iterator[FormulaPart | ProxyListSexpVector]\n    \"\"\"\n\n    def _walk(node: Node) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n        if isinstance(node, FormulaPart):\n            yield node\n        elif isinstance(node, ProxyListSexpVector):\n            yield node\n        elif isinstance(node, list):\n            for child in node:\n                yield from _walk(child)\n        else:\n            raise TypeError(\n                f\"Unexpected node type in FormulaConstruct: {type(node)!r}\"\n            )\n\n    for root in self._parts:\n        yield from _walk(root)\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct.__str__","title":"<code>__str__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self._pretty(self._parts)\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct._pretty","title":"<code>_pretty(node, _outer=True)</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def _pretty(self, node, _outer=True) -&gt; str:\n    if isinstance(node, FormulaPart):\n        return str(node)\n\n    if isinstance(node, (ProxyListSexpVector, Sexp)):\n        return _sexp_to_str(node)\n\n    if isinstance(node, list):\n        # Pretty-print each child\n        rendered = [self._pretty(child, _outer=False) for child in node]\n\n        # If only one child, no parentheses needed\n        if len(rendered) == 1:\n            return rendered[0]\n\n        # Multiple children \u2192 join with \" + \"\n        inner = \" + \".join(rendered)\n        if _outer:\n            return inner\n        else:\n            return f\"({inner})\"\n\n    raise TypeError(f\"Unexpected node type {type(node)!r} in pretty-printer\")\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaConstruct.__init__","title":"<code>__init__(_parts)</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaPart","title":"<code>FormulaPart</code>  <code>dataclass</code>","text":"<p>A single formula helper invocation.</p> <p>Instances of this type represent a call like <code>bf(\"y ~ x\")</code> or <code>set_rescor(True)</code> without executing anything. They are primarily used as nodes inside a <code>FormulaConstruct</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_fun</code> <code>Literal[...]</code> <p>Whitelisted formula helper name.</p> required <code>_args</code> <code>Sequence[Primitive]</code> <p>Positional arguments for the helper.</p> required <code>_kwargs</code> <code>Mapping[str, Primitive]</code> <p>Keyword arguments for the helper.</p> required Notes <p>This is a low-level type. Most users should construct these via the public helper functions in <code>brmspy.brms</code>.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@dataclass\nclass FormulaPart:\n    \"\"\"\n    A single formula helper invocation.\n\n    Instances of this type represent a call like `bf(\"y ~ x\")` or `set_rescor(True)`\n    without executing anything. They are primarily used as nodes inside a\n    [`FormulaConstruct`][brmspy.types.formula_dsl.FormulaConstruct].\n\n    Parameters\n    ----------\n    _fun : Literal[...]\n        Whitelisted formula helper name.\n    _args : Sequence[Primitive]\n        Positional arguments for the helper.\n    _kwargs : Mapping[str, Primitive]\n        Keyword arguments for the helper.\n\n    Notes\n    -----\n    This is a low-level type. Most users should construct these via the public\n    helper functions in [`brmspy.brms`][brmspy.brms].\n    \"\"\"\n\n    _fun: _FORMULA_FUNCTION_WHITELIST\n    _args: Sequence[Primitive]\n    _kwargs: Mapping[str, Primitive]\n\n    def __post_init__(self):\n        \"\"\"Validate `_fun`, `_args`, and `_kwargs` types after construction.\"\"\"\n        # Validate function name first\n        if self._fun not in get_args(_FORMULA_FUNCTION_WHITELIST):\n            raise ValueError(\n                f\"FormulaPart._fun must be one of {_FORMULA_FUNCTION_WHITELIST!r}, \"\n                f\"got {self._fun!r}\"\n            )\n\n        # Enforce _args is a list\n        if not isinstance(self._args, Sequence):\n            raise TypeError(\n                f\"FormulaPart._args must be a Sequence, got {type(self._args).__name__}\"\n            )\n\n        # Enforce _kwargs is a dict\n        if not isinstance(self._kwargs, Mapping):\n            raise TypeError(\n                f\"FormulaPart._kwargs must be a Mapping, got {type(self._kwargs).__name__}\"\n            )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Render a readable `fun(arg1, ..., kw=...)` representation.\"\"\"\n        args = \", \".join(repr(a) for a in self._args)\n        kwargs = \", \".join(f\"{k}={v!r}\" for k, v in self._kwargs.items())\n        inner = \", \".join(x for x in (args, kwargs) if x)\n        return f\"{self._fun}({inner})\"\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaPart-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaPart._fun","title":"<code>_fun</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaPart._args","title":"<code>_args</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaPart._kwargs","title":"<code>_kwargs</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaPart-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaPart.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate <code>_fun</code>, <code>_args</code>, and <code>_kwargs</code> types after construction.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validate `_fun`, `_args`, and `_kwargs` types after construction.\"\"\"\n    # Validate function name first\n    if self._fun not in get_args(_FORMULA_FUNCTION_WHITELIST):\n        raise ValueError(\n            f\"FormulaPart._fun must be one of {_FORMULA_FUNCTION_WHITELIST!r}, \"\n            f\"got {self._fun!r}\"\n        )\n\n    # Enforce _args is a list\n    if not isinstance(self._args, Sequence):\n        raise TypeError(\n            f\"FormulaPart._args must be a Sequence, got {type(self._args).__name__}\"\n        )\n\n    # Enforce _kwargs is a dict\n    if not isinstance(self._kwargs, Mapping):\n        raise TypeError(\n            f\"FormulaPart._kwargs must be a Mapping, got {type(self._kwargs).__name__}\"\n        )\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaPart.__str__","title":"<code>__str__()</code>","text":"<p>Render a readable <code>fun(arg1, ..., kw=...)</code> representation.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Render a readable `fun(arg1, ..., kw=...)` representation.\"\"\"\n    args = \", \".join(repr(a) for a in self._args)\n    kwargs = \", \".join(f\"{k}={v!r}\" for k, v in self._kwargs.items())\n    inner = \", \".join(x for x in (args, kwargs) if x)\n    return f\"{self._fun}({inner})\"\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaPart.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self.__str__()\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.FormulaPart.__init__","title":"<code>__init__(_fun, _args, _kwargs)</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec","title":"<code>PriorSpec</code>  <code>dataclass</code>","text":"<p>Python representation of a brms prior specification.</p> <p>This dataclass provides a typed interface to <code>brms::prior_string()</code> arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the <code>prior()</code> factory function to create instances.</p> <p>Attributes:</p> Name Type Description <code>prior</code> <code>str</code> <p>Prior distribution as string (e.g., <code>\"normal(0, 1)\"</code>, <code>\"exponential(2)\"</code>).</p> <code>class_</code> <code>(str, optional)</code> <p>Parameter class: <code>\"b\"</code> (fixed effects), <code>\"sd\"</code> (group SD), <code>\"Intercept\"</code>, <code>\"sigma\"</code>, <code>\"cor\"</code>, etc.</p> <code>coef</code> <code>(str, optional)</code> <p>Specific coefficient name for class-level priors.</p> <code>group</code> <code>(str, optional)</code> <p>Grouping variable for hierarchical effects.</p> <code>dpar</code> <code>(str, optional)</code> <p>Distributional parameter (e.g., <code>\"sigma\"</code>, <code>\"phi\"</code>, <code>\"zi\"</code>).</p> <code>resp</code> <code>(str, optional)</code> <p>Response variable for multivariate models.</p> <code>nlpar</code> <code>(str, optional)</code> <p>Non-linear parameter name.</p> <code>lb</code> <code>(float, optional)</code> <p>Lower bound for truncated priors.</p> <code>ub</code> <code>(float, optional)</code> <p>Upper bound for truncated priors.</p> See Also <p>prior : Factory function to create <code>PriorSpec</code> instances. brms::prior_string : R documentation</p> <p>Examples:</p> <p>Create prior specifications (prefer using <code>prior()</code>):</p> <pre><code>from brmspy.types import PriorSpec\n\n# Fixed effect prior\np1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n# Group-level SD prior\np2 = PriorSpec(prior=\"exponential(2)\", class_=\"sd\", group=\"patient\")\n\n# Coefficient-specific prior with bounds\np3 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\", coef=\"age\", lb=0)\n</code></pre> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass(frozen=True)\nclass PriorSpec:\n    \"\"\"\n    Python representation of a brms prior specification.\n\n    This dataclass provides a typed interface to `brms::prior_string()` arguments,\n    allowing Python developers to specify priors with IDE autocomplete and type\n    checking. Use the [`prior()`][brmspy.brms.prior] factory function to create\n    instances.\n\n    Attributes\n    ----------\n    prior : str\n        Prior distribution as string (e.g., ``\"normal(0, 1)\"``, ``\"exponential(2)\"``).\n    class_ : str, optional\n        Parameter class: ``\"b\"`` (fixed effects), ``\"sd\"`` (group SD),\n        ``\"Intercept\"``, ``\"sigma\"``, ``\"cor\"``, etc.\n    coef : str, optional\n        Specific coefficient name for class-level priors.\n    group : str, optional\n        Grouping variable for hierarchical effects.\n    dpar : str, optional\n        Distributional parameter (e.g., ``\"sigma\"``, ``\"phi\"``, ``\"zi\"``).\n    resp : str, optional\n        Response variable for multivariate models.\n    nlpar : str, optional\n        Non-linear parameter name.\n    lb : float, optional\n        Lower bound for truncated priors.\n    ub : float, optional\n        Upper bound for truncated priors.\n\n    See Also\n    --------\n    prior : Factory function to create `PriorSpec` instances.\n    brms::prior_string : [R documentation](https://paulbuerkner.com/brms/reference/prior_string.html)\n\n    Examples\n    --------\n    Create prior specifications (prefer using [`prior()`][brmspy.brms.prior]):\n\n    ```python\n    from brmspy.types import PriorSpec\n\n    # Fixed effect prior\n    p1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n    # Group-level SD prior\n    p2 = PriorSpec(prior=\"exponential(2)\", class_=\"sd\", group=\"patient\")\n\n    # Coefficient-specific prior with bounds\n    p3 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\", coef=\"age\", lb=0)\n    ```\n    \"\"\"\n\n    prior: str\n    class_: str | None = None\n    coef: str | None = None\n    group: str | None = None\n    dpar: str | None = None\n    resp: str | None = None\n    nlpar: str | None = None\n    lb: float | None = None\n    ub: float | None = None\n\n    def to_brms_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Convert PriorSpec to keyword arguments for brms::prior_string().\n\n        Maps Python dataclass fields to R function arguments, handling\n        the `class_` -&gt; `class` parameter name conversion.\n\n        Returns\n        -------\n        dict\n            Keyword arguments ready for brms::prior_string()\n\n        Examples\n        --------\n        ```python\n        from brmspy import prior\n        p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n        kwargs = p.to_brms_kwargs()\n        print(kwargs)\n        # {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n        ```\n        \"\"\"\n        out: dict[str, Any] = {\"prior\": self.prior}\n        if self.class_ is not None:\n            out[\"class\"] = self.class_\n        if self.coef is not None:\n            out[\"coef\"] = self.coef\n        if self.group is not None:\n            out[\"group\"] = self.group\n        if self.dpar is not None:\n            out[\"dpar\"] = self.dpar\n        if self.resp is not None:\n            out[\"resp\"] = self.resp\n        if self.nlpar is not None:\n            out[\"nlpar\"] = self.nlpar\n        if self.lb is not None:\n            out[\"lb\"] = self.lb\n        if self.ub is not None:\n            out[\"ub\"] = self.ub\n        return out\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec-attributes","title":"Attributes","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec.prior","title":"<code>prior</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec.class_","title":"<code>class_ = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec.coef","title":"<code>coef = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec.group","title":"<code>group = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec.dpar","title":"<code>dpar = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec.resp","title":"<code>resp = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec.nlpar","title":"<code>nlpar = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec.lb","title":"<code>lb = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec.ub","title":"<code>ub = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec.to_brms_kwargs","title":"<code>to_brms_kwargs()</code>","text":"<p>Convert PriorSpec to keyword arguments for brms::prior_string().</p> <p>Maps Python dataclass fields to R function arguments, handling the <code>class_</code> -&gt; <code>class</code> parameter name conversion.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keyword arguments ready for brms::prior_string()</p> <p>Examples:</p> <pre><code>from brmspy import prior\np = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\nkwargs = p.to_brms_kwargs()\nprint(kwargs)\n# {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n</code></pre> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>def to_brms_kwargs(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert PriorSpec to keyword arguments for brms::prior_string().\n\n    Maps Python dataclass fields to R function arguments, handling\n    the `class_` -&gt; `class` parameter name conversion.\n\n    Returns\n    -------\n    dict\n        Keyword arguments ready for brms::prior_string()\n\n    Examples\n    --------\n    ```python\n    from brmspy import prior\n    p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n    kwargs = p.to_brms_kwargs()\n    print(kwargs)\n    # {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n    ```\n    \"\"\"\n    out: dict[str, Any] = {\"prior\": self.prior}\n    if self.class_ is not None:\n        out[\"class\"] = self.class_\n    if self.coef is not None:\n        out[\"coef\"] = self.coef\n    if self.group is not None:\n        out[\"group\"] = self.group\n    if self.dpar is not None:\n        out[\"dpar\"] = self.dpar\n    if self.resp is not None:\n        out[\"resp\"] = self.resp\n    if self.nlpar is not None:\n        out[\"nlpar\"] = self.nlpar\n    if self.lb is not None:\n        out[\"lb\"] = self.lb\n    if self.ub is not None:\n        out[\"ub\"] = self.ub\n    return out\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.PriorSpec.__init__","title":"<code>__init__(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None)</code>","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan-functions","title":"Functions","text":""},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def py_to_r(obj: PyObject) -&gt; Sexp:\n    \"\"\"\n    Convert arbitrary Python objects to R objects via rpy2.\n\n    Comprehensive converter that handles nested structures (dicts, lists),\n    DataFrames, arrays, and scalars. Uses rpy2's converters with special\n    handling for dictionaries (\u2192 R named lists) and lists of dicts.\n\n    Parameters\n    ----------\n    obj : any\n        Python object to convert. Supported types:\n        - None \u2192 R NULL\n        - dict \u2192 R named list (ListVector), recursively\n        - list/tuple of dicts \u2192 R list of named lists\n        - list/tuple (other) \u2192 R vector or list\n        - pd.DataFrame \u2192 R data.frame\n        - np.ndarray \u2192 R vector/matrix\n        - scalars (int, float, str, bool) \u2192 R atomic types\n\n    Returns\n    -------\n    rpy2 R object\n        R representation of the Python object\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **None**: \u2192 R NULL\n    2. **DataFrames**: \u2192 R data.frame (via pandas2ri)\n    3. **Dictionaries**: \u2192 R named list (ListVector), recursively converting values\n    4. **Lists of dicts**: \u2192 R list with 1-based indexed names containing named lists\n    5. **Other lists/tuples**: \u2192 R vectors or lists (via rpy2 default)\n    6. **NumPy arrays**: \u2192 R vectors/matrices (via numpy2ri)\n    7. **Scalars**: \u2192 R atomic values\n\n    **Recursive Conversion:**\n\n    Dictionary values are recursively converted, allowing nested structures:\n    ```python\n    {'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n    ```\n\n    **List of Dicts:**\n\n    Lists containing only dicts are converted to R lists with 1-based indexing:\n    ```python\n    [{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n    ```\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import py_to_r\n    import numpy as np\n    import pandas as pd\n\n    # Scalars\n    py_to_r(5)        # R: 5\n    py_to_r(\"hello\")  # R: \"hello\"\n    py_to_r(None)     # R: NULL\n\n    # Arrays\n    py_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n    # DataFrames\n    df = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\n    py_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n    ```\n\n    See Also\n    --------\n    r_to_py : Convert R objects back to Python\n    kwargs_r : Convert keyword arguments dict for R function calls\n    brmspy.brms.fit : Uses this for converting data to R\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if obj is None:\n        return ro.NULL\n\n    if isinstance(obj, ro.Sexp):\n        return obj\n\n    if isinstance(obj, RListVectorExtension) and isinstance(obj.r, ro.Sexp):\n        return obj.r\n\n    _type = type(obj)\n    converter = None\n\n    if _type in _registry._PY2R_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._PY2R_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._PY2R_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._PY2R_CONVERTERS) &gt; 0, \"NO PY2R CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj)\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan._build_priors","title":"<code>_build_priors(priors=None)</code>","text":"<p>Build R brms prior object from Python PriorSpec specifications.</p> <p>Converts a sequence of PriorSpec objects to a single combined R brms prior object by calling brms::prior_string() for each spec and combining with <code>+</code>. Used internally by fit() to translate Python prior specifications to R.</p> <p>Parameters:</p> Name Type Description Default <code>priors</code> <code>sequence of PriorSpec</code> <p>List of prior specifications. Each PriorSpec contains: - prior: Prior distribution string (e.g., \"normal(0, 1)\") - class_: Parameter class (e.g., \"b\", \"Intercept\", \"sigma\") - coef: Specific coefficient name (optional) - group: Group-level effects (optional)</p> <p>If None or empty, returns empty list (brms uses default priors)</p> <code>None</code> <p>Returns:</p> Type Description <code>R brmsprior object or list</code> <p>Combined R brms prior object if priors provided, empty list otherwise</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If combined result is not a valid brmsprior object</p> Notes <p>Prior Combination:</p> <p>Multiple priors are combined using R's <code>+</code> operator: <pre><code>prior1 + prior2 + prior3\n</code></pre></p> <p>This creates a single brmsprior object containing all specifications.</p> <p>brms Prior Classes:</p> <p>Common parameter classes: - b: Population-level effects (regression coefficients) - Intercept: Model intercept - sigma: Residual standard deviation (for gaussian family) - sd: Standard deviation of group-level effects - cor: Correlation of group-level effects</p> <p>Prior String Format:</p> <p>brms uses Stan-style prior specifications: - Normal: \"normal(mean, sd)\" - Student-t: \"student_t(df, location, scale)\" - Cauchy: \"cauchy(location, scale)\" - Exponential: \"exponential(rate)\" - Uniform: \"uniform(lower, upper)\"</p> <p>Examples:</p> <pre><code>from brmspy.types import PriorSpec\nfrom brmspy.helpers.priors import _build_priors\n\n# Single prior for regression coefficients\npriors = [\n    PriorSpec(\n        prior=\"normal(0, 1)\",\n        class_=\"b\"\n    )\n]\nbrms_prior = _build_priors(priors)\n</code></pre> See Also <p>brmspy.types.PriorSpec : Prior specification class brmspy.brms.fit : Uses this to convert priors for model fitting brms::prior : R brms prior specification brms::set_prior : R function for setting priors</p> References <p>.. [1] brms prior documentation: https://paul-buerkner.github.io/brms/reference/set_prior.html .. [2] Stan prior choice recommendations: https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations</p> Source code in <code>brmspy/helpers/_rpy2/_priors.py</code> <pre><code>def _build_priors(\n    priors: None | Sequence[PriorSpec] = None,\n) -&gt; list[Sexp]:\n    \"\"\"\n    Build R brms prior object from Python PriorSpec specifications.\n\n    Converts a sequence of PriorSpec objects to a single combined R brms prior\n    object by calling brms::prior_string() for each spec and combining with `+`.\n    Used internally by fit() to translate Python prior specifications to R.\n\n    Parameters\n    ----------\n    priors : sequence of PriorSpec, optional\n        List of prior specifications. Each PriorSpec contains:\n        - prior: Prior distribution string (e.g., \"normal(0, 1)\")\n        - class_: Parameter class (e.g., \"b\", \"Intercept\", \"sigma\")\n        - coef: Specific coefficient name (optional)\n        - group: Group-level effects (optional)\n\n        If None or empty, returns empty list (brms uses default priors)\n\n    Returns\n    -------\n    R brmsprior object or list\n        Combined R brms prior object if priors provided, empty list otherwise\n\n    Raises\n    ------\n    AssertionError\n        If combined result is not a valid brmsprior object\n\n    Notes\n    -----\n    **Prior Combination:**\n\n    Multiple priors are combined using R's `+` operator:\n    ```R\n    prior1 + prior2 + prior3\n    ```\n\n    This creates a single brmsprior object containing all specifications.\n\n    **brms Prior Classes:**\n\n    Common parameter classes:\n    - **b**: Population-level effects (regression coefficients)\n    - **Intercept**: Model intercept\n    - **sigma**: Residual standard deviation (for gaussian family)\n    - **sd**: Standard deviation of group-level effects\n    - **cor**: Correlation of group-level effects\n\n    **Prior String Format:**\n\n    brms uses Stan-style prior specifications:\n    - Normal: \"normal(mean, sd)\"\n    - Student-t: \"student_t(df, location, scale)\"\n    - Cauchy: \"cauchy(location, scale)\"\n    - Exponential: \"exponential(rate)\"\n    - Uniform: \"uniform(lower, upper)\"\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.types import PriorSpec\n    from brmspy.helpers.priors import _build_priors\n\n    # Single prior for regression coefficients\n    priors = [\n        PriorSpec(\n            prior=\"normal(0, 1)\",\n            class_=\"b\"\n        )\n    ]\n    brms_prior = _build_priors(priors)\n    ```\n\n    See Also\n    --------\n    brmspy.types.PriorSpec : Prior specification class\n    brmspy.brms.fit : Uses this to convert priors for model fitting\n    brms::prior : R brms prior specification\n    brms::set_prior : R function for setting priors\n\n    References\n    ----------\n    .. [1] brms prior documentation: https://paul-buerkner.github.io/brms/reference/set_prior.html\n    .. [2] Stan prior choice recommendations: https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations\n    \"\"\"\n    if not priors:\n        return []\n    import rpy2.robjects as ro\n\n    from brmspy.helpers._rpy2._converters import r_to_py\n\n    fun_prior_string = cast(Callable, ro.r(\"brms::prior_string\"))\n\n    prior_objs = []\n    for p in priors:\n        kwargs = p.to_brms_kwargs()\n        # first argument is the prior string\n        prior_str = kwargs.pop(\"prior\")\n        prior_obj = fun_prior_string(prior_str, **kwargs)\n        prior_objs.append(prior_obj)\n\n    brms_prior = prior_objs[0]\n    for p in prior_objs[1:]:\n        brms_prior = brms_prior + p\n\n    return brms_prior\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan._execute_formula","title":"<code>_execute_formula(formula)</code>","text":"Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def _execute_formula(formula: FormulaConstruct | Sexp | str) -&gt; Sexp:\n    import rpy2.robjects as ro\n\n    if isinstance(formula, Sexp):\n        return formula\n    if isinstance(formula, str):\n        formula = FormulaConstruct._formula_parse(formula)\n\n    # Must run for formula functions, e.g me() to register\n    ro.r(\"library(brms)\")\n\n    fun_add = cast(Callable[[Sexp, Sexp], Sexp], ro.r(\"function (a, b) a + b\"))\n\n    result: Sexp | None = None\n    for summand in formula:\n        subresult: Sexp = py_to_r(summand[0])\n        for part in summand[1:]:\n            subresult = fun_add(subresult, py_to_r(part))\n\n        if result is None:\n            result = subresult\n        else:\n            result = fun_add(result, subresult)\n\n    assert result is not None\n    return result\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.bf","title":"<code>bf(*formulas, **formula_args)</code>","text":"<p>Build a brms model formula.</p> <p>This is the primary entrypoint for specifying the mean model and can be combined with other formula parts (e.g. <code>lf</code>, <code>nlf</code>, <code>acformula</code>) using <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str</code> <p>One or more brms formula strings (e.g. <code>\"y ~ x + (1|group)\"</code>). Multiple formulas are commonly used for multivariate models.</p> <code>()</code> <code>**formula_args</code> <p>Keyword arguments forwarded to R <code>brms::brmsformula()</code> (for example <code>decomp=\"QR\"</code>, <code>center=True</code>, <code>sparse=True</code>, <code>nl=True</code>, <code>loop=True</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::brmsformula : R documentation</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>QR decomposition (often helps with collinearity):</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"reaction ~ days + (days|subject)\", decomp=\"QR\")\n</code></pre> <p>Multivariate formula + residual correlation:</p> <pre><code>from brmspy.brms import bf, set_rescor\n\nf = bf(\"mvbind(y1, y2) ~ x\") + set_rescor(True)\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def bf(*formulas: str, **formula_args) -&gt; FormulaConstruct:\n    \"\"\"\n    Build a brms model formula.\n\n    This is the primary entrypoint for specifying the mean model and can be\n    combined with other formula parts (e.g. `lf`, `nlf`, `acformula`) using ``+``.\n\n    Parameters\n    ----------\n    *formulas : str\n        One or more brms formula strings (e.g. ``\"y ~ x + (1|group)\"``). Multiple\n        formulas are commonly used for multivariate models.\n    **formula_args\n        Keyword arguments forwarded to R ``brms::brmsformula()`` (for example\n        ``decomp=\"QR\"``, ``center=True``, ``sparse=True``, ``nl=True``, ``loop=True``).\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::brmsformula : [R documentation](https://paulbuerkner.com/brms/reference/brmsformula.html)\n\n    Examples\n    --------\n    Basic formula:\n\n    ```python\n    from brmspy.brms import bf\n\n    f = bf(\"y ~ x1 + x2 + (1|group)\")\n    ```\n\n    QR decomposition (often helps with collinearity):\n\n    ```python\n    from brmspy.brms import bf\n\n    f = bf(\"reaction ~ days + (days|subject)\", decomp=\"QR\")\n    ```\n\n    Multivariate formula + residual correlation:\n\n    ```python\n    from brmspy.brms import bf, set_rescor\n\n    f = bf(\"mvbind(y1, y2) ~ x\") + set_rescor(True)\n    ```\n    \"\"\"\n    part = FormulaPart(_fun=\"bf\", _args=list(formulas), _kwargs=formula_args)\n    return FormulaConstruct._formula_parse(part)\n</code></pre>"},{"location":"internals/_brms_functions/stan/#brmspy._brms_functions.stan.make_stancode","title":"<code>make_stancode(formula, data, priors=None, family='poisson', sample_prior='no', formula_args=None)</code>","text":"<p>Generate Stan code using R <code>brms::make_stancode()</code>.</p> <p>Useful for inspecting the generated Stan model before fitting.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula.</p> required <code>data</code> <code>DataFrame</code> <p>Model data.</p> required <code>priors</code> <code>Sequence[PriorSpec] or None</code> <p>Optional prior specifications created via <code>brmspy.brms.prior()</code>.</p> <code>None</code> <code>family</code> <code>str</code> <p>Distribution family (e.g. <code>\"gaussian\"</code>, <code>\"poisson\"</code>).</p> <code>\"poisson\"</code> <code>sample_prior</code> <code>str</code> <p>Prior sampling mode passed to brms (<code>\"no\"</code>, <code>\"yes\"</code>, <code>\"only\"</code>).</p> <code>\"no\"</code> <code>formula_args</code> <code>dict or None</code> <p>Reserved for future use. Currently ignored.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Complete Stan program as a string.</p> See Also <p>brms::make_stancode : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\ncode = brms.make_stancode(\n    \"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n)\n\nassert isinstance(code, str)\n</code></pre> Source code in <code>brmspy/_brms_functions/stan.py</code> <pre><code>def make_stancode(\n    formula: FormulaConstruct | str,\n    data: pd.DataFrame,\n    priors: typing.Sequence[PriorSpec] | None = None,\n    family: str = \"poisson\",\n    sample_prior: str = \"no\",\n    formula_args: dict | None = None,\n) -&gt; str:\n    \"\"\"\n    Generate Stan code using R ``brms::make_stancode()``.\n\n    Useful for inspecting the generated Stan model before fitting.\n\n    Parameters\n    ----------\n    formula : str or FormulaConstruct\n        Model formula.\n    data : pandas.DataFrame\n        Model data.\n    priors : Sequence[PriorSpec] or None, default=None\n        Optional prior specifications created via `brmspy.brms.prior()`.\n    family : str, default=\"poisson\"\n        Distribution family (e.g. ``\"gaussian\"``, ``\"poisson\"``).\n    sample_prior : str, default=\"no\"\n        Prior sampling mode passed to brms (``\"no\"``, ``\"yes\"``, ``\"only\"``).\n    formula_args : dict or None, default=None\n        Reserved for future use. Currently ignored.\n\n    Returns\n    -------\n    str\n        Complete Stan program as a string.\n\n    See Also\n    --------\n    brms::make_stancode : [R documentation](https://paulbuerkner.com/brms/reference/make_stancode.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    epilepsy = brms.get_brms_data(\"epilepsy\")\n    code = brms.make_stancode(\n        \"count ~ zAge + zBase * Trt + (1|patient)\",\n        data=epilepsy,\n        family=\"poisson\",\n    )\n\n    assert isinstance(code, str)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    fun_make_stancode = typing.cast(typing.Callable, ro.r(\"brms::make_stancode\"))\n\n    data_r = py_to_r(data)\n    priors_r = _build_priors(priors)\n    if isinstance(formula, FormulaConstruct):\n        formula_obj = _execute_formula(formula)\n    else:\n        if formula_args is None:\n            formula_args = {}\n        formula = FormulaConstruct._formula_parse(formula)\n        formula_obj = _execute_formula(formula)\n\n    if len(priors_r) &gt; 0:\n        return fun_make_stancode(\n            formula=formula_obj,\n            data=data_r,\n            prior=priors_r,\n            family=family,\n            sample_prior=sample_prior,\n        )[0]\n    else:\n        return fun_make_stancode(\n            formula=formula_obj, data=data_r, family=family, sample_prior=sample_prior\n        )[0]\n</code></pre>"},{"location":"internals/_build/_metadata/","title":"_metadata","text":"<p>Build manifest metadata collection from R environment.</p>"},{"location":"internals/_build/_metadata/#brmspy._build._metadata-functions","title":"Functions","text":""},{"location":"internals/_build/_metadata/#brmspy._build._metadata._run_r_json","title":"<code>_run_r_json(code)</code>","text":"<p>Execute R code and parse JSON output to Python dictionary.</p> Source code in <code>brmspy/_build/_metadata.py</code> <pre><code>def _run_r_json(code: str) -&gt; dict:\n    \"\"\"Execute R code and parse JSON output to Python dictionary.\"\"\"\n    import rpy2.robjects as ro\n\n    res = cast(List[str], ro.r(code))\n    json_str = res[0]\n    return json.loads(json_str)\n</code></pre>"},{"location":"internals/_build/_metadata/#brmspy._build._metadata.collect_runtime_metadata","title":"<code>collect_runtime_metadata()</code>","text":"<p>Collect comprehensive R environment metadata for runtime bundle.</p> <p>Queries R via rpy2 to gather complete information about the current R installation, including R version, CmdStan installation, and full dependency closure of brms + cmdstanr with all package details.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Metadata dictionary containing: - r_version : str - R version (e.g., \"4.3.1\") - cmdstan_path : str - Path to CmdStan installation - cmdstan_version : str - CmdStan version - packages : list of dict - Package information</p> Source code in <code>brmspy/_build/_metadata.py</code> <pre><code>def collect_runtime_metadata() -&gt; dict:\n    \"\"\"\n    Collect comprehensive R environment metadata for runtime bundle.\n\n    Queries R via rpy2 to gather complete information about the current\n    R installation, including R version, CmdStan installation, and full\n    dependency closure of brms + cmdstanr with all package details.\n\n    Returns\n    -------\n    dict\n        Metadata dictionary containing:\n        - r_version : str - R version (e.g., \"4.3.1\")\n        - cmdstan_path : str - Path to CmdStan installation\n        - cmdstan_version : str - CmdStan version\n        - packages : list of dict - Package information\n    \"\"\"\n    import rpy2.robjects as ro\n\n    script_path = os.path.realpath(__file__)\n    script_dir = os.path.dirname(script_path)\n\n    # Read build-manifest.R from build directory\n    manifest_r_path = os.path.join(script_dir, \"build-manifest.R\")\n    with open(manifest_r_path, \"r\") as f:\n        r_code = f.read()\n\n    # Make sure jsonlite is available\n    ro.r(\n        'if (!requireNamespace(\"jsonlite\", quietly = TRUE)) '\n        'install.packages(\"jsonlite\", repos=\"https://cloud.r-project.org\")'\n    )\n\n    return _run_r_json(r_code)\n</code></pre>"},{"location":"internals/_build/_pack/","title":"_pack","text":"<p>Pack runtime into distributable archive.</p>"},{"location":"internals/_build/_pack/#brmspy._build._pack-functions","title":"Functions","text":""},{"location":"internals/_build/_pack/#brmspy._build._pack.log","title":"<code>log(*msg, method_name=None, level=logging.INFO)</code>","text":"<p>Log a message with automatic method name detection.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log</p> <code>()</code> <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> <code>level</code> <code>int</code> <p>Logging level (default: logging.INFO)</p> <code>INFO</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log(*msg: str, method_name: str | None = None, level: int = logging.INFO):\n    \"\"\"\n    Log a message with automatic method name detection.\n\n    Parameters\n    ----------\n    msg : str\n        The message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n    level : int, optional\n        Logging level (default: logging.INFO)\n    \"\"\"\n    if method_name is None:\n        method_name = _get_caller_name()\n\n    msg_str = \" \".join(str(v) for v in msg)\n\n    logger = get_logger()\n    logger.log(level, msg_str, extra={\"method_name\": method_name})\n</code></pre>"},{"location":"internals/_build/_pack/#brmspy._build._pack.pack_runtime","title":"<code>pack_runtime(runtime_root, out_dir, runtime_version)</code>","text":"<p>Create compressed tar archive from runtime directory.</p> <p>Packages the staged runtime directory into a distributable .tar.gz archive with standardized naming for platform/version identification.</p> <p>Archive naming format: brmspy-runtime-{runtime_version}-{fingerprint}.tar.gz</p> <p>Parameters:</p> Name Type Description Default <code>runtime_root</code> <code>Path</code> <p>Path to staged runtime directory (from stage_runtime_tree)</p> required <code>out_dir</code> <code>Path</code> <p>Output directory for archive file</p> required <code>runtime_version</code> <code>str</code> <p>Runtime schema version (e.g., \"0.1.0\")</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to created .tar.gz archive file</p> Source code in <code>brmspy/_build/_pack.py</code> <pre><code>def pack_runtime(runtime_root: Path, out_dir: Path, runtime_version: str) -&gt; Path:\n    \"\"\"\n    Create compressed tar archive from runtime directory.\n\n    Packages the staged runtime directory into a distributable .tar.gz\n    archive with standardized naming for platform/version identification.\n\n    Archive naming format:\n    brmspy-runtime-{runtime_version}-{fingerprint}.tar.gz\n\n    Parameters\n    ----------\n    runtime_root : Path\n        Path to staged runtime directory (from stage_runtime_tree)\n    out_dir : Path\n        Output directory for archive file\n    runtime_version : str\n        Runtime schema version (e.g., \"0.1.0\")\n\n    Returns\n    -------\n    Path\n        Path to created .tar.gz archive file\n    \"\"\"\n    fingerprint = runtime_root.name\n    archive_name = f\"brmspy-runtime-{runtime_version}-{fingerprint}.tar.gz\"\n    archive_path = out_dir / archive_name\n\n    out_dir.mkdir(parents=True, exist_ok=True)\n\n    log(f\"[tar] Creating archive {archive_path}\")\n    with tarfile.open(archive_path, \"w:gz\") as tf:\n        # Add the runtime root directory contents under \"runtime/\"\n        tf.add(runtime_root, arcname=\"runtime\")\n\n    return archive_path\n</code></pre>"},{"location":"internals/_build/_stage/","title":"_stage","text":"<p>Stage runtime tree structure.</p>"},{"location":"internals/_build/_stage/#brmspy._build._stage-functions","title":"Functions","text":""},{"location":"internals/_build/_stage/#brmspy._build._stage.system_fingerprint","title":"<code>system_fingerprint()</code>","text":"<p>Returns '{os}-{arch}-r{major}.{minor}' string.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def system_fingerprint() -&gt; str:\n    \"\"\"Returns '{os}-{arch}-r{major}.{minor}' string.\"\"\"\n    os_name = get_os()\n    arch = get_arch()\n    r_ver = get_r_version()\n    if not r_ver:\n        raise RuntimeError(\"R version could not be determined\")\n    major, minor, _ = r_ver\n    return f\"{os_name}-{arch}-r{major}.{minor}\"\n</code></pre>"},{"location":"internals/_build/_stage/#brmspy._build._stage.log","title":"<code>log(*msg, method_name=None, level=logging.INFO)</code>","text":"<p>Log a message with automatic method name detection.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log</p> <code>()</code> <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> <code>level</code> <code>int</code> <p>Logging level (default: logging.INFO)</p> <code>INFO</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log(*msg: str, method_name: str | None = None, level: int = logging.INFO):\n    \"\"\"\n    Log a message with automatic method name detection.\n\n    Parameters\n    ----------\n    msg : str\n        The message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n    level : int, optional\n        Logging level (default: logging.INFO)\n    \"\"\"\n    if method_name is None:\n        method_name = _get_caller_name()\n\n    msg_str = \" \".join(str(v) for v in msg)\n\n    logger = get_logger()\n    logger.log(level, msg_str, extra={\"method_name\": method_name})\n</code></pre>"},{"location":"internals/_build/_stage/#brmspy._build._stage._generate_manifest_hash","title":"<code>_generate_manifest_hash(manifest)</code>","text":"<p>Generate deterministic SHA256 hash of runtime manifest.</p> Source code in <code>brmspy/_build/_stage.py</code> <pre><code>def _generate_manifest_hash(manifest: dict) -&gt; str:\n    \"\"\"Generate deterministic SHA256 hash of runtime manifest.\"\"\"\n    manifest_string = json.dumps(manifest, sort_keys=True, separators=(',', ':'))\n    return hashlib.sha256(manifest_string.encode('utf-8')).hexdigest()\n</code></pre>"},{"location":"internals/_build/_stage/#brmspy._build._stage.stage_runtime_tree","title":"<code>stage_runtime_tree(base_dir, metadata, runtime_version)</code>","text":"<p>Create runtime directory structure and copy all required files.</p> <p>Builds the complete runtime directory tree by: 1. Creating fingerprint-specific directory structure 2. Copying all R packages to Rlib/ 3. Copying CmdStan installation to cmdstan/ 4. Generating manifest.json with checksums</p> <p>Parameters:</p> Name Type Description Default <code>base_dir</code> <code>Path</code> <p>Base directory for runtime tree</p> required <code>metadata</code> <code>dict</code> <p>Metadata from collect_runtime_metadata()</p> required <code>runtime_version</code> <code>str</code> <p>Runtime schema version (e.g., \"0.1.0\")</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to the runtime root directory</p> Source code in <code>brmspy/_build/_stage.py</code> <pre><code>def stage_runtime_tree(base_dir: Path, metadata: dict, runtime_version: str) -&gt; Path:\n    \"\"\"\n    Create runtime directory structure and copy all required files.\n\n    Builds the complete runtime directory tree by:\n    1. Creating fingerprint-specific directory structure\n    2. Copying all R packages to Rlib/\n    3. Copying CmdStan installation to cmdstan/\n    4. Generating manifest.json with checksums\n\n    Parameters\n    ----------\n    base_dir : Path\n        Base directory for runtime tree\n    metadata : dict\n        Metadata from collect_runtime_metadata()\n    runtime_version : str\n        Runtime schema version (e.g., \"0.1.0\")\n\n    Returns\n    -------\n    Path\n        Path to the runtime root directory\n    \"\"\"\n    fingerprint = system_fingerprint()\n    if fingerprint is None:\n        raise RuntimeError(\"system_fingerprint() returned None; cannot build runtime bundle.\")\n\n    runtime_root = base_dir / f\"{fingerprint}-{runtime_version}\"\n    rlib_dir = runtime_root / \"Rlib\"\n    cmdstan_dir = runtime_root / \"cmdstan\"\n\n    runtime_root.mkdir(parents=True, exist_ok=True)\n    rlib_dir.mkdir(parents=True, exist_ok=True)\n\n    # Copy R packages into Rlib/\n    pkgs = metadata.get(\"packages\", [])\n    if not pkgs:\n        raise RuntimeError(\"No package metadata returned from R; cannot build runtime.\")\n\n    for pkg in pkgs:\n        name = pkg[\"Package\"]\n        libpath = pkg[\"LibPath\"]\n        src = Path(libpath) / name\n        dest = rlib_dir / name\n\n        if not src.exists():\n            raise RuntimeError(f\"Package directory not found: {src}\")\n\n        log(f\"[Rlib] Copying {name} from {src} to {dest}\")\n        shutil.copytree(src, dest, dirs_exist_ok=True)\n\n    # Copy CmdStan tree into cmdstan/\n    cmdstan_path = Path(metadata[\"cmdstan_path\"])\n    if not cmdstan_path.exists():\n        raise RuntimeError(f\"cmdstan_path does not exist on disk: {cmdstan_path}\")\n\n    log(f\"[cmdstan] Copying CmdStan from {cmdstan_path} to {cmdstan_dir}\")\n    shutil.copytree(cmdstan_path, cmdstan_dir, dirs_exist_ok=True)\n\n\n    # On macOS, drop precompiled headers (PCH) to avoid SDK/PCH mismatch issues\n    if sys.platform == \"darwin\":\n        model_dir = cmdstan_dir / \"stan\" / \"src\" / \"stan\" / \"model\"\n        if model_dir.exists():\n            for entry in model_dir.iterdir():\n                # Clang stores PCH in dirs like \"model_header.hpp.gch/\"\n                if entry.is_dir() and entry.name.endswith(\".hpp.gch\"):\n                    log(f\"[cmdstan] Removing PCH directory on macOS: {entry}\")\n                    shutil.rmtree(entry, ignore_errors=True)\n\n    # Write manifest.json\n    r_pkg_versions = {pkg[\"Package\"]: pkg[\"Version\"] for pkg in pkgs}\n\n    manifest = {\n        \"runtime_version\": runtime_version,\n        \"fingerprint\": fingerprint,\n        \"r_version\": metadata[\"r_version\"],\n        \"cmdstan_version\": metadata[\"cmdstan_version\"],\n        \"r_packages\": r_pkg_versions\n    }\n\n    hash_val = _generate_manifest_hash(manifest)\n    manifest['manifest_hash'] = hash_val\n    manifest['built_at'] = datetime.now(timezone.utc).isoformat()\n\n    manifest_path = runtime_root / \"manifest.json\"\n    with manifest_path.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(manifest, f, indent=2)\n    log(f\"[manifest] Wrote {manifest_path}\")\n\n    return runtime_root\n</code></pre>"},{"location":"internals/_runtime/_activation/","title":"_activation","text":"<p>Runtime activation/deactivation. Mutates R environment ONLY. Does NOT touch config - that's the caller's responsibility.</p>"},{"location":"internals/_runtime/_activation/#brmspy._runtime._activation-attributes","title":"Attributes","text":""},{"location":"internals/_runtime/_activation/#brmspy._runtime._activation.MANAGED_PACKAGES","title":"<code>MANAGED_PACKAGES = ('brms', 'cmdstanr', 'rstan', 'StanHeaders', 'tibble', 'pkgconfig')</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_activation/#brmspy._runtime._activation-functions","title":"Functions","text":""},{"location":"internals/_runtime/_activation/#brmspy._runtime._activation.log","title":"<code>log(*msg, method_name=None, level=logging.INFO)</code>","text":"<p>Log a message with automatic method name detection.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log</p> <code>()</code> <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> <code>level</code> <code>int</code> <p>Logging level (default: logging.INFO)</p> <code>INFO</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log(*msg: str, method_name: str | None = None, level: int = logging.INFO):\n    \"\"\"\n    Log a message with automatic method name detection.\n\n    Parameters\n    ----------\n    msg : str\n        The message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n    level : int, optional\n        Logging level (default: logging.INFO)\n    \"\"\"\n    if method_name is None:\n        method_name = _get_caller_name()\n\n    msg_str = \" \".join(str(v) for v in msg)\n\n    logger = get_logger()\n    logger.log(level, msg_str, extra={\"method_name\": method_name})\n</code></pre>"},{"location":"internals/_runtime/_activation/#brmspy._runtime._activation.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/_runtime/_activation/#brmspy._runtime._activation.activate","title":"<code>activate(runtime_path)</code>","text":"<p>Activate runtime by mutating R environment.</p> <p>Steps: 1. Parse and validate manifest 2. Store original R environment (if not already stored) 3. Unload managed packages if loaded 4. Set .libPaths() to runtime's Rlib/ 5. Set cmdstan path to runtime's cmdstan/ 6. Verify packages are loadable 7. Invalidate package singletons</p> <p>Does NOT save to config. Caller handles that.</p> <p>On failure, attempts to restore original environment.</p> Source code in <code>brmspy/_runtime/_activation.py</code> <pre><code>def activate(runtime_path: Path) -&gt; None:\n    \"\"\"\n    Activate runtime by mutating R environment.\n\n    Steps:\n    1. Parse and validate manifest\n    2. Store original R environment (if not already stored)\n    3. Unload managed packages if loaded\n    4. Set .libPaths() to runtime's Rlib/\n    5. Set cmdstan path to runtime's cmdstan/\n    6. Verify packages are loadable\n    7. Invalidate package singletons\n\n    Does NOT save to config. Caller handles that.\n\n    On failure, attempts to restore original environment.\n    \"\"\"\n    log(f\"Activating runtime {runtime_path}\")\n    stored = _state.get_stored_env()\n\n    # Validate\n    manifest = _manifest.parse_manifest(runtime_path / \"manifest.json\")\n    if manifest is None:\n        raise RuntimeError(f\"Invalid manifest in {runtime_path}\")\n\n    _manifest.validate_manifest(manifest, _platform.system_fingerprint())\n\n    if stored is not None:\n        deactivate()\n\n    # Capture original env (unless already captured from previous activation)\n    if not _state.has_stored_env():\n        original = _state.capture_current_env()\n        _state.store_env(original)\n\n    # Attempt activation with rollback on failure\n    try:\n        _unload_managed_packages()\n\n        rlib = runtime_path / \"Rlib\"\n        cmdstan = runtime_path / \"cmdstan\"\n\n        rlib_posix = rlib.as_posix()\n        cmdstan_posix = cmdstan.as_posix()\n\n        _r_env.set_lib_paths([str(rlib_posix)])\n        log(f\"lib paths are {_r_env.get_lib_paths()}\")\n        _state.invalidate_packages()\n        _verify_runtime_loadable()\n        log(f\"Setting cmdstan path to {cmdstan_posix}\")\n        _r_env.set_cmdstan_path(str(cmdstan_posix))\n\n    except Exception as e:\n        # Rollback\n        _rollback_to_stored_env()\n        raise RuntimeError(f\"Activation failed: {e}\") from e\n</code></pre>"},{"location":"internals/_runtime/_activation/#brmspy._runtime._activation.deactivate","title":"<code>deactivate()</code>","text":"<p>Deactivate runtime by restoring original R environment.</p> <p>Does NOT clear config. Caller handles that.</p> <p>Raises:     RuntimeError: If no stored environment to restore.</p> Source code in <code>brmspy/_runtime/_activation.py</code> <pre><code>def deactivate() -&gt; None:\n    \"\"\"\n    Deactivate runtime by restoring original R environment.\n\n    Does NOT clear config. Caller handles that.\n\n    Raises:\n        RuntimeError: If no stored environment to restore.\n    \"\"\"\n    active_path = _config.get_active_runtime_path()\n    stored = _state.get_stored_env()\n    if stored is None:\n        raise RuntimeError(\"No runtime is currently active (no stored environment)\")\n\n    if _platform.get_os() != \"windows\":\n        _r_env._unload_libpath_packages(active_path)\n        _unload_managed_packages()\n    else:\n        _unload_managed_packages()\n\n    _r_env.set_lib_paths(stored.lib_paths)\n    try:\n        _r_env.set_cmdstan_path(stored.cmdstan_path)\n    except Exception as e:\n        log_warning(\n            f\"Failed to set_cmdstan_path to stored default ({stored.cmdstan_path}). Skipping! {e}\"\n        )\n    _state.clear_stored_env()\n    _state.invalidate_packages()\n</code></pre>"},{"location":"internals/_runtime/_activation/#brmspy._runtime._activation._unload_managed_packages","title":"<code>_unload_managed_packages()</code>","text":"<p>Unload brms, cmdstanr, rstan if loaded.</p> Source code in <code>brmspy/_runtime/_activation.py</code> <pre><code>def _unload_managed_packages() -&gt; None:\n    \"\"\"Unload brms, cmdstanr, rstan if loaded.\"\"\"\n    for pkg in MANAGED_PACKAGES:\n        if _r_env.is_namespace_loaded(pkg) or _r_env.is_package_attached(pkg):\n            try:\n                _r_env.unload_package(pkg)\n            except Exception as e:\n                log_warning(f\"{e}\")\n</code></pre>"},{"location":"internals/_runtime/_activation/#brmspy._runtime._activation._remove_managed_packages","title":"<code>_remove_managed_packages()</code>","text":"<p>removes brms, cmdstanr, rstan if loaded.</p> Source code in <code>brmspy/_runtime/_activation.py</code> <pre><code>def _remove_managed_packages() -&gt; None:\n    \"\"\"removes brms, cmdstanr, rstan if loaded.\"\"\"\n    for pkg in MANAGED_PACKAGES:\n        if _r_packages.is_package_installed(pkg):\n            try:\n                _r_packages.remove_package(pkg)\n            except Exception as e:\n                log_warning(f\"{e}\")\n</code></pre>"},{"location":"internals/_runtime/_activation/#brmspy._runtime._activation._verify_runtime_loadable","title":"<code>_verify_runtime_loadable()</code>","text":"<p>Verify brms and cmdstanr can be loaded.</p> Source code in <code>brmspy/_runtime/_activation.py</code> <pre><code>def _verify_runtime_loadable() -&gt; None:\n    \"\"\"Verify brms and cmdstanr can be loaded.\"\"\"\n    _state.get_brms()\n    _state.get_cmdstanr()\n</code></pre>"},{"location":"internals/_runtime/_activation/#brmspy._runtime._activation._rollback_to_stored_env","title":"<code>_rollback_to_stored_env()</code>","text":"<p>Restore original env on activation failure.</p> Source code in <code>brmspy/_runtime/_activation.py</code> <pre><code>def _rollback_to_stored_env() -&gt; None:\n    \"\"\"Restore original env on activation failure.\"\"\"\n    stored = _state.get_stored_env()\n    if stored:\n        try:\n            _r_env.set_lib_paths(stored.lib_paths)\n            _r_env.set_cmdstan_path(stored.cmdstan_path)\n        except Exception:\n            pass  # Best effort\n</code></pre>"},{"location":"internals/_runtime/_config/","title":"_config","text":"<p>Config file I/O only. No R interaction, no activation logic. Pure persistence layer.</p>"},{"location":"internals/_runtime/_config/#brmspy._runtime._config-functions","title":"Functions","text":""},{"location":"internals/_runtime/_config/#brmspy._runtime._config.get_config_dir","title":"<code>get_config_dir()</code>","text":"<p>Returns ~/.brmspy/, creating if needed.</p> Source code in <code>brmspy/_runtime/_config.py</code> <pre><code>def get_config_dir() -&gt; Path:\n    \"\"\"Returns ~/.brmspy/, creating if needed.\"\"\"\n    config_dir = Path.home() / \".brmspy\"\n    config_dir.mkdir(parents=True, exist_ok=True)\n    return config_dir\n</code></pre>"},{"location":"internals/_runtime/_config/#brmspy._runtime._config.get_config_path","title":"<code>get_config_path()</code>","text":"<p>Returns ~/.brmspy/runtime_state.json.</p> Source code in <code>brmspy/_runtime/_config.py</code> <pre><code>def get_config_path() -&gt; Path:\n    \"\"\"Returns ~/.brmspy/runtime_state.json.\"\"\"\n    return get_config_dir() / \"runtime_state.json\"\n</code></pre>"},{"location":"internals/_runtime/_config/#brmspy._runtime._config.read_config","title":"<code>read_config()</code>","text":"<p>Read config file. Returns empty dict if missing/invalid.</p> Source code in <code>brmspy/_runtime/_config.py</code> <pre><code>def read_config() -&gt; dict:\n    \"\"\"Read config file. Returns empty dict if missing/invalid.\"\"\"\n    config_path = get_config_path()\n\n    if not config_path.exists():\n        return {}\n\n    try:\n        with config_path.open('r', encoding='utf-8') as f:\n            return json.load(f)\n    except Exception:\n        return {}\n</code></pre>"},{"location":"internals/_runtime/_config/#brmspy._runtime._config.write_config","title":"<code>write_config(config)</code>","text":"<p>Atomic write to config file (write to temp, rename).</p> Source code in <code>brmspy/_runtime/_config.py</code> <pre><code>def write_config(config: dict) -&gt; None:\n    \"\"\"Atomic write to config file (write to temp, rename).\"\"\"\n    config_path = get_config_path()\n\n    try:\n        # Atomic write: write to temp file, then rename\n        temp_path = config_path.with_suffix('.tmp')\n        with temp_path.open('w', encoding='utf-8') as f:\n            json.dump(config, f, indent=2)\n\n        # Atomic rename (overwrites existing file)\n        temp_path.replace(config_path)\n    except Exception:\n        pass\n</code></pre>"},{"location":"internals/_runtime/_config/#brmspy._runtime._config.get_active_runtime_path","title":"<code>get_active_runtime_path()</code>","text":"<p>Read active_runtime from config.</p> Source code in <code>brmspy/_runtime/_config.py</code> <pre><code>def get_active_runtime_path() -&gt; Path | None:\n    \"\"\"Read active_runtime from config.\"\"\"\n    config = read_config()\n    runtime_str = config.get('active_runtime')\n\n    if runtime_str is None:\n        return None\n\n    return Path(runtime_str).expanduser().resolve()\n</code></pre>"},{"location":"internals/_runtime/_config/#brmspy._runtime._config.set_active_runtime_path","title":"<code>set_active_runtime_path(path)</code>","text":"<p>Write active_runtime to config. Pass None to clear.</p> Source code in <code>brmspy/_runtime/_config.py</code> <pre><code>def set_active_runtime_path(path: Path | None) -&gt; None:\n    \"\"\"Write active_runtime to config. Pass None to clear.\"\"\"\n    config = read_config()\n    if path:\n        path = Path(path).expanduser().resolve()\n        config['active_runtime'] = str(path)\n    else:\n        config['active_runtime'] = None\n    write_config(config)\n</code></pre>"},{"location":"internals/_runtime/_download/","title":"_download","text":"<p>Download and extraction operations.</p>"},{"location":"internals/_runtime/_download/#brmspy._runtime._download-functions","title":"Functions","text":""},{"location":"internals/_runtime/_download/#brmspy._runtime._download.download_file","title":"<code>download_file(url, dest, show_progress=True)</code>","text":"<p>Download file from URL to destination with optional progress bar.</p> Source code in <code>brmspy/_runtime/_download.py</code> <pre><code>def download_file(\n    url: str,\n    dest: Path,\n    show_progress: bool = True,\n) -&gt; None:\n    \"\"\"Download file from URL to destination with optional progress bar.\"\"\"\n    urllib.request.urlretrieve(url, dest)\n</code></pre>"},{"location":"internals/_runtime/_download/#brmspy._runtime._download.extract_archive","title":"<code>extract_archive(archive, dest_dir)</code>","text":"<p>Extract tar.gz archive. Returns path to extracted root directory.</p> Source code in <code>brmspy/_runtime/_download.py</code> <pre><code>def extract_archive(archive: Path, dest_dir: Path) -&gt; Path:\n    \"\"\"Extract tar.gz archive. Returns path to extracted root directory.\"\"\"\n    dest_dir.mkdir(parents=True, exist_ok=True)\n\n    with tarfile.open(archive, mode=\"r:*\") as tf:\n        tf.extractall(path=dest_dir)\n\n    # Return the extracted directory (should be single top-level dir)\n    items = list(dest_dir.iterdir())\n    if len(items) == 1 and items[0].is_dir():\n        return items[0]\n    return dest_dir\n</code></pre>"},{"location":"internals/_runtime/_download/#brmspy._runtime._download.download_runtime","title":"<code>download_runtime(url, dest_dir, expected_hash=None)</code>","text":"<p>Download runtime archive and extract. Validates hash if provided. Returns path to extracted (not yet installed) runtime.</p> Source code in <code>brmspy/_runtime/_download.py</code> <pre><code>def download_runtime(\n    url: str,\n    dest_dir: Path,\n    expected_hash: str | None = None,\n) -&gt; Path:\n    \"\"\"\n    Download runtime archive and extract.\n    Validates hash if provided.\n    Returns path to extracted (not yet installed) runtime.\n    \"\"\"\n    # Download to temp file\n    with tempfile.NamedTemporaryFile(suffix=\".tar.gz\", delete=False) as tmp:\n        tmp_path = Path(tmp.name)\n\n    try:\n        download_file(url, tmp_path)\n\n        # TODO: Validate hash if provided\n\n        # Extract\n        extracted = extract_archive(tmp_path, dest_dir)\n\n        return extracted\n    finally:\n        if tmp_path.exists():\n            tmp_path.unlink()\n</code></pre>"},{"location":"internals/_runtime/_github/","title":"_github","text":"<p>GitHub API operations for runtime downloads.</p>"},{"location":"internals/_runtime/_github/#brmspy._runtime._github-attributes","title":"Attributes","text":""},{"location":"internals/_runtime/_github/#brmspy._runtime._github.REPO_OWNER","title":"<code>REPO_OWNER = 'kaitumisuuringute-keskus'</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_github/#brmspy._runtime._github.REPO_NAME","title":"<code>REPO_NAME = 'brmspy'</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_github/#brmspy._runtime._github-functions","title":"Functions","text":""},{"location":"internals/_runtime/_github/#brmspy._runtime._github.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/_runtime/_github/#brmspy._runtime._github.parse_release_url","title":"<code>parse_release_url(url)</code>","text":"<p>Parse a GitHub release asset URL into (owner, repo, tag, asset_name).</p> <p>Expected pattern:     https://github.com///releases/download// Source code in <code>brmspy/_runtime/_github.py</code> <pre><code>def parse_release_url(url: str) -&gt; tuple[str, str, str, str]:\n    \"\"\"\n    Parse a GitHub release asset URL into (owner, repo, tag, asset_name).\n\n    Expected pattern:\n        https://github.com/&lt;owner&gt;/&lt;repo&gt;/releases/download/&lt;tag&gt;/&lt;asset_name&gt;\n    \"\"\"\n    parsed = urlparse(url)\n\n    if parsed.scheme not in {\"http\", \"https\"}:\n        raise ValueError(f\"Malformed GitHub release URL: Invalid scheme: {url}\")\n\n    if parsed.hostname != \"github.com\":\n        raise ValueError(\n            f\"Malformed GitHub release URL: Unexpected host: {parsed.hostname!r}\"\n        )\n\n    # Split path, ignoring leading slash\n    parts = parsed.path.lstrip(\"/\").split(\"/\")\n\n    # Expected:\n    #   0: owner\n    #   1: repo\n    #   2: releases\n    #   3: download\n    #   4: tag\n    #   5: asset_name\n    if len(parts) &lt; 6:\n        raise ValueError(f\"Malformed GitHub release URL path: {parsed.path!r}\")\n\n    if parts[2] != \"releases\" or parts[3] != \"download\":\n        raise ValueError(\n            f\"Malformed GitHub release URL: Path does not match releases/download structure: {parsed.path!r}\"\n        )\n\n    owner, repo, _, _, tag, asset_name = parts[:6]\n    return owner, repo, tag, asset_name\n</code></pre>"},{"location":"internals/_runtime/_github/#brmspy._runtime._github.fetch_release_metadata","title":"<code>fetch_release_metadata(owner, repo, tag, use_token=True)</code>","text":"<p>Fetch release metadata from GitHub API (handles auth + retries).</p> Source code in <code>brmspy/_runtime/_github.py</code> <pre><code>def fetch_release_metadata(owner: str, repo: str, tag: str, use_token=True) -&gt; dict:\n    \"\"\"Fetch release metadata from GitHub API (handles auth + retries).\"\"\"\n    api_url = f\"https://api.github.com/repos/{owner}/{repo}/releases/tags/{tag}\"\n\n    # Prepare headers with auth if available\n    headers = {\"Accept\": \"application/vnd.github.v3+json\"}\n    if use_token:\n        token = os.environ.get(\"GITHUB_TOKEN\") or os.environ.get(\"GITHUB_PAT\")\n        if token:\n            headers[\"Authorization\"] = f\"token {token}\"\n\n    req = urllib.request.Request(api_url, headers=headers)\n\n    try:\n        with urllib.request.urlopen(req) as response:\n            return json.loads(response.read())\n    except Exception as e:\n        raise ConnectionError(f\"Failed to fetch release metadata: {e}\") from e\n</code></pre>"},{"location":"internals/_runtime/_github/#brmspy._runtime._github.get_asset_sha256","title":"<code>get_asset_sha256(url)</code>  <code>cached</code>","text":"<p>Get SHA256 hash from release asset metadata.</p> Source code in <code>brmspy/_runtime/_github.py</code> <pre><code>@functools.cache  # to avoid rate limits.\ndef get_asset_sha256(url: str) -&gt; str | None:\n    \"\"\"Get SHA256 hash from release asset metadata.\"\"\"\n    try:\n        owner, repo, tag, asset_name = parse_release_url(url)\n        try:\n            metadata = fetch_release_metadata(owner, repo, tag, use_token=False)\n        except Exception as e:\n            log_warning(\n                f\"Anonymous asset sha256 fetching failed, trying with token... Reason: {e}\"\n            )\n            metadata = fetch_release_metadata(owner, repo, tag, use_token=True)\n\n        # Find the asset in the release\n        for asset in metadata.get(\"assets\", []):\n            if asset.get(\"name\") == asset_name:\n                # GitHub doesn't provide SHA256 directly, but we can check if there's\n                # a .sha256 file or similar\n                # For now, return None as this needs to be implemented based on\n                # how the releases are structured\n                return asset.get(\"digest\")\n\n        return None\n    except Exception as e:\n        log_warning(f\"Could not get asset metadata: {e}\")\n        return None\n</code></pre>"},{"location":"internals/_runtime/_github/#brmspy._runtime._github.get_runtime_download_url","title":"<code>get_runtime_download_url(fingerprint, version='latest')</code>","text":"<p>Construct download URL for runtime bundle.</p> Source code in <code>brmspy/_runtime/_github.py</code> <pre><code>def get_runtime_download_url(fingerprint: str, version: str = \"latest\") -&gt; str:\n    \"\"\"Construct download URL for runtime bundle.\"\"\"\n    if version == \"latest\":\n        version = get_latest_runtime_version()\n    return f\"https://github.com/{REPO_OWNER}/{REPO_NAME}/releases/download/runtime/brmspy-runtime-{version}-{fingerprint}.tar.gz\"\n</code></pre>"},{"location":"internals/_runtime/_github/#brmspy._runtime._github.get_latest_runtime_version","title":"<code>get_latest_runtime_version()</code>","text":"<p>Query GitHub for latest runtime release version.</p> Source code in <code>brmspy/_runtime/_github.py</code> <pre><code>def get_latest_runtime_version() -&gt; str:\n    \"\"\"Query GitHub for latest runtime release version.\"\"\"\n    # For now, return a default version\n    # This should query the GitHub API for the latest release\n    return \"0.2.0\"\n</code></pre>"},{"location":"internals/_runtime/_github/#brmspy._runtime._github.get_github_asset_sha256_from_url","title":"<code>get_github_asset_sha256_from_url(url, require_digest=False)</code>","text":"<p>Get SHA256 from GitHub release asset. Used by old code.</p> Source code in <code>brmspy/_runtime/_github.py</code> <pre><code>def get_github_asset_sha256_from_url(\n    url: str, require_digest: bool = False\n) -&gt; str | None:\n    \"\"\"Get SHA256 from GitHub release asset. Used by old code.\"\"\"\n    sha = get_asset_sha256(url)\n    if require_digest and sha is None:\n        raise ValueError(f\"Could not fetch SHA256 digest for {url}\")\n    return sha\n</code></pre>"},{"location":"internals/_runtime/_install/","title":"_install","text":"<p>Installation orchestration for both traditional and prebuilt modes.</p>"},{"location":"internals/_runtime/_install/#brmspy._runtime._install-functions","title":"Functions","text":""},{"location":"internals/_runtime/_install/#brmspy._runtime._install.install_traditional","title":"<code>install_traditional(*, brms_version=None, cmdstanr_version=None, install_rstan=True, install_rtools=False, install_cmdstanr=True, rstan_version=None)</code>","text":"<p>Install brms via traditional R package installation.</p> <p>Installs into system R library, builds CmdStan from source. Takes 20-30 minutes typically.</p> Source code in <code>brmspy/_runtime/_install.py</code> <pre><code>def install_traditional(\n    *,\n    brms_version: str | None = None,\n    cmdstanr_version: str | None = None,\n    install_rstan: bool = True,\n    install_rtools: bool = False,\n    install_cmdstanr: bool = True,\n    rstan_version: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Install brms via traditional R package installation.\n\n    Installs into system R library, builds CmdStan from source.\n    Takes 20-30 minutes typically.\n    \"\"\"\n    # Validate\n    _platform.require_r_available()\n\n    # Setup\n    _r_env.forward_github_token()\n\n    if install_rtools and _platform.get_os() == \"windows\":\n        _rtools.ensure_installed()\n\n    repos_cmdstanr: list[str] = [\n        \"https://stan-dev.r-universe.dev\",\n        \"https://mc-stan.org/r-packages/\",\n    ]\n\n    # Install packages\n    _r_packages.install_package(\n        \"brms\", version=brms_version, repos_extra=repos_cmdstanr\n    )\n    _r_packages.install_package_deps(\"brms\", repos_extra=repos_cmdstanr)\n    # _r_packages.install_package(\"StanHeaders\", repos_extra=repos_cmdstanr)\n\n    if install_cmdstanr:\n        _r_packages.install_package(\n            \"cmdstanr\", version=cmdstanr_version, repos_extra=repos_cmdstanr\n        )\n        _r_packages.install_package_deps(\"cmdstanr\", repos_extra=repos_cmdstanr)\n        _r_packages.build_cmdstan()\n\n    if install_rstan:\n        _r_packages.install_package(\n            \"rstan\", version=rstan_version, repos_extra=repos_cmdstanr\n        )\n        _r_packages.install_package_deps(\"rstan\", repos_extra=repos_cmdstanr)\n\n    _state.invalidate_packages()\n    _state.get_brms()\n</code></pre>"},{"location":"internals/_runtime/_install/#brmspy._runtime._install.install_runtime","title":"<code>install_runtime(*, install_rtools=False)</code>","text":"<p>Install prebuilt runtime bundle.</p> <p>Downloads from GitHub, extracts to ~/.brmspy/runtime/. Does NOT activate - caller handles that.</p> <p>Returns:     Path to installed runtime directory.</p> Source code in <code>brmspy/_runtime/_install.py</code> <pre><code>def install_runtime(\n    *,\n    install_rtools: bool = False,\n) -&gt; Path:\n    \"\"\"\n    Install prebuilt runtime bundle.\n\n    Downloads from GitHub, extracts to ~/.brmspy/runtime/.\n    Does NOT activate - caller handles that.\n\n    Returns:\n        Path to installed runtime directory.\n    \"\"\"\n    # Validate system compatibility\n    _platform.require_prebuilt_compatible()\n\n    # Setup\n    _r_env.forward_github_token()\n\n    if install_rtools and _platform.get_os() == \"windows\":\n        _rtools.ensure_installed()\n\n    fingerprint = _platform.system_fingerprint()\n    version = _github.get_latest_runtime_version()\n\n    # Check if already installed with matching hash\n    existing = _storage.find_runtime_by_fingerprint(fingerprint)\n    url = _github.get_runtime_download_url(fingerprint, version)\n    expected_hash = _github.get_asset_sha256(url)\n\n    if not expected_hash:\n        raise Exception(f\"No expected hash from {url}\")\n\n    if existing:\n        stored_hash = _storage.read_stored_hash(existing)\n        if expected_hash and stored_hash == expected_hash:\n            return existing  # Reuse existing\n\n    # Download to temp directory\n    with tempfile.TemporaryDirectory() as temp_dir:\n        temp_path = Path(temp_dir)\n\n        # Download archive\n        archive_path = temp_path / \"runtime.tar.gz\"\n        urllib.request.urlretrieve(url, archive_path)\n\n        # Install from archive\n        runtime_path = _storage.install_from_archive(archive_path, fingerprint, version)\n\n    if expected_hash:\n        _storage.write_stored_hash(runtime_path, expected_hash)\n\n    _state.invalidate_packages()\n\n    return runtime_path\n</code></pre>"},{"location":"internals/_runtime/_manifest/","title":"_manifest","text":"<p>Manifest parsing and validation. Pure functions.</p>"},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest-classes","title":"Classes","text":""},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.RuntimeManifest","title":"<code>RuntimeManifest</code>  <code>dataclass</code>","text":"<p>Manifest for a prebuilt runtime bundle.</p> <p>This structure is typically loaded from a <code>manifest.json</code> stored alongside a runtime directory.</p> <p>Attributes:</p> Name Type Description <code>runtime_version</code> <code>str</code> <p>brmspy runtime bundle version.</p> <code>fingerprint</code> <code>str</code> <p>System fingerprint this runtime was built for.</p> <code>r_version</code> <code>str</code> <p>R version string used for the runtime build (for example <code>\"4.5.0\"</code>).</p> <code>cmdstan_version</code> <code>str</code> <p>CmdStan version included in the runtime.</p> <code>r_packages</code> <code>dict[str, str]</code> <p>Mapping of R package names to versions.</p> <code>manifest_hash</code> <code>str</code> <p>Hash used to validate the runtime contents.</p> <code>built_at</code> <code>str</code> <p>Build timestamp.</p> Source code in <code>brmspy/types/runtime.py</code> <pre><code>@dataclass(frozen=True)\nclass RuntimeManifest:\n    \"\"\"\n    Manifest for a prebuilt runtime bundle.\n\n    This structure is typically loaded from a `manifest.json` stored alongside a\n    runtime directory.\n\n    Attributes\n    ----------\n    runtime_version : str\n        brmspy runtime bundle version.\n    fingerprint : str\n        System fingerprint this runtime was built for.\n    r_version : str\n        R version string used for the runtime build (for example ``\"4.5.0\"``).\n    cmdstan_version : str\n        CmdStan version included in the runtime.\n    r_packages : dict[str, str]\n        Mapping of R package names to versions.\n    manifest_hash : str\n        Hash used to validate the runtime contents.\n    built_at : str\n        Build timestamp.\n    \"\"\"\n\n    runtime_version: str\n    fingerprint: str\n    r_version: str\n    cmdstan_version: str\n    r_packages: dict[str, str]  # {package_name: version}\n    manifest_hash: str\n    built_at: str\n</code></pre>"},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.RuntimeManifest-attributes","title":"Attributes","text":""},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.RuntimeManifest.runtime_version","title":"<code>runtime_version</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.RuntimeManifest.fingerprint","title":"<code>fingerprint</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.RuntimeManifest.r_version","title":"<code>r_version</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.RuntimeManifest.cmdstan_version","title":"<code>cmdstan_version</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.RuntimeManifest.r_packages","title":"<code>r_packages</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.RuntimeManifest.manifest_hash","title":"<code>manifest_hash</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.RuntimeManifest.built_at","title":"<code>built_at</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.RuntimeManifest-functions","title":"Functions","text":""},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.RuntimeManifest.__init__","title":"<code>__init__(runtime_version, fingerprint, r_version, cmdstan_version, r_packages, manifest_hash, built_at)</code>","text":""},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest-functions","title":"Functions","text":""},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.parse_manifest","title":"<code>parse_manifest(path)</code>","text":"<p>Parse manifest.json. Returns None if missing/invalid.</p> Source code in <code>brmspy/_runtime/_manifest.py</code> <pre><code>def parse_manifest(path: Path) -&gt; RuntimeManifest | None:\n    \"\"\"Parse manifest.json. Returns None if missing/invalid.\"\"\"\n    if not path.exists():\n        return None\n\n    data = None\n    try:\n        with path.open(\"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n\n        return RuntimeManifest(\n            runtime_version=data.get(\"runtime_version\", \"\"),\n            fingerprint=data.get(\"fingerprint\", \"\"),\n            r_version=data.get(\"r_version\", \"\"),\n            cmdstan_version=data.get(\"cmdstan_version\", \"\"),\n            r_packages=data.get(\"r_packages\", {}),\n            manifest_hash=data.get(\"manifest_hash\", \"\"),\n            built_at=data.get(\"built_at\", \"\"),\n        )\n    except Exception as e:\n        log_warning(f\"Failed parsing manifest: {e}\")\n        log_warning(f\"Broken manifest contents: {data}\")\n        return None\n</code></pre>"},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.validate_manifest","title":"<code>validate_manifest(manifest, expected_fingerprint)</code>","text":"<p>Validate manifest matches expected fingerprint. Raises RuntimeError with details if mismatch.</p> Source code in <code>brmspy/_runtime/_manifest.py</code> <pre><code>def validate_manifest(manifest: RuntimeManifest, expected_fingerprint: str) -&gt; None:\n    \"\"\"\n    Validate manifest matches expected fingerprint.\n    Raises RuntimeError with details if mismatch.\n    \"\"\"\n    if manifest.fingerprint != expected_fingerprint:\n        raise RuntimeError(\n            f\"Runtime fingerprint mismatch: \"\n            f\"manifest={manifest.fingerprint}, expected={expected_fingerprint}\"\n        )\n</code></pre>"},{"location":"internals/_runtime/_manifest/#brmspy._runtime._manifest.compute_manifest_hash","title":"<code>compute_manifest_hash(manifest_dict)</code>","text":"<p>Compute SHA256 of manifest content.</p> Source code in <code>brmspy/_runtime/_manifest.py</code> <pre><code>def compute_manifest_hash(manifest_dict: dict) -&gt; str:\n    \"\"\"Compute SHA256 of manifest content.\"\"\"\n    # Create a copy without the hash field itself\n    data = {k: v for k, v in manifest_dict.items() if k != \"manifest_hash\"}\n\n    # Serialize to JSON in a deterministic way\n    json_str = json.dumps(data, sort_keys=True, separators=(\",\", \":\"))\n\n    # Compute SHA256\n    return hashlib.sha256(json_str.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"internals/_runtime/_platform/","title":"_platform","text":"<p>System and environment detection. All functions are pure. No side effects, no R environment mutation.</p>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform-attributes","title":"Attributes","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.ENCODING_LOCALE","title":"<code>ENCODING_LOCALE = locale.getpreferredencoding()</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.PREBUILT_FINGERPRINTS","title":"<code>PREBUILT_FINGERPRINTS = set()</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform-classes","title":"Classes","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.SystemInfo","title":"<code>SystemInfo</code>  <code>dataclass</code>","text":"<p>Immutable snapshot of the system environment relevant to runtime selection.</p> <p>Attributes:</p> Name Type Description <code>os</code> <code>str</code> <p>Operating system identifier (for example <code>\"linux\"</code>, <code>\"macos\"</code>, <code>\"windows\"</code>).</p> <code>arch</code> <code>str</code> <p>CPU architecture (for example <code>\"x86_64\"</code>, <code>\"arm64\"</code>).</p> <code>r_version</code> <code>tuple[int, int, int] or None</code> <p>Detected R version as <code>(major, minor, patch)</code>.</p> <code>fingerprint</code> <code>str</code> <p>Fingerprint used for runtime lookup and caching (for example <code>\"linux-x86_64-r4.3\"</code>).</p> <code>glibc_version</code> <code>tuple[int, int] or None</code> <p>Linux-only: glibc major/minor version used for compatibility checks.</p> <code>clang_version</code> <code>tuple[int, int] or None</code> <p>macOS-only: clang major/minor version.</p> <code>gxx_version</code> <code>tuple[int, int] or None</code> <p>C++ compiler major/minor version if detected.</p> <code>has_rtools</code> <code>bool</code> <p>Windows-only: whether Rtools is available.</p> Source code in <code>brmspy/types/runtime.py</code> <pre><code>@dataclass(frozen=True)\nclass SystemInfo:\n    \"\"\"\n    Immutable snapshot of the system environment relevant to runtime selection.\n\n    Attributes\n    ----------\n    os : str\n        Operating system identifier (for example ``\"linux\"``, ``\"macos\"``, ``\"windows\"``).\n    arch : str\n        CPU architecture (for example ``\"x86_64\"``, ``\"arm64\"``).\n    r_version : tuple[int, int, int] or None\n        Detected R version as ``(major, minor, patch)``.\n    fingerprint : str\n        Fingerprint used for runtime lookup and caching (for example ``\"linux-x86_64-r4.3\"``).\n\n    glibc_version : tuple[int, int] or None\n        Linux-only: glibc major/minor version used for compatibility checks.\n    clang_version : tuple[int, int] or None\n        macOS-only: clang major/minor version.\n    gxx_version : tuple[int, int] or None\n        C++ compiler major/minor version if detected.\n    has_rtools : bool\n        Windows-only: whether Rtools is available.\n    \"\"\"\n\n    os: str  # 'linux', 'macos', 'windows'\n    arch: str  # 'x86_64', 'arm64'\n    r_version: tuple[int, int, int] | None  # (4, 3, 2)\n    fingerprint: str  # 'linux-x86_64-r4.3'\n\n    # Toolchain (populated based on OS)\n    glibc_version: tuple[int, int] | None  # Linux\n    clang_version: tuple[int, int] | None  # macOS\n    gxx_version: tuple[int, int] | None  # All platforms\n    has_rtools: bool  # Windows\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.SystemInfo-attributes","title":"Attributes","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.SystemInfo.os","title":"<code>os</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.SystemInfo.arch","title":"<code>arch</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.SystemInfo.r_version","title":"<code>r_version</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.SystemInfo.fingerprint","title":"<code>fingerprint</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.SystemInfo.glibc_version","title":"<code>glibc_version</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.SystemInfo.clang_version","title":"<code>clang_version</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.SystemInfo.gxx_version","title":"<code>gxx_version</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.SystemInfo.has_rtools","title":"<code>has_rtools</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.SystemInfo-functions","title":"Functions","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.SystemInfo.__init__","title":"<code>__init__(os, arch, r_version, fingerprint, glibc_version, clang_version, gxx_version, has_rtools)</code>","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform-functions","title":"Functions","text":""},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.log_error","title":"<code>log_error(msg, method_name=None)</code>","text":"<p>Log an error message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The error message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_error(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log an error message.\n\n    Parameters\n    ----------\n    msg : str\n        The error message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.ERROR)\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.get_os","title":"<code>get_os()</code>","text":"<p>Returns 'linux', 'macos', or 'windows'.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def get_os() -&gt; str:\n    \"\"\"Returns 'linux', 'macos', or 'windows'.\"\"\"\n    raw_os = platform.system().lower()\n    if raw_os == \"darwin\":\n        return \"macos\"\n    elif raw_os in (\"windows\", \"linux\"):\n        return raw_os\n    else:\n        return raw_os\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.get_arch","title":"<code>get_arch()</code>","text":"<p>Returns 'x86_64' or 'arm64'.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def get_arch() -&gt; str:\n    \"\"\"Returns 'x86_64' or 'arm64'.\"\"\"\n    raw_arch = platform.machine().lower()\n    if raw_arch in (\"x86_64\", \"amd64\"):\n        return \"x86_64\"\n    elif raw_arch in (\"arm64\", \"aarch64\"):\n        return \"arm64\"\n    else:\n        return raw_arch\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform._resolve_r_binary","title":"<code>_resolve_r_binary()</code>","text":"<p>Return path to R binary, preferring R_HOME if set.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def _resolve_r_binary() -&gt; str | None:\n    \"\"\"Return path to R binary, preferring R_HOME if set.\"\"\"\n    r_home = os.environ.get(\"R_HOME\")\n\n    if r_home:\n        # Construct OS-agnostic path:\n        candidate = os.path.join(r_home, \"bin\", \"R\")\n        if os.name == \"nt\":\n            candidate += \".exe\"\n\n        if os.path.isfile(candidate):\n            return candidate\n        # If R_HOME is set but binary missing, fall back to PATH resolution\n\n    # Fall back: search in PATH\n    return shutil.which(\"R\")\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.r_version_from_subprocess","title":"<code>r_version_from_subprocess()</code>","text":"Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def r_version_from_subprocess() -&gt; str:\n    r_bin = _resolve_r_binary()\n    if not r_bin:\n        raise RuntimeError(\"R not found via R_HOME or PATH\")\n\n    tmp = subprocess.check_output([r_bin, \"--version\"], stderr=subprocess.STDOUT)\n    r_version = tmp.decode(ENCODING_LOCALE, \"ignore\").split(os.linesep)\n\n    if r_version[0].startswith(\"WARNING\"):\n        value = r_version[1].strip()\n    value = r_version[0].strip()\n\n    value = value.replace(\"R version \", \"\").strip()\n    return value\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.get_r_version","title":"<code>get_r_version()</code>","text":"<p>Returns R version tuple or None if R not available.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def get_r_version() -&gt; tuple[int, int, int] | None:\n    \"\"\"Returns R version tuple or None if R not available.\"\"\"\n    try:\n        r_version = r_version_from_subprocess()\n        parts = r_version.split(\".\")\n        major = int(parts[0])\n        minor = int(parts[1]) if len(parts) &gt; 1 and parts[1].isdigit() else 0\n        patch = int(parts[2]) if len(parts) &gt; 2 and parts[2].isdigit() else 0\n        return major, minor, patch\n    except Exception as e:\n        log_warning(f\"{e}\")\n        return None\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.system_fingerprint","title":"<code>system_fingerprint()</code>","text":"<p>Returns '{os}-{arch}-r{major}.{minor}' string.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def system_fingerprint() -&gt; str:\n    \"\"\"Returns '{os}-{arch}-r{major}.{minor}' string.\"\"\"\n    os_name = get_os()\n    arch = get_arch()\n    r_ver = get_r_version()\n    if not r_ver:\n        raise RuntimeError(\"R version could not be determined\")\n    major, minor, _ = r_ver\n    return f\"{os_name}-{arch}-r{major}.{minor}\"\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.get_glibc_version","title":"<code>get_glibc_version()</code>","text":"<p>Linux only. Parse from ldd --version.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def get_glibc_version() -&gt; tuple[int, int] | None:\n    \"\"\"Linux only. Parse from ldd --version.\"\"\"\n    if get_os() != \"linux\":\n        return None\n\n    try:\n        out = subprocess.check_output([\"ldd\", \"--version\"], text=True, timeout=10)\n        for line in out.splitlines():\n            for token in line.split():\n                if token[0].isdigit() and \".\" in token:\n                    parts = token.split(\".\")\n                    if len(parts) &gt;= 2 and parts[0].isdigit() and parts[1].isdigit():\n                        return int(parts[0]), int(parts[1])\n    except Exception:\n        pass\n    return None\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.get_clang_version","title":"<code>get_clang_version()</code>","text":"<p>macOS only. Parse from clang --version.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def get_clang_version() -&gt; tuple[int, int] | None:\n    \"\"\"macOS only. Parse from clang --version.\"\"\"\n    if get_os() != \"macos\":\n        return None\n\n    try:\n        out = subprocess.check_output([\"clang\", \"--version\"], text=True, timeout=10)\n        for line in out.splitlines():\n            if \"clang\" not in line.lower():\n                continue\n            for token in line.split():\n                if token[0].isdigit() and \".\" in token:\n                    parts = token.split(\".\")\n                    if len(parts) &gt;= 2 and parts[0].isdigit() and parts[1].isdigit():\n                        return int(parts[0]), int(parts[1])\n    except Exception:\n        pass\n    return None\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.get_gxx_version","title":"<code>get_gxx_version(out=None)</code>","text":"<p>Parse from g++ --version.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def get_gxx_version(out: None | str = None) -&gt; tuple[int, int] | None:\n    \"\"\"Parse from g++ --version.\"\"\"\n    try:\n        if out is None:\n            out = subprocess.check_output([\"g++\", \"--version\"], text=True, timeout=10)\n        # Parse g++ version (same logic as helpers/rtools.py)\n        for line in out.splitlines():\n            for token in line.split():\n                if token[0].isdigit() and \".\" in token:\n                    parts = token.split(\".\")\n                    if len(parts) &gt;= 2 and parts[0].isdigit() and parts[1].isdigit():\n                        return int(parts[0]), int(parts[1])\n    except Exception:\n        pass\n    return None\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.get_system_info","title":"<code>get_system_info()</code>","text":"<p>Collect all system info into immutable dataclass.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def get_system_info() -&gt; SystemInfo:\n    \"\"\"Collect all system info into immutable dataclass.\"\"\"\n    os_name = get_os()\n    arch = get_arch()\n    r_ver = get_r_version()\n    fp = system_fingerprint() if r_ver else f\"{os_name}-{arch}-rUNK\"\n\n    # Collect toolchain info based on OS\n    glibc_ver = None\n    clang_ver = None\n    gxx_ver = None\n    has_rtools = False\n\n    if os_name == \"linux\":\n        glibc_ver = get_glibc_version()\n        gxx_ver = get_gxx_version()\n    elif os_name == \"macos\":\n        clang_ver = get_clang_version()\n    elif os_name == \"windows\":\n        has_rtools = _windows_has_rtools(silent=True)\n        gxx_ver = get_gxx_version()\n\n    return SystemInfo(\n        os=os_name,\n        arch=arch,\n        r_version=r_ver,\n        fingerprint=fp,\n        glibc_version=glibc_ver,\n        clang_version=clang_ver,\n        gxx_version=gxx_ver,\n        has_rtools=has_rtools,\n    )\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.is_platform_supported","title":"<code>is_platform_supported()</code>","text":"<p>True if OS/arch combination is supported.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def is_platform_supported() -&gt; bool:\n    \"\"\"True if OS/arch combination is supported.\"\"\"\n    os_name = get_os()\n    arch = get_arch()\n    supported_os = (\"linux\", \"macos\", \"windows\")\n    supported_os_arch = {\"windows\": {\"x86_64\"}, \"linux\": {\"x86_64\"}, \"macos\": {\"arm64\"}}\n\n    if os_name not in supported_os:\n        return False\n\n    supported_archs = supported_os_arch.get(os_name, set())\n    if arch not in supported_archs:\n        return False\n\n    return True\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.is_r_available","title":"<code>is_r_available()</code>","text":"<p>True if R is installed.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def is_r_available() -&gt; bool:\n    \"\"\"True if R is installed.\"\"\"\n    return get_r_version() is not None\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.is_r_supported","title":"<code>is_r_supported(min_version=(4, 0))</code>","text":"<p>True if R version meets minimum.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def is_r_supported(min_version: tuple[int, int] = (4, 0)) -&gt; bool:\n    \"\"\"True if R version meets minimum.\"\"\"\n    v = get_r_version()\n    if v is None:\n        return False\n    major, minor, _ = v\n    min_major, min_minor = min_version\n    if major &lt; min_major:\n        return False\n    if major == min_major and minor &lt; min_minor:\n        return False\n    return True\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.is_linux_toolchain_ok","title":"<code>is_linux_toolchain_ok()</code>","text":"<p>True if glibc &gt;= 2.27 and g++ &gt;= 9.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def is_linux_toolchain_ok() -&gt; bool:\n    \"\"\"True if glibc &gt;= 2.27 and g++ &gt;= 9.\"\"\"\n    glibc = get_glibc_version()\n    if glibc is None or glibc &lt; (2, 27):\n        return False\n\n    gxx = get_gxx_version()\n    if gxx is None or gxx &lt; (9, 0):\n        return False\n\n    return True\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.is_macos_toolchain_ok","title":"<code>is_macos_toolchain_ok()</code>","text":"<p>True if Xcode CLT installed and clang &gt;= 11.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def is_macos_toolchain_ok() -&gt; bool:\n    \"\"\"True if Xcode CLT installed and clang &gt;= 11.\"\"\"\n    try:\n        subprocess.check_output([\"xcode-select\", \"-p\"], text=True, timeout=10)\n    except Exception:\n        return False\n\n    clang = get_clang_version()\n    if clang is None or clang &lt; (11, 0):\n        return False\n\n    return True\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.is_windows_toolchain_ok","title":"<code>is_windows_toolchain_ok()</code>","text":"<p>True if Rtools with g++ &gt;= 9.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def is_windows_toolchain_ok() -&gt; bool:\n    \"\"\"True if Rtools with g++ &gt;= 9.\"\"\"\n    if not _windows_has_rtools(silent=True):\n        return False\n    gxx_version = get_gxx_version()\n    if gxx_version is None or gxx_version &lt; (9, 0):\n        return False\n    return True\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.is_toolchain_compatible","title":"<code>is_toolchain_compatible()</code>","text":"<p>Route to OS-specific check.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def is_toolchain_compatible() -&gt; bool:\n    \"\"\"Route to OS-specific check.\"\"\"\n    os_name = get_os()\n    if os_name == \"linux\":\n        return is_linux_toolchain_ok()\n    elif os_name == \"macos\":\n        return is_macos_toolchain_ok()\n    elif os_name == \"windows\":\n        return is_windows_toolchain_ok()\n    return False\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.can_use_prebuilt","title":"<code>can_use_prebuilt()</code>","text":"<p>Master check: platform + R + toolchain.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def can_use_prebuilt() -&gt; bool:\n    \"\"\"Master check: platform + R + toolchain.\"\"\"\n    if not is_platform_supported():\n        return False\n    if not is_r_supported():\n        return False\n    if not is_toolchain_compatible():\n        return False\n    return True\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.is_prebuilt_available","title":"<code>is_prebuilt_available(fingerprint)</code>","text":"<p>True if we publish prebuilt for this fingerprint.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def is_prebuilt_available(fingerprint: str) -&gt; bool:\n    \"\"\"True if we publish prebuilt for this fingerprint.\"\"\"\n    # Currently we allow all fingerprints if can_use_prebuilt() passes\n    # In future, this could check against PREBUILT_FINGERPRINTS\n    return fingerprint in PREBUILT_FINGERPRINTS if PREBUILT_FINGERPRINTS else True\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.get_compatibility_issues","title":"<code>get_compatibility_issues()</code>","text":"<p>Return list of human-readable compatibility issues.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def get_compatibility_issues() -&gt; list[str]:\n    \"\"\"Return list of human-readable compatibility issues.\"\"\"\n    issues = []\n\n    if not is_platform_supported():\n        os_name = get_os()\n        arch = get_arch()\n        issues.append(f\"Unsupported platform: {os_name}-{arch}\")\n\n    if not is_r_available():\n        issues.append(\"R is not available\")\n    elif not is_r_supported():\n        r_ver = get_r_version()\n        issues.append(f\"R version {r_ver} is too old (need &gt;= 4.0)\")\n\n    if not is_toolchain_compatible():\n        os_name = get_os()\n        if os_name == \"linux\":\n            glibc = get_glibc_version()\n            gxx = get_gxx_version()\n            if glibc is None or glibc &lt; (2, 27):\n                issues.append(f\"glibc {glibc} is too old (need &gt;= 2.27)\")\n            if gxx is None or gxx &lt; (9, 0):\n                issues.append(f\"g++ {gxx} is too old (need &gt;= 9.0)\")\n        elif os_name == \"macos\":\n            try:\n                subprocess.check_output([\"xcode-select\", \"-p\"], text=True, timeout=10)\n            except Exception:\n                issues.append(\"Xcode Command Line Tools not installed\")\n            clang = get_clang_version()\n            if clang is None or clang &lt; (11, 0):\n                issues.append(f\"clang {clang} is too old (need &gt;= 11.0)\")\n        elif os_name == \"windows\":\n            if not is_windows_toolchain_ok():\n                issues.append(\"Rtools not found or insufficient version\")\n\n    return issues\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.require_platform_supported","title":"<code>require_platform_supported()</code>","text":"<p>Raise RuntimeError with actionable message if unsupported.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def require_platform_supported() -&gt; None:\n    \"\"\"Raise RuntimeError with actionable message if unsupported.\"\"\"\n    if not is_platform_supported():\n        os_name = get_os()\n        arch = get_arch()\n        raise RuntimeError(\n            f\"Platform {os_name}-{arch} is not supported. \"\n            f\"Supported platforms: linux-x86_64, macos-arm64, windows-x86_64\"\n        )\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.require_r_available","title":"<code>require_r_available(min_version=(4, 0))</code>","text":"<p>Raise RuntimeError if R missing or too old.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def require_r_available(min_version: tuple[int, int] = (4, 0)) -&gt; None:\n    \"\"\"Raise RuntimeError if R missing or too old.\"\"\"\n    if not is_r_available():\n        raise RuntimeError(\n            \"R is not available. Please install R &gt;= 4.0 from https://cran.r-project.org/\"\n        )\n    if not is_r_supported(min_version):\n        r_ver = get_r_version()\n        raise RuntimeError(\n            f\"R version {r_ver} is too old. Please upgrade to R &gt;= {min_version[0]}.{min_version[1]}\"\n        )\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.require_toolchain_compatible","title":"<code>require_toolchain_compatible()</code>","text":"<p>Raise RuntimeError with install instructions if toolchain insufficient.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def require_toolchain_compatible() -&gt; None:\n    \"\"\"Raise RuntimeError with install instructions if toolchain insufficient.\"\"\"\n    os_name = get_os()\n\n    if os_name == \"linux\":\n        if not is_linux_toolchain_ok():\n            glibc = get_glibc_version()\n            gxx = get_gxx_version()\n            raise RuntimeError(\n                f\"Linux toolchain insufficient:\\n\"\n                f\"  glibc: {glibc} (need &gt;= 2.27)\\n\"\n                f\"  g++: {gxx} (need &gt;= 9.0)\\n\"\n                f\"Please upgrade your system or install from source.\"\n            )\n    elif os_name == \"macos\":\n        if not is_macos_toolchain_ok():\n            raise RuntimeError(\n                \"macOS toolchain insufficient:\\n\"\n                \"  Install Xcode Command Line Tools: xcode-select --install\\n\"\n                \"  Need clang &gt;= 11.0\"\n            )\n    elif os_name == \"windows\":\n        if not is_windows_toolchain_ok():\n            raise RuntimeError(\n                \"Windows toolchain insufficient:\\n\"\n                \"  Install Rtools from https://cran.r-project.org/bin/windows/Rtools/\\n\"\n                \"  Or run install(install_rtools=True)\"\n            )\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform.require_prebuilt_compatible","title":"<code>require_prebuilt_compatible()</code>","text":"<p>Raise RuntimeError if system can't use prebuilt runtimes.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def require_prebuilt_compatible() -&gt; None:\n    \"\"\"Raise RuntimeError if system can't use prebuilt runtimes.\"\"\"\n    issues = get_compatibility_issues()\n    can_use = can_use_prebuilt()\n    if issues or not can_use:\n        raise RuntimeError(\n            \"System cannot use prebuilt runtimes:\\n\"\n            + \"\\n\".join(f\"  - {issue}\" for issue in issues)\n        )\n</code></pre>"},{"location":"internals/_runtime/_platform/#brmspy._runtime._platform._windows_has_rtools","title":"<code>_windows_has_rtools(silent=False)</code>","text":"Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def _windows_has_rtools(silent=False) -&gt; bool:\n    # Fast path: RTOOLS*_HOME\n    for name in (\n        \"RTOOLS47_HOME\",\n        \"RTOOLS46_HOME\",\n        \"RTOOLS45_HOME\",\n        \"RTOOLS44_HOME\",\n        \"RTOOLS43_HOME\",\n        \"RTOOLS42_HOME\",\n        \"RTOOLS40_HOME\",\n    ):\n        home = os.environ.get(name)\n        if home:\n            make = Path(home) / \"usr\" / \"bin\" / \"make.exe\"\n            if make.exists():\n                return True\n\n    try:\n        out = subprocess.check_output(\n            [\"g++\", \"--version\"], text=True, shell=True, timeout=5\n        )\n    except Exception:\n        if not silent:\n            log_warning(\"g++ not found\")\n        return False\n\n    # Very rough: we expect mingw in the banner\n    if \"mingw\" not in out.lower():\n        if not silent:\n            log_warning(\"mingw not found in g++ banner\")\n        return False\n\n    return True\n</code></pre>"},{"location":"internals/_runtime/_r_env/","title":"_r_env","text":"<p>R environment operations: libPaths, cmdstan path, package loading. Each function does exactly one R operation. Stateless.</p>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env-functions","title":"Functions","text":""},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env.get_lib_paths","title":"<code>get_lib_paths()</code>","text":"<p>Get current .libPaths() from R.</p> Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def get_lib_paths() -&gt; list[str]:\n    \"\"\"Get current .libPaths() from R.\"\"\"\n    import rpy2.robjects as ro\n    result = cast(ro.ListVector, ro.r('.libPaths()'))\n    return [str(p) for p in result]\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env.get_cmdstan_path","title":"<code>get_cmdstan_path()</code>","text":"<p>Get current cmdstanr::cmdstan_path() or None.</p> Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def get_cmdstan_path() -&gt; str | None:\n    \"\"\"Get current cmdstanr::cmdstan_path() or None.\"\"\"\n    import rpy2.robjects as ro\n    try:\n        result = cast(ro.ListVector, ro.r(\"suppressWarnings(suppressMessages(cmdstanr::cmdstan_path()))\"))\n        return str(result[0]) if result else None\n    except Exception:\n        return None\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env.is_namespace_loaded","title":"<code>is_namespace_loaded(name)</code>","text":"<p>Check if package namespace is loaded.</p> Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def is_namespace_loaded(name: str) -&gt; bool:\n    \"\"\"Check if package namespace is loaded.\"\"\"\n    import rpy2.robjects as ro\n    expr = f'\"{name}\" %in% loadedNamespaces()'\n\n    res = cast(ro. ListVector, ro.r(expr))\n    return str(res[0]).lower().strip() == \"true\"\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env.is_package_attached","title":"<code>is_package_attached(name)</code>","text":"<p>Check if package is on search path.</p> Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def is_package_attached(name: str) -&gt; bool:\n    \"\"\"Check if package is on search path.\"\"\"\n    import rpy2.robjects as ro\n    expr = f'paste0(\"package:\", \"{name}\") %in% search()'\n    res = cast(ro.ListVector, ro.r(expr))\n    return str(res[0]).lower().strip() == \"true\"\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env.unload_package","title":"<code>unload_package(name)</code>","text":"<p>Also known as footgun. Don't call without very good reason.</p> <p>Attempt to unload package. Returns True if successful. Tries: detach -&gt; unloadNamespace -&gt; library.dynam.unload Does NOT uninstall.</p> Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def unload_package(name: str) -&gt; bool:\n    \"\"\"\n    Also known as footgun. Don't call without very good reason.\n\n    Attempt to unload package. Returns True if successful.\n    Tries: detach -&gt; unloadNamespace -&gt; library.dynam.unload\n    Does NOT uninstall.\n    \"\"\"\n    import rpy2.robjects as ro\n\n    detach_only = False\n\n    r_code = f\"\"\"\n      pkg &lt;- \"{name}\"\n      detach_only &lt;- {str(detach_only).upper()}\n\n      .unload_pkg &lt;- function(pkg, detach_only) {{\n        success &lt;- TRUE\n\n        # Always try to detach from search path first\n        tryCatch({{\n          search_name &lt;- paste0(\"package:\", pkg)\n          if (search_name %in% search()) {{\n            detach(search_name,\n                   unload = !detach_only,\n                   character.only = TRUE)\n          }}\n        }}, error = function(e) {{ success &lt;&lt;- FALSE }})\n\n        if (detach_only) {{\n          # do *not* touch namespace or DLL\n          return(success)\n        }}\n\n        # 2) Unload namespace\n        tryCatch({{\n          if (pkg %in% loadedNamespaces()) {{\n            unloadNamespace(pkg)\n          }}\n        }}, error = function(e) {{ success &lt;&lt;- FALSE }})\n\n        # 3) pkgload (devtools-style unload)\n        tryCatch({{\n          if (requireNamespace(\"pkgload\", quietly = TRUE)) {{\n            pkgload::unload(pkg)\n          }}\n        }}, error = function(e) {{}})\n\n        # 4) DLL unload if still registered\n        tryCatch({{\n          dlls &lt;- getLoadedDLLs()\n          if (pkg %in% rownames(dlls)) {{\n            dll_info &lt;- dlls[[pkg]]\n            dll_name &lt;- dll_info[[\"name\"]]\n            libpath  &lt;- dirname(dll_info[[\"path\"]])\n            library.dynam.unload(\n              chname  = dll_name,\n              package = pkg,\n              libpath = libpath\n            )\n          }}\n        }}, error = function(e) {{}})\n\n        success\n      }}\n\n      .unload_pkg(pkg, detach_only)\n    \"\"\"\n\n    try:\n        result = cast(list, ro.r(r_code))\n        return str(result[0]).lower().strip() == \"true\"\n    except Exception:\n        return False\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env._find_libpath_packages","title":"<code>_find_libpath_packages(libpath, include_not_loaded=False)</code>","text":"Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def _find_libpath_packages(libpath: Path | None, include_not_loaded: bool = False) -&gt; list[str]:\n    import rpy2.robjects as ro\n    if libpath is None:\n        return []\n    pkgs = cast(Callable, ro.r(\"\"\"\nfunction(runtime_root, include_not_loaded = FALSE) {\n  lib_root &lt;- file.path(runtime_root, \"Rlib\")\n  lib_root &lt;- normalizePath(lib_root, winslash = \"/\", mustWork = TRUE)\n\n  attached &lt;- sub(\"^package:\", \"\", grep(\"^package:\", search(), value = TRUE))\n  ns &lt;- loadedNamespaces()\n  pkgs &lt;- unique(c(attached, ns))\n\n  # optionally add packages that are installed in this lib_root\n  if (isTRUE(include_not_loaded)) {\n    inst &lt;- tryCatch(\n      installed.packages(lib.loc = lib_root)[, \"Package\"],\n      error = function(e) character(0L)\n    )\n    pkgs &lt;- unique(c(pkgs, inst))\n  }\n\n  res &lt;- vapply(pkgs, function(p) {\n    path &lt;- suppressWarnings(tryCatch(\n      find.package(p, quiet = TRUE)[1],\n      error = function(e) NA_character_\n    ))\n\n    if (is.na(path) || !nzchar(path)) {\n      return(NA_character_)\n    }\n\n    path &lt;- normalizePath(path, winslash = \"/\", mustWork = FALSE)\n\n    if (startsWith(path, lib_root)) p else NA_character_\n  }, character(1L))\n\n  res[!is.na(res)]\n}\n    \"\"\"))(libpath.as_posix(), include_not_loaded)\n\n    pkgs = [str(v) for v in cast(ro.StrVector, pkgs)]\n\n    return pkgs\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env._compute_unload_order","title":"<code>_compute_unload_order(pkgs)</code>","text":"Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def _compute_unload_order(pkgs: list[str] | None) -&gt; list[str] | None:\n    if pkgs is None:\n        return None\n    if len(pkgs) == 0:\n        return []\n    import rpy2.robjects as ro\n    fun = cast(Callable, ro.r(\"\"\"\nfunction(pkgs) {\n  pkgs &lt;- unique(as.character(pkgs))\n  if (!length(pkgs)) return(character(0L))\n\n  # Try to get metadata; if this fails, just treat as \"no deps info\"\n  ip &lt;- tryCatch(\n    installed.packages(lib.loc = .libPaths(), noCache = TRUE)[, \"Package\"],\n    error = function(e) character(0L)\n  )\n\n  pkgs_with_meta &lt;- intersect(pkgs, ip)\n\n  deps &lt;- vector(\"list\", length(pkgs))\n  names(deps) &lt;- pkgs\n\n  if (length(pkgs_with_meta)) {\n    d &lt;- tools::package_dependencies(\n      pkgs_with_meta,\n      which     = c(\"Depends\", \"Imports\", \"LinkingTo\"),\n      recursive = FALSE,\n      reverse   = TRUE\n    )\n    # Keep only edges within our original pkgs set\n    d &lt;- lapply(d, function(x) intersect(x, pkgs))\n    deps[names(d)] &lt;- d\n  }\n\n  remaining &lt;- pkgs\n  order &lt;- character(0L)\n\n  while (length(remaining)) {\n    has_dependents &lt;- unique(unlist(deps[remaining]))\n    leaves &lt;- setdiff(remaining, has_dependents)\n\n    if (!length(leaves)) {\n      # Cycle or no dep info: just append the rest\n      order &lt;- c(order, remaining)\n      break\n    }\n\n    order &lt;- c(order, leaves)\n    remaining &lt;- setdiff(remaining, leaves)\n  }\n\n  order\n}\n\"\"\"))\n    lv = cast(ro.StrVector, fun(ro.StrVector(pkgs)))\n    return [str(v) for v in lv]\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env._unload_libpath_packages","title":"<code>_unload_libpath_packages(libpath)</code>","text":"Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def _unload_libpath_packages(libpath: Path | None) -&gt; None:\n    if not libpath or not libpath.exists():\n        return\n    pkgs = _find_libpath_packages(libpath)\n    if len(pkgs) == 0:\n        return\n    pkgs = _compute_unload_order(pkgs)\n    if not pkgs:\n        return\n    for pkg in pkgs:\n        try:\n            unload_package(pkg)\n        except Exception as e:\n            log_warning(f\"{e}\")\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env._is_runtime_path","title":"<code>_is_runtime_path(p)</code>","text":"Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def _is_runtime_path(p: str):\n    return \".brmspy/runtime/\" not in p and \".brmspy\\\\runtime\\\\\" not in p\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env._is_environment_path","title":"<code>_is_environment_path(p)</code>","text":"Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def _is_environment_path(p: str):\n    return \".brmspy/runtime/\" not in p and \".brmspy\\\\runtime\\\\\" not in p\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env._path_priority","title":"<code>_path_priority(p)</code>","text":"Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def _path_priority(p: str) -&gt; int:\n    if _is_environment_path(p):\n        return 0\n    if _is_runtime_path(p):\n        return 1\n    return 2\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env.set_lib_paths","title":"<code>set_lib_paths(paths)</code>","text":"<p>Set .libPaths() in R.</p> Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def set_lib_paths(paths: list[str]) -&gt; None:\n    \"\"\"Set .libPaths() in R.\"\"\"\n    import rpy2.robjects as ro\n\n    current = [str(p) for p in cast(ro.StrVector, ro.r(\".libPaths()\"))]\n    if any(_is_environment_path(p) for p in paths):\n        current = [p for p in current if not _is_environment_path(p)]\n    elif any(_is_runtime_path(p) for p in paths):\n        current = [p for p in current if not _is_runtime_path(p)]\n\n    new_paths = list(dict.fromkeys(list(paths) + current))\n    new_paths = sorted(new_paths, key=_path_priority)\n    r_fun = cast(Callable, ro.r('.libPaths'))\n    r_fun(ro.StrVector(new_paths))\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env.set_cmdstan_path","title":"<code>set_cmdstan_path(path)</code>","text":"<p>Set cmdstanr::set_cmdstan_path().</p> Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def set_cmdstan_path(path: str | None) -&gt; None:\n    \"\"\"Set cmdstanr::set_cmdstan_path().\"\"\"\n    import rpy2.robjects as ro\n\n    try:\n      if path is None:\n          path_str = \"NULL\"\n      else:\n          path_str = f'\"{path}\"'\n\n      ro.r(f'''\n      if (!requireNamespace(\"cmdstanr\", quietly = TRUE)) {{\n        stop(\"cmdstanr is not available in rlibs\")\n      }}\n      suppressWarnings(suppressMessages(cmdstanr::set_cmdstan_path(path={path_str})))\n      ''')\n\n    except Exception as e:\n        log_warning(f\"Failed to set cmdstan_path to {path}: {e}\")\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env.run_gc","title":"<code>run_gc()</code>","text":"<p>Run garbage collection in both Python and R.</p> Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def run_gc() -&gt; None:\n    \"\"\"Run garbage collection in both Python and R.\"\"\"\n    import gc\n\n    import rpy2.robjects as ro\n    gc.collect()\n    try:\n        ro.r('gc()')\n    except Exception:\n        pass\n</code></pre>"},{"location":"internals/_runtime/_r_env/#brmspy._runtime._r_env.forward_github_token","title":"<code>forward_github_token()</code>","text":"<p>Copy GITHUB_TOKEN/GITHUB_PAT to R's Sys.setenv.</p> Source code in <code>brmspy/_runtime/_r_env.py</code> <pre><code>def forward_github_token() -&gt; None:\n    \"\"\"Copy GITHUB_TOKEN/GITHUB_PAT to R's Sys.setenv.\"\"\"\n    import rpy2.robjects as ro\n    try:\n        kwargs = {}\n        pat = os.environ.get(\"GITHUB_PAT\")\n        token = os.environ.get(\"GITHUB_TOKEN\")\n\n        if not pat and not token:\n            return\n\n        r_setenv = cast(Callable, ro.r(\"Sys.setenv\"))\n\n        if pat:\n            kwargs[\"GITHUB_PAT\"] = pat\n        elif token:\n            kwargs[\"GITHUB_TOKEN\"] = token\n\n        if kwargs:\n            r_setenv(**kwargs)\n    except Exception:\n        pass\n</code></pre>"},{"location":"internals/_runtime/_r_packages/","title":"_r_packages","text":"<p>R package queries and installation. Stateless - no caching.</p>"},{"location":"internals/_runtime/_r_packages/#brmspy._runtime._r_packages-functions","title":"Functions","text":""},{"location":"internals/_runtime/_r_packages/#brmspy._runtime._r_packages.log","title":"<code>log(*msg, method_name=None, level=logging.INFO)</code>","text":"<p>Log a message with automatic method name detection.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log</p> <code>()</code> <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> <code>level</code> <code>int</code> <p>Logging level (default: logging.INFO)</p> <code>INFO</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log(*msg: str, method_name: str | None = None, level: int = logging.INFO):\n    \"\"\"\n    Log a message with automatic method name detection.\n\n    Parameters\n    ----------\n    msg : str\n        The message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n    level : int, optional\n        Logging level (default: logging.INFO)\n    \"\"\"\n    if method_name is None:\n        method_name = _get_caller_name()\n\n    msg_str = \" \".join(str(v) for v in msg)\n\n    logger = get_logger()\n    logger.log(level, msg_str, extra={\"method_name\": method_name})\n</code></pre>"},{"location":"internals/_runtime/_r_packages/#brmspy._runtime._r_packages.log_error","title":"<code>log_error(msg, method_name=None)</code>","text":"<p>Log an error message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The error message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_error(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log an error message.\n\n    Parameters\n    ----------\n    msg : str\n        The error message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.ERROR)\n</code></pre>"},{"location":"internals/_runtime/_r_packages/#brmspy._runtime._r_packages.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/_runtime/_r_packages/#brmspy._runtime._r_packages.get_package_version","title":"<code>get_package_version(name)</code>","text":"<p>Get installed package version or None.</p> Source code in <code>brmspy/_runtime/_r_packages.py</code> <pre><code>def get_package_version(name: str) -&gt; str | None:\n    \"\"\"Get installed package version or None.\"\"\"\n    import rpy2.robjects as ro\n\n    if not is_package_installed(name):\n        return None\n    try:\n        expr = f\"\"\"\n        v &lt;- utils::packageDescription('{name}', fields = 'Version', lib.loc=.libPaths())\n        if (is.na(v)) stop('Package not found')\n        v\n        \"\"\"\n        v_str = cast(list, ro.r(expr))[0]\n        return str(v_str)\n    except Exception:\n        return None\n</code></pre>"},{"location":"internals/_runtime/_r_packages/#brmspy._runtime._r_packages.is_package_installed","title":"<code>is_package_installed(name, lib_loc=None)</code>","text":"<p>Check if package is installed.</p> Source code in <code>brmspy/_runtime/_r_packages.py</code> <pre><code>def is_package_installed(name: str, lib_loc=None) -&gt; bool:\n    \"\"\"Check if package is installed.\"\"\"\n    from rpy2.robjects.packages import isinstalled\n\n    try:\n        return isinstalled(name, lib_loc=lib_loc)\n    except Exception:\n        return False\n</code></pre>"},{"location":"internals/_runtime/_r_packages/#brmspy._runtime._r_packages.set_cran_mirror","title":"<code>set_cran_mirror(mirror=None)</code>","text":"<p>Set CRAN mirror. Uses Posit Package Manager on Linux for binary packages.</p> Source code in <code>brmspy/_runtime/_r_packages.py</code> <pre><code>def set_cran_mirror(mirror: str | None = None) -&gt; None:\n    \"\"\"\n    Set CRAN mirror.\n    Uses Posit Package Manager on Linux for binary packages.\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if mirror is None:\n        mirror = \"https://cloud.r-project.org\"\n    ro.r(f'options(repos = c(CRAN = \"{mirror}\"))')\n</code></pre>"},{"location":"internals/_runtime/_r_packages/#brmspy._runtime._r_packages._get_linux_repo","title":"<code>_get_linux_repo()</code>","text":"<p>Get Posit Package Manager URL for Linux binaries.</p> Source code in <code>brmspy/_runtime/_r_packages.py</code> <pre><code>def _get_linux_repo() -&gt; str:\n    \"\"\"Get Posit Package Manager URL for Linux binaries.\"\"\"\n    try:\n        with open(\"/etc/os-release\") as f:\n            lines = f.readlines()\n\n        codename = \"jammy\"  # Default fallback (Ubuntu 22.04)\n        for line in lines:\n            if line.startswith(\"VERSION_CODENAME=\"):\n                codename = line.strip().split(\"=\")[1].strip('\"')\n                break\n\n        return f\"https://packagemanager.posit.co/cran/__linux__/{codename}/latest\"\n    except FileNotFoundError:\n        return \"https://packagemanager.posit.co/cran/__linux__/jammy/latest\"\n</code></pre>"},{"location":"internals/_runtime/_r_packages/#brmspy._runtime._r_packages.install_package","title":"<code>install_package(name, version=None, repos_extra=None)</code>","text":"Source code in <code>brmspy/_runtime/_r_packages.py</code> <pre><code>def install_package(\n    name: str,\n    version: str | None = None,\n    repos_extra: str | list[str | None] | list[str] | None = None,\n) -&gt; None:\n    import rpy2.robjects as ro\n    from rpy2.robjects.packages import importr\n\n    from brmspy._runtime._r_env import get_lib_paths, unload_package\n\n    # Normalise special values that mean \"latest / no constraint\"\n    if version is not None:\n        v = version.strip()\n        if v == \"\" or v.lower() in (\"latest\", \"any\"):\n            version = None\n        else:\n            version = v\n\n    set_cran_mirror()\n\n    utils = importr(\"utils\")\n    system = platform.system()\n    cores = multiprocessing.cpu_count()\n\n    lib_path_py = [get_lib_paths()[0]]\n    lib_path = ro.StrVector(lib_path_py)\n\n    already_installed = is_package_installed(name, lib_loc=lib_path_py[0])\n\n    repos: list[str] = [\"https://cloud.r-project.org\"]  # good default mirror\n\n    if system == \"Linux\":\n        # On Linux, we MUST use P3M to get binaries. These present as \"source\"\n        # to R, so type=\"source\" is actually fine.\n        binary_repo = _get_linux_repo()\n        repos.insert(0, binary_repo)  # high priority\n        preferred_type = \"source\"\n    else:\n        # Windows / macOS use native CRAN binaries in the \"no version\" path\n        preferred_type = \"binary\"\n\n    if repos_extra:\n        if isinstance(repos_extra, list):\n            for _r in repos_extra:\n                if isinstance(_r, str) and _r not in repos:\n                    repos.append(_r)\n        elif repos_extra not in repos:\n            repos.append(repos_extra)\n\n    # ------------------------------------------------------------------\n    # BRANCH 1: version *specified* -&gt; delegate entirely to remotes\n    # ------------------------------------------------------------------\n    if version is not None:\n        log(\n            f\"Installing {name} \"\n            f\"(version spec: {version!r}) via remotes::install_version()...\"\n        )\n\n        # Ensure remotes is available\n        ro.r(\n            'if (!requireNamespace(\"remotes\", quietly = TRUE)) '\n            'install.packages(\"remotes\", repos = \"https://cloud.r-project.org\")'\n        )\n\n        # Pass repo vector from Python into R\n        ro.globalenv[\".brmspy_repos\"] = ro.StrVector(repos)\n\n        # Escape double quotes in version spec just in case\n        v_escaped = version.replace('\"', '\\\\\"')\n\n        try:\n            if already_installed and system == \"Windows\":\n                unload_package(name)\n            ro.r(\n                f\"remotes::install_version(\"\n                f'package = \"{name}\", '\n                f'version = \"{v_escaped}\", '\n                f\"repos = .brmspy_repos)\"\n            )\n        finally:\n            # Clean up\n            del ro.globalenv[\".brmspy_repos\"]\n\n        installed_version = get_package_version(name)\n        if installed_version is None:\n            raise RuntimeError(\n                f\"{name} did not appear after remotes::install_version('{version}').\"\n            )\n\n        log(\n            f\"Installed {name} via remotes::install_version \"\n            f\"(installed: {installed_version}).\"\n        )\n        return\n\n    # ------------------------------------------------------------------\n    # BRANCH 2: no version spec -&gt; \"latest\" from repos via install.packages\n    # ------------------------------------------------------------------\n    installed_version = None\n    try:\n        if already_installed:\n            installed_version = get_package_version(name)\n    except Exception:\n        installed_version = None\n\n    if installed_version is not None:\n        log(f\"{name} {installed_version} already installed.\")\n        return\n\n    log(f\"Installing {name} on {system} (Repos: {len(repos)})...\")\n\n    try:\n        # Primary Attempt (Fast Binary / P3M)\n        if already_installed and system == \"Windows\":\n            unload_package(name)\n        utils.install_packages(\n            ro.StrVector((name,)),\n            repos=ro.StrVector(repos),\n            lib=lib_path,\n            type=preferred_type,\n            Ncpus=cores,\n        )\n        installed_version = get_package_version(name)\n        if installed_version is None:\n            raise RuntimeError(\n                f\"{name} did not appear after install (type={preferred_type}).\"\n            )\n        log(f\"Installed {name} via {preferred_type} path.\")\n    except Exception as e:\n        log_warning(\n            f\"{preferred_type} install failed for {name}. \"\n            f\"Falling back to source compilation. ({e})\"\n        )\n        try:\n            if already_installed and system == \"Windows\":\n                unload_package(name)\n            utils.install_packages(\n                ro.StrVector((name,)),\n                repos=ro.StrVector(repos),\n                # don't set type, let R manage this.\n                lib=lib_path,\n                Ncpus=cores,\n            )\n            installed_version = get_package_version(name)\n            if installed_version is None:\n                raise RuntimeError(f\"{name} did not appear after source install.\")\n            log(f\"brmspy: Installed {name} from source.\")\n        except Exception as e2:\n            log_error(f\"Failed to install {name}: {e2}\")\n            raise e2\n</code></pre>"},{"location":"internals/_runtime/_r_packages/#brmspy._runtime._r_packages.install_package_deps","title":"<code>install_package_deps(name, include_suggests=False, repos_extra=None)</code>","text":"<p>Install dependencies of an R package.</p> Source code in <code>brmspy/_runtime/_r_packages.py</code> <pre><code>def install_package_deps(\n    name: str,\n    include_suggests: bool = False,\n    repos_extra: str | list[str | None] | list[str] | None = None,\n) -&gt; None:\n    \"\"\"Install dependencies of an R package.\"\"\"\n    import rpy2.robjects as ro\n\n    set_cran_mirror()\n\n    which_deps = ro.StrVector([\"Depends\", \"Imports\", \"LinkingTo\"])\n    if include_suggests:\n        which_deps = ro.StrVector([\"Depends\", \"Imports\", \"LinkingTo\", \"Suggests\"])\n\n    ncpus = multiprocessing.cpu_count() - 1\n    ncpus = max(1, ncpus)\n\n    repos: list[str] = [\"https://cloud.r-project.org\"]  # good default mirror\n\n    if repos_extra:\n        if isinstance(repos_extra, list):\n            for _r in repos_extra:\n                if isinstance(_r, str) and _r not in repos:\n                    repos.append(_r)\n        elif repos_extra not in repos:\n            repos.append(repos_extra)\n\n    try:\n        cast(\n            Callable,\n            ro.r(\n                \"\"\"\n        function (which_deps, name, ncpus, repos) {\n            pkgs &lt;- unique(unlist(\n                tools::package_dependencies(\n                    name,\n                    recursive = TRUE,\n                    which = which_deps,\n                    db = available.packages()\n                )\n            ))\n\n            to_install &lt;- setdiff(pkgs, rownames(installed.packages(lib.loc = .libPaths(), noCache = TRUE)))\n            if (length(to_install)) {\n                install.packages(to_install, Ncpus = ncpus, repos = repos, lib = .libPaths()[1L])\n            }\n        }\n        \"\"\"\n            ),\n        )(which_deps, ro.StrVector([name]), ncpus, ro.StrVector(repos))\n    except Exception as e:\n        log_warning(str(e))\n        return\n</code></pre>"},{"location":"internals/_runtime/_r_packages/#brmspy._runtime._r_packages.build_cmdstan","title":"<code>build_cmdstan(cores=None)</code>","text":"<p>Build CmdStan via cmdstanr::install_cmdstan().</p> Source code in <code>brmspy/_runtime/_r_packages.py</code> <pre><code>def build_cmdstan(cores: int | None = None) -&gt; None:\n    \"\"\"Build CmdStan via cmdstanr::install_cmdstan().\"\"\"\n    import rpy2.robjects as ro\n\n    if cores is None:\n        cores = multiprocessing.cpu_count()\n        if cores &gt; 4:\n            cores -= 1\n\n    ro.r(\"library(cmdstanr)\")\n\n    if platform.system() == \"Windows\":\n        try:\n            ro.r(\"cmdstanr::check_cmdstan_toolchain(fix = TRUE)\")\n        except Exception as e:\n            raise RuntimeError(\n                \"Windows toolchain check failed. \"\n                \"Please install Rtools from https://cran.r-project.org/bin/windows/Rtools/ \"\n                \"or run install(install_rtools=True)\"\n            ) from e\n\n    ro.r(f\"cmdstanr::install_cmdstan(cores = {cores}, overwrite = FALSE)\")\n</code></pre>"},{"location":"internals/_runtime/_r_packages/#brmspy._runtime._r_packages.remove_package","title":"<code>remove_package(name)</code>","text":"Source code in <code>brmspy/_runtime/_r_packages.py</code> <pre><code>def remove_package(name: str) -&gt; bool:\n    import rpy2.robjects as ro\n\n    r_code = f\"\"\"\n    (function(pkg) {{\n        removed &lt;- FALSE\n        libs &lt;- .libPaths()\n\n        for (lib in libs) {{\n            pkg_path &lt;- file.path(lib, pkg)\n            if (dir.exists(pkg_path)) {{\n                tryCatch({{\n                    # Use normalized path for cross-platform safety\n                    lib_norm &lt;- normalizePath(lib, winslash = \"/\", mustWork = FALSE)\n                    suppressWarnings(remove.packages(pkg, lib = lib_norm))\n                    removed &lt;- TRUE\n                }}, error = function(e) {{\n                    # Windows fallback: try direct deletion if DLLs are unloaded\n                    if (.Platform$OS.type == \"windows\") {{\n                        tryCatch({{\n                            unlink(pkg_path, recursive = TRUE, force = TRUE)\n                            removed &lt;- TRUE\n                        }}, error = function(e2) NULL)\n                    }}\n                }})\n            }}\n        }}\n\n        # Check if actually removed\n        return(!dir.exists(file.path(.libPaths()[1], pkg)))\n    }})('{name}')\n    \"\"\"\n\n    try:\n        result = cast(list, ro.r(r_code))\n        return str(result[0]).lower().strip() == \"true\"\n    except Exception:\n        return False\n</code></pre>"},{"location":"internals/_runtime/_rtools/","title":"_rtools","text":"<p>Windows Rtools management. Split into focused functions.</p>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools-attributes","title":"Attributes","text":""},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.RTOOLS_VERSIONS","title":"<code>RTOOLS_VERSIONS = {(4, 0): '40', (4, 2): '42', (4, 3): '43', (4, 4): '44', (4, 5): '45', (4, 6): '46', (4, 7): '47', (4, 8): '48'}</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.RTOOLS_SUBDIRS","title":"<code>RTOOLS_SUBDIRS = [os.path.join('usr', 'bin'), os.path.join('mingw64', 'bin')]</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.RTOOLS_FALLBACK_URLS","title":"<code>RTOOLS_FALLBACK_URLS = {'40': 'https://cran.r-project.org/bin/windows/Rtools/rtools40-x86_64.exe', '42': 'https://cran.r-project.org/bin/windows/Rtools/rtools42/files/rtools42-5355-5357.exe', '43': 'https://cran.r-project.org/bin/windows/Rtools/rtools43/files/rtools43-5976-5975.exe', '44': 'https://cran.r-project.org/bin/windows/Rtools/rtools44/files/rtools44-6459-6401.exe', '45': 'https://cran.r-project.org/bin/windows/Rtools/rtools45/files/rtools45-6691-6492.exe'}</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.RTOOLS_BASE","title":"<code>RTOOLS_BASE = 'https://cran.r-project.org/bin/windows/Rtools'</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools-functions","title":"Functions","text":""},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.get_arch","title":"<code>get_arch()</code>","text":"<p>Returns 'x86_64' or 'arm64'.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def get_arch() -&gt; str:\n    \"\"\"Returns 'x86_64' or 'arm64'.\"\"\"\n    raw_arch = platform.machine().lower()\n    if raw_arch in (\"x86_64\", \"amd64\"):\n        return \"x86_64\"\n    elif raw_arch in (\"arm64\", \"aarch64\"):\n        return \"arm64\"\n    else:\n        return raw_arch\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.get_os","title":"<code>get_os()</code>","text":"<p>Returns 'linux', 'macos', or 'windows'.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def get_os() -&gt; str:\n    \"\"\"Returns 'linux', 'macos', or 'windows'.\"\"\"\n    raw_os = platform.system().lower()\n    if raw_os == \"darwin\":\n        return \"macos\"\n    elif raw_os in (\"windows\", \"linux\"):\n        return raw_os\n    else:\n        return raw_os\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools._windows_drives","title":"<code>_windows_drives()</code>","text":"<p>Return a list of existing drive roots like ['C:\\', 'D:\\', ...].</p> Source code in <code>brmspy/_runtime/_rtools.py</code> <pre><code>def _windows_drives() -&gt; list[str]:\n    \"\"\"Return a list of existing drive roots like ['C:\\\\', 'D:\\\\', ...].\"\"\"\n    drives = []\n    for letter in string.ascii_uppercase:\n        root = f\"{letter}:\\\\\"\n        if Path(root).exists():\n            drives.append(root)\n    return drives\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools._candidate_rtools_paths","title":"<code>_candidate_rtools_paths()</code>","text":"<p>Generate all plausible Rtools bin paths across all drives.</p> Source code in <code>brmspy/_runtime/_rtools.py</code> <pre><code>def _candidate_rtools_paths() -&gt; list[str]:\n    \"\"\"Generate all plausible Rtools bin paths across all drives.\"\"\"\n    candidates: list[str] = []\n    for drive in _windows_drives():\n        for ver in RTOOLS_VERSIONS.values():\n            base = os.path.join(drive, f\"rtools{ver}\")\n            base2 = os.path.join(drive, f\"Rtools{ver}\")\n            for sub in RTOOLS_SUBDIRS:\n                candidates.append(os.path.join(base, sub))\n                candidates.append(os.path.join(base2, sub))\n    return candidates\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.get_required_version","title":"<code>get_required_version(r_version)</code>","text":"<p>Map R version to required Rtools version.</p> Source code in <code>brmspy/_runtime/_rtools.py</code> <pre><code>def get_required_version(r_version: tuple[int, int, int] | Version) -&gt; str | None:\n    \"\"\"Map R version to required Rtools version.\"\"\"\n    if isinstance(r_version, Version):\n        major, minor = r_version.major, r_version.minor\n    else:\n        major, minor, _ = r_version\n\n    # Find the appropriate Rtools version\n    for (r_major, r_minor), rtools_ver in sorted(RTOOLS_VERSIONS.items(), reverse=True):\n        if major &gt; r_major or (major == r_major and minor &gt;= r_minor):\n            return rtools_ver\n\n    return None\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools._discover_rtools_installer","title":"<code>_discover_rtools_installer(rtools_version, timeout=10.0, aarch64=False)</code>","text":"<p>Try to discover the latest Rtools installer .exe from the CRAN directory index.</p> <p>Looks at:     https://cran.r-project.org/bin/windows/Rtools/rtools{version}/files/ and picks the newest-looking <code>rtools{version}-*.exe</code>.</p> <p>If <code>aarch64</code> is True, prefer the <code>-aarch64-</code> installer. Otherwise prefer the x86_64 installer and avoid the aarch64 one.</p> Source code in <code>brmspy/_runtime/_rtools.py</code> <pre><code>def _discover_rtools_installer(\n    rtools_version: str,\n    timeout: float = 10.0,\n    aarch64: bool = False,\n) -&gt; str | None:\n    \"\"\"\n    Try to discover the latest Rtools installer .exe from the CRAN directory index.\n\n    Looks at:\n        https://cran.r-project.org/bin/windows/Rtools/rtools{version}/files/\n    and picks the newest-looking `rtools{version}-*.exe`.\n\n    If ``aarch64`` is True, prefer the ``-aarch64-`` installer.\n    Otherwise prefer the x86_64 installer and avoid the aarch64 one.\n    \"\"\"\n    index_url = f\"{RTOOLS_BASE}/rtools{rtools_version}/files/\"\n\n    try:\n        with urllib.request.urlopen(index_url, timeout=timeout) as resp:\n            html = resp.read().decode(\"utf-8\", errors=\"ignore\")\n    except (HTTPError, URLError):\n        return None\n\n    # Match things like:\n    #   rtools45-6691-6492.exe\n    #   rtools45-aarch64-6691-6492.exe\n    pattern = rf'href=\"(rtools{re.escape(rtools_version)}-[^\"]+\\.exe)\"'\n    matches = re.findall(pattern, html)\n    if not matches:\n        return None\n\n    # Split by arch:\n    aarch64_candidates = [m for m in matches if \"-aarch64-\" in m]\n    x86_candidates = [m for m in matches if \"-aarch64-\" not in m]\n\n    if aarch64:\n        candidates = aarch64_candidates or x86_candidates\n    else:\n        candidates = x86_candidates or aarch64_candidates\n\n    if not candidates:\n        return None\n\n    # Lexicographically last is usually the newest build\n    filename = sorted(candidates)[-1]\n    return index_url + filename\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.get_download_url","title":"<code>get_download_url(rtools_version)</code>","text":"<p>Get download URL for Rtools version.</p> Source code in <code>brmspy/_runtime/_rtools.py</code> <pre><code>def get_download_url(rtools_version: str) -&gt; str:\n    \"\"\"Get download URL for Rtools version.\"\"\"\n    # Try to dynamically discover from CRAN directory listing\n    is_arm64 = get_arch() == \"arm64\"\n\n    url = _discover_rtools_installer(rtools_version, aarch64=is_arm64)\n    if url is not None:\n        return url\n\n    # Fall back to old hard-coded mapping if discovery fails\n    if rtools_version in RTOOLS_FALLBACK_URLS:\n        return RTOOLS_FALLBACK_URLS[rtools_version]\n\n    # Probably will NOT work, but return it anyways\n    return f\"https://cran.r-project.org/bin/windows/Rtools/rtools{rtools_version}/files/rtools{rtools_version}-x86_64.exe\"\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.is_installed","title":"<code>is_installed()</code>","text":"<p>Check if Rtools is installed (make + mingw g++ on PATH).</p> Source code in <code>brmspy/_runtime/_rtools.py</code> <pre><code>def is_installed() -&gt; bool:\n    \"\"\"Check if Rtools is installed (make + mingw g++ on PATH).\"\"\"\n    try:\n        # Check for make\n        subprocess.run(\n            [\"make\", \"--version\"], capture_output=True, check=True, timeout=10\n        )\n\n        # Check for mingw g++\n        result = subprocess.run(\n            [\"g++\", \"--version\"], capture_output=True, text=True, check=True, timeout=10\n        )\n\n        # Verify it's mingw\n        output = result.stdout.lower()\n        if \"mingw\" in output or \"rtools\" in output:\n            return True\n\n        return False\n    except Exception:\n        return False\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.get_installed_gxx_version","title":"<code>get_installed_gxx_version()</code>","text":"<p>Get g++ version from Rtools.</p> Source code in <code>brmspy/_runtime/_rtools.py</code> <pre><code>def get_installed_gxx_version() -&gt; tuple[int, int] | None:\n    \"\"\"Get g++ version from Rtools.\"\"\"\n    try:\n        result = subprocess.check_output([\"g++\", \"--version\"], text=True, timeout=10)\n        # Parse version\n        for line in result.splitlines():\n            for token in line.split():\n                if token[0].isdigit() and \".\" in token:\n                    parts = token.split(\".\")\n                    if len(parts) &gt;= 2 and parts[0].isdigit() and parts[1].isdigit():\n                        return int(parts[0]), int(parts[1])\n    except Exception:\n        pass\n    return None\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools._stream_download","title":"<code>_stream_download(url, dst, timeout=30)</code>","text":"<p>Download URL to dst in chunks, verifying size if Content-Length is present.</p> Source code in <code>brmspy/_runtime/_rtools.py</code> <pre><code>def _stream_download(url: str, dst: Path, timeout: float | None = 30) -&gt; None:\n    \"\"\"Download URL to dst in chunks, verifying size if Content-Length is present.\"\"\"\n    CHUNK_SIZE = 1024 * 1024  # 1 MB\n\n    with urllib.request.urlopen(url, timeout=timeout) as resp, dst.open(\"wb\") as f:\n        content_length = resp.headers.get(\"Content-Length\")\n        expected_size: int | None = int(content_length) if content_length else None\n\n        total = 0\n        while True:\n            chunk = resp.read(CHUNK_SIZE)\n            if not chunk:\n                break\n            f.write(chunk)\n            total += len(chunk)\n\n    if expected_size is not None and total != expected_size:\n        raise OSError(\n            f\"incomplete download: got {total} bytes, expected {expected_size}\"\n        )\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.download_installer","title":"<code>download_installer(rtools_version, max_retries=3)</code>","text":"<p>Download Rtools installer to temp directory with retries and size check.</p> Source code in <code>brmspy/_runtime/_rtools.py</code> <pre><code>def download_installer(rtools_version: str, max_retries: int = 3) -&gt; Path:\n    \"\"\"Download Rtools installer to temp directory with retries and size check.\"\"\"\n    url = get_download_url(rtools_version)\n    last_err: Exception | None = None\n\n    for attempt in range(1, max_retries + 1):\n        with tempfile.NamedTemporaryFile(suffix=\".exe\", delete=False) as tmp:\n            tmp_path = Path(tmp.name)\n\n        try:\n            _stream_download(url, tmp_path)\n            # If we got here, download is complete (or server didn't send length).\n            return tmp_path\n\n        except (OSError, URLError, ContentTooShortError) as e:\n            last_err = e\n            try:\n                tmp_path.unlink(missing_ok=True)\n            except OSError:\n                pass\n\n            log_warning(\n                f\"[rtools] download attempt {attempt}/{max_retries} failed: {e}\"\n            )\n\n    raise RuntimeError(\n        f\"Failed to download Rtools installer from {url} after {max_retries} attempts\"\n    ) from last_err\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.run_installer","title":"<code>run_installer(installer, rtools_version, silent=True)</code>","text":"<p>Run Rtools installer safely on Windows and CI.</p> Source code in <code>brmspy/_runtime/_rtools.py</code> <pre><code>def run_installer(installer: Path, rtools_version: str, silent: bool = True) -&gt; None:\n    \"\"\"Run Rtools installer safely on Windows and CI.\"\"\"\n    system_drive = os.environ.get(\"SystemDrive\", \"C:\")\n    assert rtools_version in list(RTOOLS_VERSIONS.values())\n\n    install_dir = Path(system_drive) / f\"Rtools{rtools_version}\"\n\n    # Ensure parent directory exists to avoid ACL weirdness\n    install_dir.parent.mkdir(parents=True, exist_ok=True)\n\n    args = [str(installer)]\n\n    if silent:\n        args.extend(\n            [\n                \"/SP-\",  # skip intro dialog (CRITICAL)\n                \"/VERYSILENT\",\n                \"/SUPPRESSMSGBOXES\",\n                \"/NORESTART\",\n                f\"/DIR={install_dir}\",  # no inner quotes\n            ]\n        )\n\n    # 5 minute timeout - Rtools installers typically complete in 1-3 minutes\n    subprocess.run(args, check=True, timeout=300)\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.update_paths","title":"<code>update_paths()</code>","text":"<p>Update PATH in both Python os.environ and R Sys.setenv.</p> Source code in <code>brmspy/_runtime/_rtools.py</code> <pre><code>def update_paths() -&gt; None:\n    \"\"\"Update PATH in both Python os.environ and R Sys.setenv.\"\"\"\n    if get_os() != \"windows\":\n        return None\n    import rpy2.robjects as ro\n\n    current_path = os.environ.get(\"PATH\", \"\")\n    current_entries = current_path.split(os.pathsep) if current_path else []\n\n    new_entries: list[str] = []\n\n    for candidate in _candidate_rtools_paths():\n        p = Path(candidate)\n        if p.exists():\n            # avoid duplicates in both new_entries and existing PATH\n            if candidate not in current_entries and candidate not in new_entries:\n                new_entries.append(candidate)\n\n    if not new_entries:\n        return\n\n    # Update Python PATH\n    os.environ[\"PATH\"] = os.pathsep.join(new_entries + current_entries)\n\n    # Update R PATH using rpy2 in a safe way (no manual quoting)\n    try:\n        sys_setenv = cast(Callable, ro.r(\"Sys.setenv\"))\n        sys_setenv(PATH=os.environ[\"PATH\"])\n    except Exception:\n        # Best-effort; don't crash if R isn't ready\n        pass\n</code></pre>"},{"location":"internals/_runtime/_rtools/#brmspy._runtime._rtools.ensure_installed","title":"<code>ensure_installed()</code>","text":"<p>Orchestrator: ensure Rtools is installed for current R. Downloads and installs if needed. Updates paths.</p> Source code in <code>brmspy/_runtime/_rtools.py</code> <pre><code>def ensure_installed() -&gt; None:\n    \"\"\"\n    Orchestrator: ensure Rtools is installed for current R.\n    Downloads and installs if needed. Updates paths.\n    \"\"\"\n    if platform.system() != \"Windows\":\n        return\n\n    # Check if already installed\n    if is_installed():\n        update_paths()\n        return\n\n    # Get R version and determine required Rtools version\n    from brmspy._runtime._platform import get_r_version\n\n    r_ver = get_r_version()\n    if r_ver is None:\n        raise RuntimeError(\"Cannot determine R version\")\n\n    rtools_ver = get_required_version(r_ver)\n    if rtools_ver is None:\n        raise RuntimeError(f\"No Rtools version available for R {r_ver}\")\n\n    # Download and install\n    installer = download_installer(rtools_ver)\n    try:\n        run_installer(installer, rtools_version=rtools_ver, silent=True)\n    finally:\n        if installer.exists():\n            installer.unlink()\n\n    # Update paths\n    update_paths()\n\n    # Verify installation\n    if not is_installed():\n        raise RuntimeError(\"Rtools installation failed\")\n</code></pre>"},{"location":"internals/_runtime/_state/","title":"_state","text":"<p>All singletons in one place: R packages and stored environment. This is the ONLY module with global mutable state.</p>"},{"location":"internals/_runtime/_state/#brmspy._runtime._state-attributes","title":"Attributes","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state._brms","title":"<code>_brms = None</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state._cmdstanr","title":"<code>_cmdstanr = None</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state._rstan","title":"<code>_rstan = None</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state._base","title":"<code>_base = None</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state._posterior","title":"<code>_posterior = None</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state._stored_env","title":"<code>_stored_env = None</code>  <code>module-attribute</code>","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state-classes","title":"Classes","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state.StoredEnv","title":"<code>StoredEnv</code>  <code>dataclass</code>","text":"<p>Captured R environment used for deactivation/restoration.</p> <p>Attributes:</p> Name Type Description <code>lib_paths</code> <code>list[str]</code> <p><code>.libPaths()</code> values captured before activation.</p> <code>cmdstan_path</code> <code>str or None</code> <p>CmdStan path captured before activation.</p> Source code in <code>brmspy/types/runtime.py</code> <pre><code>@dataclass\nclass StoredEnv:\n    \"\"\"\n    Captured R environment used for deactivation/restoration.\n\n    Attributes\n    ----------\n    lib_paths : list[str]\n        `.libPaths()` values captured before activation.\n    cmdstan_path : str or None\n        CmdStan path captured before activation.\n    \"\"\"\n\n    lib_paths: list[str]\n    cmdstan_path: str | None\n</code></pre>"},{"location":"internals/_runtime/_state/#brmspy._runtime._state.StoredEnv-attributes","title":"Attributes","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state.StoredEnv.lib_paths","title":"<code>lib_paths</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state.StoredEnv.cmdstan_path","title":"<code>cmdstan_path</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state.StoredEnv-functions","title":"Functions","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state.StoredEnv.__init__","title":"<code>__init__(lib_paths, cmdstan_path)</code>","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state-functions","title":"Functions","text":""},{"location":"internals/_runtime/_state/#brmspy._runtime._state.get_brms","title":"<code>get_brms()</code>","text":"<p>Get brms R package, importing on first access.</p> Source code in <code>brmspy/_runtime/_state.py</code> <pre><code>def get_brms() -&gt; Any:\n    \"\"\"Get brms R package, importing on first access.\"\"\"\n    global _brms\n    if _brms is None:\n        try:\n            from rpy2.robjects.packages import importr\n            import rpy2.robjects as ro\n\n            _brms = importr(\"brms\")\n            ro.r(\"library(brms)\")\n        except Exception as e:\n            raise ImportError(\n                \"brms R package not found. Install it using:\\n\\n\"\n                \"  import brmspy\\n\"\n                \"  brmspy.install_brms(use_prebuilt=True)  # for prebuilt binaries\\n\\n\"\n                \"Or install from source:\\n\"\n                \"  brmspy.install_brms()\\n\"\n            ) from e\n    return _brms\n</code></pre>"},{"location":"internals/_runtime/_state/#brmspy._runtime._state.get_cmdstanr","title":"<code>get_cmdstanr()</code>","text":"<p>Get cmdstanr R package or None if not available.</p> Source code in <code>brmspy/_runtime/_state.py</code> <pre><code>def get_cmdstanr() -&gt; Any | None:\n    \"\"\"Get cmdstanr R package or None if not available.\"\"\"\n    global _cmdstanr\n    if _cmdstanr is None:\n        try:\n            from rpy2.robjects.packages import importr\n\n            _cmdstanr = importr(\"cmdstanr\")\n        except Exception:\n            pass\n    return _cmdstanr\n</code></pre>"},{"location":"internals/_runtime/_state/#brmspy._runtime._state.get_rstan","title":"<code>get_rstan()</code>","text":"<p>Get rstan R package or None if not available.</p> Source code in <code>brmspy/_runtime/_state.py</code> <pre><code>def get_rstan() -&gt; Any | None:\n    \"\"\"Get rstan R package or None if not available.\"\"\"\n    global _rstan\n    if _rstan is None:\n        try:\n            from rpy2.robjects.packages import importr\n\n            _rstan = importr(\"rstan\")\n        except Exception:\n            pass\n    return _rstan\n</code></pre>"},{"location":"internals/_runtime/_state/#brmspy._runtime._state.get_base","title":"<code>get_base()</code>","text":"<p>Get base R package.</p> Source code in <code>brmspy/_runtime/_state.py</code> <pre><code>def get_base() -&gt; Any:\n    \"\"\"Get base R package.\"\"\"\n    global _base\n    if _base is None:\n        from rpy2.robjects.packages import importr\n\n        _base = importr(\"base\")\n    return _base\n</code></pre>"},{"location":"internals/_runtime/_state/#brmspy._runtime._state.get_posterior","title":"<code>get_posterior()</code>","text":"<p>Get posterior R package.</p> Source code in <code>brmspy/_runtime/_state.py</code> <pre><code>def get_posterior() -&gt; Any:\n    \"\"\"Get posterior R package.\"\"\"\n    global _posterior\n    if _posterior is None:\n        from rpy2.robjects.packages import importr\n\n        _posterior = importr(\"posterior\")\n    return _posterior\n</code></pre>"},{"location":"internals/_runtime/_state/#brmspy._runtime._state.invalidate_packages","title":"<code>invalidate_packages()</code>","text":"<p>Clear all cached package singletons.</p> Source code in <code>brmspy/_runtime/_state.py</code> <pre><code>def invalidate_packages() -&gt; None:\n    \"\"\"Clear all cached package singletons.\"\"\"\n    global _brms, _cmdstanr, _rstan, _base, _posterior\n    _brms = None\n    _cmdstanr = None\n    _rstan = None\n    _base = None\n    _posterior = None\n</code></pre>"},{"location":"internals/_runtime/_state/#brmspy._runtime._state.capture_current_env","title":"<code>capture_current_env()</code>","text":"<p>Capture current R environment (lib_paths, cmdstan_path).</p> Source code in <code>brmspy/_runtime/_state.py</code> <pre><code>def capture_current_env() -&gt; StoredEnv:\n    \"\"\"Capture current R environment (lib_paths, cmdstan_path).\"\"\"\n    return StoredEnv(\n        lib_paths=_r_env.get_lib_paths(),\n        cmdstan_path=_r_env.get_cmdstan_path(),\n    )\n</code></pre>"},{"location":"internals/_runtime/_state/#brmspy._runtime._state.store_env","title":"<code>store_env(env)</code>","text":"<p>Store environment for later restoration.</p> Source code in <code>brmspy/_runtime/_state.py</code> <pre><code>def store_env(env: StoredEnv) -&gt; None:\n    \"\"\"Store environment for later restoration.\"\"\"\n    if \".brmspy/runtime/\" in env.lib_paths or \".brmspy\\\\runtime\\\\\" in env.lib_paths:\n        return\n    global _stored_env\n    _stored_env = env\n</code></pre>"},{"location":"internals/_runtime/_state/#brmspy._runtime._state.get_stored_env","title":"<code>get_stored_env()</code>","text":"<p>Get stored environment or None.</p> Source code in <code>brmspy/_runtime/_state.py</code> <pre><code>def get_stored_env() -&gt; StoredEnv | None:\n    \"\"\"Get stored environment or None.\"\"\"\n    return _stored_env\n</code></pre>"},{"location":"internals/_runtime/_state/#brmspy._runtime._state.clear_stored_env","title":"<code>clear_stored_env()</code>","text":"<p>Clear stored environment.</p> Source code in <code>brmspy/_runtime/_state.py</code> <pre><code>def clear_stored_env() -&gt; None:\n    \"\"\"Clear stored environment.\"\"\"\n    global _stored_env\n    _stored_env = None\n</code></pre>"},{"location":"internals/_runtime/_state/#brmspy._runtime._state.has_stored_env","title":"<code>has_stored_env()</code>","text":"<p>Check if environment is stored (i.e., runtime is active).</p> Source code in <code>brmspy/_runtime/_state.py</code> <pre><code>def has_stored_env() -&gt; bool:\n    \"\"\"Check if environment is stored (i.e., runtime is active).\"\"\"\n    return _stored_env is not None\n</code></pre>"},{"location":"internals/_runtime/_storage/","title":"_storage","text":"<p>Runtime directory operations. Disk only, no R, no config.</p>"},{"location":"internals/_runtime/_storage/#brmspy._runtime._storage-functions","title":"Functions","text":""},{"location":"internals/_runtime/_storage/#brmspy._runtime._storage.get_os","title":"<code>get_os()</code>","text":"<p>Returns 'linux', 'macos', or 'windows'.</p> Source code in <code>brmspy/_runtime/_platform.py</code> <pre><code>def get_os() -&gt; str:\n    \"\"\"Returns 'linux', 'macos', or 'windows'.\"\"\"\n    raw_os = platform.system().lower()\n    if raw_os == \"darwin\":\n        return \"macos\"\n    elif raw_os in (\"windows\", \"linux\"):\n        return raw_os\n    else:\n        return raw_os\n</code></pre>"},{"location":"internals/_runtime/_storage/#brmspy._runtime._storage.get_runtime_base_dir","title":"<code>get_runtime_base_dir()</code>","text":"<p>Returns ~/.brmspy/runtime/, creating if needed.</p> Source code in <code>brmspy/_runtime/_storage.py</code> <pre><code>def get_runtime_base_dir() -&gt; Path:\n    \"\"\"Returns ~/.brmspy/runtime/, creating if needed.\"\"\"\n    base_dir = Path.home() / \".brmspy\" / \"runtime\"\n    base_dir.mkdir(parents=True, exist_ok=True)\n    return base_dir\n</code></pre>"},{"location":"internals/_runtime/_storage/#brmspy._runtime._storage.get_runtime_path","title":"<code>get_runtime_path(fingerprint, version, n=None, allow_existing=True)</code>","text":"<p>Returns ~/.brmspy/runtime/{fingerprint}-{version}/.</p> Source code in <code>brmspy/_runtime/_storage.py</code> <pre><code>def get_runtime_path(fingerprint: str, version: str, n=None, allow_existing=True) -&gt; Path:\n    \"\"\"Returns ~/.brmspy/runtime/{fingerprint}-{version}/.\"\"\"\n    if n is None:\n        runtime_path = get_runtime_base_dir() / f\"{fingerprint}-{version}\"\n    else:\n        runtime_path = get_runtime_base_dir() / f\"{fingerprint}-{version}-{n}\"\n    if not allow_existing:\n        if runtime_path.exists():\n            if n is None:\n                n = 0\n            return get_runtime_path(fingerprint, version, n + 1)\n\n    return runtime_path\n</code></pre>"},{"location":"internals/_runtime/_storage/#brmspy._runtime._storage.is_runtime_dir","title":"<code>is_runtime_dir(path)</code>","text":"<p>Check if path has valid structure (manifest.json, Rlib/, cmdstan/).</p> Source code in <code>brmspy/_runtime/_storage.py</code> <pre><code>def is_runtime_dir(path: Path) -&gt; bool:\n    \"\"\"Check if path has valid structure (manifest.json, Rlib/, cmdstan/).\"\"\"\n    if not path.is_dir():\n        return False\n    manifest = path / \"manifest.json\"\n    return manifest.is_file()\n</code></pre>"},{"location":"internals/_runtime/_storage/#brmspy._runtime._storage.list_installed_runtimes","title":"<code>list_installed_runtimes()</code>","text":"<p>List all installed runtime directories.</p> Source code in <code>brmspy/_runtime/_storage.py</code> <pre><code>def list_installed_runtimes() -&gt; list[Path]:\n    \"\"\"List all installed runtime directories.\"\"\"\n    base_dir = get_runtime_base_dir()\n    if not base_dir.exists():\n        return []\n\n    runtimes = []\n    for item in base_dir.iterdir():\n        if item.is_dir() and is_runtime_dir(item):\n            runtimes.append(item)\n    return runtimes\n</code></pre>"},{"location":"internals/_runtime/_storage/#brmspy._runtime._storage.find_runtime_by_fingerprint","title":"<code>find_runtime_by_fingerprint(fingerprint)</code>","text":"<p>Find newest installed runtime matching fingerprint.</p> Source code in <code>brmspy/_runtime/_storage.py</code> <pre><code>def find_runtime_by_fingerprint(fingerprint: str) -&gt; Path | None:\n    \"\"\"Find newest installed runtime matching fingerprint.\"\"\"\n    runtimes = list_installed_runtimes()\n    matching = [r for r in runtimes if fingerprint in r.name]\n    if not matching:\n        return None\n    # Sort by name (which includes version) and return newest\n    return sorted(matching, reverse=True)[0]\n</code></pre>"},{"location":"internals/_runtime/_storage/#brmspy._runtime._storage.read_stored_hash","title":"<code>read_stored_hash(path)</code>","text":"<p>Read hash file from runtime directory.</p> Source code in <code>brmspy/_runtime/_storage.py</code> <pre><code>def read_stored_hash(path: Path) -&gt; str | None:\n    \"\"\"Read hash file from runtime directory.\"\"\"\n    hash_path = path / \"hash\"\n    if not hash_path.is_file():\n        return None\n    return hash_path.read_text(encoding=\"utf-8\").strip()\n</code></pre>"},{"location":"internals/_runtime/_storage/#brmspy._runtime._storage.write_stored_hash","title":"<code>write_stored_hash(path, hash_value)</code>","text":"<p>Write hash file to runtime directory.</p> Source code in <code>brmspy/_runtime/_storage.py</code> <pre><code>def write_stored_hash(path: Path, hash_value: str) -&gt; None:\n    \"\"\"Write hash file to runtime directory.\"\"\"\n    hash_path = path / \"hash\"\n    hash_path.write_text(hash_value.strip() + \"\\n\", encoding=\"utf-8\")\n</code></pre>"},{"location":"internals/_runtime/_storage/#brmspy._runtime._storage.install_from_archive","title":"<code>install_from_archive(archive, fingerprint, version)</code>","text":"<p>Extract archive to runtime directory. Returns path to installed runtime.</p> Source code in <code>brmspy/_runtime/_storage.py</code> <pre><code>def install_from_archive(\n    archive: Path,\n    fingerprint: str,\n    version: str,\n) -&gt; Path:\n    \"\"\"\n    Extract archive to runtime directory.\n    Returns path to installed runtime.\n    \"\"\"\n    import time\n\n    base_dir = get_runtime_base_dir()\n    is_windows = get_os() == \"windows\"\n    runtime_root = get_runtime_path(fingerprint, version, allow_existing=not is_windows)\n\n    # Extract to temp directory first\n    temp_extract_root = base_dir / \"_tmp_extract\"\n    if temp_extract_root.exists():\n        shutil.rmtree(temp_extract_root)\n    temp_extract_root.mkdir(parents=True, exist_ok=True)\n\n    try:\n        with tarfile.open(archive, mode=\"r:*\") as tf:\n            # 'data' filter breaks on windows and python 3.14 demands a filter.\n            # fully_trusted is least error prone for now\n            tf.extractall(path=temp_extract_root, filter=\"fully_trusted\")\n\n        # Find the runtime directory in extracted content\n        runtime_tmp = temp_extract_root / \"runtime\"\n        if not runtime_tmp.is_dir():\n            raise RuntimeError(\n                f\"Extracted archive does not contain 'runtime/' under {temp_extract_root}\"\n            )\n\n        # Validate manifest\n        manifest_path = runtime_tmp / \"manifest.json\"\n        if not manifest_path.is_file():\n            raise RuntimeError(f\"Missing manifest.json in {runtime_tmp}\")\n\n        # Remove existing runtime if present - critical for Windows!\n        # On Windows, if runtime_root exists and rmtree fails silently,\n        # shutil.move() will place runtime_tmp INSIDE runtime_root instead of replacing it.\n        if runtime_root.exists():\n            shutil.rmtree(runtime_root, ignore_errors=False)\n            # Wait for deletion to complete on Windows (file locking issues)\n            for _ in range(10):\n                if not runtime_root.exists():\n                    break\n                time.sleep(0.1)\n\n        # Move to final location\n        shutil.move(str(runtime_tmp), str(runtime_root))\n\n    finally:\n        shutil.rmtree(temp_extract_root, ignore_errors=True)\n\n    return runtime_root\n</code></pre>"},{"location":"internals/_runtime/_storage/#brmspy._runtime._storage.install_from_directory","title":"<code>install_from_directory(source, fingerprint, version)</code>","text":"<p>Copy/move directory to runtime location. Returns path to installed runtime.</p> Source code in <code>brmspy/_runtime/_storage.py</code> <pre><code>def install_from_directory(\n    source: Path,\n    fingerprint: str,\n    version: str,\n) -&gt; Path:\n    \"\"\"\n    Copy/move directory to runtime location.\n    Returns path to installed runtime.\n    \"\"\"\n    runtime_root = get_runtime_path(fingerprint, version)\n\n    # Validate manifest\n    manifest_path = source / \"manifest.json\"\n    if not manifest_path.is_file():\n        raise RuntimeError(f\"Missing manifest.json in {source}\")\n\n    source = source.resolve()\n    runtime_root = runtime_root.resolve()\n\n    # If already in place, just return\n    if source == runtime_root:\n        return runtime_root\n\n    # Remove existing runtime if present\n    if runtime_root.exists():\n        shutil.rmtree(runtime_root, ignore_errors=True)\n\n    # Move to final location\n    shutil.move(str(source), str(runtime_root))\n\n    return runtime_root\n</code></pre>"},{"location":"internals/_runtime/_storage/#brmspy._runtime._storage.remove_runtime","title":"<code>remove_runtime(path)</code>","text":"<p>Remove installed runtime directory.</p> Source code in <code>brmspy/_runtime/_storage.py</code> <pre><code>def remove_runtime(path: Path) -&gt; None:\n    \"\"\"Remove installed runtime directory.\"\"\"\n    if path.exists() and path.is_dir():\n        shutil.rmtree(path)\n</code></pre>"},{"location":"internals/_session/environment/","title":"environment","text":"<p>Environment store helpers (internal).</p> <p>This module provides small filesystem helpers for brmspy \"environments\", which are named directories under <code>~/.brmspy/environment/&lt;name&gt;/</code> containing:</p> <ul> <li><code>config.json</code> (serialized <code>EnvironmentConfig</code>)</li> <li><code>Rlib/</code> (user-managed R library for that environment)</li> </ul> <p>The session layer uses these helpers when entering/leaving context-managed tools (e.g. <code>manage()</code>), and for convenience methods like environment existence checks.</p>"},{"location":"internals/_session/environment/#brmspy._session.environment-classes","title":"Classes","text":""},{"location":"internals/_session/environment/#brmspy._session.environment.EnvironmentConfig","title":"<code>EnvironmentConfig</code>  <code>dataclass</code>","text":"<p>Worker environment configuration.</p> <p>This configuration is applied in the worker before importing/using brms.</p> <p>Parameters:</p> Name Type Description Default <code>r_home</code> <code>str or None</code> <p>Override for <code>R_HOME</code>. If None, the worker will rely on system detection.</p> <code>None</code> <code>startup_scripts</code> <code>list[str]</code> <p>R code snippets executed in the worker after initialization.</p> <code>list()</code> <code>environment_name</code> <code>str</code> <p>brmspy environment name (used to determine <code>~/.brmspy/environment/&lt;name&gt;/Rlib</code>).</p> <code>'default'</code> <code>runtime_path</code> <code>str or None</code> <p>Path to a brmspy runtime bundle to activate in the worker.</p> <code>None</code> <code>env</code> <code>dict[str, str]</code> <p>Extra environment variables applied when spawning the worker.</p> <code>dict()</code> Source code in <code>brmspy/types/session.py</code> <pre><code>@dataclass\nclass EnvironmentConfig:\n    \"\"\"\n    Worker environment configuration.\n\n    This configuration is applied in the worker before importing/using brms.\n\n    Parameters\n    ----------\n    r_home : str or None\n        Override for `R_HOME`. If None, the worker will rely on system detection.\n    startup_scripts : list[str]\n        R code snippets executed in the worker after initialization.\n    environment_name : str\n        brmspy environment name (used to determine `~/.brmspy/environment/&lt;name&gt;/Rlib`).\n    runtime_path : str or None\n        Path to a brmspy runtime bundle to activate in the worker.\n    env : dict[str, str]\n        Extra environment variables applied when spawning the worker.\n    \"\"\"\n\n    r_home: None | str = None\n    startup_scripts: list[str] = field(default_factory=list)\n    environment_name: str = \"default\"\n    runtime_path: None | str = None\n    env: dict[str, str] = field(default_factory=dict)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Serialize configuration for persistence to JSON.\"\"\"\n        return {\n            \"environment_name\": self.environment_name,\n            \"r_home\": self.r_home,\n            \"startup_scripts\": self.startup_scripts or [],\n            \"runtime_path\": self.runtime_path,\n            \"env\": self.env,\n        }\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any]) -&gt; EnvironmentConfig:\n        \"\"\"Deserialize configuration from a JSON object.\"\"\"\n        return cls(\n            r_home=obj[\"r_home\"],\n            startup_scripts=obj[\"startup_scripts\"],\n            environment_name=obj[\"environment_name\"],\n            runtime_path=obj[\"runtime_path\"],\n            env=obj[\"env\"],\n        )\n\n    @classmethod\n    def from_obj(\n        cls, obj: None | dict[str, Any] | EnvironmentConfig\n    ) -&gt; EnvironmentConfig:\n        \"\"\"Normalize `None | dict | EnvironmentConfig` into an `EnvironmentConfig`.\"\"\"\n        if obj is None:\n            return cls()\n        if isinstance(obj, dict):\n            return cls.from_dict(obj)\n        return obj\n</code></pre>"},{"location":"internals/_session/environment/#brmspy._session.environment.EnvironmentConfig-attributes","title":"Attributes","text":""},{"location":"internals/_session/environment/#brmspy._session.environment.EnvironmentConfig.r_home","title":"<code>r_home = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/environment/#brmspy._session.environment.EnvironmentConfig.startup_scripts","title":"<code>startup_scripts = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/environment/#brmspy._session.environment.EnvironmentConfig.environment_name","title":"<code>environment_name = 'default'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/environment/#brmspy._session.environment.EnvironmentConfig.runtime_path","title":"<code>runtime_path = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/environment/#brmspy._session.environment.EnvironmentConfig.env","title":"<code>env = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/environment/#brmspy._session.environment.EnvironmentConfig-functions","title":"Functions","text":""},{"location":"internals/_session/environment/#brmspy._session.environment.EnvironmentConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize configuration for persistence to JSON.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Serialize configuration for persistence to JSON.\"\"\"\n    return {\n        \"environment_name\": self.environment_name,\n        \"r_home\": self.r_home,\n        \"startup_scripts\": self.startup_scripts or [],\n        \"runtime_path\": self.runtime_path,\n        \"env\": self.env,\n    }\n</code></pre>"},{"location":"internals/_session/environment/#brmspy._session.environment.EnvironmentConfig.from_dict","title":"<code>from_dict(obj)</code>  <code>classmethod</code>","text":"<p>Deserialize configuration from a JSON object.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any]) -&gt; EnvironmentConfig:\n    \"\"\"Deserialize configuration from a JSON object.\"\"\"\n    return cls(\n        r_home=obj[\"r_home\"],\n        startup_scripts=obj[\"startup_scripts\"],\n        environment_name=obj[\"environment_name\"],\n        runtime_path=obj[\"runtime_path\"],\n        env=obj[\"env\"],\n    )\n</code></pre>"},{"location":"internals/_session/environment/#brmspy._session.environment.EnvironmentConfig.from_obj","title":"<code>from_obj(obj)</code>  <code>classmethod</code>","text":"<p>Normalize <code>None | dict | EnvironmentConfig</code> into an <code>EnvironmentConfig</code>.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@classmethod\ndef from_obj(\n    cls, obj: None | dict[str, Any] | EnvironmentConfig\n) -&gt; EnvironmentConfig:\n    \"\"\"Normalize `None | dict | EnvironmentConfig` into an `EnvironmentConfig`.\"\"\"\n    if obj is None:\n        return cls()\n    if isinstance(obj, dict):\n        return cls.from_dict(obj)\n    return obj\n</code></pre>"},{"location":"internals/_session/environment/#brmspy._session.environment.EnvironmentConfig.__init__","title":"<code>__init__(r_home=None, startup_scripts=list(), environment_name='default', runtime_path=None, env=dict())</code>","text":""},{"location":"internals/_session/environment/#brmspy._session.environment-functions","title":"Functions","text":""},{"location":"internals/_session/environment/#brmspy._session.environment.get_environment_base_dir","title":"<code>get_environment_base_dir()</code>","text":"<p>Return the base directory for brmspy environments, creating it if needed.</p> <p>Returns:</p> Type Description <code>Path</code> <p><code>~/.brmspy/environment/</code></p> Source code in <code>brmspy/_session/environment.py</code> <pre><code>def get_environment_base_dir() -&gt; Path:\n    \"\"\"\n    Return the base directory for brmspy environments, creating it if needed.\n\n    Returns\n    -------\n    pathlib.Path\n        `~/.brmspy/environment/`\n    \"\"\"\n    base_dir = Path.home() / \".brmspy\" / \"environment\"\n    base_dir.mkdir(parents=True, exist_ok=True)\n    return base_dir\n</code></pre>"},{"location":"internals/_session/environment/#brmspy._session.environment.get_environment_dir","title":"<code>get_environment_dir(name)</code>","text":"<p>Return the directory for a named environment (may or may not exist).</p> Source code in <code>brmspy/_session/environment.py</code> <pre><code>def get_environment_dir(name: str) -&gt; Path:\n    \"\"\"Return the directory for a named environment (may or may not exist).\"\"\"\n    base_dir = get_environment_base_dir()\n    env_dir = base_dir / name\n    return env_dir\n</code></pre>"},{"location":"internals/_session/environment/#brmspy._session.environment.get_environments_state_path","title":"<code>get_environments_state_path()</code>","text":"<p>Return the path to <code>environment_state.json</code> (stores last active environment name).</p> Source code in <code>brmspy/_session/environment.py</code> <pre><code>def get_environments_state_path() -&gt; Path:\n    \"\"\"Return the path to `environment_state.json` (stores last active environment name).\"\"\"\n    return Path.home() / \".brmspy\" / \"environment_state.json\"\n</code></pre>"},{"location":"internals/_session/environment/#brmspy._session.environment.get_environment_userlibs_dir","title":"<code>get_environment_userlibs_dir(name)</code>","text":"<p>Return the per-environment user library directory: <code>.../&lt;name&gt;/Rlib</code>.</p> Source code in <code>brmspy/_session/environment.py</code> <pre><code>def get_environment_userlibs_dir(name: str) -&gt; Path:\n    \"\"\"Return the per-environment user library directory: `.../&lt;name&gt;/Rlib`.\"\"\"\n    return get_environment_dir(name=name) / \"Rlib\"\n</code></pre>"},{"location":"internals/_session/environment/#brmspy._session.environment.get_environment_exists","title":"<code>get_environment_exists(name)</code>","text":"<p>Return True if an environment exists (determined by presence of <code>config.json</code>).</p> Source code in <code>brmspy/_session/environment.py</code> <pre><code>def get_environment_exists(name: str) -&gt; bool:\n    \"\"\"\n    Return True if an environment exists (determined by presence of `config.json`).\n    \"\"\"\n    base_dir = get_environment_base_dir()\n    env_dir = base_dir / name\n    config_dir = env_dir / \"config.json\"\n\n    return config_dir.exists()\n</code></pre>"},{"location":"internals/_session/environment/#brmspy._session.environment.get_environment_config","title":"<code>get_environment_config(name)</code>","text":"<p>Load an environment configuration from disk.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Environment name.</p> required <p>Returns:</p> Type Description <code>EnvironmentConfig</code> <p>Loaded configuration. If no config file exists, returns a default config with <code>environment_name=name</code>.</p> Source code in <code>brmspy/_session/environment.py</code> <pre><code>def get_environment_config(name: str) -&gt; EnvironmentConfig:\n    \"\"\"\n    Load an environment configuration from disk.\n\n    Parameters\n    ----------\n    name : str\n        Environment name.\n\n    Returns\n    -------\n    brmspy.types.session.EnvironmentConfig\n        Loaded configuration. If no config file exists, returns a default config\n        with `environment_name=name`.\n    \"\"\"\n    base_dir = get_environment_base_dir()\n    env_dir = base_dir / name\n    config_dir = env_dir / \"config.json\"\n\n    if not config_dir.exists():\n        return EnvironmentConfig(environment_name=name)\n\n    with open(config_dir) as f:\n        data = json.load(f)\n        return EnvironmentConfig.from_dict(data)\n</code></pre>"},{"location":"internals/_session/environment_parent/","title":"environment_parent","text":""},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent-classes","title":"Classes","text":""},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.EnvironmentConfig","title":"<code>EnvironmentConfig</code>  <code>dataclass</code>","text":"<p>Worker environment configuration.</p> <p>This configuration is applied in the worker before importing/using brms.</p> <p>Parameters:</p> Name Type Description Default <code>r_home</code> <code>str or None</code> <p>Override for <code>R_HOME</code>. If None, the worker will rely on system detection.</p> <code>None</code> <code>startup_scripts</code> <code>list[str]</code> <p>R code snippets executed in the worker after initialization.</p> <code>list()</code> <code>environment_name</code> <code>str</code> <p>brmspy environment name (used to determine <code>~/.brmspy/environment/&lt;name&gt;/Rlib</code>).</p> <code>'default'</code> <code>runtime_path</code> <code>str or None</code> <p>Path to a brmspy runtime bundle to activate in the worker.</p> <code>None</code> <code>env</code> <code>dict[str, str]</code> <p>Extra environment variables applied when spawning the worker.</p> <code>dict()</code> Source code in <code>brmspy/types/session.py</code> <pre><code>@dataclass\nclass EnvironmentConfig:\n    \"\"\"\n    Worker environment configuration.\n\n    This configuration is applied in the worker before importing/using brms.\n\n    Parameters\n    ----------\n    r_home : str or None\n        Override for `R_HOME`. If None, the worker will rely on system detection.\n    startup_scripts : list[str]\n        R code snippets executed in the worker after initialization.\n    environment_name : str\n        brmspy environment name (used to determine `~/.brmspy/environment/&lt;name&gt;/Rlib`).\n    runtime_path : str or None\n        Path to a brmspy runtime bundle to activate in the worker.\n    env : dict[str, str]\n        Extra environment variables applied when spawning the worker.\n    \"\"\"\n\n    r_home: None | str = None\n    startup_scripts: list[str] = field(default_factory=list)\n    environment_name: str = \"default\"\n    runtime_path: None | str = None\n    env: dict[str, str] = field(default_factory=dict)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Serialize configuration for persistence to JSON.\"\"\"\n        return {\n            \"environment_name\": self.environment_name,\n            \"r_home\": self.r_home,\n            \"startup_scripts\": self.startup_scripts or [],\n            \"runtime_path\": self.runtime_path,\n            \"env\": self.env,\n        }\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any]) -&gt; EnvironmentConfig:\n        \"\"\"Deserialize configuration from a JSON object.\"\"\"\n        return cls(\n            r_home=obj[\"r_home\"],\n            startup_scripts=obj[\"startup_scripts\"],\n            environment_name=obj[\"environment_name\"],\n            runtime_path=obj[\"runtime_path\"],\n            env=obj[\"env\"],\n        )\n\n    @classmethod\n    def from_obj(\n        cls, obj: None | dict[str, Any] | EnvironmentConfig\n    ) -&gt; EnvironmentConfig:\n        \"\"\"Normalize `None | dict | EnvironmentConfig` into an `EnvironmentConfig`.\"\"\"\n        if obj is None:\n            return cls()\n        if isinstance(obj, dict):\n            return cls.from_dict(obj)\n        return obj\n</code></pre>"},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.EnvironmentConfig-attributes","title":"Attributes","text":""},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.EnvironmentConfig.r_home","title":"<code>r_home = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.EnvironmentConfig.startup_scripts","title":"<code>startup_scripts = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.EnvironmentConfig.environment_name","title":"<code>environment_name = 'default'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.EnvironmentConfig.runtime_path","title":"<code>runtime_path = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.EnvironmentConfig.env","title":"<code>env = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.EnvironmentConfig-functions","title":"Functions","text":""},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.EnvironmentConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize configuration for persistence to JSON.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Serialize configuration for persistence to JSON.\"\"\"\n    return {\n        \"environment_name\": self.environment_name,\n        \"r_home\": self.r_home,\n        \"startup_scripts\": self.startup_scripts or [],\n        \"runtime_path\": self.runtime_path,\n        \"env\": self.env,\n    }\n</code></pre>"},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.EnvironmentConfig.from_dict","title":"<code>from_dict(obj)</code>  <code>classmethod</code>","text":"<p>Deserialize configuration from a JSON object.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any]) -&gt; EnvironmentConfig:\n    \"\"\"Deserialize configuration from a JSON object.\"\"\"\n    return cls(\n        r_home=obj[\"r_home\"],\n        startup_scripts=obj[\"startup_scripts\"],\n        environment_name=obj[\"environment_name\"],\n        runtime_path=obj[\"runtime_path\"],\n        env=obj[\"env\"],\n    )\n</code></pre>"},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.EnvironmentConfig.from_obj","title":"<code>from_obj(obj)</code>  <code>classmethod</code>","text":"<p>Normalize <code>None | dict | EnvironmentConfig</code> into an <code>EnvironmentConfig</code>.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@classmethod\ndef from_obj(\n    cls, obj: None | dict[str, Any] | EnvironmentConfig\n) -&gt; EnvironmentConfig:\n    \"\"\"Normalize `None | dict | EnvironmentConfig` into an `EnvironmentConfig`.\"\"\"\n    if obj is None:\n        return cls()\n    if isinstance(obj, dict):\n        return cls.from_dict(obj)\n    return obj\n</code></pre>"},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.EnvironmentConfig.__init__","title":"<code>__init__(r_home=None, startup_scripts=list(), environment_name='default', runtime_path=None, env=dict())</code>","text":""},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent-functions","title":"Functions","text":""},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.get_environment_base_dir","title":"<code>get_environment_base_dir()</code>","text":"<p>Return the base directory for brmspy environments, creating it if needed.</p> <p>Returns:</p> Type Description <code>Path</code> <p><code>~/.brmspy/environment/</code></p> Source code in <code>brmspy/_session/environment.py</code> <pre><code>def get_environment_base_dir() -&gt; Path:\n    \"\"\"\n    Return the base directory for brmspy environments, creating it if needed.\n\n    Returns\n    -------\n    pathlib.Path\n        `~/.brmspy/environment/`\n    \"\"\"\n    base_dir = Path.home() / \".brmspy\" / \"environment\"\n    base_dir.mkdir(parents=True, exist_ok=True)\n    return base_dir\n</code></pre>"},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.get_environment_userlibs_dir","title":"<code>get_environment_userlibs_dir(name)</code>","text":"<p>Return the per-environment user library directory: <code>.../&lt;name&gt;/Rlib</code>.</p> Source code in <code>brmspy/_session/environment.py</code> <pre><code>def get_environment_userlibs_dir(name: str) -&gt; Path:\n    \"\"\"Return the per-environment user library directory: `.../&lt;name&gt;/Rlib`.\"\"\"\n    return get_environment_dir(name=name) / \"Rlib\"\n</code></pre>"},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.get_environments_state_path","title":"<code>get_environments_state_path()</code>","text":"<p>Return the path to <code>environment_state.json</code> (stores last active environment name).</p> Source code in <code>brmspy/_session/environment.py</code> <pre><code>def get_environments_state_path() -&gt; Path:\n    \"\"\"Return the path to `environment_state.json` (stores last active environment name).\"\"\"\n    return Path.home() / \".brmspy\" / \"environment_state.json\"\n</code></pre>"},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.save","title":"<code>save(env_conf)</code>","text":"<p>Persist an environment configuration and ensure the directory structure exists.</p> <p>Parameters:</p> Name Type Description Default <code>env_conf</code> <code>EnvironmentConfig</code> <p>Environment configuration to write.</p> required Source code in <code>brmspy/_session/environment_parent.py</code> <pre><code>def save(env_conf: EnvironmentConfig) -&gt; None:\n    \"\"\"\n    Persist an environment configuration and ensure the directory structure exists.\n\n    Parameters\n    ----------\n    env_conf : brmspy.types.session.EnvironmentConfig\n        Environment configuration to write.\n    \"\"\"\n    base_dir = get_environment_base_dir()\n    env_dir = base_dir / env_conf.environment_name\n    env_rlib_dir = get_environment_userlibs_dir(name=env_conf.environment_name)\n    config_dir = env_dir / \"config.json\"\n    os.makedirs(env_dir, exist_ok=True)\n    os.makedirs(env_rlib_dir, exist_ok=True)\n\n    if \"BRMSPY_AUTOLOAD\" in env_conf.env:\n        del env_conf.env[\"BRMSPY_AUTOLOAD\"]\n\n    with open(config_dir, \"w\", encoding=\"utf-8\") as f:\n        json.dump(env_conf.to_dict(), f, indent=2, ensure_ascii=False)\n</code></pre>"},{"location":"internals/_session/environment_parent/#brmspy._session.environment_parent.save_as_state","title":"<code>save_as_state(env_conf)</code>","text":"<p>Record the active environment name in <code>environment_state.json</code>.</p> <p>Parameters:</p> Name Type Description Default <code>env_conf</code> <code>EnvironmentConfig</code> <p>Environment configuration whose name should be recorded.</p> required Source code in <code>brmspy/_session/environment_parent.py</code> <pre><code>def save_as_state(env_conf: EnvironmentConfig) -&gt; None:\n    \"\"\"\n    Record the active environment name in `environment_state.json`.\n\n    Parameters\n    ----------\n    env_conf : brmspy.types.session.EnvironmentConfig\n        Environment configuration whose name should be recorded.\n    \"\"\"\n    state_path = get_environments_state_path()\n    with open(state_path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(\n            {\"active\": env_conf.environment_name}, f, indent=2, ensure_ascii=False\n        )\n</code></pre>"},{"location":"internals/_session/session/","title":"session","text":""},{"location":"internals/_session/session/#brmspy._session.session-attributes","title":"Attributes","text":""},{"location":"internals/_session/session/#brmspy._session.session.ctx","title":"<code>ctx = mp.get_context('spawn')</code>  <code>module-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session._INTERNAL_ATTRS","title":"<code>_INTERNAL_ATTRS = {'_module', '_module_path', '_environment_conf', '_mgr', '_proc', '_conn', '_shm_pool', '_reg', '_closed', '_func_cache', '_call_remote', '_encode_arg', '_decode_result', '_active_ctx', 'add_contextmanager', 'restart', 'shutdown', 'environment_exists', 'environment_activate', '_run_test_by_name'}</code>  <code>module-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session-classes","title":"Classes","text":""},{"location":"internals/_session/session/#brmspy._session.session.RSessionError","title":"<code>RSessionError</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Error raised when a worker call fails.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error message (often derived from R error messages).</p> required <code>remote_traceback</code> <code>str or None</code> <p>Best-effort traceback text from the worker process. For R errors this may be an R traceback string; for Python errors inside the worker it may be a Python traceback.</p> <code>None</code> Notes <p>This exception type is designed to preserve the remote failure context while keeping the main process free of rpy2/R state.</p> Source code in <code>brmspy/types/errors.py</code> <pre><code>class RSessionError(RuntimeError):\n    \"\"\"\n    Error raised when a worker call fails.\n\n    Parameters\n    ----------\n    message : str\n        Human-readable error message (often derived from R error messages).\n    remote_traceback : str or None, default=None\n        Best-effort traceback text from the worker process. For R errors this may\n        be an R traceback string; for Python errors inside the worker it may be\n        a Python traceback.\n\n    Notes\n    -----\n    This exception type is designed to preserve the *remote* failure context\n    while keeping the main process free of rpy2/R state.\n    \"\"\"\n\n    def __init__(self, message: str, remote_traceback: str | None = None) -&gt; None:\n        super().__init__(message)\n        self.remote_traceback = remote_traceback\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return message plus the remote traceback (if available).\"\"\"\n        base = super().__str__()\n        if self.remote_traceback:\n            return f\"{base}\\n\\nRemote traceback:\\n{self.remote_traceback}\\n\\n\"\n        return base\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RSessionError-attributes","title":"Attributes","text":""},{"location":"internals/_session/session/#brmspy._session.session.RSessionError.remote_traceback","title":"<code>remote_traceback = remote_traceback</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.RSessionError-functions","title":"Functions","text":""},{"location":"internals/_session/session/#brmspy._session.session.RSessionError.__init__","title":"<code>__init__(message, remote_traceback=None)</code>","text":"Source code in <code>brmspy/types/errors.py</code> <pre><code>def __init__(self, message: str, remote_traceback: str | None = None) -&gt; None:\n    super().__init__(message)\n    self.remote_traceback = remote_traceback\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RSessionError.__str__","title":"<code>__str__()</code>","text":"<p>Return message plus the remote traceback (if available).</p> Source code in <code>brmspy/types/errors.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return message plus the remote traceback (if available).\"\"\"\n    base = super().__str__()\n    if self.remote_traceback:\n        return f\"{base}\\n\\nRemote traceback:\\n{self.remote_traceback}\\n\\n\"\n    return base\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RWorkerCrashedError","title":"<code>RWorkerCrashedError</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when the R worker process crashes during an operation.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable description of the failure.</p> required <code>recovered</code> <code>bool</code> <p>Indicates whether a fresh worker session was successfully started.</p> <ul> <li><code>True</code>  \u2013 The crash occurred, but automatic recovery succeeded.               The failed operation did not complete, but the worker               is now in a clean state. Callers may safely retry.</li> <li><code>False</code> \u2013 The crash occurred and automatic recovery failed.               A usable worker session is not available. Callers should               treat this as a hard failure and abort or escalate.</li> </ul> required <code>cause</code> <code>BaseException</code> <p>The original exception that triggered the crash. Stored as <code>__cause__</code> for chained exception inspection.</p> <code>None</code> Usage <p>In user code or automated pipelines, you can distinguish between a recoverable and unrecoverable crash:</p> <pre><code>try:\n    brms.brm(...)\nexcept RWorkerCrashedError as err:\n    if err.recovered:\n        # Crash occurred, but a fresh worker is ready.\n        # Safe to retry the operation once.\n        brms.brm(...)\n    else:\n        # Worker could not be restarted.\n        # Treat this as a hard failure.\n        raise\n</code></pre> Notes <p>All crashes automatically produce a new exception that wraps the original failure using Python's exception chaining (<code>raise ... from cause</code>). Inspect <code>err.__cause__</code> for the underlying system error.</p> Source code in <code>brmspy/types/errors.py</code> <pre><code>class RWorkerCrashedError(RuntimeError):\n    \"\"\"\n    Raised when the R worker process crashes during an operation.\n\n    Parameters\n    ----------\n    message : str\n        Human-readable description of the failure.\n    recovered : bool\n        Indicates whether a fresh worker session was successfully started.\n\n        * ``True``  \u2013 The crash occurred, but automatic recovery succeeded.\n                      The failed operation did *not* complete, but the worker\n                      is now in a clean state. Callers may safely retry.\n        * ``False`` \u2013 The crash occurred and automatic recovery failed.\n                      A usable worker session is not available. Callers should\n                      treat this as a hard failure and abort or escalate.\n    cause : BaseException, optional\n        The original exception that triggered the crash. Stored as ``__cause__``\n        for chained exception inspection.\n\n    Usage\n    -----\n    In user code or automated pipelines, you can distinguish between a\n    recoverable and unrecoverable crash:\n\n    ```python\n    try:\n        brms.brm(...)\n    except RWorkerCrashedError as err:\n        if err.recovered:\n            # Crash occurred, but a fresh worker is ready.\n            # Safe to retry the operation once.\n            brms.brm(...)\n        else:\n            # Worker could not be restarted.\n            # Treat this as a hard failure.\n            raise\n    ```\n\n    Notes\n    -----\n    All crashes automatically produce a new exception that wraps the original\n    failure using Python's exception chaining (``raise ... from cause``).\n    Inspect ``err.__cause__`` for the underlying system error.\n    \"\"\"\n\n    def __init__(\n        self, message: str, *, recovered: bool, cause: BaseException | None = None\n    ):\n        super().__init__(message)\n        self.recovered = recovered\n        self.__cause__ = cause\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RWorkerCrashedError-attributes","title":"Attributes","text":""},{"location":"internals/_session/session/#brmspy._session.session.RWorkerCrashedError.recovered","title":"<code>recovered = recovered</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.RWorkerCrashedError.__cause__","title":"<code>__cause__ = cause</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.RWorkerCrashedError-functions","title":"Functions","text":""},{"location":"internals/_session/session/#brmspy._session.session.RWorkerCrashedError.__init__","title":"<code>__init__(message, *, recovered, cause=None)</code>","text":"Source code in <code>brmspy/types/errors.py</code> <pre><code>def __init__(\n    self, message: str, *, recovered: bool, cause: BaseException | None = None\n):\n    super().__init__(message)\n    self.recovered = recovered\n    self.__cause__ = cause\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.EncodeResult","title":"<code>EncodeResult</code>  <code>dataclass</code>","text":"<p>Result of encoding a Python value for IPC transfer.</p> <p>Attributes:</p> Name Type Description <code>codec</code> <code>str</code> <p>Codec identifier.</p> <code>meta</code> <code>dict[str, Any]</code> <p>JSON-serializable metadata required for decoding.</p> <code>buffers</code> <code>list[ShmRef]</code> <p>Shared-memory blocks backing the encoded payload.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@dataclass\nclass EncodeResult:\n    \"\"\"\n    Result of encoding a Python value for IPC transfer.\n\n    Attributes\n    ----------\n    codec : str\n        Codec identifier.\n    meta : dict[str, Any]\n        JSON-serializable metadata required for decoding.\n    buffers : list[ShmRef]\n        Shared-memory blocks backing the encoded payload.\n    \"\"\"\n\n    codec: str\n    meta: dict[str, Any]\n    buffers: list[ShmRef]\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.EncodeResult-attributes","title":"Attributes","text":""},{"location":"internals/_session/session/#brmspy._session.session.EncodeResult.codec","title":"<code>codec</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.EncodeResult.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.EncodeResult.buffers","title":"<code>buffers</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.EncodeResult-functions","title":"Functions","text":""},{"location":"internals/_session/session/#brmspy._session.session.EncodeResult.__init__","title":"<code>__init__(codec, meta, buffers)</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.EnvironmentConfig","title":"<code>EnvironmentConfig</code>  <code>dataclass</code>","text":"<p>Worker environment configuration.</p> <p>This configuration is applied in the worker before importing/using brms.</p> <p>Parameters:</p> Name Type Description Default <code>r_home</code> <code>str or None</code> <p>Override for <code>R_HOME</code>. If None, the worker will rely on system detection.</p> <code>None</code> <code>startup_scripts</code> <code>list[str]</code> <p>R code snippets executed in the worker after initialization.</p> <code>list()</code> <code>environment_name</code> <code>str</code> <p>brmspy environment name (used to determine <code>~/.brmspy/environment/&lt;name&gt;/Rlib</code>).</p> <code>'default'</code> <code>runtime_path</code> <code>str or None</code> <p>Path to a brmspy runtime bundle to activate in the worker.</p> <code>None</code> <code>env</code> <code>dict[str, str]</code> <p>Extra environment variables applied when spawning the worker.</p> <code>dict()</code> Source code in <code>brmspy/types/session.py</code> <pre><code>@dataclass\nclass EnvironmentConfig:\n    \"\"\"\n    Worker environment configuration.\n\n    This configuration is applied in the worker before importing/using brms.\n\n    Parameters\n    ----------\n    r_home : str or None\n        Override for `R_HOME`. If None, the worker will rely on system detection.\n    startup_scripts : list[str]\n        R code snippets executed in the worker after initialization.\n    environment_name : str\n        brmspy environment name (used to determine `~/.brmspy/environment/&lt;name&gt;/Rlib`).\n    runtime_path : str or None\n        Path to a brmspy runtime bundle to activate in the worker.\n    env : dict[str, str]\n        Extra environment variables applied when spawning the worker.\n    \"\"\"\n\n    r_home: None | str = None\n    startup_scripts: list[str] = field(default_factory=list)\n    environment_name: str = \"default\"\n    runtime_path: None | str = None\n    env: dict[str, str] = field(default_factory=dict)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Serialize configuration for persistence to JSON.\"\"\"\n        return {\n            \"environment_name\": self.environment_name,\n            \"r_home\": self.r_home,\n            \"startup_scripts\": self.startup_scripts or [],\n            \"runtime_path\": self.runtime_path,\n            \"env\": self.env,\n        }\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any]) -&gt; EnvironmentConfig:\n        \"\"\"Deserialize configuration from a JSON object.\"\"\"\n        return cls(\n            r_home=obj[\"r_home\"],\n            startup_scripts=obj[\"startup_scripts\"],\n            environment_name=obj[\"environment_name\"],\n            runtime_path=obj[\"runtime_path\"],\n            env=obj[\"env\"],\n        )\n\n    @classmethod\n    def from_obj(\n        cls, obj: None | dict[str, Any] | EnvironmentConfig\n    ) -&gt; EnvironmentConfig:\n        \"\"\"Normalize `None | dict | EnvironmentConfig` into an `EnvironmentConfig`.\"\"\"\n        if obj is None:\n            return cls()\n        if isinstance(obj, dict):\n            return cls.from_dict(obj)\n        return obj\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.EnvironmentConfig-attributes","title":"Attributes","text":""},{"location":"internals/_session/session/#brmspy._session.session.EnvironmentConfig.r_home","title":"<code>r_home = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.EnvironmentConfig.startup_scripts","title":"<code>startup_scripts = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.EnvironmentConfig.environment_name","title":"<code>environment_name = 'default'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.EnvironmentConfig.runtime_path","title":"<code>runtime_path = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.EnvironmentConfig.env","title":"<code>env = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.EnvironmentConfig-functions","title":"Functions","text":""},{"location":"internals/_session/session/#brmspy._session.session.EnvironmentConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize configuration for persistence to JSON.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Serialize configuration for persistence to JSON.\"\"\"\n    return {\n        \"environment_name\": self.environment_name,\n        \"r_home\": self.r_home,\n        \"startup_scripts\": self.startup_scripts or [],\n        \"runtime_path\": self.runtime_path,\n        \"env\": self.env,\n    }\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.EnvironmentConfig.from_dict","title":"<code>from_dict(obj)</code>  <code>classmethod</code>","text":"<p>Deserialize configuration from a JSON object.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any]) -&gt; EnvironmentConfig:\n    \"\"\"Deserialize configuration from a JSON object.\"\"\"\n    return cls(\n        r_home=obj[\"r_home\"],\n        startup_scripts=obj[\"startup_scripts\"],\n        environment_name=obj[\"environment_name\"],\n        runtime_path=obj[\"runtime_path\"],\n        env=obj[\"env\"],\n    )\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.EnvironmentConfig.from_obj","title":"<code>from_obj(obj)</code>  <code>classmethod</code>","text":"<p>Normalize <code>None | dict | EnvironmentConfig</code> into an <code>EnvironmentConfig</code>.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@classmethod\ndef from_obj(\n    cls, obj: None | dict[str, Any] | EnvironmentConfig\n) -&gt; EnvironmentConfig:\n    \"\"\"Normalize `None | dict | EnvironmentConfig` into an `EnvironmentConfig`.\"\"\"\n    if obj is None:\n        return cls()\n    if isinstance(obj, dict):\n        return cls.from_dict(obj)\n    return obj\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.EnvironmentConfig.__init__","title":"<code>__init__(r_home=None, startup_scripts=list(), environment_name='default', runtime_path=None, env=dict())</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.PayloadRef","title":"<code>PayloadRef</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Encoded argument/result payload sent over the control pipe.</p> <p>A payload is:</p> <ul> <li><code>codec</code>: the codec identifier used by the registry</li> <li><code>meta</code>: JSON-serializable metadata needed to reconstruct the value</li> <li><code>buffers</code>: shared-memory buffer references backing the payload</li> </ul> Source code in <code>brmspy/types/session.py</code> <pre><code>class PayloadRef(TypedDict):\n    \"\"\"\n    Encoded argument/result payload sent over the control pipe.\n\n    A payload is:\n\n    - `codec`: the codec identifier used by the registry\n    - `meta`: JSON-serializable metadata needed to reconstruct the value\n    - `buffers`: shared-memory buffer references backing the payload\n    \"\"\"\n\n    codec: str\n    meta: dict[str, Any]\n    buffers: list[ShmRef]\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.PayloadRef-attributes","title":"Attributes","text":""},{"location":"internals/_session/session/#brmspy._session.session.PayloadRef.codec","title":"<code>codec</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.PayloadRef.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.PayloadRef.buffers","title":"<code>buffers</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.Request","title":"<code>Request</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>IPC request message sent from main process to worker.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Correlation id for the request/response pair.</p> <code>cmd</code> <code>{'CALL', 'SHUTDOWN', 'PING', '_RUN_TEST_BY_NAME'}</code> <p>Command type.</p> <code>target</code> <code>str</code> <p>Worker target spec (see <code>_resolve_module_target()</code>).</p> <code>args, kwargs</code> <p>Encoded arguments.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>class Request(TypedDict):\n    \"\"\"\n    IPC request message sent from main process to worker.\n\n    Attributes\n    ----------\n    id : str\n        Correlation id for the request/response pair.\n    cmd : {\"CALL\", \"SHUTDOWN\", \"PING\", \"_RUN_TEST_BY_NAME\"}\n        Command type.\n    target : str\n        Worker target spec (see [`_resolve_module_target()`][brmspy._session.worker.worker._resolve_module_target]).\n    args, kwargs\n        Encoded arguments.\n    \"\"\"\n\n    id: str\n    cmd: CommandType\n    target: str\n    args: list[PayloadRef]\n    kwargs: dict[str, PayloadRef]\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.Request-attributes","title":"Attributes","text":""},{"location":"internals/_session/session/#brmspy._session.session.Request.id","title":"<code>id</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.Request.cmd","title":"<code>cmd</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.Request.target","title":"<code>target</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.Request.args","title":"<code>args</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.Request.kwargs","title":"<code>kwargs</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>IPC response message sent from worker back to the main process.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>class Response(TypedDict):\n    \"\"\"\n    IPC response message sent from worker back to the main process.\n    \"\"\"\n\n    id: str\n    ok: bool\n    result: None | PayloadRef\n    error: None | str\n    traceback: None | str\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.Response-attributes","title":"Attributes","text":""},{"location":"internals/_session/session/#brmspy._session.session.Response.id","title":"<code>id</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.Response.ok","title":"<code>ok</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.Response.result","title":"<code>result</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.Response.error","title":"<code>error</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.Response.traceback","title":"<code>traceback</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.ShmPool","title":"<code>ShmPool</code>","text":"<p>               Bases: <code>ShmPool</code></p> <p>Concrete shared-memory pool implementation that temporarily tracks attached blocks.</p> <p>_blocks dict keeps references to shm buffers TEMPORARILY and is cleaned up before each 'responding to main' or 'sending new message to worker'. This allows the in-between processing of shm buffers to rely on the buffers not being garbage collected.</p> <p>After reconstructing an object from a shm buffer, it's the CodecRegistrys role to take over the reference by initiating a weakref between the reconstructed object and buffer (or skipping if the object is temporary).</p> <p>This helps ensure that a minimal amount of shm buffers are actively mapped and garbage collection can remove file descriptors no longer needed.</p> Source code in <code>brmspy/_session/transport.py</code> <pre><code>class ShmPool(_ShmPool):\n    \"\"\"\n    Concrete shared-memory pool implementation that temporarily tracks attached blocks.\n\n    _blocks dict keeps references to shm buffers TEMPORARILY and is cleaned up\n    before each 'responding to main' or 'sending new message to worker'. This\n    allows the in-between processing of shm buffers to rely on the buffers not\n    being garbage collected.\n\n    After reconstructing an object from a shm buffer, it's the CodecRegistrys role\n    to take over the reference by initiating a weakref between the reconstructed\n    object and buffer (or skipping if the object is temporary).\n\n    This helps ensure that a minimal amount of shm buffers are actively mapped\n    and garbage collection can remove file descriptors no longer needed.\n    \"\"\"\n\n    def __init__(self, manager: SharedMemoryManager) -&gt; None:\n        self._manager = manager\n        self._blocks: dict[str, ShmBlock] = {}\n\n    def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n        # print(f\"alloc {'temp' if temporary else ''}\")\n        shm = self._manager.SharedMemory(size=size)\n        block = ShmBlock(\n            name=shm.name,\n            size=shm.size,\n            shm=shm,\n            content_size=size,\n            temporary=temporary,\n        )\n        self._blocks[block.name] = block\n        return block\n\n    def attach(self, ref: ShmRef) -&gt; ShmBlock:\n        if ref[\"name\"] in self._blocks:\n            return self._blocks[ref[\"name\"]]\n        shm = SharedMemory(name=ref[\"name\"])\n        block = ShmBlock(\n            name=ref[\"name\"],\n            size=ref[\"size\"],\n            shm=shm,\n            content_size=ref[\"content_size\"],\n            temporary=ref[\"temporary\"],\n        )\n        self._blocks[ref[\"name\"]] = block\n        return block\n\n    def close_all(self) -&gt; None:\n        for block in self._blocks.values():\n            block.shm.close()\n        self._blocks.clear()\n\n    def gc(self, name: str | None = None):\n        if name is not None:\n            b = self._blocks.pop(name, None)\n            if b is not None:\n                b.shm.close()\n            return\n\n        for key in list(self._blocks.keys()):\n            b = self._blocks[key]\n            if b.temporary:\n                b.shm.close()\n            del self._blocks[key]\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.ShmPool-attributes","title":"Attributes","text":""},{"location":"internals/_session/session/#brmspy._session.session.ShmPool._manager","title":"<code>_manager = manager</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.ShmPool._blocks","title":"<code>_blocks = {}</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.ShmPool-functions","title":"Functions","text":""},{"location":"internals/_session/session/#brmspy._session.session.ShmPool.__init__","title":"<code>__init__(manager)</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def __init__(self, manager: SharedMemoryManager) -&gt; None:\n    self._manager = manager\n    self._blocks: dict[str, ShmBlock] = {}\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.ShmPool.alloc","title":"<code>alloc(size, temporary=False)</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n    # print(f\"alloc {'temp' if temporary else ''}\")\n    shm = self._manager.SharedMemory(size=size)\n    block = ShmBlock(\n        name=shm.name,\n        size=shm.size,\n        shm=shm,\n        content_size=size,\n        temporary=temporary,\n    )\n    self._blocks[block.name] = block\n    return block\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.ShmPool.attach","title":"<code>attach(ref)</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def attach(self, ref: ShmRef) -&gt; ShmBlock:\n    if ref[\"name\"] in self._blocks:\n        return self._blocks[ref[\"name\"]]\n    shm = SharedMemory(name=ref[\"name\"])\n    block = ShmBlock(\n        name=ref[\"name\"],\n        size=ref[\"size\"],\n        shm=shm,\n        content_size=ref[\"content_size\"],\n        temporary=ref[\"temporary\"],\n    )\n    self._blocks[ref[\"name\"]] = block\n    return block\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.ShmPool.close_all","title":"<code>close_all()</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def close_all(self) -&gt; None:\n    for block in self._blocks.values():\n        block.shm.close()\n    self._blocks.clear()\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.ShmPool.gc","title":"<code>gc(name=None)</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def gc(self, name: str | None = None):\n    if name is not None:\n        b = self._blocks.pop(name, None)\n        if b is not None:\n            b.shm.close()\n        return\n\n    for key in list(self._blocks.keys()):\n        b = self._blocks[key]\n        if b.temporary:\n            b.shm.close()\n        del self._blocks[key]\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy","title":"<code>ClassProxy</code>","text":"<p>Class-like proxy that exposes only @staticmethod members of a surface class and executes them in the worker.</p> <p>Worker target format:     mod:{module_path}::{class_name}.{method_name}</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>class ClassProxy:\n    \"\"\"\n    Class-like proxy that exposes only @staticmethod members of a surface class\n    and executes them in the worker.\n\n    Worker target format:\n        mod:{module_path}::{class_name}.{method_name}\n    \"\"\"\n\n    _INTERNAL = {\n        \"_session\",\n        \"_surface_class\",\n        \"_module_path\",\n        \"_class_name\",\n        \"_allowed\",\n        \"_func_cache\",\n    }\n\n    def __init__(\n        self,\n        *,\n        session: \"RModuleSession\",\n        surface_class: type,\n        module_path: str,\n        class_name: str,\n    ) -&gt; None:\n        self._session = session\n        self._surface_class = surface_class\n        self._module_path = module_path\n        self._class_name = class_name\n\n        # Only expose names backed by `@staticmethod` descriptors.\n        allowed: list[str] = []\n        for k, v in getattr(surface_class, \"__dict__\", {}).items():\n            if isinstance(v, staticmethod):\n                allowed.append(k)\n        self._allowed = tuple(sorted(set(allowed)))\n        self._func_cache: dict[str, Callable[..., Any]] = {}\n\n    def __getattribute__(self, name: str) -&gt; Any:\n        if name in ClassProxy._INTERNAL or (\n            name.startswith(\"__\") and name.endswith(\"__\")\n        ):\n            return object.__getattribute__(self, name)\n\n        allowed = object.__getattribute__(self, \"_allowed\")\n        if name not in allowed:\n            raise AttributeError(\n                f\"{self.__class__.__name__!r} has no attribute {name!r}\"\n            )\n\n        func_cache = object.__getattribute__(self, \"_func_cache\")\n        if name in func_cache:\n            return func_cache[name]\n\n        surface_class = object.__getattribute__(self, \"_surface_class\")\n        raw = surface_class.__dict__.get(name)\n\n        # We only allow staticmethod entries; enforce again defensively.\n        if not isinstance(raw, staticmethod):\n            raise AttributeError(f\"{surface_class!r} has no staticmethod {name!r}\")\n\n        session = object.__getattribute__(self, \"_session\")\n        module_path = object.__getattribute__(self, \"_module_path\")\n        class_name = object.__getattribute__(self, \"_class_name\")\n\n        # Grab underlying function only for metadata (__doc__/__name__)\n        orig = raw.__func__\n\n        def wrapper(*args, **kwargs):\n            return session._call_remote(\n                f\"mod:{module_path}::{class_name}.{name}\", *args, **kwargs\n            )\n\n        wrapper.__name__ = getattr(orig, \"__name__\", name)\n        wrapper.__doc__ = getattr(orig, \"__doc__\", None)\n        wrapper.__wrapped__ = orig  # type: ignore[attr-defined]\n\n        func_cache[name] = wrapper\n        return wrapper\n\n    def __dir__(self):\n        allowed = object.__getattribute__(self, \"_allowed\")\n        return sorted(set(allowed))\n\n    def __repr__(self) -&gt; str:\n        module_path = object.__getattribute__(self, \"_module_path\")\n        class_name = object.__getattribute__(self, \"_class_name\")\n        return f\"&lt;ClassProxy {module_path}::{class_name}&gt;\"\n\n    @property\n    def __all__(self) -&gt; list[str]:\n        return list(object.__getattribute__(self, \"_allowed\"))\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy-attributes","title":"Attributes","text":""},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy._INTERNAL","title":"<code>_INTERNAL = {'_session', '_surface_class', '_module_path', '_class_name', '_allowed', '_func_cache'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy._session","title":"<code>_session = session</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy._surface_class","title":"<code>_surface_class = surface_class</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy._module_path","title":"<code>_module_path = module_path</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy._class_name","title":"<code>_class_name = class_name</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy._allowed","title":"<code>_allowed = tuple(sorted(set(allowed)))</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy._func_cache","title":"<code>_func_cache = {}</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy.__all__","title":"<code>__all__</code>  <code>property</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy-functions","title":"Functions","text":""},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy.__init__","title":"<code>__init__(*, session, surface_class, module_path, class_name)</code>","text":"Source code in <code>brmspy/_session/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    session: \"RModuleSession\",\n    surface_class: type,\n    module_path: str,\n    class_name: str,\n) -&gt; None:\n    self._session = session\n    self._surface_class = surface_class\n    self._module_path = module_path\n    self._class_name = class_name\n\n    # Only expose names backed by `@staticmethod` descriptors.\n    allowed: list[str] = []\n    for k, v in getattr(surface_class, \"__dict__\", {}).items():\n        if isinstance(v, staticmethod):\n            allowed.append(k)\n    self._allowed = tuple(sorted(set(allowed)))\n    self._func_cache: dict[str, Callable[..., Any]] = {}\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy.__getattribute__","title":"<code>__getattribute__(name)</code>","text":"Source code in <code>brmspy/_session/session.py</code> <pre><code>def __getattribute__(self, name: str) -&gt; Any:\n    if name in ClassProxy._INTERNAL or (\n        name.startswith(\"__\") and name.endswith(\"__\")\n    ):\n        return object.__getattribute__(self, name)\n\n    allowed = object.__getattribute__(self, \"_allowed\")\n    if name not in allowed:\n        raise AttributeError(\n            f\"{self.__class__.__name__!r} has no attribute {name!r}\"\n        )\n\n    func_cache = object.__getattribute__(self, \"_func_cache\")\n    if name in func_cache:\n        return func_cache[name]\n\n    surface_class = object.__getattribute__(self, \"_surface_class\")\n    raw = surface_class.__dict__.get(name)\n\n    # We only allow staticmethod entries; enforce again defensively.\n    if not isinstance(raw, staticmethod):\n        raise AttributeError(f\"{surface_class!r} has no staticmethod {name!r}\")\n\n    session = object.__getattribute__(self, \"_session\")\n    module_path = object.__getattribute__(self, \"_module_path\")\n    class_name = object.__getattribute__(self, \"_class_name\")\n\n    # Grab underlying function only for metadata (__doc__/__name__)\n    orig = raw.__func__\n\n    def wrapper(*args, **kwargs):\n        return session._call_remote(\n            f\"mod:{module_path}::{class_name}.{name}\", *args, **kwargs\n        )\n\n    wrapper.__name__ = getattr(orig, \"__name__\", name)\n    wrapper.__doc__ = getattr(orig, \"__doc__\", None)\n    wrapper.__wrapped__ = orig  # type: ignore[attr-defined]\n\n    func_cache[name] = wrapper\n    return wrapper\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy.__dir__","title":"<code>__dir__()</code>","text":"Source code in <code>brmspy/_session/session.py</code> <pre><code>def __dir__(self):\n    allowed = object.__getattribute__(self, \"_allowed\")\n    return sorted(set(allowed))\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.ClassProxy.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/_session/session.py</code> <pre><code>def __repr__(self) -&gt; str:\n    module_path = object.__getattribute__(self, \"_module_path\")\n    class_name = object.__getattribute__(self, \"_class_name\")\n    return f\"&lt;ClassProxy {module_path}::{class_name}&gt;\"\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession","title":"<code>RModuleSession</code>","text":"<p>               Bases: <code>ModuleType</code></p> <p>Module-like proxy that forwards attribute access and function calls to a worker process.</p> <p>In the main process, <code>brmspy.brms</code> is an instance of this class wrapping the real worker-side module. Access patterns are:</p> <ul> <li>Callables (functions) are wrapped so calling them performs an IPC roundtrip:   encode args/kwargs \u2192 send request \u2192 run in worker \u2192 encode result \u2192 decode result.</li> <li>Non-callables (constants, types) are mirrored directly from the wrapped module   to keep <code>dir()</code> and IDE autocomplete useful.</li> </ul> <p>This class also owns the worker lifecycle:</p> <ul> <li>creates a <code>SharedMemoryManager</code> for large payload buffers</li> <li>spawns the worker process using spawn semantics</li> <li>bridges worker logging back into the parent's handlers via a log queue</li> <li>performs a <code>PING</code> handshake to ensure the worker is ready before requests</li> </ul> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>ModuleType</code> <p>The module object whose surface is mirrored in the main process. In practice this is the import of the worker-facing module (e.g. <code>brmspy.brms._brms_module</code>) but executed in the main process only for metadata / attribute discovery.</p> required <code>module_path</code> <code>str</code> <p>Import path used inside the worker when resolving targets (e.g. <code>\"brmspy.brms\"</code>).</p> required <code>environment_conf</code> <code>EnvironmentConfig | dict[str, Any] | None</code> <p>Initial environment configuration for the worker. If omitted, brmspy will try to load <code>default</code> from the environment store.</p> <code>None</code> Notes <ul> <li>The main process must not import <code>rpy2.robjects</code>; the worker owns all embedded-R state.</li> <li>Any R objects returned by the worker are replaced with lightweight wrappers and can   only be reattached inside the same worker process lifetime.</li> </ul> Source code in <code>brmspy/_session/session.py</code> <pre><code>class RModuleSession(ModuleType):\n    \"\"\"\n    Module-like proxy that forwards attribute access and function calls to a worker process.\n\n    In the main process, `brmspy.brms` is an instance of this class wrapping the\n    real worker-side module. Access patterns are:\n\n    - **Callables** (functions) are wrapped so calling them performs an IPC roundtrip:\n      encode args/kwargs \u2192 send request \u2192 run in worker \u2192 encode result \u2192 decode result.\n    - **Non-callables** (constants, types) are mirrored directly from the wrapped module\n      to keep `dir()` and IDE autocomplete useful.\n\n    This class also owns the worker lifecycle:\n\n    - creates a `SharedMemoryManager` for large payload buffers\n    - spawns the worker process using spawn semantics\n    - bridges worker logging back into the parent's handlers via a log queue\n    - performs a `PING` handshake to ensure the worker is ready before requests\n\n    Parameters\n    ----------\n    module : types.ModuleType\n        The module object whose surface is mirrored in the main process. In practice\n        this is the import of the worker-facing module (e.g. `brmspy.brms._brms_module`)\n        but executed in the main process only for metadata / attribute discovery.\n    module_path : str\n        Import path used inside the worker when resolving targets (e.g. ``\"brmspy.brms\"``).\n    environment_conf : brmspy.types.session.EnvironmentConfig | dict[str, Any] | None, optional\n        Initial environment configuration for the worker. If omitted, brmspy will try\n        to load `default` from the environment store.\n\n    Notes\n    -----\n    - The main process must not import `rpy2.robjects`; the worker owns all embedded-R state.\n    - Any R objects returned by the worker are replaced with lightweight wrappers and can\n      only be reattached inside the same worker process lifetime.\n    \"\"\"\n\n    _instances: weakref.WeakSet[RModuleSession] = weakref.WeakSet()\n    _atexit_registered: bool = False\n    _is_rsession: bool = True\n\n    def __init__(\n        self,\n        module: ModuleType,\n        module_path: str,\n        environment_conf: EnvironmentConfig | dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Create a new session proxy and immediately start its worker.\n\n        Parameters\n        ----------\n        module : types.ModuleType\n            Wrapped module used for surface mirroring in the main process.\n        module_path : str\n            Worker import root used for resolving targets.\n        environment_conf : brmspy.types.session.EnvironmentConfig | dict[str, Any] | None\n            Initial worker environment configuration.\n\n        Raises\n        ------\n        RuntimeError\n            If the worker fails to start or does not respond to the startup handshake.\n        \"\"\"\n        # Pretend to be the same module (for IDEs/docs)\n        super().__init__(module.__name__, module.__doc__)\n\n        if environment_conf is None:\n\n            try:\n                environment_conf = get_environment_config(\"default\")\n            except:\n\n                pass\n\n        # Store wrapped module and how to import it in worker\n        self._module: ModuleType = module\n        self._module_path: str = module_path\n        self._environment_conf: EnvironmentConfig = EnvironmentConfig.from_obj(\n            environment_conf\n        )\n\n        if \"BRMSPY_AUTOLOAD\" in self._environment_conf.env:\n            del self._environment_conf.env[\"BRMSPY_AUTOLOAD\"]\n\n        # cache of Python wrappers for functions\n        self._func_cache: dict[str, Callable[..., Any]] = {}\n\n        # Disallow nested tooling contexts (manage/_build/etc)\n        self._active_ctx: str | None = None\n\n        self._closed = True\n\n        # start SHM manager + worker\n        self._setup_worker()\n\n        # copy attributes so IDEs / dir() see the module surface\n        self.__dict__.update(module.__dict__)\n\n        # register for global cleanup at exit\n        RModuleSession._instances.add(self)\n        if not RModuleSession._atexit_registered:\n            atexit.register(RModuleSession._cleanup_all)\n            RModuleSession._atexit_registered = True\n\n    def _setup_worker(self, autoload: bool = True) -&gt; None:\n        \"\"\"\n        Start the SHM manager + worker process and perform the startup handshake.\n\n        Parameters\n        ----------\n        autoload : bool, default=True\n            If True, sets `BRMSPY_AUTOLOAD=1` for the worker, allowing it to auto-activate\n            the last configured runtime on startup. Context-managed tooling flows\n            (e.g. `manage()`) typically start the worker with `autoload=False`.\n\n        Raises\n        ------\n        RuntimeError\n            If the worker fails to start within the handshake timeout or reports an init error.\n        \"\"\"\n\n        mgr = SharedMemoryManager(ctx=ctx)\n        mgr.start()\n\n        mgr_address = mgr.address\n        mgr_authkey = mgr._authkey  # type: ignore[attr-defined]\n\n        parent_conn, child_conn = mp.Pipe()\n        self._conn = parent_conn\n\n        env_overrides: dict[str, str] = {\n            \"BRMSPY_WORKER\": \"1\",\n            **self._environment_conf.env,\n        }\n        # --- logging bridge: child -&gt; parent ---\n        self._log_queue: mp.Queue = ctx.Queue()\n\n        # Use whatever handlers are currently on the root logger.\n        root = logging.getLogger()\n        self._log_listener = QueueListener(\n            self._log_queue,\n            *root.handlers,\n            respect_handler_level=True,\n        )\n        self._log_listener.start()\n\n        if autoload:\n            env_overrides[\"BRMSPY_AUTOLOAD\"] = \"1\"\n        else:\n            env_overrides[\"BRMSPY_AUTOLOAD\"] = \"0\"\n\n        # Spawn worker. Important: close our local copy of the child's end of the Pipe\n        # after the process starts, otherwise each restart leaks file descriptors.\n        proc = None\n        try:\n            proc = spawn_worker(\n                target=worker_main,\n                args=(child_conn, mgr_address, mgr_authkey, self._environment_conf),\n                env_overrides=env_overrides,\n                log_queue=self._log_queue,\n            )\n        finally:\n            try:\n                child_conn.close()\n            except Exception:\n                pass\n\n        self._mgr = mgr\n        self._proc = proc\n        self._shm_pool = ShmPool(mgr)\n        from .._singleton._shm_singleton import _set_shm\n\n        _set_shm(self._shm_pool)\n\n        self._reg = get_default_registry()\n        self._closed = False\n\n        # --- handshake: wait until worker is ready ---\n        # This is MANDATORY. Unless we want zombies or race conditions.\n        req_id = str(uuid.uuid4())\n        self._conn.send(\n            {\n                \"id\": req_id,\n                \"cmd\": \"PING\",\n                \"target\": \"\",\n                \"args\": [],\n                \"kwargs\": {},\n            }\n        )\n        if not self._conn.poll(30.0):\n            # worker never replied -&gt; treat as startup failure,\n            # clean up and raise\n            self._teardown_worker()\n            raise RuntimeError(\"Worker failed to start within timeout\")\n\n        resp = self._conn.recv()\n        if not resp.get(\"ok\", False):\n            self._teardown_worker()\n            raise RuntimeError(f\"Worker failed to initialize: {resp.get('error')}\")\n\n    def _teardown_worker(self) -&gt; None:\n        \"\"\"\n        Tear down worker process, SHM manager, and logging bridge.\n\n        This is best-effort cleanup used by `shutdown()` and `restart()`:\n\n        - sends `SHUTDOWN` (non-fatal if it fails)\n        - stops the `QueueListener` for worker logging\n        - shuts down the `SharedMemoryManager`\n        - joins/terminates the worker if needed\n\n        Notes\n        -----\n        The \"join then terminate\" sequence is intentional to avoid leaving zombie\n        processes behind in interactive environments.\n        \"\"\"\n        if self._closed:\n            return\n\n        # best-effort graceful shutdown\n        try:\n            if self._conn:\n                req_id = str(uuid.uuid4())\n                self._conn.send(\n                    {\n                        \"id\": req_id,\n                        \"cmd\": \"SHUTDOWN\",\n                        \"target\": \"\",\n                        \"args\": [],\n                        \"kwargs\": {},\n                    }\n                )\n                # wait for ack, but don't block forever\n                if self._conn.poll(5.0):\n                    _ = self._conn.recv()\n        except Exception:\n            pass\n\n        # close the pipe connection in this process (best-effort)\n        try:\n            conn = getattr(self, \"_conn\", None)\n            if conn is not None:\n                conn.close()\n        except Exception:\n            pass\n\n        # stop logging listener\n        try:\n            listener = getattr(self, \"_log_listener\", None)\n            if listener is not None:\n                listener.stop()\n        except Exception:\n            pass\n\n        # close the log queue to release its pipe FDs (important on macOS low ulimit)\n        try:\n            q = getattr(self, \"_log_queue\", None)\n            if q is not None:\n                try:\n                    q.close()\n                except Exception:\n                    pass\n                # Avoid potential hangs waiting for queue feeder threads in teardown paths.\n                try:\n                    q.cancel_join_thread()\n                except Exception:\n                    pass\n        except Exception:\n            pass\n\n        # close any SHM blocks we have attached/allocated in this process\n        try:\n            pool = getattr(self, \"_shm_pool\", None)\n            if pool is not None:\n                pool.close_all()\n            from .._singleton._shm_singleton import _set_shm\n\n            _set_shm(None)\n        except Exception:\n            pass\n\n        # shut down SHM manager\n        try:\n            self._mgr.shutdown()\n        except Exception:\n            pass\n\n        # give worker a chance to exit, then kill it if needed\n        # This is MANDATORY. Unless we want zombies or race conditions running amock\n        try:\n            if self._proc is not None:\n                self._proc.join(timeout=5.0)\n                if self._proc.is_alive():\n                    self._proc.terminate()\n                    self._proc.join(timeout=5.0)\n        except Exception:\n            pass\n\n        self._closed = True\n\n    # ----------------- global cleanup -----------------\n\n    @classmethod\n    def _cleanup_all(cls) -&gt; None:\n        \"\"\"\n        Atexit hook to shut down all live sessions.\n\n        This is registered once for the class and iterates over a WeakSet of\n        `RModuleSession` instances.\n        \"\"\"\n        for inst in list(cls._instances):\n            try:\n                inst.shutdown()\n            except Exception:\n                pass\n\n    # ----------------- IPC helpers --------------------\n\n    def _encode_arg(self, obj: Any) -&gt; PayloadRef:\n        \"\"\"\n        Encode a single Python argument into an IPC payload dict.\n\n        Parameters\n        ----------\n        obj : Any\n            Value to encode.\n\n        Returns\n        -------\n        dict[str, Any]\n            A JSON-serializable structure containing:\n\n            - `codec`: registry codec id\n            - `meta`: codec metadata\n            - `buffers`: list of SHM block references (`name`, `size`)\n        \"\"\"\n        enc = self._reg.encode(obj, self._shm_pool)\n        return {\n            \"codec\": enc.codec,\n            \"meta\": enc.meta,\n            \"buffers\": enc.buffers,\n        }\n\n    def _decode_result(self, resp: Response) -&gt; Any:\n        \"\"\"\n        Decode a worker response into a Python value or raise.\n\n        Parameters\n        ----------\n        resp : dict[str, Any]\n            Response message from the worker.\n\n        Returns\n        -------\n        Any\n            Decoded Python object.\n\n        Raises\n        ------\n        brmspy.types.errors.RSessionError\n            If `resp[\"ok\"]` is false. Includes best-effort remote traceback.\n        \"\"\"\n        if not resp[\"ok\"]:\n            raise RSessionError(\n                resp.get(\"error\") or \"Worker error\",\n                remote_traceback=resp.get(\"traceback\"),\n            )\n        pres = resp[\"result\"]\n        if not pres:\n            return None\n        decoded = self._reg.decode(\n            pres,\n            shm_pool=self._shm_pool,\n        )\n        return decoded\n\n    def _call_remote(self, func_name: str, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Perform a remote call in the worker.\n\n        Parameters\n        ----------\n        func_name : str\n            Function name or fully qualified target.\n\n            - If it starts with ``\"mod:\"``, it is treated as a full worker target.\n            - Otherwise it is resolved as a function on `self._module_path`.\n        *args, **kwargs\n            Call arguments, encoded via the session codec registry.\n\n        Returns\n        -------\n        Any\n            Decoded return value.\n\n        Raises\n        ------\n        RuntimeError\n            If the session has been shut down.\n        brmspy.types.errors.RSessionError\n            If the worker reports an error while executing the call.\n        \"\"\"\n        if self._closed:\n            raise RuntimeError(\"RModuleSession is closed\")\n\n        try:\n            if func_name.startswith(\"mod:\"):\n                target = func_name\n            else:\n                target = f\"mod:{self._module_path}.{func_name}\"\n\n            req_id = str(uuid.uuid4())\n            req: Request = {\n                \"id\": req_id,\n                \"cmd\": \"CALL\",\n                \"target\": target,\n                \"args\": [self._encode_arg(a) for a in args],\n                \"kwargs\": {k: self._encode_arg(v) for k, v in kwargs.items()},\n            }\n            self._conn.send(req)\n            resp = self._conn.recv()\n            decoded = self._decode_result(resp)\n\n            try:\n                # MUST be run after and never before decoding!\n                if self._shm_pool:\n                    self._shm_pool.gc()\n            except:\n                pass\n\n            return decoded\n\n        except (BrokenPipeError, ConnectionResetError, EOFError) as e:\n            self._recover(e)\n\n    def _recover(self, orig_exc: BaseException) -&gt; None:\n        logger = get_logger()\n\n        logger.warning(\n            \"R worker crashed; attempting to start a new session...\",\n            exc_info=orig_exc,\n        )\n\n        try:\n            # Best-effort shutdown; don't let this kill the recovery path\n            try:\n                self.shutdown()\n            except Exception:\n                logger.debug(\n                    \"Failed to cleanly shut down crashed worker\",\n                    exc_info=True,\n                )\n\n            # Restart must succeed or we bail\n            self.restart(autoload=False)\n\n        except Exception as restart_exc:\n            # Recovery itself failed\n            logger.error(\n                \"R worker crashed and automatic restart failed.\",\n                exc_info=restart_exc,\n            )\n            raise RWorkerCrashedError(\n                \"R worker crashed; failed to start new session.\",\n                recovered=False,\n                cause=restart_exc,\n            ) from restart_exc\n\n        # Recovery succeeded, but the *call* that hit this still failed\n        raise RWorkerCrashedError(\n            \"R worker crashed; started a fresh session. See __cause__ for details.\",\n            recovered=True,\n            cause=orig_exc,\n        ) from orig_exc\n\n    # ----------------- attribute proxying --------------\n\n    def __getattribute__(self, name: str) -&gt; Any:\n        \"\"\"\n        Proxy attribute access for a module-like experience.\n\n        Rules\n        -----\n        - Internal attributes are handled locally.\n        - Callables found on the wrapped module are returned as wrappers that call into the worker.\n        - Non-callables are mirrored directly.\n        \"\"\"\n        # 1. Always allow access to internal attributes via base implementation\n        if name in _INTERNAL_ATTRS or name.startswith(\"__\") and name.endswith(\"__\"):\n            return ModuleType.__getattribute__(self, name)\n\n        # 2. If we already have a cached wrapper for this name, return it\n        func_cache = ModuleType.__getattribute__(self, \"_func_cache\")\n        if name in func_cache:\n            return func_cache[name]\n\n        module = ModuleType.__getattribute__(self, \"_module\")\n\n        # 3. If wrapped module has this attribute, decide what to do\n        if hasattr(module, name):\n            attr = getattr(module, name)\n\n            if callable(attr) and not inspect.isclass(attr):\n                # wrap callables so they run in worker\n                return self._get_or_create_wrapper(name, attr)\n\n            # non-callables (constants, types, etc.) are just mirrored\n            return attr\n\n        # 4. Fallback: use normal module attribute resolution\n        return ModuleType.__getattribute__(self, name)\n\n    def _get_or_create_wrapper(\n        self, name: str, orig: Callable[..., Any]\n    ) -&gt; Callable[..., Any]:\n        \"\"\"\n        Return a cached worker-calling wrapper for a callable attribute.\n\n        Parameters\n        ----------\n        name : str\n            Attribute name on the wrapped module.\n        orig : collections.abc.Callable[..., Any]\n            Original callable (used for metadata only).\n\n        Returns\n        -------\n        collections.abc.Callable[..., Any]\n            Wrapper that performs an IPC roundtrip to execute the callable in the worker.\n        \"\"\"\n        func_cache = ModuleType.__getattribute__(self, \"_func_cache\")\n        if name in func_cache:\n            return func_cache[name]\n\n        def wrapper(*args: Any, **kwargs: Any):\n            return self._call_remote(name, *args, **kwargs)\n\n        wrapper.__name__ = getattr(orig, \"__name__\", name)\n        wrapper.__doc__ = getattr(orig, \"__doc__\", None)\n        wrapper.__wrapped__ = orig  # type: ignore[attr-defined]\n\n        func_cache[name] = wrapper\n        return wrapper\n\n    def __dir__(self) -&gt; list[str]:\n        \"\"\"Expose the merged surface of the proxy and the wrapped module.\"\"\"\n        module = ModuleType.__getattribute__(self, \"_module\")\n        return sorted(set(self.__dict__) | set(dir(module)))\n\n    # ----------------- lifetime ------------------------\n\n    def shutdown(self) -&gt; None:\n        \"\"\"Shut down the worker and related resources.\"\"\"\n        self._teardown_worker()\n\n    def __del__(self) -&gt; None:\n        \"\"\"Best-effort cleanup on GC; errors are suppressed.\"\"\"\n        try:\n            self.shutdown()\n        except Exception:\n            pass\n\n    def add_contextmanager(\n        self,\n        *,\n        surface_class: type,\n        surface_class_path: str,\n    ):\n        \"\"\"\n        Attach a class-based \"surface\" API as a context manager factory.\n\n        This is used to implement `brmspy.brms.manage()` and `brmspy.brms._build()`\n        without exposing worker internals to the main process.\n\n        Parameters\n        ----------\n        surface_class : type\n            Class whose `@staticmethod` members define the surface API available inside\n            the context. Only staticmethod members are exposed.\n        surface_class_path : str\n            Fully qualified path like ``\"pkg.module.ClassName\"`` used for worker target\n            resolution.\n\n        Returns\n        -------\n        collections.abc.Callable[..., contextlib.AbstractContextManager]\n            Factory that produces a context manager. On enter it restarts the worker\n            (autoload disabled) and yields a `ClassProxy` for the surface class.\n\n        Notes\n        -----\n        - Nesting contexts is forbidden; this is enforced via `self._active_ctx`.\n        - On exit, the selected environment config is persisted via the environment store.\n        \"\"\"\n\n        session = self\n\n        if surface_class is None or surface_class_path is None:\n            raise ValueError(\"surface_class and surface_class_path must both be set.\")\n        if \".\" not in surface_class_path:\n            raise ValueError(\n                \"surface_class_path must look like 'pkg.module.ClassName'.\"\n            )\n\n        module_path, class_name = surface_class_path.rsplit(\".\", 1)\n        ctx_label = f\"{module_path}::{class_name}\"\n\n        class _Ctx:\n            def __init__(\n                self,\n                *,\n                environment_config: EnvironmentConfig | dict[str, str] | None = None,\n                environment_name: str | None = None,\n            ) -&gt; None:\n                self._environment_config = environment_config\n                self._environment_name = environment_name\n                self._new_conf: EnvironmentConfig | None = None\n\n            def __enter__(self):\n                if session._active_ctx is not None:\n                    raise RuntimeError(\n                        f\"Nested brmspy contexts are not supported \"\n                        f\"(active={session._active_ctx!r}, new={ctx_label!r}).\"\n                    )\n                try:\n                    session._active_ctx = ctx_label\n\n                    if self._environment_name and self._environment_config:\n                        session._active_ctx = None\n                        raise Exception(\n                            \"Only provide one: environment name or environment config\"\n                        )\n\n                    if not self._environment_name and self._environment_config:\n                        overrides = EnvironmentConfig.from_obj(self._environment_config)\n                    elif self._environment_name:\n                        overrides = get_environment_config(self._environment_name)\n                    else:\n                        overrides = None\n\n                    old_conf = session._environment_conf\n                    new_conf = overrides if overrides else old_conf\n                    self._new_conf = new_conf\n\n                    # fresh worker with new_conf\n                    session.restart(environment_conf=new_conf, autoload=False)\n\n                    return ClassProxy(\n                        session=session,\n                        surface_class=surface_class,\n                        module_path=module_path,\n                        class_name=class_name,\n                    )\n                except Exception as e:\n                    session._active_ctx = None\n                    raise e\n\n            def __exit__(self, exc_type, exc, tb) -&gt; None:\n                try:\n                    if self._new_conf is not None:\n                        save(self._new_conf)\n                        save_as_state(self._new_conf)\n                finally:\n                    session._active_ctx = None\n                return None\n\n        def factory(\n            *,\n            environment_config: EnvironmentConfig | dict[str, str] | None = None,\n            environment_name: str | None = None,\n        ):\n            return _Ctx(\n                environment_config=environment_config, environment_name=environment_name\n            )\n\n        return factory\n\n    def restart(\n        self,\n        environment_conf: dict[str, Any] | EnvironmentConfig | None = None,\n        autoload: bool = True,\n        # empty_shm: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Restart the worker process and SHM manager.\n\n        Parameters\n        ----------\n        environment_conf : dict[str, Any] | brmspy.types.session.EnvironmentConfig | None\n            If provided, replaces the existing environment configuration for the new worker.\n        autoload : bool, default=True\n            Whether to enable autoload for the new worker process.\n\n        Notes\n        -----\n        This tears down the existing worker and starts a new one. Any previously\n        returned R object wrappers are no longer reattachable after restart.\n        \"\"\"\n        if environment_conf is not None:\n            self._environment_conf = EnvironmentConfig.from_obj(environment_conf)\n\n        # Tear down existing worker (if any)\n        self._teardown_worker()\n\n        self._func_cache.clear()\n\n        # Start a fresh worker with current env conf\n        self._setup_worker(autoload=autoload)\n\n    def environment_exists(self, name: str) -&gt; bool:\n        \"\"\"\n        Check whether an environment with the given name exists on disk.\n\n        Parameters\n        ----------\n        name : str\n            Environment name.\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        return get_environment_exists(name)\n\n    def environment_activate(self, name: str) -&gt; None:\n        \"\"\"\n        Activate an environment by restarting the worker through `manage()`.\n\n        Parameters\n        ----------\n        name : str\n            Environment name to activate.\n\n        Notes\n        -----\n        This is a convenience helper used by tests and developer flows.\n        \"\"\"\n        manage = self.manage\n        if manage:\n            with manage(environment_name=name) as ctx:\n                pass\n        else:\n            raise Exception(\"Invalid state. manage is not defined!\")\n\n    def _run_test_by_name(\n        self, module_path: str, class_name: str | None, func_name: str\n    ) -&gt; Any:\n        \"\"\"\n        Run a test identified by module/class/function inside the worker.\n\n        Parameters\n        ----------\n        module_path : str\n            Importable module path (e.g. ``\"tests.test_file\"``).\n        class_name : str | None\n            Optional class name if the test is a method.\n        func_name : str\n            Test function/method name.\n\n        Returns\n        -------\n        Any\n            Decoded return value from the test function.\n\n        Raises\n        ------\n        RuntimeError\n            If `BRMSPY_TEST=1` is not set.\n        brmspy.types.errors.RSessionError\n            If the worker reports a failure.\n        \"\"\"\n        if os.getenv(\"BRMSPY_TEST\") != \"1\":\n            raise RuntimeError(\"BRMSPY_TEST=1 required for worker test execution\")\n        if self._closed:\n            raise RuntimeError(\"Connection not open! Cant run test.\")\n\n        req_id = str(uuid.uuid4())\n        self._conn.send(\n            {\n                \"id\": req_id,\n                \"cmd\": \"_RUN_TEST_BY_NAME\",\n                \"target\": \"\",\n                \"args\": [],\n                \"kwargs\": {\n                    \"module\": module_path,\n                    \"class\": class_name,\n                    \"func\": func_name,\n                },\n            }\n        )\n\n        resp = self._conn.recv()\n\n        if not resp.get(\"ok\", False):\n            raise RSessionError(\n                resp.get(\"error\", \"Worker test failed\"),\n                remote_traceback=resp.get(\"traceback\"),\n            )\n\n        pres = resp[\"result\"]\n\n        return self._reg.decode(\n            pres,\n            shm_pool=self._shm_pool,\n        )\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession-attributes","title":"Attributes","text":""},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._instances","title":"<code>_instances = weakref.WeakSet()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._atexit_registered","title":"<code>_atexit_registered = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._is_rsession","title":"<code>_is_rsession = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._module","title":"<code>_module = module</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._module_path","title":"<code>_module_path = module_path</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._environment_conf","title":"<code>_environment_conf = EnvironmentConfig.from_obj(environment_conf)</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._func_cache","title":"<code>_func_cache = {}</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._active_ctx","title":"<code>_active_ctx = None</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._closed","title":"<code>_closed = True</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession-functions","title":"Functions","text":""},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession.__init__","title":"<code>__init__(module, module_path, environment_conf=None)</code>","text":"<p>Create a new session proxy and immediately start its worker.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>ModuleType</code> <p>Wrapped module used for surface mirroring in the main process.</p> required <code>module_path</code> <code>str</code> <p>Worker import root used for resolving targets.</p> required <code>environment_conf</code> <code>EnvironmentConfig | dict[str, Any] | None</code> <p>Initial worker environment configuration.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the worker fails to start or does not respond to the startup handshake.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>def __init__(\n    self,\n    module: ModuleType,\n    module_path: str,\n    environment_conf: EnvironmentConfig | dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Create a new session proxy and immediately start its worker.\n\n    Parameters\n    ----------\n    module : types.ModuleType\n        Wrapped module used for surface mirroring in the main process.\n    module_path : str\n        Worker import root used for resolving targets.\n    environment_conf : brmspy.types.session.EnvironmentConfig | dict[str, Any] | None\n        Initial worker environment configuration.\n\n    Raises\n    ------\n    RuntimeError\n        If the worker fails to start or does not respond to the startup handshake.\n    \"\"\"\n    # Pretend to be the same module (for IDEs/docs)\n    super().__init__(module.__name__, module.__doc__)\n\n    if environment_conf is None:\n\n        try:\n            environment_conf = get_environment_config(\"default\")\n        except:\n\n            pass\n\n    # Store wrapped module and how to import it in worker\n    self._module: ModuleType = module\n    self._module_path: str = module_path\n    self._environment_conf: EnvironmentConfig = EnvironmentConfig.from_obj(\n        environment_conf\n    )\n\n    if \"BRMSPY_AUTOLOAD\" in self._environment_conf.env:\n        del self._environment_conf.env[\"BRMSPY_AUTOLOAD\"]\n\n    # cache of Python wrappers for functions\n    self._func_cache: dict[str, Callable[..., Any]] = {}\n\n    # Disallow nested tooling contexts (manage/_build/etc)\n    self._active_ctx: str | None = None\n\n    self._closed = True\n\n    # start SHM manager + worker\n    self._setup_worker()\n\n    # copy attributes so IDEs / dir() see the module surface\n    self.__dict__.update(module.__dict__)\n\n    # register for global cleanup at exit\n    RModuleSession._instances.add(self)\n    if not RModuleSession._atexit_registered:\n        atexit.register(RModuleSession._cleanup_all)\n        RModuleSession._atexit_registered = True\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._setup_worker","title":"<code>_setup_worker(autoload=True)</code>","text":"<p>Start the SHM manager + worker process and perform the startup handshake.</p> <p>Parameters:</p> Name Type Description Default <code>autoload</code> <code>bool</code> <p>If True, sets <code>BRMSPY_AUTOLOAD=1</code> for the worker, allowing it to auto-activate the last configured runtime on startup. Context-managed tooling flows (e.g. <code>manage()</code>) typically start the worker with <code>autoload=False</code>.</p> <code>True</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the worker fails to start within the handshake timeout or reports an init error.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>def _setup_worker(self, autoload: bool = True) -&gt; None:\n    \"\"\"\n    Start the SHM manager + worker process and perform the startup handshake.\n\n    Parameters\n    ----------\n    autoload : bool, default=True\n        If True, sets `BRMSPY_AUTOLOAD=1` for the worker, allowing it to auto-activate\n        the last configured runtime on startup. Context-managed tooling flows\n        (e.g. `manage()`) typically start the worker with `autoload=False`.\n\n    Raises\n    ------\n    RuntimeError\n        If the worker fails to start within the handshake timeout or reports an init error.\n    \"\"\"\n\n    mgr = SharedMemoryManager(ctx=ctx)\n    mgr.start()\n\n    mgr_address = mgr.address\n    mgr_authkey = mgr._authkey  # type: ignore[attr-defined]\n\n    parent_conn, child_conn = mp.Pipe()\n    self._conn = parent_conn\n\n    env_overrides: dict[str, str] = {\n        \"BRMSPY_WORKER\": \"1\",\n        **self._environment_conf.env,\n    }\n    # --- logging bridge: child -&gt; parent ---\n    self._log_queue: mp.Queue = ctx.Queue()\n\n    # Use whatever handlers are currently on the root logger.\n    root = logging.getLogger()\n    self._log_listener = QueueListener(\n        self._log_queue,\n        *root.handlers,\n        respect_handler_level=True,\n    )\n    self._log_listener.start()\n\n    if autoload:\n        env_overrides[\"BRMSPY_AUTOLOAD\"] = \"1\"\n    else:\n        env_overrides[\"BRMSPY_AUTOLOAD\"] = \"0\"\n\n    # Spawn worker. Important: close our local copy of the child's end of the Pipe\n    # after the process starts, otherwise each restart leaks file descriptors.\n    proc = None\n    try:\n        proc = spawn_worker(\n            target=worker_main,\n            args=(child_conn, mgr_address, mgr_authkey, self._environment_conf),\n            env_overrides=env_overrides,\n            log_queue=self._log_queue,\n        )\n    finally:\n        try:\n            child_conn.close()\n        except Exception:\n            pass\n\n    self._mgr = mgr\n    self._proc = proc\n    self._shm_pool = ShmPool(mgr)\n    from .._singleton._shm_singleton import _set_shm\n\n    _set_shm(self._shm_pool)\n\n    self._reg = get_default_registry()\n    self._closed = False\n\n    # --- handshake: wait until worker is ready ---\n    # This is MANDATORY. Unless we want zombies or race conditions.\n    req_id = str(uuid.uuid4())\n    self._conn.send(\n        {\n            \"id\": req_id,\n            \"cmd\": \"PING\",\n            \"target\": \"\",\n            \"args\": [],\n            \"kwargs\": {},\n        }\n    )\n    if not self._conn.poll(30.0):\n        # worker never replied -&gt; treat as startup failure,\n        # clean up and raise\n        self._teardown_worker()\n        raise RuntimeError(\"Worker failed to start within timeout\")\n\n    resp = self._conn.recv()\n    if not resp.get(\"ok\", False):\n        self._teardown_worker()\n        raise RuntimeError(f\"Worker failed to initialize: {resp.get('error')}\")\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._teardown_worker","title":"<code>_teardown_worker()</code>","text":"<p>Tear down worker process, SHM manager, and logging bridge.</p> <p>This is best-effort cleanup used by <code>shutdown()</code> and <code>restart()</code>:</p> <ul> <li>sends <code>SHUTDOWN</code> (non-fatal if it fails)</li> <li>stops the <code>QueueListener</code> for worker logging</li> <li>shuts down the <code>SharedMemoryManager</code></li> <li>joins/terminates the worker if needed</li> </ul> Notes <p>The \"join then terminate\" sequence is intentional to avoid leaving zombie processes behind in interactive environments.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>def _teardown_worker(self) -&gt; None:\n    \"\"\"\n    Tear down worker process, SHM manager, and logging bridge.\n\n    This is best-effort cleanup used by `shutdown()` and `restart()`:\n\n    - sends `SHUTDOWN` (non-fatal if it fails)\n    - stops the `QueueListener` for worker logging\n    - shuts down the `SharedMemoryManager`\n    - joins/terminates the worker if needed\n\n    Notes\n    -----\n    The \"join then terminate\" sequence is intentional to avoid leaving zombie\n    processes behind in interactive environments.\n    \"\"\"\n    if self._closed:\n        return\n\n    # best-effort graceful shutdown\n    try:\n        if self._conn:\n            req_id = str(uuid.uuid4())\n            self._conn.send(\n                {\n                    \"id\": req_id,\n                    \"cmd\": \"SHUTDOWN\",\n                    \"target\": \"\",\n                    \"args\": [],\n                    \"kwargs\": {},\n                }\n            )\n            # wait for ack, but don't block forever\n            if self._conn.poll(5.0):\n                _ = self._conn.recv()\n    except Exception:\n        pass\n\n    # close the pipe connection in this process (best-effort)\n    try:\n        conn = getattr(self, \"_conn\", None)\n        if conn is not None:\n            conn.close()\n    except Exception:\n        pass\n\n    # stop logging listener\n    try:\n        listener = getattr(self, \"_log_listener\", None)\n        if listener is not None:\n            listener.stop()\n    except Exception:\n        pass\n\n    # close the log queue to release its pipe FDs (important on macOS low ulimit)\n    try:\n        q = getattr(self, \"_log_queue\", None)\n        if q is not None:\n            try:\n                q.close()\n            except Exception:\n                pass\n            # Avoid potential hangs waiting for queue feeder threads in teardown paths.\n            try:\n                q.cancel_join_thread()\n            except Exception:\n                pass\n    except Exception:\n        pass\n\n    # close any SHM blocks we have attached/allocated in this process\n    try:\n        pool = getattr(self, \"_shm_pool\", None)\n        if pool is not None:\n            pool.close_all()\n        from .._singleton._shm_singleton import _set_shm\n\n        _set_shm(None)\n    except Exception:\n        pass\n\n    # shut down SHM manager\n    try:\n        self._mgr.shutdown()\n    except Exception:\n        pass\n\n    # give worker a chance to exit, then kill it if needed\n    # This is MANDATORY. Unless we want zombies or race conditions running amock\n    try:\n        if self._proc is not None:\n            self._proc.join(timeout=5.0)\n            if self._proc.is_alive():\n                self._proc.terminate()\n                self._proc.join(timeout=5.0)\n    except Exception:\n        pass\n\n    self._closed = True\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._cleanup_all","title":"<code>_cleanup_all()</code>  <code>classmethod</code>","text":"<p>Atexit hook to shut down all live sessions.</p> <p>This is registered once for the class and iterates over a WeakSet of <code>RModuleSession</code> instances.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>@classmethod\ndef _cleanup_all(cls) -&gt; None:\n    \"\"\"\n    Atexit hook to shut down all live sessions.\n\n    This is registered once for the class and iterates over a WeakSet of\n    `RModuleSession` instances.\n    \"\"\"\n    for inst in list(cls._instances):\n        try:\n            inst.shutdown()\n        except Exception:\n            pass\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._encode_arg","title":"<code>_encode_arg(obj)</code>","text":"<p>Encode a single Python argument into an IPC payload dict.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Value to encode.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A JSON-serializable structure containing:</p> <ul> <li><code>codec</code>: registry codec id</li> <li><code>meta</code>: codec metadata</li> <li><code>buffers</code>: list of SHM block references (<code>name</code>, <code>size</code>)</li> </ul> Source code in <code>brmspy/_session/session.py</code> <pre><code>def _encode_arg(self, obj: Any) -&gt; PayloadRef:\n    \"\"\"\n    Encode a single Python argument into an IPC payload dict.\n\n    Parameters\n    ----------\n    obj : Any\n        Value to encode.\n\n    Returns\n    -------\n    dict[str, Any]\n        A JSON-serializable structure containing:\n\n        - `codec`: registry codec id\n        - `meta`: codec metadata\n        - `buffers`: list of SHM block references (`name`, `size`)\n    \"\"\"\n    enc = self._reg.encode(obj, self._shm_pool)\n    return {\n        \"codec\": enc.codec,\n        \"meta\": enc.meta,\n        \"buffers\": enc.buffers,\n    }\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._decode_result","title":"<code>_decode_result(resp)</code>","text":"<p>Decode a worker response into a Python value or raise.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>dict[str, Any]</code> <p>Response message from the worker.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Decoded Python object.</p> <p>Raises:</p> Type Description <code>RSessionError</code> <p>If <code>resp[\"ok\"]</code> is false. Includes best-effort remote traceback.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>def _decode_result(self, resp: Response) -&gt; Any:\n    \"\"\"\n    Decode a worker response into a Python value or raise.\n\n    Parameters\n    ----------\n    resp : dict[str, Any]\n        Response message from the worker.\n\n    Returns\n    -------\n    Any\n        Decoded Python object.\n\n    Raises\n    ------\n    brmspy.types.errors.RSessionError\n        If `resp[\"ok\"]` is false. Includes best-effort remote traceback.\n    \"\"\"\n    if not resp[\"ok\"]:\n        raise RSessionError(\n            resp.get(\"error\") or \"Worker error\",\n            remote_traceback=resp.get(\"traceback\"),\n        )\n    pres = resp[\"result\"]\n    if not pres:\n        return None\n    decoded = self._reg.decode(\n        pres,\n        shm_pool=self._shm_pool,\n    )\n    return decoded\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._call_remote","title":"<code>_call_remote(func_name, *args, **kwargs)</code>","text":"<p>Perform a remote call in the worker.</p> <p>Parameters:</p> Name Type Description Default <code>func_name</code> <code>str</code> <p>Function name or fully qualified target.</p> <ul> <li>If it starts with <code>\"mod:\"</code>, it is treated as a full worker target.</li> <li>Otherwise it is resolved as a function on <code>self._module_path</code>.</li> </ul> required <code>*args</code> <code>Any</code> <p>Call arguments, encoded via the session codec registry.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Call arguments, encoded via the session codec registry.</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p>Decoded return value.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the session has been shut down.</p> <code>RSessionError</code> <p>If the worker reports an error while executing the call.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>def _call_remote(self, func_name: str, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Perform a remote call in the worker.\n\n    Parameters\n    ----------\n    func_name : str\n        Function name or fully qualified target.\n\n        - If it starts with ``\"mod:\"``, it is treated as a full worker target.\n        - Otherwise it is resolved as a function on `self._module_path`.\n    *args, **kwargs\n        Call arguments, encoded via the session codec registry.\n\n    Returns\n    -------\n    Any\n        Decoded return value.\n\n    Raises\n    ------\n    RuntimeError\n        If the session has been shut down.\n    brmspy.types.errors.RSessionError\n        If the worker reports an error while executing the call.\n    \"\"\"\n    if self._closed:\n        raise RuntimeError(\"RModuleSession is closed\")\n\n    try:\n        if func_name.startswith(\"mod:\"):\n            target = func_name\n        else:\n            target = f\"mod:{self._module_path}.{func_name}\"\n\n        req_id = str(uuid.uuid4())\n        req: Request = {\n            \"id\": req_id,\n            \"cmd\": \"CALL\",\n            \"target\": target,\n            \"args\": [self._encode_arg(a) for a in args],\n            \"kwargs\": {k: self._encode_arg(v) for k, v in kwargs.items()},\n        }\n        self._conn.send(req)\n        resp = self._conn.recv()\n        decoded = self._decode_result(resp)\n\n        try:\n            # MUST be run after and never before decoding!\n            if self._shm_pool:\n                self._shm_pool.gc()\n        except:\n            pass\n\n        return decoded\n\n    except (BrokenPipeError, ConnectionResetError, EOFError) as e:\n        self._recover(e)\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._recover","title":"<code>_recover(orig_exc)</code>","text":"Source code in <code>brmspy/_session/session.py</code> <pre><code>def _recover(self, orig_exc: BaseException) -&gt; None:\n    logger = get_logger()\n\n    logger.warning(\n        \"R worker crashed; attempting to start a new session...\",\n        exc_info=orig_exc,\n    )\n\n    try:\n        # Best-effort shutdown; don't let this kill the recovery path\n        try:\n            self.shutdown()\n        except Exception:\n            logger.debug(\n                \"Failed to cleanly shut down crashed worker\",\n                exc_info=True,\n            )\n\n        # Restart must succeed or we bail\n        self.restart(autoload=False)\n\n    except Exception as restart_exc:\n        # Recovery itself failed\n        logger.error(\n            \"R worker crashed and automatic restart failed.\",\n            exc_info=restart_exc,\n        )\n        raise RWorkerCrashedError(\n            \"R worker crashed; failed to start new session.\",\n            recovered=False,\n            cause=restart_exc,\n        ) from restart_exc\n\n    # Recovery succeeded, but the *call* that hit this still failed\n    raise RWorkerCrashedError(\n        \"R worker crashed; started a fresh session. See __cause__ for details.\",\n        recovered=True,\n        cause=orig_exc,\n    ) from orig_exc\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession.__getattribute__","title":"<code>__getattribute__(name)</code>","text":"<p>Proxy attribute access for a module-like experience.</p> Rules <ul> <li>Internal attributes are handled locally.</li> <li>Callables found on the wrapped module are returned as wrappers that call into the worker.</li> <li>Non-callables are mirrored directly.</li> </ul> Source code in <code>brmspy/_session/session.py</code> <pre><code>def __getattribute__(self, name: str) -&gt; Any:\n    \"\"\"\n    Proxy attribute access for a module-like experience.\n\n    Rules\n    -----\n    - Internal attributes are handled locally.\n    - Callables found on the wrapped module are returned as wrappers that call into the worker.\n    - Non-callables are mirrored directly.\n    \"\"\"\n    # 1. Always allow access to internal attributes via base implementation\n    if name in _INTERNAL_ATTRS or name.startswith(\"__\") and name.endswith(\"__\"):\n        return ModuleType.__getattribute__(self, name)\n\n    # 2. If we already have a cached wrapper for this name, return it\n    func_cache = ModuleType.__getattribute__(self, \"_func_cache\")\n    if name in func_cache:\n        return func_cache[name]\n\n    module = ModuleType.__getattribute__(self, \"_module\")\n\n    # 3. If wrapped module has this attribute, decide what to do\n    if hasattr(module, name):\n        attr = getattr(module, name)\n\n        if callable(attr) and not inspect.isclass(attr):\n            # wrap callables so they run in worker\n            return self._get_or_create_wrapper(name, attr)\n\n        # non-callables (constants, types, etc.) are just mirrored\n        return attr\n\n    # 4. Fallback: use normal module attribute resolution\n    return ModuleType.__getattribute__(self, name)\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._get_or_create_wrapper","title":"<code>_get_or_create_wrapper(name, orig)</code>","text":"<p>Return a cached worker-calling wrapper for a callable attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name on the wrapped module.</p> required <code>orig</code> <code>Callable[..., Any]</code> <p>Original callable (used for metadata only).</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>Wrapper that performs an IPC roundtrip to execute the callable in the worker.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>def _get_or_create_wrapper(\n    self, name: str, orig: Callable[..., Any]\n) -&gt; Callable[..., Any]:\n    \"\"\"\n    Return a cached worker-calling wrapper for a callable attribute.\n\n    Parameters\n    ----------\n    name : str\n        Attribute name on the wrapped module.\n    orig : collections.abc.Callable[..., Any]\n        Original callable (used for metadata only).\n\n    Returns\n    -------\n    collections.abc.Callable[..., Any]\n        Wrapper that performs an IPC roundtrip to execute the callable in the worker.\n    \"\"\"\n    func_cache = ModuleType.__getattribute__(self, \"_func_cache\")\n    if name in func_cache:\n        return func_cache[name]\n\n    def wrapper(*args: Any, **kwargs: Any):\n        return self._call_remote(name, *args, **kwargs)\n\n    wrapper.__name__ = getattr(orig, \"__name__\", name)\n    wrapper.__doc__ = getattr(orig, \"__doc__\", None)\n    wrapper.__wrapped__ = orig  # type: ignore[attr-defined]\n\n    func_cache[name] = wrapper\n    return wrapper\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession.__dir__","title":"<code>__dir__()</code>","text":"<p>Expose the merged surface of the proxy and the wrapped module.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>def __dir__(self) -&gt; list[str]:\n    \"\"\"Expose the merged surface of the proxy and the wrapped module.\"\"\"\n    module = ModuleType.__getattribute__(self, \"_module\")\n    return sorted(set(self.__dict__) | set(dir(module)))\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession.shutdown","title":"<code>shutdown()</code>","text":"<p>Shut down the worker and related resources.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shut down the worker and related resources.\"\"\"\n    self._teardown_worker()\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession.__del__","title":"<code>__del__()</code>","text":"<p>Best-effort cleanup on GC; errors are suppressed.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Best-effort cleanup on GC; errors are suppressed.\"\"\"\n    try:\n        self.shutdown()\n    except Exception:\n        pass\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession.add_contextmanager","title":"<code>add_contextmanager(*, surface_class, surface_class_path)</code>","text":"<p>Attach a class-based \"surface\" API as a context manager factory.</p> <p>This is used to implement <code>brmspy.brms.manage()</code> and <code>brmspy.brms._build()</code> without exposing worker internals to the main process.</p> <p>Parameters:</p> Name Type Description Default <code>surface_class</code> <code>type</code> <p>Class whose <code>@staticmethod</code> members define the surface API available inside the context. Only staticmethod members are exposed.</p> required <code>surface_class_path</code> <code>str</code> <p>Fully qualified path like <code>\"pkg.module.ClassName\"</code> used for worker target resolution.</p> required <p>Returns:</p> Type Description <code>Callable[..., AbstractContextManager]</code> <p>Factory that produces a context manager. On enter it restarts the worker (autoload disabled) and yields a <code>ClassProxy</code> for the surface class.</p> Notes <ul> <li>Nesting contexts is forbidden; this is enforced via <code>self._active_ctx</code>.</li> <li>On exit, the selected environment config is persisted via the environment store.</li> </ul> Source code in <code>brmspy/_session/session.py</code> <pre><code>def add_contextmanager(\n    self,\n    *,\n    surface_class: type,\n    surface_class_path: str,\n):\n    \"\"\"\n    Attach a class-based \"surface\" API as a context manager factory.\n\n    This is used to implement `brmspy.brms.manage()` and `brmspy.brms._build()`\n    without exposing worker internals to the main process.\n\n    Parameters\n    ----------\n    surface_class : type\n        Class whose `@staticmethod` members define the surface API available inside\n        the context. Only staticmethod members are exposed.\n    surface_class_path : str\n        Fully qualified path like ``\"pkg.module.ClassName\"`` used for worker target\n        resolution.\n\n    Returns\n    -------\n    collections.abc.Callable[..., contextlib.AbstractContextManager]\n        Factory that produces a context manager. On enter it restarts the worker\n        (autoload disabled) and yields a `ClassProxy` for the surface class.\n\n    Notes\n    -----\n    - Nesting contexts is forbidden; this is enforced via `self._active_ctx`.\n    - On exit, the selected environment config is persisted via the environment store.\n    \"\"\"\n\n    session = self\n\n    if surface_class is None or surface_class_path is None:\n        raise ValueError(\"surface_class and surface_class_path must both be set.\")\n    if \".\" not in surface_class_path:\n        raise ValueError(\n            \"surface_class_path must look like 'pkg.module.ClassName'.\"\n        )\n\n    module_path, class_name = surface_class_path.rsplit(\".\", 1)\n    ctx_label = f\"{module_path}::{class_name}\"\n\n    class _Ctx:\n        def __init__(\n            self,\n            *,\n            environment_config: EnvironmentConfig | dict[str, str] | None = None,\n            environment_name: str | None = None,\n        ) -&gt; None:\n            self._environment_config = environment_config\n            self._environment_name = environment_name\n            self._new_conf: EnvironmentConfig | None = None\n\n        def __enter__(self):\n            if session._active_ctx is not None:\n                raise RuntimeError(\n                    f\"Nested brmspy contexts are not supported \"\n                    f\"(active={session._active_ctx!r}, new={ctx_label!r}).\"\n                )\n            try:\n                session._active_ctx = ctx_label\n\n                if self._environment_name and self._environment_config:\n                    session._active_ctx = None\n                    raise Exception(\n                        \"Only provide one: environment name or environment config\"\n                    )\n\n                if not self._environment_name and self._environment_config:\n                    overrides = EnvironmentConfig.from_obj(self._environment_config)\n                elif self._environment_name:\n                    overrides = get_environment_config(self._environment_name)\n                else:\n                    overrides = None\n\n                old_conf = session._environment_conf\n                new_conf = overrides if overrides else old_conf\n                self._new_conf = new_conf\n\n                # fresh worker with new_conf\n                session.restart(environment_conf=new_conf, autoload=False)\n\n                return ClassProxy(\n                    session=session,\n                    surface_class=surface_class,\n                    module_path=module_path,\n                    class_name=class_name,\n                )\n            except Exception as e:\n                session._active_ctx = None\n                raise e\n\n        def __exit__(self, exc_type, exc, tb) -&gt; None:\n            try:\n                if self._new_conf is not None:\n                    save(self._new_conf)\n                    save_as_state(self._new_conf)\n            finally:\n                session._active_ctx = None\n            return None\n\n    def factory(\n        *,\n        environment_config: EnvironmentConfig | dict[str, str] | None = None,\n        environment_name: str | None = None,\n    ):\n        return _Ctx(\n            environment_config=environment_config, environment_name=environment_name\n        )\n\n    return factory\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession.restart","title":"<code>restart(environment_conf=None, autoload=True)</code>","text":"<p>Restart the worker process and SHM manager.</p> <p>Parameters:</p> Name Type Description Default <code>environment_conf</code> <code>dict[str, Any] | EnvironmentConfig | None</code> <p>If provided, replaces the existing environment configuration for the new worker.</p> <code>None</code> <code>autoload</code> <code>bool</code> <p>Whether to enable autoload for the new worker process.</p> <code>True</code> Notes <p>This tears down the existing worker and starts a new one. Any previously returned R object wrappers are no longer reattachable after restart.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>def restart(\n    self,\n    environment_conf: dict[str, Any] | EnvironmentConfig | None = None,\n    autoload: bool = True,\n    # empty_shm: bool = False,\n) -&gt; None:\n    \"\"\"\n    Restart the worker process and SHM manager.\n\n    Parameters\n    ----------\n    environment_conf : dict[str, Any] | brmspy.types.session.EnvironmentConfig | None\n        If provided, replaces the existing environment configuration for the new worker.\n    autoload : bool, default=True\n        Whether to enable autoload for the new worker process.\n\n    Notes\n    -----\n    This tears down the existing worker and starts a new one. Any previously\n    returned R object wrappers are no longer reattachable after restart.\n    \"\"\"\n    if environment_conf is not None:\n        self._environment_conf = EnvironmentConfig.from_obj(environment_conf)\n\n    # Tear down existing worker (if any)\n    self._teardown_worker()\n\n    self._func_cache.clear()\n\n    # Start a fresh worker with current env conf\n    self._setup_worker(autoload=autoload)\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession.environment_exists","title":"<code>environment_exists(name)</code>","text":"<p>Check whether an environment with the given name exists on disk.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Environment name.</p> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>brmspy/_session/session.py</code> <pre><code>def environment_exists(self, name: str) -&gt; bool:\n    \"\"\"\n    Check whether an environment with the given name exists on disk.\n\n    Parameters\n    ----------\n    name : str\n        Environment name.\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return get_environment_exists(name)\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession.environment_activate","title":"<code>environment_activate(name)</code>","text":"<p>Activate an environment by restarting the worker through <code>manage()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Environment name to activate.</p> required Notes <p>This is a convenience helper used by tests and developer flows.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>def environment_activate(self, name: str) -&gt; None:\n    \"\"\"\n    Activate an environment by restarting the worker through `manage()`.\n\n    Parameters\n    ----------\n    name : str\n        Environment name to activate.\n\n    Notes\n    -----\n    This is a convenience helper used by tests and developer flows.\n    \"\"\"\n    manage = self.manage\n    if manage:\n        with manage(environment_name=name) as ctx:\n            pass\n    else:\n        raise Exception(\"Invalid state. manage is not defined!\")\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.RModuleSession._run_test_by_name","title":"<code>_run_test_by_name(module_path, class_name, func_name)</code>","text":"<p>Run a test identified by module/class/function inside the worker.</p> <p>Parameters:</p> Name Type Description Default <code>module_path</code> <code>str</code> <p>Importable module path (e.g. <code>\"tests.test_file\"</code>).</p> required <code>class_name</code> <code>str | None</code> <p>Optional class name if the test is a method.</p> required <code>func_name</code> <code>str</code> <p>Test function/method name.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Decoded return value from the test function.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>BRMSPY_TEST=1</code> is not set.</p> <code>RSessionError</code> <p>If the worker reports a failure.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>def _run_test_by_name(\n    self, module_path: str, class_name: str | None, func_name: str\n) -&gt; Any:\n    \"\"\"\n    Run a test identified by module/class/function inside the worker.\n\n    Parameters\n    ----------\n    module_path : str\n        Importable module path (e.g. ``\"tests.test_file\"``).\n    class_name : str | None\n        Optional class name if the test is a method.\n    func_name : str\n        Test function/method name.\n\n    Returns\n    -------\n    Any\n        Decoded return value from the test function.\n\n    Raises\n    ------\n    RuntimeError\n        If `BRMSPY_TEST=1` is not set.\n    brmspy.types.errors.RSessionError\n        If the worker reports a failure.\n    \"\"\"\n    if os.getenv(\"BRMSPY_TEST\") != \"1\":\n        raise RuntimeError(\"BRMSPY_TEST=1 required for worker test execution\")\n    if self._closed:\n        raise RuntimeError(\"Connection not open! Cant run test.\")\n\n    req_id = str(uuid.uuid4())\n    self._conn.send(\n        {\n            \"id\": req_id,\n            \"cmd\": \"_RUN_TEST_BY_NAME\",\n            \"target\": \"\",\n            \"args\": [],\n            \"kwargs\": {\n                \"module\": module_path,\n                \"class\": class_name,\n                \"func\": func_name,\n            },\n        }\n    )\n\n    resp = self._conn.recv()\n\n    if not resp.get(\"ok\", False):\n        raise RSessionError(\n            resp.get(\"error\", \"Worker test failed\"),\n            remote_traceback=resp.get(\"traceback\"),\n        )\n\n    pres = resp[\"result\"]\n\n    return self._reg.decode(\n        pres,\n        shm_pool=self._shm_pool,\n    )\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session-functions","title":"Functions","text":""},{"location":"internals/_session/session/#brmspy._session.session.get_environment_config","title":"<code>get_environment_config(name)</code>","text":"<p>Load an environment configuration from disk.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Environment name.</p> required <p>Returns:</p> Type Description <code>EnvironmentConfig</code> <p>Loaded configuration. If no config file exists, returns a default config with <code>environment_name=name</code>.</p> Source code in <code>brmspy/_session/environment.py</code> <pre><code>def get_environment_config(name: str) -&gt; EnvironmentConfig:\n    \"\"\"\n    Load an environment configuration from disk.\n\n    Parameters\n    ----------\n    name : str\n        Environment name.\n\n    Returns\n    -------\n    brmspy.types.session.EnvironmentConfig\n        Loaded configuration. If no config file exists, returns a default config\n        with `environment_name=name`.\n    \"\"\"\n    base_dir = get_environment_base_dir()\n    env_dir = base_dir / name\n    config_dir = env_dir / \"config.json\"\n\n    if not config_dir.exists():\n        return EnvironmentConfig(environment_name=name)\n\n    with open(config_dir) as f:\n        data = json.load(f)\n        return EnvironmentConfig.from_dict(data)\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.get_environment_exists","title":"<code>get_environment_exists(name)</code>","text":"<p>Return True if an environment exists (determined by presence of <code>config.json</code>).</p> Source code in <code>brmspy/_session/environment.py</code> <pre><code>def get_environment_exists(name: str) -&gt; bool:\n    \"\"\"\n    Return True if an environment exists (determined by presence of `config.json`).\n    \"\"\"\n    base_dir = get_environment_base_dir()\n    env_dir = base_dir / name\n    config_dir = env_dir / \"config.json\"\n\n    return config_dir.exists()\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.save","title":"<code>save(env_conf)</code>","text":"<p>Persist an environment configuration and ensure the directory structure exists.</p> <p>Parameters:</p> Name Type Description Default <code>env_conf</code> <code>EnvironmentConfig</code> <p>Environment configuration to write.</p> required Source code in <code>brmspy/_session/environment_parent.py</code> <pre><code>def save(env_conf: EnvironmentConfig) -&gt; None:\n    \"\"\"\n    Persist an environment configuration and ensure the directory structure exists.\n\n    Parameters\n    ----------\n    env_conf : brmspy.types.session.EnvironmentConfig\n        Environment configuration to write.\n    \"\"\"\n    base_dir = get_environment_base_dir()\n    env_dir = base_dir / env_conf.environment_name\n    env_rlib_dir = get_environment_userlibs_dir(name=env_conf.environment_name)\n    config_dir = env_dir / \"config.json\"\n    os.makedirs(env_dir, exist_ok=True)\n    os.makedirs(env_rlib_dir, exist_ok=True)\n\n    if \"BRMSPY_AUTOLOAD\" in env_conf.env:\n        del env_conf.env[\"BRMSPY_AUTOLOAD\"]\n\n    with open(config_dir, \"w\", encoding=\"utf-8\") as f:\n        json.dump(env_conf.to_dict(), f, indent=2, ensure_ascii=False)\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.save_as_state","title":"<code>save_as_state(env_conf)</code>","text":"<p>Record the active environment name in <code>environment_state.json</code>.</p> <p>Parameters:</p> Name Type Description Default <code>env_conf</code> <code>EnvironmentConfig</code> <p>Environment configuration whose name should be recorded.</p> required Source code in <code>brmspy/_session/environment_parent.py</code> <pre><code>def save_as_state(env_conf: EnvironmentConfig) -&gt; None:\n    \"\"\"\n    Record the active environment name in `environment_state.json`.\n\n    Parameters\n    ----------\n    env_conf : brmspy.types.session.EnvironmentConfig\n        Environment configuration whose name should be recorded.\n    \"\"\"\n    state_path = get_environments_state_path()\n    with open(state_path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(\n            {\"active\": env_conf.environment_name}, f, indent=2, ensure_ascii=False\n        )\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.get_logger","title":"<code>get_logger()</code>","text":"<p>Get or create the brmspy logger instance.</p> <p>Returns a configured logger with a custom formatter that outputs messages in the format: <code>[brmspy][method_name] msg here</code></p> <p>Returns:</p> Type Description <code>Logger</code> <p>Configured brmspy logger instance</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy.helpers.log import get_logger\n&gt;&gt;&gt; logger = get_logger()\n&gt;&gt;&gt; logger.info(\"Starting process\")  # Prints: [brmspy][&lt;module&gt;] Starting process\n</code></pre> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def get_logger() -&gt; logging.Logger:\n    \"\"\"\n    Get or create the brmspy logger instance.\n\n    Returns a configured logger with a custom formatter that outputs\n    messages in the format: `[brmspy][method_name] msg here`\n\n    Returns\n    -------\n    logging.Logger\n        Configured brmspy logger instance\n\n    Examples\n    --------\n    &gt;&gt;&gt; from brmspy.helpers.log import get_logger\n    &gt;&gt;&gt; logger = get_logger()\n    &gt;&gt;&gt; logger.info(\"Starting process\")  # Prints: [brmspy][&lt;module&gt;] Starting process\n    \"\"\"\n    global _logger\n\n    if _logger is None:\n        _logger = logging.getLogger(\"brmspy\")\n        _logger.setLevel(logging.INFO)\n\n        if not _logger.handlers:\n            # Handler for \"normal\" logs\n            normal_handler = logging.StreamHandler()\n            normal_handler.setFormatter(BrmspyFormatter())\n            normal_handler.addFilter(NonPrintFilter())\n            _logger.addHandler(normal_handler)\n\n            # print logs: preserve control chars and explicit \\n/\\r\n            print_handler = logging.StreamHandler()\n            print_handler.setFormatter(logging.Formatter(\"%(message)s\"))\n            print_handler.addFilter(PrintOnlyFilter())\n            print_handler.terminator = \"\"\n            _logger.addHandler(print_handler)\n\n        if _running_under_pytest():\n            _logger.propagate = True\n        else:\n            _logger.propagate = False\n\n    return _logger\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.get_default_registry","title":"<code>get_default_registry()</code>","text":"<p>Return the process-global default codec registry.</p> <p>Returns:</p> Type Description <code>CodecRegistry</code> <p>Registry with SHM-first codecs registered, plus a pickle fallback.</p> Source code in <code>brmspy/_session/codec/registry.py</code> <pre><code>def get_default_registry() -&gt; CodecRegistry:\n    \"\"\"\n    Return the process-global default codec registry.\n\n    Returns\n    -------\n    brmspy._session.codec.base.CodecRegistry\n        Registry with SHM-first codecs registered, plus a pickle fallback.\n    \"\"\"\n    global _default_registry\n    if _default_registry is None:\n        reg = CodecRegistry()\n        reg.register(NumpyArrayCodec())\n        reg.register(InferenceDataCodec())\n        reg.register(PandasDFCodec())\n\n        register_dataclasses(reg)\n\n        # MUST BE LAST\n        reg.register(PickleCodec())\n\n        _default_registry = reg\n    return _default_registry\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.worker_main","title":"<code>worker_main(conn, mgr_address, mgr_authkey, runtime_conf, log_queue)</code>","text":"<p>Worker entrypoint.</p> <ul> <li>Connects to the already-running SharedMemoryManager (started in parent)</li> <li>Optionally configures R env via <code>runtime_conf</code></li> <li>Receives CALL/SHUTDOWN commands over <code>conn</code></li> <li>Executes Python functions in modules inside this worker.   Those modules are free to use rpy2 / brms / cmdstanr however they like.</li> </ul> Source code in <code>brmspy/_session/worker/worker.py</code> <pre><code>def worker_main(\n    conn: Connection,\n    mgr_address: str | None,\n    mgr_authkey: bytes | None,\n    runtime_conf: EnvironmentConfig,\n    log_queue: mp.Queue,\n) -&gt; None:\n    \"\"\"\n    Worker entrypoint.\n\n    - Connects to the already-running SharedMemoryManager (started in parent)\n    - Optionally configures R env via `runtime_conf`\n    - Receives CALL/SHUTDOWN commands over `conn`\n    - Executes *Python* functions in modules inside this worker.\n      Those modules are free to use rpy2 / brms / cmdstanr however they like.\n    \"\"\"\n\n    setup_worker_logging(log_queue)\n\n    import os\n\n    os.environ[\"BRMSPY_WORKER\"] = \"1\"\n\n    _initialise_r_safe()\n\n    # 1. Connect to SHM manager\n    smm = SharedMemoryManager(address=mgr_address, authkey=mgr_authkey, ctx=ctx)\n    smm.connect()\n\n    # 2. Optional environment init (R_HOME, R_LIBS_USER, etc.)\n    activate(runtime_conf)\n    run_startup_scripts(runtime_conf)\n\n    shm_pool = ShmPool(smm)\n    reg = get_default_registry()\n\n    module_cache: dict[str, Any] = {}\n\n    import rpy2.rinterface_lib.callbacks\n    from rpy2.rinterface_lib.sexp import Sexp\n\n    rpy2.rinterface_lib.callbacks._WRITECONSOLE_EXCEPTION_LOG = (\n        \"[R]: {exception} {exc_value} {traceback}\"\n    )\n\n    from ..._singleton._shm_singleton import _set_shm\n\n    _set_shm(shm_pool)\n\n    try:\n        while True:\n            req = conn.recv()\n            cmd = req[\"cmd\"]\n            req_id = req[\"id\"]\n\n            shm_pool.gc()\n\n            try:\n                if cmd == \"SHUTDOWN\":\n                    conn.send(\n                        {\n                            \"id\": req_id,\n                            \"ok\": True,\n                            \"result\": None,\n                            \"error\": None,\n                            \"traceback\": None,\n                        }\n                    )\n                    break\n\n                elif cmd == \"PING\":\n                    conn.send(\n                        {\n                            \"id\": req_id,\n                            \"ok\": True,\n                            \"result\": None,\n                            \"error\": None,\n                            \"traceback\": None,\n                        }\n                    )\n                    continue\n\n                elif cmd == \"CALL\":\n                    # decode Python args\n                    args = [reg.decode(p, shm_pool=shm_pool) for p in req[\"args\"]]\n                    kwargs = {\n                        k: reg.decode(p, shm_pool=shm_pool)\n                        for k, p in req[\"kwargs\"].items()\n                    }\n                    args: list[Any] = reattach_sexp(args)\n                    kwargs: dict[str, Any] = reattach_sexp(kwargs)\n\n                    # resolve \"mod:pkg.module.func\"\n                    target = _resolve_module_target(req[\"target\"], module_cache)\n                    out = target(*args, **kwargs)\n                    out = cache_sexp(out)\n\n                    # encode result\n                    enc = reg.encode(out, shm_pool)\n                    result_payload: PayloadRef = {\n                        \"codec\": enc.codec,\n                        \"meta\": enc.meta,\n                        \"buffers\": enc.buffers,\n                    }\n\n                    conn.send(\n                        {\n                            \"id\": req_id,\n                            \"ok\": True,\n                            \"result\": result_payload,\n                            \"error\": None,\n                            \"traceback\": None,\n                        }\n                    )\n\n                elif cmd == \"_RUN_TEST_BY_NAME\":\n                    module = req[\"kwargs\"][\"module\"]\n                    classname = req[\"kwargs\"][\"class\"]\n                    funcname = req[\"kwargs\"][\"func\"]\n\n                    try:\n                        mod = importlib.import_module(module)\n\n                        if classname:\n                            cls = getattr(mod, classname)\n                            inst = cls()\n                            fn = getattr(inst, funcname)\n                        else:\n                            fn = getattr(mod, funcname)\n\n                        result = fn()\n\n                        enc = reg.encode(result, shm_pool)\n                        conn.send(\n                            {\n                                \"id\": req_id,\n                                \"ok\": True,\n                                \"result\": {\n                                    \"codec\": enc.codec,\n                                    \"meta\": enc.meta,\n                                    \"buffers\": enc.buffers,\n                                },\n                                \"error\": None,\n                                \"traceback\": None,\n                            }\n                        )\n\n                    except Exception as e:\n                        import traceback\n\n                        conn.send(\n                            {\n                                \"id\": req_id,\n                                \"ok\": False,\n                                \"result\": None,\n                                \"error\": str(e),\n                                \"traceback\": traceback.format_exc(),\n                            }\n                        )\n\n                else:\n                    raise ValueError(f\"Unknown command: {cmd!r}\")\n\n            except RRuntimeError as e:\n                import traceback\n                import rpy2.robjects as ro\n\n                tb = \"\".join(traceback.format_exception(type(e), e, e.__traceback__))\n                full_msg = str(e)\n\n                ignore_msgs = [\"Can't show last error because no error was recorded\"]\n\n                try:\n\n                    # traceback() prints and returns a pairlist -&gt; coerce to something nice\n                    r_tb = \"\\n\".join(\n                        list(\n                            str(v)\n                            for v in cast(ro.ListVector, ro.r(\"unlist(traceback())\"))\n                        )\n                    )\n                    tb = r_tb\n                except Exception as tb_exc:\n                    pass\n\n                # Full base R error message\n                try:\n                    # full rlang error message (can be multi-line, with bullets etc.)\n                    _msg = str(\n                        cast(\n                            ro.ListVector,\n                            ro.r(\"rlang::format_error_bullets(rlang::last_error())\"),\n                        )[0]\n                    )\n                    if _msg and not any(part in _msg for part in ignore_msgs):\n                        full_msg = _msg\n                    else:\n                        raise\n                except Exception:\n                    # fallback to base R\n                    try:\n                        _msg = str(cast(ro.ListVector, ro.r(\"geterrmessage()\"))[0])\n                        if _msg and not any(part in _msg for part in ignore_msgs):\n                            full_msg = _msg\n                        else:\n                            raise\n                    except Exception:\n                        pass\n\n                conn.send(\n                    {\n                        \"id\": req_id,\n                        \"ok\": False,\n                        \"result\": None,\n                        \"error\": str(full_msg),\n                        \"traceback\": tb,\n                    }\n                )\n\n            except Exception as e:\n                import traceback\n\n                tb = \"\".join(traceback.format_exception(type(e), e, e.__traceback__))\n                conn.send(\n                    {\n                        \"id\": req_id,\n                        \"ok\": False,\n                        \"result\": None,\n                        \"error\": str(e),\n                        \"traceback\": tb,\n                    }\n                )\n    finally:\n        pass\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.r_home_from_subprocess","title":"<code>r_home_from_subprocess()</code>","text":"<p>Return the R home directory by calling <code>R RHOME</code> in a subprocess.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>def r_home_from_subprocess() -&gt; str | None:\n    \"\"\"Return the R home directory by calling `R RHOME` in a subprocess.\"\"\"\n    cmd = (\"R\", \"RHOME\")\n    tmp = subprocess.check_output(cmd, universal_newlines=True)\n    # may raise FileNotFoundError, WindowsError, etc\n    r_home = tmp.split(os.linesep)\n    if r_home[0].startswith(\"WARNING\"):\n        res = r_home[1]\n    else:\n        res = r_home[0].strip()\n    return res\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.add_env_defaults","title":"<code>add_env_defaults(overrides)</code>","text":"<p>Ensure required R environment variables exist inside overrides. Mutates overrides in-place and returns it.</p> <ul> <li>Ensures R_HOME exists (or auto-detects)</li> <li>Ensures LD_LIBRARY_PATH includes R_HOME/lib (Unix only)</li> </ul> Source code in <code>brmspy/_session/session.py</code> <pre><code>def add_env_defaults(overrides: dict[str, str]) -&gt; dict[str, str]:\n    \"\"\"\n    Ensure required R environment variables exist inside overrides.\n    Mutates overrides in-place and returns it.\n\n    - Ensures R_HOME exists (or auto-detects)\n    - Ensures LD_LIBRARY_PATH includes R_HOME/lib (Unix only)\n    \"\"\"\n    # ---------------------------------------------------------\n    # 1) R_HOME detection / override handling\n    # ---------------------------------------------------------\n    if \"R_HOME\" not in overrides:\n        r_home = r_home_from_subprocess()\n        if not r_home:\n            raise RuntimeError(\n                \"`R_HOME` not provided and cannot auto-detect via subprocess. \"\n                \"R must be installed or explicitly configured.\"\n            )\n        r_home_path = Path(r_home)\n        overrides[\"R_HOME\"] = r_home_path.as_posix()\n    else:\n        r_home_path = Path(overrides[\"R_HOME\"])\n\n    # ---------------------------------------------------------\n    # 2) LD_LIBRARY_PATH for Unix-like systems\n    # ---------------------------------------------------------\n    if platform.system() != \"Windows\":\n        r_lib_dir = (r_home_path / \"lib\").as_posix()\n\n        if \"LD_LIBRARY_PATH\" not in overrides:\n            # Take current LD_LIBRARY_PATH from environment\n            current = os.environ.get(\"LD_LIBRARY_PATH\", \"\")\n        else:\n            current = overrides[\"LD_LIBRARY_PATH\"]\n\n        # Split into entries (ignore empty ones)\n        existing_parts = [p for p in current.split(\":\") if p]\n\n        # Prepend R_HOME/lib if not already present\n        if r_lib_dir not in existing_parts:\n            new_ld = \":\".join([r_lib_dir] + existing_parts)\n        else:\n            new_ld = current  # already included\n\n        overrides[\"LD_LIBRARY_PATH\"] = new_ld\n\n    if \"RPY2_CFFI_MODE\" not in overrides:\n        overrides[\"RPY2_CFFI_MODE\"] = \"ABI\"\n\n    # ---------------------------------------------------------\n    return overrides\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.with_env","title":"<code>with_env(overrides)</code>","text":"<p>Temporarily apply environment overrides, then restore.</p> Source code in <code>brmspy/_session/session.py</code> <pre><code>@contextmanager\ndef with_env(overrides: dict[str, str]) -&gt; Iterator[None]:\n    \"\"\"Temporarily apply environment overrides, then restore.\"\"\"\n    overrides = add_env_defaults(overrides)\n\n    old = {}\n    sentinel = object()\n\n    for k, v in overrides.items():\n        old[k] = os.environ.get(k, sentinel)\n        os.environ[k] = v\n\n    try:\n        yield\n    finally:\n        for k, v_old in old.items():\n            if v_old is sentinel:\n                os.environ.pop(k, None)\n            else:\n                os.environ[k] = v_old\n</code></pre>"},{"location":"internals/_session/session/#brmspy._session.session.spawn_worker","title":"<code>spawn_worker(target, args, env_overrides, log_queue=None)</code>","text":"<p>Spawn the worker process with temporary environment overrides.</p> Notes <ul> <li>brmspy uses spawn semantics (see <code>ctx = mp.get_context(\"spawn\")</code>).</li> <li>The worker receives the log queue as an extra trailing argument when present.</li> </ul> Source code in <code>brmspy/_session/session.py</code> <pre><code>def spawn_worker(\n    target, args, env_overrides: dict[str, str], log_queue: mp.Queue | None = None\n):\n    \"\"\"\n    Spawn the worker process with temporary environment overrides.\n\n    Notes\n    -----\n    - brmspy uses spawn semantics (see `ctx = mp.get_context(\"spawn\")`).\n    - The worker receives the log queue as an extra trailing argument when present.\n    \"\"\"\n    with with_env(env_overrides):\n        daemon = os.environ.get(\"BRMSPY_TEST\") != \"1\" and not os.environ.get(\n            \"COVERAGE_PROCESS_START\"\n        )\n        daemon = True\n        if log_queue is not None:\n            args = (*args, log_queue)\n        proc = ctx.Process(target=target, args=args, daemon=daemon)\n        proc.start()\n    return proc\n</code></pre>"},{"location":"internals/_session/transport/","title":"transport","text":"<p>Shared-memory transport utilities (internal).</p> <p><code>RModuleSession</code> uses shared memory to move large payloads between main and worker. The parent allocates blocks and passes only <code>(name, size)</code> references over the Pipe. The worker (or the main process during decode) attaches by name to access buffers.</p> <p>This module implements the concrete <code>ShmPool</code> used by the session layer.</p>"},{"location":"internals/_session/transport/#brmspy._session.transport-classes","title":"Classes","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmRef","title":"<code>ShmRef</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Reference to a shared-memory block sent over IPC.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Shared memory block name (as assigned by <code>SharedMemoryManager</code>).</p> <code>size</code> <code>int</code> <p>Allocated block size in bytes.</p> <code>content_size</code> <code>int</code> <p>Actual used size</p> <code>temporary</code> <code>bool</code> <p>Whether this buffer can be GC-d immediately after use or should it be attached to object its constructed into.</p> Notes <p>Codecs may store a logical payload smaller than <code>size</code>. In that case, the codec metadata must include the logical <code>nbytes</code>/length so that decoders can slice the buffer appropriately.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>class ShmRef(TypedDict):\n    \"\"\"\n    Reference to a shared-memory block sent over IPC.\n\n    Attributes\n    ----------\n    name : str\n        Shared memory block name (as assigned by `SharedMemoryManager`).\n    size : int\n        Allocated block size in bytes.\n    content_size : int\n        Actual used size\n    temporary : bool\n        Whether this buffer can be GC-d immediately after use or should it be attached to object its constructed into.\n\n    Notes\n    -----\n    Codecs may store a logical payload smaller than `size`. In that case, the\n    codec metadata must include the logical `nbytes`/length so that decoders can\n    slice the buffer appropriately.\n    \"\"\"\n\n    name: str\n    size: int\n    content_size: int\n    temporary: bool\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport.ShmRef-attributes","title":"Attributes","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmRef.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmRef.size","title":"<code>size</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmRef.content_size","title":"<code>content_size</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmRef.temporary","title":"<code>temporary</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmBlock","title":"<code>ShmBlock</code>  <code>dataclass</code>","text":"<p>Attached shared-memory block (name/size + live <code>SharedMemory</code> handle).</p> Notes <p>This object owns a <code>SharedMemory</code> handle and must be closed when no longer needed. In brmspy this is managed by a <code>ShmPool</code> implementation.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>@dataclass\nclass ShmBlock:\n    \"\"\"\n    Attached shared-memory block (name/size + live `SharedMemory` handle).\n\n    Notes\n    -----\n    This object owns a `SharedMemory` handle and must be closed when no longer\n    needed. In brmspy this is managed by a `ShmPool` implementation.\n    \"\"\"\n\n    name: str\n    size: int\n    content_size: int\n    shm: SharedMemory\n    temporary: bool\n\n    def to_ref(self) -&gt; ShmRef:\n        return {\n            \"name\": self.name,\n            \"size\": self.size,\n            \"content_size\": self.content_size,\n            \"temporary\": self.temporary,\n        }\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport.ShmBlock-attributes","title":"Attributes","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmBlock.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmBlock.size","title":"<code>size</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmBlock.content_size","title":"<code>content_size</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmBlock.shm","title":"<code>shm</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmBlock.temporary","title":"<code>temporary</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmBlock-functions","title":"Functions","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmBlock.to_ref","title":"<code>to_ref()</code>","text":"Source code in <code>brmspy/types/shm.py</code> <pre><code>def to_ref(self) -&gt; ShmRef:\n    return {\n        \"name\": self.name,\n        \"size\": self.size,\n        \"content_size\": self.content_size,\n        \"temporary\": self.temporary,\n    }\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport.ShmBlock.__init__","title":"<code>__init__(name, size, content_size, shm, temporary)</code>","text":""},{"location":"internals/_session/transport/#brmspy._session.transport._ShmPool","title":"<code>_ShmPool</code>","text":"<p>Minimal interface for allocating and attaching shared-memory blocks.</p> <p>The concrete implementation lives in <code>brmspy._session.transport.ShmPool</code> and tracks blocks so they can be closed on teardown.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>class ShmPool:\n    \"\"\"\n    Minimal interface for allocating and attaching shared-memory blocks.\n\n    The concrete implementation lives in\n    [`brmspy._session.transport.ShmPool`][brmspy._session.transport.ShmPool] and tracks\n    blocks so they can be closed on teardown.\n    \"\"\"\n\n    def __init__(self, manager: SharedMemoryManager) -&gt; None:\n        \"\"\"\n        Create a pool bound to an existing `SharedMemoryManager`.\n\n        Parameters\n        ----------\n        manager : multiprocessing.managers.SharedMemoryManager\n            Manager used to allocate blocks.\n        \"\"\"\n        ...\n\n    def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n        \"\"\"\n        Allocate a new shared-memory block.\n\n        Parameters\n        ----------\n        size : int\n            Size in bytes.\n\n        Returns\n        -------\n        ShmBlock\n            Newly allocated block.\n        \"\"\"\n        ...\n\n    def attach(self, ref: ShmRef) -&gt; ShmBlock:\n        \"\"\"\n        Attach to an existing shared-memory block by name.\n\n        Returns\n        -------\n        ShmBlock\n            Attached block.\n        \"\"\"\n        ...\n\n    def close_all(self) -&gt; None:\n        \"\"\"\n        Close all tracked shared-memory handles owned by this pool.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        ...\n\n    def gc(self, name: str | None = None) -&gt; None: ...\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport._ShmPool-functions","title":"Functions","text":""},{"location":"internals/_session/transport/#brmspy._session.transport._ShmPool.__init__","title":"<code>__init__(manager)</code>","text":"<p>Create a pool bound to an existing <code>SharedMemoryManager</code>.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SharedMemoryManager</code> <p>Manager used to allocate blocks.</p> required Source code in <code>brmspy/types/shm.py</code> <pre><code>def __init__(self, manager: SharedMemoryManager) -&gt; None:\n    \"\"\"\n    Create a pool bound to an existing `SharedMemoryManager`.\n\n    Parameters\n    ----------\n    manager : multiprocessing.managers.SharedMemoryManager\n        Manager used to allocate blocks.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport._ShmPool.alloc","title":"<code>alloc(size, temporary=False)</code>","text":"<p>Allocate a new shared-memory block.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size in bytes.</p> required <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Newly allocated block.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n    \"\"\"\n    Allocate a new shared-memory block.\n\n    Parameters\n    ----------\n    size : int\n        Size in bytes.\n\n    Returns\n    -------\n    ShmBlock\n        Newly allocated block.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport._ShmPool.attach","title":"<code>attach(ref)</code>","text":"<p>Attach to an existing shared-memory block by name.</p> <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Attached block.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>def attach(self, ref: ShmRef) -&gt; ShmBlock:\n    \"\"\"\n    Attach to an existing shared-memory block by name.\n\n    Returns\n    -------\n    ShmBlock\n        Attached block.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport._ShmPool.close_all","title":"<code>close_all()</code>","text":"<p>Close all tracked shared-memory handles owned by this pool.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>brmspy/types/shm.py</code> <pre><code>def close_all(self) -&gt; None:\n    \"\"\"\n    Close all tracked shared-memory handles owned by this pool.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport._ShmPool.gc","title":"<code>gc(name=None)</code>","text":"Source code in <code>brmspy/types/shm.py</code> <pre><code>def gc(self, name: str | None = None) -&gt; None: ...\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport.ShmPool","title":"<code>ShmPool</code>","text":"<p>               Bases: <code>ShmPool</code></p> <p>Concrete shared-memory pool implementation that temporarily tracks attached blocks.</p> <p>_blocks dict keeps references to shm buffers TEMPORARILY and is cleaned up before each 'responding to main' or 'sending new message to worker'. This allows the in-between processing of shm buffers to rely on the buffers not being garbage collected.</p> <p>After reconstructing an object from a shm buffer, it's the CodecRegistrys role to take over the reference by initiating a weakref between the reconstructed object and buffer (or skipping if the object is temporary).</p> <p>This helps ensure that a minimal amount of shm buffers are actively mapped and garbage collection can remove file descriptors no longer needed.</p> Source code in <code>brmspy/_session/transport.py</code> <pre><code>class ShmPool(_ShmPool):\n    \"\"\"\n    Concrete shared-memory pool implementation that temporarily tracks attached blocks.\n\n    _blocks dict keeps references to shm buffers TEMPORARILY and is cleaned up\n    before each 'responding to main' or 'sending new message to worker'. This\n    allows the in-between processing of shm buffers to rely on the buffers not\n    being garbage collected.\n\n    After reconstructing an object from a shm buffer, it's the CodecRegistrys role\n    to take over the reference by initiating a weakref between the reconstructed\n    object and buffer (or skipping if the object is temporary).\n\n    This helps ensure that a minimal amount of shm buffers are actively mapped\n    and garbage collection can remove file descriptors no longer needed.\n    \"\"\"\n\n    def __init__(self, manager: SharedMemoryManager) -&gt; None:\n        self._manager = manager\n        self._blocks: dict[str, ShmBlock] = {}\n\n    def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n        # print(f\"alloc {'temp' if temporary else ''}\")\n        shm = self._manager.SharedMemory(size=size)\n        block = ShmBlock(\n            name=shm.name,\n            size=shm.size,\n            shm=shm,\n            content_size=size,\n            temporary=temporary,\n        )\n        self._blocks[block.name] = block\n        return block\n\n    def attach(self, ref: ShmRef) -&gt; ShmBlock:\n        if ref[\"name\"] in self._blocks:\n            return self._blocks[ref[\"name\"]]\n        shm = SharedMemory(name=ref[\"name\"])\n        block = ShmBlock(\n            name=ref[\"name\"],\n            size=ref[\"size\"],\n            shm=shm,\n            content_size=ref[\"content_size\"],\n            temporary=ref[\"temporary\"],\n        )\n        self._blocks[ref[\"name\"]] = block\n        return block\n\n    def close_all(self) -&gt; None:\n        for block in self._blocks.values():\n            block.shm.close()\n        self._blocks.clear()\n\n    def gc(self, name: str | None = None):\n        if name is not None:\n            b = self._blocks.pop(name, None)\n            if b is not None:\n                b.shm.close()\n            return\n\n        for key in list(self._blocks.keys()):\n            b = self._blocks[key]\n            if b.temporary:\n                b.shm.close()\n            del self._blocks[key]\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport.ShmPool-attributes","title":"Attributes","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmPool._manager","title":"<code>_manager = manager</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmPool._blocks","title":"<code>_blocks = {}</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmPool-functions","title":"Functions","text":""},{"location":"internals/_session/transport/#brmspy._session.transport.ShmPool.__init__","title":"<code>__init__(manager)</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def __init__(self, manager: SharedMemoryManager) -&gt; None:\n    self._manager = manager\n    self._blocks: dict[str, ShmBlock] = {}\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport.ShmPool.alloc","title":"<code>alloc(size, temporary=False)</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n    # print(f\"alloc {'temp' if temporary else ''}\")\n    shm = self._manager.SharedMemory(size=size)\n    block = ShmBlock(\n        name=shm.name,\n        size=shm.size,\n        shm=shm,\n        content_size=size,\n        temporary=temporary,\n    )\n    self._blocks[block.name] = block\n    return block\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport.ShmPool.attach","title":"<code>attach(ref)</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def attach(self, ref: ShmRef) -&gt; ShmBlock:\n    if ref[\"name\"] in self._blocks:\n        return self._blocks[ref[\"name\"]]\n    shm = SharedMemory(name=ref[\"name\"])\n    block = ShmBlock(\n        name=ref[\"name\"],\n        size=ref[\"size\"],\n        shm=shm,\n        content_size=ref[\"content_size\"],\n        temporary=ref[\"temporary\"],\n    )\n    self._blocks[ref[\"name\"]] = block\n    return block\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport.ShmPool.close_all","title":"<code>close_all()</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def close_all(self) -&gt; None:\n    for block in self._blocks.values():\n        block.shm.close()\n    self._blocks.clear()\n</code></pre>"},{"location":"internals/_session/transport/#brmspy._session.transport.ShmPool.gc","title":"<code>gc(name=None)</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def gc(self, name: str | None = None):\n    if name is not None:\n        b = self._blocks.pop(name, None)\n        if b is not None:\n            b.shm.close()\n        return\n\n    for key in list(self._blocks.keys()):\n        b = self._blocks[key]\n        if b.temporary:\n            b.shm.close()\n        del self._blocks[key]\n</code></pre>"},{"location":"internals/_session/codec/base/","title":"base","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base-classes","title":"Classes","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.Encoder","title":"<code>Encoder</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol implemented by codecs in the session codec registry.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@runtime_checkable\nclass Encoder(Protocol):\n    \"\"\"\n    Protocol implemented by codecs in the session codec registry.\n    \"\"\"\n\n    def can_encode(self, obj: Any) -&gt; bool: ...\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult: ...\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        get_buf: Callable[[ShmRef], GetBufContext],\n        *args: Any,\n    ) -&gt; Any: ...\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.Encoder-functions","title":"Functions","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.Encoder.can_encode","title":"<code>can_encode(obj)</code>","text":"Source code in <code>brmspy/types/session.py</code> <pre><code>def can_encode(self, obj: Any) -&gt; bool: ...\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.Encoder.encode","title":"<code>encode(obj, shm_pool)</code>","text":"Source code in <code>brmspy/types/session.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult: ...\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.Encoder.decode","title":"<code>decode(payload, get_buf, *args)</code>","text":"Source code in <code>brmspy/types/session.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    get_buf: Callable[[ShmRef], GetBufContext],\n    *args: Any,\n) -&gt; Any: ...\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.EncodeResult","title":"<code>EncodeResult</code>  <code>dataclass</code>","text":"<p>Result of encoding a Python value for IPC transfer.</p> <p>Attributes:</p> Name Type Description <code>codec</code> <code>str</code> <p>Codec identifier.</p> <code>meta</code> <code>dict[str, Any]</code> <p>JSON-serializable metadata required for decoding.</p> <code>buffers</code> <code>list[ShmRef]</code> <p>Shared-memory blocks backing the encoded payload.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@dataclass\nclass EncodeResult:\n    \"\"\"\n    Result of encoding a Python value for IPC transfer.\n\n    Attributes\n    ----------\n    codec : str\n        Codec identifier.\n    meta : dict[str, Any]\n        JSON-serializable metadata required for decoding.\n    buffers : list[ShmRef]\n        Shared-memory blocks backing the encoded payload.\n    \"\"\"\n\n    codec: str\n    meta: dict[str, Any]\n    buffers: list[ShmRef]\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.EncodeResult-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.EncodeResult.codec","title":"<code>codec</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.EncodeResult.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.EncodeResult.buffers","title":"<code>buffers</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.EncodeResult-functions","title":"Functions","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.EncodeResult.__init__","title":"<code>__init__(codec, meta, buffers)</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.PayloadRef","title":"<code>PayloadRef</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Encoded argument/result payload sent over the control pipe.</p> <p>A payload is:</p> <ul> <li><code>codec</code>: the codec identifier used by the registry</li> <li><code>meta</code>: JSON-serializable metadata needed to reconstruct the value</li> <li><code>buffers</code>: shared-memory buffer references backing the payload</li> </ul> Source code in <code>brmspy/types/session.py</code> <pre><code>class PayloadRef(TypedDict):\n    \"\"\"\n    Encoded argument/result payload sent over the control pipe.\n\n    A payload is:\n\n    - `codec`: the codec identifier used by the registry\n    - `meta`: JSON-serializable metadata needed to reconstruct the value\n    - `buffers`: shared-memory buffer references backing the payload\n    \"\"\"\n\n    codec: str\n    meta: dict[str, Any]\n    buffers: list[ShmRef]\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.PayloadRef-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.PayloadRef.codec","title":"<code>codec</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.PayloadRef.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.PayloadRef.buffers","title":"<code>buffers</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmBlock","title":"<code>ShmBlock</code>  <code>dataclass</code>","text":"<p>Attached shared-memory block (name/size + live <code>SharedMemory</code> handle).</p> Notes <p>This object owns a <code>SharedMemory</code> handle and must be closed when no longer needed. In brmspy this is managed by a <code>ShmPool</code> implementation.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>@dataclass\nclass ShmBlock:\n    \"\"\"\n    Attached shared-memory block (name/size + live `SharedMemory` handle).\n\n    Notes\n    -----\n    This object owns a `SharedMemory` handle and must be closed when no longer\n    needed. In brmspy this is managed by a `ShmPool` implementation.\n    \"\"\"\n\n    name: str\n    size: int\n    content_size: int\n    shm: SharedMemory\n    temporary: bool\n\n    def to_ref(self) -&gt; ShmRef:\n        return {\n            \"name\": self.name,\n            \"size\": self.size,\n            \"content_size\": self.content_size,\n            \"temporary\": self.temporary,\n        }\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmBlock-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmBlock.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmBlock.size","title":"<code>size</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmBlock.content_size","title":"<code>content_size</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmBlock.shm","title":"<code>shm</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmBlock.temporary","title":"<code>temporary</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmBlock-functions","title":"Functions","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmBlock.to_ref","title":"<code>to_ref()</code>","text":"Source code in <code>brmspy/types/shm.py</code> <pre><code>def to_ref(self) -&gt; ShmRef:\n    return {\n        \"name\": self.name,\n        \"size\": self.size,\n        \"content_size\": self.content_size,\n        \"temporary\": self.temporary,\n    }\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmBlock.__init__","title":"<code>__init__(name, size, content_size, shm, temporary)</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmRef","title":"<code>ShmRef</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Reference to a shared-memory block sent over IPC.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Shared memory block name (as assigned by <code>SharedMemoryManager</code>).</p> <code>size</code> <code>int</code> <p>Allocated block size in bytes.</p> <code>content_size</code> <code>int</code> <p>Actual used size</p> <code>temporary</code> <code>bool</code> <p>Whether this buffer can be GC-d immediately after use or should it be attached to object its constructed into.</p> Notes <p>Codecs may store a logical payload smaller than <code>size</code>. In that case, the codec metadata must include the logical <code>nbytes</code>/length so that decoders can slice the buffer appropriately.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>class ShmRef(TypedDict):\n    \"\"\"\n    Reference to a shared-memory block sent over IPC.\n\n    Attributes\n    ----------\n    name : str\n        Shared memory block name (as assigned by `SharedMemoryManager`).\n    size : int\n        Allocated block size in bytes.\n    content_size : int\n        Actual used size\n    temporary : bool\n        Whether this buffer can be GC-d immediately after use or should it be attached to object its constructed into.\n\n    Notes\n    -----\n    Codecs may store a logical payload smaller than `size`. In that case, the\n    codec metadata must include the logical `nbytes`/length so that decoders can\n    slice the buffer appropriately.\n    \"\"\"\n\n    name: str\n    size: int\n    content_size: int\n    temporary: bool\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmRef-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmRef.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmRef.size","title":"<code>size</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmRef.content_size","title":"<code>content_size</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.ShmRef.temporary","title":"<code>temporary</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.CodecRegistry","title":"<code>CodecRegistry</code>","text":"<p>Ordered registry of encoders used for IPC serialization.</p> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>class CodecRegistry:\n    \"\"\"Ordered registry of encoders used for IPC serialization.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._by_codec: dict[str, Encoder] = {}\n        self._encoders: list[Encoder] = []\n\n    def register(self, encoder: Encoder) -&gt; None:\n        \"\"\"\n        Register an encoder instance.\n\n        Parameters\n        ----------\n        encoder : brmspy.types.session.Encoder\n            Encoder to register. Its `codec` attribute is used as the key when present,\n            otherwise the class name is used.\n        \"\"\"\n        if hasattr(encoder, \"codec\") and encoder.codec:  # type: ignore\n            codec_name = encoder.codec  # type: ignore\n        else:\n            codec_name = type(encoder).__name__\n        self._by_codec[codec_name] = encoder\n        encoder.codec = codec_name  # type: ignore\n        self._encoders.append(encoder)\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n        \"\"\"\n        Encode an object by selecting the first encoder that accepts it.\n\n        Parameters\n        ----------\n        obj : Any\n            Value to encode.\n        shm_pool : Any\n            SHM pool used by codecs for allocating buffers.\n\n        Returns\n        -------\n        brmspy.types.session.EncodeResult\n        \"\"\"\n        for enc in self._encoders:\n            if enc.can_encode(obj):\n                res = enc.encode(obj, shm_pool)\n                if not res.codec:\n                    res.codec = type(enc).__name__\n                return res\n\n        # fallback to pickle\n        if \"PickleCodec\" not in self._by_codec:\n            raise RuntimeError(\"No pickle codec registered\")\n        return self._by_codec[\"PickleCodec\"].encode(obj, shm_pool)\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        shm_pool: Any,\n    ) -&gt; Any:\n        \"\"\"\n        Decode a payload using a named codec.\n\n        Parameters\n        ----------\n        codec : str\n            Codec identifier previously returned by `encode()`.\n        meta : dict[str, Any]\n            Codec metadata.\n        buffers : list[memoryview]\n            Memoryviews for attached SHM buffers.\n        buffer_specs : list[dict]\n            Original buffer specs (name/size) corresponding to `buffers`.\n        shm_pool : Any\n            SHM pool (some codecs may attach additional buffers).\n\n        Returns\n        -------\n        Any\n        \"\"\"\n        codec = payload[\"codec\"]\n        if codec not in self._by_codec:\n            raise ValueError(\n                f\"Unknown codec: {codec}, available: {list(self._by_codec.keys())}\"\n            )\n\n        buffers = []\n\n        @contextmanager\n        def get_buf(ref: ShmRef) -&gt; Iterator[tuple[ShmBlock, memoryview]]:\n            buf = shm_pool.attach(ref)\n            memview = memoryview(buf.shm.buf)\n            view = memview[: ref[\"content_size\"]].cast(\"B\")\n\n            try:\n                if not ref[\"temporary\"]:\n                    # non-temporary buffers are associated with columns / objects\n                    buffers.append(buf)\n\n                yield buf, view\n\n            finally:\n                # deterministic cleanup for temporary buffers\n                if ref[\"temporary\"]:\n                    # IMPORTANT: release view before closing shm\n                    try:\n                        view.release()\n                        memview.release()\n                        shm_pool.gc(ref[\"name\"])\n                        buf.shm.close()\n                    except:\n                        pass\n\n        value = self._by_codec[codec].decode(payload, get_buf, shm_pool)\n        self._attach_shm_lifetime(value, buffers)\n\n        return value\n\n    @classmethod\n    def _attach_shm_lifetime(cls, obj: Any, shms: list[ShmBlock]) -&gt; None:\n        \"\"\"Keep SHM blocks alive as long as `obj` is alive.\"\"\"\n        if not shms:\n            return\n        if obj is None or isinstance(obj, (bool, str, int, float)):\n            return\n\n        try:\n            weakref.finalize(obj, _noop, tuple(shms))\n        except:\n            return\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.CodecRegistry-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.CodecRegistry._by_codec","title":"<code>_by_codec = {}</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.CodecRegistry._encoders","title":"<code>_encoders = []</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.CodecRegistry-functions","title":"Functions","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.CodecRegistry.__init__","title":"<code>__init__()</code>","text":"Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._by_codec: dict[str, Encoder] = {}\n    self._encoders: list[Encoder] = []\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.CodecRegistry.register","title":"<code>register(encoder)</code>","text":"<p>Register an encoder instance.</p> <p>Parameters:</p> Name Type Description Default <code>encoder</code> <code>Encoder</code> <p>Encoder to register. Its <code>codec</code> attribute is used as the key when present, otherwise the class name is used.</p> required Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def register(self, encoder: Encoder) -&gt; None:\n    \"\"\"\n    Register an encoder instance.\n\n    Parameters\n    ----------\n    encoder : brmspy.types.session.Encoder\n        Encoder to register. Its `codec` attribute is used as the key when present,\n        otherwise the class name is used.\n    \"\"\"\n    if hasattr(encoder, \"codec\") and encoder.codec:  # type: ignore\n        codec_name = encoder.codec  # type: ignore\n    else:\n        codec_name = type(encoder).__name__\n    self._by_codec[codec_name] = encoder\n    encoder.codec = codec_name  # type: ignore\n    self._encoders.append(encoder)\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.CodecRegistry.encode","title":"<code>encode(obj, shm_pool)</code>","text":"<p>Encode an object by selecting the first encoder that accepts it.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Value to encode.</p> required <code>shm_pool</code> <code>Any</code> <p>SHM pool used by codecs for allocating buffers.</p> required <p>Returns:</p> Type Description <code>EncodeResult</code> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n    \"\"\"\n    Encode an object by selecting the first encoder that accepts it.\n\n    Parameters\n    ----------\n    obj : Any\n        Value to encode.\n    shm_pool : Any\n        SHM pool used by codecs for allocating buffers.\n\n    Returns\n    -------\n    brmspy.types.session.EncodeResult\n    \"\"\"\n    for enc in self._encoders:\n        if enc.can_encode(obj):\n            res = enc.encode(obj, shm_pool)\n            if not res.codec:\n                res.codec = type(enc).__name__\n            return res\n\n    # fallback to pickle\n    if \"PickleCodec\" not in self._by_codec:\n        raise RuntimeError(\"No pickle codec registered\")\n    return self._by_codec[\"PickleCodec\"].encode(obj, shm_pool)\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.CodecRegistry.decode","title":"<code>decode(payload, shm_pool)</code>","text":"<p>Decode a payload using a named codec.</p> <p>Parameters:</p> Name Type Description Default <code>codec</code> <code>str</code> <p>Codec identifier previously returned by <code>encode()</code>.</p> required <code>meta</code> <code>dict[str, Any]</code> <p>Codec metadata.</p> required <code>buffers</code> <code>list[memoryview]</code> <p>Memoryviews for attached SHM buffers.</p> required <code>buffer_specs</code> <code>list[dict]</code> <p>Original buffer specs (name/size) corresponding to <code>buffers</code>.</p> required <code>shm_pool</code> <code>Any</code> <p>SHM pool (some codecs may attach additional buffers).</p> required <p>Returns:</p> Type Description <code>Any</code> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    shm_pool: Any,\n) -&gt; Any:\n    \"\"\"\n    Decode a payload using a named codec.\n\n    Parameters\n    ----------\n    codec : str\n        Codec identifier previously returned by `encode()`.\n    meta : dict[str, Any]\n        Codec metadata.\n    buffers : list[memoryview]\n        Memoryviews for attached SHM buffers.\n    buffer_specs : list[dict]\n        Original buffer specs (name/size) corresponding to `buffers`.\n    shm_pool : Any\n        SHM pool (some codecs may attach additional buffers).\n\n    Returns\n    -------\n    Any\n    \"\"\"\n    codec = payload[\"codec\"]\n    if codec not in self._by_codec:\n        raise ValueError(\n            f\"Unknown codec: {codec}, available: {list(self._by_codec.keys())}\"\n        )\n\n    buffers = []\n\n    @contextmanager\n    def get_buf(ref: ShmRef) -&gt; Iterator[tuple[ShmBlock, memoryview]]:\n        buf = shm_pool.attach(ref)\n        memview = memoryview(buf.shm.buf)\n        view = memview[: ref[\"content_size\"]].cast(\"B\")\n\n        try:\n            if not ref[\"temporary\"]:\n                # non-temporary buffers are associated with columns / objects\n                buffers.append(buf)\n\n            yield buf, view\n\n        finally:\n            # deterministic cleanup for temporary buffers\n            if ref[\"temporary\"]:\n                # IMPORTANT: release view before closing shm\n                try:\n                    view.release()\n                    memview.release()\n                    shm_pool.gc(ref[\"name\"])\n                    buf.shm.close()\n                except:\n                    pass\n\n    value = self._by_codec[codec].decode(payload, get_buf, shm_pool)\n    self._attach_shm_lifetime(value, buffers)\n\n    return value\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base.CodecRegistry._attach_shm_lifetime","title":"<code>_attach_shm_lifetime(obj, shms)</code>  <code>classmethod</code>","text":"<p>Keep SHM blocks alive as long as <code>obj</code> is alive.</p> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>@classmethod\ndef _attach_shm_lifetime(cls, obj: Any, shms: list[ShmBlock]) -&gt; None:\n    \"\"\"Keep SHM blocks alive as long as `obj` is alive.\"\"\"\n    if not shms:\n        return\n    if obj is None or isinstance(obj, (bool, str, int, float)):\n        return\n\n    try:\n        weakref.finalize(obj, _noop, tuple(shms))\n    except:\n        return\n</code></pre>"},{"location":"internals/_session/codec/base/#brmspy._session.codec.base-functions","title":"Functions","text":""},{"location":"internals/_session/codec/base/#brmspy._session.codec.base._noop","title":"<code>_noop(_blocks)</code>","text":"Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def _noop(_blocks):\n    pass\n</code></pre>"},{"location":"internals/_session/codec/builtin/","title":"builtin","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.GetBufContext","title":"<code>GetBufContext = _GeneratorContextManager[tuple[ShmBlock, memoryview], None, None]</code>  <code>module-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ONE_MB","title":"<code>ONE_MB = 1024 * 1024</code>  <code>module-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin-classes","title":"Classes","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.CodecRegistry","title":"<code>CodecRegistry</code>","text":"<p>Ordered registry of encoders used for IPC serialization.</p> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>class CodecRegistry:\n    \"\"\"Ordered registry of encoders used for IPC serialization.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._by_codec: dict[str, Encoder] = {}\n        self._encoders: list[Encoder] = []\n\n    def register(self, encoder: Encoder) -&gt; None:\n        \"\"\"\n        Register an encoder instance.\n\n        Parameters\n        ----------\n        encoder : brmspy.types.session.Encoder\n            Encoder to register. Its `codec` attribute is used as the key when present,\n            otherwise the class name is used.\n        \"\"\"\n        if hasattr(encoder, \"codec\") and encoder.codec:  # type: ignore\n            codec_name = encoder.codec  # type: ignore\n        else:\n            codec_name = type(encoder).__name__\n        self._by_codec[codec_name] = encoder\n        encoder.codec = codec_name  # type: ignore\n        self._encoders.append(encoder)\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n        \"\"\"\n        Encode an object by selecting the first encoder that accepts it.\n\n        Parameters\n        ----------\n        obj : Any\n            Value to encode.\n        shm_pool : Any\n            SHM pool used by codecs for allocating buffers.\n\n        Returns\n        -------\n        brmspy.types.session.EncodeResult\n        \"\"\"\n        for enc in self._encoders:\n            if enc.can_encode(obj):\n                res = enc.encode(obj, shm_pool)\n                if not res.codec:\n                    res.codec = type(enc).__name__\n                return res\n\n        # fallback to pickle\n        if \"PickleCodec\" not in self._by_codec:\n            raise RuntimeError(\"No pickle codec registered\")\n        return self._by_codec[\"PickleCodec\"].encode(obj, shm_pool)\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        shm_pool: Any,\n    ) -&gt; Any:\n        \"\"\"\n        Decode a payload using a named codec.\n\n        Parameters\n        ----------\n        codec : str\n            Codec identifier previously returned by `encode()`.\n        meta : dict[str, Any]\n            Codec metadata.\n        buffers : list[memoryview]\n            Memoryviews for attached SHM buffers.\n        buffer_specs : list[dict]\n            Original buffer specs (name/size) corresponding to `buffers`.\n        shm_pool : Any\n            SHM pool (some codecs may attach additional buffers).\n\n        Returns\n        -------\n        Any\n        \"\"\"\n        codec = payload[\"codec\"]\n        if codec not in self._by_codec:\n            raise ValueError(\n                f\"Unknown codec: {codec}, available: {list(self._by_codec.keys())}\"\n            )\n\n        buffers = []\n\n        @contextmanager\n        def get_buf(ref: ShmRef) -&gt; Iterator[tuple[ShmBlock, memoryview]]:\n            buf = shm_pool.attach(ref)\n            memview = memoryview(buf.shm.buf)\n            view = memview[: ref[\"content_size\"]].cast(\"B\")\n\n            try:\n                if not ref[\"temporary\"]:\n                    # non-temporary buffers are associated with columns / objects\n                    buffers.append(buf)\n\n                yield buf, view\n\n            finally:\n                # deterministic cleanup for temporary buffers\n                if ref[\"temporary\"]:\n                    # IMPORTANT: release view before closing shm\n                    try:\n                        view.release()\n                        memview.release()\n                        shm_pool.gc(ref[\"name\"])\n                        buf.shm.close()\n                    except:\n                        pass\n\n        value = self._by_codec[codec].decode(payload, get_buf, shm_pool)\n        self._attach_shm_lifetime(value, buffers)\n\n        return value\n\n    @classmethod\n    def _attach_shm_lifetime(cls, obj: Any, shms: list[ShmBlock]) -&gt; None:\n        \"\"\"Keep SHM blocks alive as long as `obj` is alive.\"\"\"\n        if not shms:\n            return\n        if obj is None or isinstance(obj, (bool, str, int, float)):\n            return\n\n        try:\n            weakref.finalize(obj, _noop, tuple(shms))\n        except:\n            return\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.CodecRegistry-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.CodecRegistry._by_codec","title":"<code>_by_codec = {}</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.CodecRegistry._encoders","title":"<code>_encoders = []</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.CodecRegistry-functions","title":"Functions","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.CodecRegistry.__init__","title":"<code>__init__()</code>","text":"Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._by_codec: dict[str, Encoder] = {}\n    self._encoders: list[Encoder] = []\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.CodecRegistry.register","title":"<code>register(encoder)</code>","text":"<p>Register an encoder instance.</p> <p>Parameters:</p> Name Type Description Default <code>encoder</code> <code>Encoder</code> <p>Encoder to register. Its <code>codec</code> attribute is used as the key when present, otherwise the class name is used.</p> required Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def register(self, encoder: Encoder) -&gt; None:\n    \"\"\"\n    Register an encoder instance.\n\n    Parameters\n    ----------\n    encoder : brmspy.types.session.Encoder\n        Encoder to register. Its `codec` attribute is used as the key when present,\n        otherwise the class name is used.\n    \"\"\"\n    if hasattr(encoder, \"codec\") and encoder.codec:  # type: ignore\n        codec_name = encoder.codec  # type: ignore\n    else:\n        codec_name = type(encoder).__name__\n    self._by_codec[codec_name] = encoder\n    encoder.codec = codec_name  # type: ignore\n    self._encoders.append(encoder)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.CodecRegistry.encode","title":"<code>encode(obj, shm_pool)</code>","text":"<p>Encode an object by selecting the first encoder that accepts it.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Value to encode.</p> required <code>shm_pool</code> <code>Any</code> <p>SHM pool used by codecs for allocating buffers.</p> required <p>Returns:</p> Type Description <code>EncodeResult</code> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n    \"\"\"\n    Encode an object by selecting the first encoder that accepts it.\n\n    Parameters\n    ----------\n    obj : Any\n        Value to encode.\n    shm_pool : Any\n        SHM pool used by codecs for allocating buffers.\n\n    Returns\n    -------\n    brmspy.types.session.EncodeResult\n    \"\"\"\n    for enc in self._encoders:\n        if enc.can_encode(obj):\n            res = enc.encode(obj, shm_pool)\n            if not res.codec:\n                res.codec = type(enc).__name__\n            return res\n\n    # fallback to pickle\n    if \"PickleCodec\" not in self._by_codec:\n        raise RuntimeError(\"No pickle codec registered\")\n    return self._by_codec[\"PickleCodec\"].encode(obj, shm_pool)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.CodecRegistry.decode","title":"<code>decode(payload, shm_pool)</code>","text":"<p>Decode a payload using a named codec.</p> <p>Parameters:</p> Name Type Description Default <code>codec</code> <code>str</code> <p>Codec identifier previously returned by <code>encode()</code>.</p> required <code>meta</code> <code>dict[str, Any]</code> <p>Codec metadata.</p> required <code>buffers</code> <code>list[memoryview]</code> <p>Memoryviews for attached SHM buffers.</p> required <code>buffer_specs</code> <code>list[dict]</code> <p>Original buffer specs (name/size) corresponding to <code>buffers</code>.</p> required <code>shm_pool</code> <code>Any</code> <p>SHM pool (some codecs may attach additional buffers).</p> required <p>Returns:</p> Type Description <code>Any</code> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    shm_pool: Any,\n) -&gt; Any:\n    \"\"\"\n    Decode a payload using a named codec.\n\n    Parameters\n    ----------\n    codec : str\n        Codec identifier previously returned by `encode()`.\n    meta : dict[str, Any]\n        Codec metadata.\n    buffers : list[memoryview]\n        Memoryviews for attached SHM buffers.\n    buffer_specs : list[dict]\n        Original buffer specs (name/size) corresponding to `buffers`.\n    shm_pool : Any\n        SHM pool (some codecs may attach additional buffers).\n\n    Returns\n    -------\n    Any\n    \"\"\"\n    codec = payload[\"codec\"]\n    if codec not in self._by_codec:\n        raise ValueError(\n            f\"Unknown codec: {codec}, available: {list(self._by_codec.keys())}\"\n        )\n\n    buffers = []\n\n    @contextmanager\n    def get_buf(ref: ShmRef) -&gt; Iterator[tuple[ShmBlock, memoryview]]:\n        buf = shm_pool.attach(ref)\n        memview = memoryview(buf.shm.buf)\n        view = memview[: ref[\"content_size\"]].cast(\"B\")\n\n        try:\n            if not ref[\"temporary\"]:\n                # non-temporary buffers are associated with columns / objects\n                buffers.append(buf)\n\n            yield buf, view\n\n        finally:\n            # deterministic cleanup for temporary buffers\n            if ref[\"temporary\"]:\n                # IMPORTANT: release view before closing shm\n                try:\n                    view.release()\n                    memview.release()\n                    shm_pool.gc(ref[\"name\"])\n                    buf.shm.close()\n                except:\n                    pass\n\n    value = self._by_codec[codec].decode(payload, get_buf, shm_pool)\n    self._attach_shm_lifetime(value, buffers)\n\n    return value\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.CodecRegistry._attach_shm_lifetime","title":"<code>_attach_shm_lifetime(obj, shms)</code>  <code>classmethod</code>","text":"<p>Keep SHM blocks alive as long as <code>obj</code> is alive.</p> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>@classmethod\ndef _attach_shm_lifetime(cls, obj: Any, shms: list[ShmBlock]) -&gt; None:\n    \"\"\"Keep SHM blocks alive as long as `obj` is alive.\"\"\"\n    if not shms:\n        return\n    if obj is None or isinstance(obj, (bool, str, int, float)):\n        return\n\n    try:\n        weakref.finalize(obj, _noop, tuple(shms))\n    except:\n        return\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.EncodeResult","title":"<code>EncodeResult</code>  <code>dataclass</code>","text":"<p>Result of encoding a Python value for IPC transfer.</p> <p>Attributes:</p> Name Type Description <code>codec</code> <code>str</code> <p>Codec identifier.</p> <code>meta</code> <code>dict[str, Any]</code> <p>JSON-serializable metadata required for decoding.</p> <code>buffers</code> <code>list[ShmRef]</code> <p>Shared-memory blocks backing the encoded payload.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@dataclass\nclass EncodeResult:\n    \"\"\"\n    Result of encoding a Python value for IPC transfer.\n\n    Attributes\n    ----------\n    codec : str\n        Codec identifier.\n    meta : dict[str, Any]\n        JSON-serializable metadata required for decoding.\n    buffers : list[ShmRef]\n        Shared-memory blocks backing the encoded payload.\n    \"\"\"\n\n    codec: str\n    meta: dict[str, Any]\n    buffers: list[ShmRef]\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.EncodeResult-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.EncodeResult.codec","title":"<code>codec</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.EncodeResult.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.EncodeResult.buffers","title":"<code>buffers</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.EncodeResult-functions","title":"Functions","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.EncodeResult.__init__","title":"<code>__init__(codec, meta, buffers)</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.Encoder","title":"<code>Encoder</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol implemented by codecs in the session codec registry.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@runtime_checkable\nclass Encoder(Protocol):\n    \"\"\"\n    Protocol implemented by codecs in the session codec registry.\n    \"\"\"\n\n    def can_encode(self, obj: Any) -&gt; bool: ...\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult: ...\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        get_buf: Callable[[ShmRef], GetBufContext],\n        *args: Any,\n    ) -&gt; Any: ...\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.Encoder-functions","title":"Functions","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.Encoder.can_encode","title":"<code>can_encode(obj)</code>","text":"Source code in <code>brmspy/types/session.py</code> <pre><code>def can_encode(self, obj: Any) -&gt; bool: ...\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.Encoder.encode","title":"<code>encode(obj, shm_pool)</code>","text":"Source code in <code>brmspy/types/session.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult: ...\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.Encoder.decode","title":"<code>decode(payload, get_buf, *args)</code>","text":"Source code in <code>brmspy/types/session.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    get_buf: Callable[[ShmRef], GetBufContext],\n    *args: Any,\n) -&gt; Any: ...\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PayloadRef","title":"<code>PayloadRef</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Encoded argument/result payload sent over the control pipe.</p> <p>A payload is:</p> <ul> <li><code>codec</code>: the codec identifier used by the registry</li> <li><code>meta</code>: JSON-serializable metadata needed to reconstruct the value</li> <li><code>buffers</code>: shared-memory buffer references backing the payload</li> </ul> Source code in <code>brmspy/types/session.py</code> <pre><code>class PayloadRef(TypedDict):\n    \"\"\"\n    Encoded argument/result payload sent over the control pipe.\n\n    A payload is:\n\n    - `codec`: the codec identifier used by the registry\n    - `meta`: JSON-serializable metadata needed to reconstruct the value\n    - `buffers`: shared-memory buffer references backing the payload\n    \"\"\"\n\n    codec: str\n    meta: dict[str, Any]\n    buffers: list[ShmRef]\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PayloadRef-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PayloadRef.codec","title":"<code>codec</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PayloadRef.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PayloadRef.buffers","title":"<code>buffers</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmSeriesMetadata","title":"<code>ShmSeriesMetadata</code>","text":"<p>               Bases: <code>TypedDict</code></p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>class ShmSeriesMetadata(TypedDict):\n    name: Hashable | None\n    np_dtype: str\n    pd_dtype: str\n    params: dict[str, Any]  # extra info per logical type\n    block: ShmRef\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmSeriesMetadata-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmSeriesMetadata.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmSeriesMetadata.np_dtype","title":"<code>np_dtype</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmSeriesMetadata.pd_dtype","title":"<code>pd_dtype</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmSeriesMetadata.params","title":"<code>params</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmSeriesMetadata.block","title":"<code>block</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmArray","title":"<code>ShmArray</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>NumPy array view backed by a shared-memory block.</p> <p>Attributes:</p> Name Type Description <code>block</code> <code>ShmRef</code> <p>Reference to the shared-memory block backing the array data.</p> Notes <p>This is a view over <code>SharedMemory.buf</code>. Closing/unlinking the underlying shared memory while the array is still in use will lead to undefined behavior.</p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>class ShmArray(np.ndarray):\n    \"\"\"\n    NumPy array view backed by a shared-memory block.\n\n    Attributes\n    ----------\n    block : ShmRef\n        Reference to the shared-memory block backing the array data.\n\n    Notes\n    -----\n    This is a *view* over `SharedMemory.buf`. Closing/unlinking the underlying\n    shared memory while the array is still in use will lead to undefined\n    behavior.\n    \"\"\"\n\n    _shm_metadata: ShmRef  # for type checkers\n\n    @classmethod\n    def from_metadata(\n        cls, meta: ShmArrayMetadata | dict[str, Any], block: ShmBlock\n    ) -&gt; np.ndarray:\n        dtype = np.dtype(meta[\"dtype\"])\n        shape = tuple(meta[\"shape\"])\n        order = meta[\"order\"]\n\n        return ShmArray.from_block(block=block, shape=shape, dtype=dtype, order=order)\n\n    @classmethod\n    def from_block(\n        cls, block: ShmBlock, shape: tuple[int, ...], dtype: np.dtype, **kwargs\n    ) -&gt; Union[\"ShmArray\", np.ndarray]:\n        \"\"\"\n        Create an array view backed by an existing shared-memory block.\n\n        Parameters\n        ----------\n        block : ShmBlock\n            Attached shared-memory block.\n        shape : tuple[int, ...]\n            Desired array shape.\n        dtype : numpy.dtype\n            NumPy dtype of the array.\n        **kwargs\n            Reserved for future compatibility. Currently unused.\n\n        Returns\n        -------\n        ShmArray\n            Array view into the shared-memory buffer.\n        \"\"\"\n        is_object = np.dtype(dtype) == np.dtype(\"O\")\n\n        if not is_object:\n            if block.shm.buf:\n                view = memoryview(block.shm.buf)\n                view = view[: block.content_size]\n            else:\n                view = None\n            base = np.ndarray(\n                shape=shape,\n                dtype=dtype,\n                buffer=view,\n                order=kwargs.get(\"order\", \"F\"),\n            )\n            obj = base.view(ShmArray)\n            obj._shm_metadata = block.to_ref()\n        else:\n            assert block.shm.buf\n            view = memoryview(block.shm.buf)\n            view = view[: block.content_size]\n            payload = bytes(view)\n            obj = pickle.loads(payload)\n            assert isinstance(obj, np.ndarray)\n\n        return obj\n\n    @classmethod\n    def array_order(cls, a: np.ndarray) -&gt; Literal[\"C\", \"F\", \"non-contiguous\"]:\n        \"\"\"\n        Determine how an array can be reconstructed from a raw buffer.\n\n        Returns `\"C\"` for C-contiguous arrays, `\"F\"` for Fortran-contiguous arrays,\n        otherwise `\"non-contiguous\"` (meaning: bytes were obtained by forcing\n        a contiguous copy during encoding).\n        \"\"\"\n        if a.flags[\"C_CONTIGUOUS\"]:\n            return \"C\"\n        if a.flags[\"F_CONTIGUOUS\"]:\n            return \"F\"\n        return \"non-contiguous\"\n\n    @classmethod\n    def is_string_object(cls, a: np.ndarray, sample: int = 1000):\n        if np.dtype(a.dtype) != np.dtype(\"O\"):\n            return False\n        it = a.flat\n        for _ in range(min(sample, a.size)):\n            v = next(it, None)\n            if v is not None and not isinstance(v, str):\n                return False\n        return True\n\n    @classmethod\n    def to_shm(\n        cls, obj: np.ndarray | pd.Series | list, shm_pool: Any\n    ) -&gt; tuple[np.ndarray | None, ShmRef, str, list[int], str]:\n        if isinstance(obj, pd.Series):\n            if isinstance(obj.dtype, pd.CategoricalDtype):\n                arr = obj.cat.codes.to_numpy(copy=False)\n            else:\n                arr = obj.to_numpy(copy=False)\n        elif not isinstance(obj, np.ndarray):\n            arr = np.asarray(obj)\n        else:\n            arr = obj\n\n        is_object = np.dtype(arr.dtype) == np.dtype(\"O\")\n        is_string = cls.is_string_object(arr)\n\n        arr_modified = None\n        if isinstance(arr, ShmArray):\n            ref = arr._shm_metadata\n\n        else:\n            temporary = False\n            if not is_object:\n                data = arr.tobytes(order=\"C\")\n            elif is_string:\n                arr = arr.astype(\"U\")\n                arr_modified = arr\n                data = arr.tobytes(order=\"C\")\n            else:\n                data = pickle.dumps(arr, protocol=pickle.HIGHEST_PROTOCOL)\n                temporary = True\n\n            nbytes = len(data)\n\n            # Ask for exactly nbytes; OS may round up internally, that's fine.\n            block = shm_pool.alloc(nbytes, temporary=temporary)\n            block.shm.buf[:nbytes] = data\n            ref = block.to_ref()\n\n        ref, dtype, shape, order = (\n            ref,\n            str(arr.dtype),\n            list(arr.shape),\n            cls.array_order(arr),\n        )\n\n        return arr_modified, ref, dtype, shape, order\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmArray-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmArray._shm_metadata","title":"<code>_shm_metadata</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmArray-functions","title":"Functions","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmArray.from_metadata","title":"<code>from_metadata(meta, block)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef from_metadata(\n    cls, meta: ShmArrayMetadata | dict[str, Any], block: ShmBlock\n) -&gt; np.ndarray:\n    dtype = np.dtype(meta[\"dtype\"])\n    shape = tuple(meta[\"shape\"])\n    order = meta[\"order\"]\n\n    return ShmArray.from_block(block=block, shape=shape, dtype=dtype, order=order)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmArray.from_block","title":"<code>from_block(block, shape, dtype, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create an array view backed by an existing shared-memory block.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>ShmBlock</code> <p>Attached shared-memory block.</p> required <code>shape</code> <code>tuple[int, ...]</code> <p>Desired array shape.</p> required <code>dtype</code> <code>dtype</code> <p>NumPy dtype of the array.</p> required <code>**kwargs</code> <p>Reserved for future compatibility. Currently unused.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ShmArray</code> <p>Array view into the shared-memory buffer.</p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef from_block(\n    cls, block: ShmBlock, shape: tuple[int, ...], dtype: np.dtype, **kwargs\n) -&gt; Union[\"ShmArray\", np.ndarray]:\n    \"\"\"\n    Create an array view backed by an existing shared-memory block.\n\n    Parameters\n    ----------\n    block : ShmBlock\n        Attached shared-memory block.\n    shape : tuple[int, ...]\n        Desired array shape.\n    dtype : numpy.dtype\n        NumPy dtype of the array.\n    **kwargs\n        Reserved for future compatibility. Currently unused.\n\n    Returns\n    -------\n    ShmArray\n        Array view into the shared-memory buffer.\n    \"\"\"\n    is_object = np.dtype(dtype) == np.dtype(\"O\")\n\n    if not is_object:\n        if block.shm.buf:\n            view = memoryview(block.shm.buf)\n            view = view[: block.content_size]\n        else:\n            view = None\n        base = np.ndarray(\n            shape=shape,\n            dtype=dtype,\n            buffer=view,\n            order=kwargs.get(\"order\", \"F\"),\n        )\n        obj = base.view(ShmArray)\n        obj._shm_metadata = block.to_ref()\n    else:\n        assert block.shm.buf\n        view = memoryview(block.shm.buf)\n        view = view[: block.content_size]\n        payload = bytes(view)\n        obj = pickle.loads(payload)\n        assert isinstance(obj, np.ndarray)\n\n    return obj\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmArray.array_order","title":"<code>array_order(a)</code>  <code>classmethod</code>","text":"<p>Determine how an array can be reconstructed from a raw buffer.</p> <p>Returns <code>\"C\"</code> for C-contiguous arrays, <code>\"F\"</code> for Fortran-contiguous arrays, otherwise <code>\"non-contiguous\"</code> (meaning: bytes were obtained by forcing a contiguous copy during encoding).</p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef array_order(cls, a: np.ndarray) -&gt; Literal[\"C\", \"F\", \"non-contiguous\"]:\n    \"\"\"\n    Determine how an array can be reconstructed from a raw buffer.\n\n    Returns `\"C\"` for C-contiguous arrays, `\"F\"` for Fortran-contiguous arrays,\n    otherwise `\"non-contiguous\"` (meaning: bytes were obtained by forcing\n    a contiguous copy during encoding).\n    \"\"\"\n    if a.flags[\"C_CONTIGUOUS\"]:\n        return \"C\"\n    if a.flags[\"F_CONTIGUOUS\"]:\n        return \"F\"\n    return \"non-contiguous\"\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmArray.is_string_object","title":"<code>is_string_object(a, sample=1000)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef is_string_object(cls, a: np.ndarray, sample: int = 1000):\n    if np.dtype(a.dtype) != np.dtype(\"O\"):\n        return False\n    it = a.flat\n    for _ in range(min(sample, a.size)):\n        v = next(it, None)\n        if v is not None and not isinstance(v, str):\n            return False\n    return True\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmArray.to_shm","title":"<code>to_shm(obj, shm_pool)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef to_shm(\n    cls, obj: np.ndarray | pd.Series | list, shm_pool: Any\n) -&gt; tuple[np.ndarray | None, ShmRef, str, list[int], str]:\n    if isinstance(obj, pd.Series):\n        if isinstance(obj.dtype, pd.CategoricalDtype):\n            arr = obj.cat.codes.to_numpy(copy=False)\n        else:\n            arr = obj.to_numpy(copy=False)\n    elif not isinstance(obj, np.ndarray):\n        arr = np.asarray(obj)\n    else:\n        arr = obj\n\n    is_object = np.dtype(arr.dtype) == np.dtype(\"O\")\n    is_string = cls.is_string_object(arr)\n\n    arr_modified = None\n    if isinstance(arr, ShmArray):\n        ref = arr._shm_metadata\n\n    else:\n        temporary = False\n        if not is_object:\n            data = arr.tobytes(order=\"C\")\n        elif is_string:\n            arr = arr.astype(\"U\")\n            arr_modified = arr\n            data = arr.tobytes(order=\"C\")\n        else:\n            data = pickle.dumps(arr, protocol=pickle.HIGHEST_PROTOCOL)\n            temporary = True\n\n        nbytes = len(data)\n\n        # Ask for exactly nbytes; OS may round up internally, that's fine.\n        block = shm_pool.alloc(nbytes, temporary=temporary)\n        block.shm.buf[:nbytes] = data\n        ref = block.to_ref()\n\n    ref, dtype, shape, order = (\n        ref,\n        str(arr.dtype),\n        list(arr.shape),\n        cls.array_order(arr),\n    )\n\n    return arr_modified, ref, dtype, shape, order\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns","title":"<code>ShmDataFrameColumns</code>","text":"<p>               Bases: <code>DataFrame</code></p> <p>pandas DataFrame backed by per-column shared-memory blocks (numeric only).</p> <p>Attributes:</p> Name Type Description <code>_blocks_columns</code> <code>dict[str, PandasColumnMetadata]</code> <p>Mapping from column name to data required for its reconstruction</p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>class ShmDataFrameColumns(pd.DataFrame):\n    \"\"\"\n    pandas DataFrame backed by per-column shared-memory blocks (numeric only).\n\n    Attributes\n    ----------\n    _blocks_columns : dict[str, PandasColumnMetadata]\n        Mapping from column name to data required for its reconstruction\n    \"\"\"\n\n    _metadata = [\"_shm_metadata\"]\n    _shm_metadata: dict[str, ShmSeriesMetadata]\n\n    @property\n    def _constructor(self):\n        # We INTENTIONALLY do not return ShmSeriesMetadata\n        # whenever the dataframe is reindexed, slices, we want to get rid of all _shm_metadata,\n        # as otherwise we will have immediate problems with buffer alignment\n        return pd.DataFrame\n\n    @classmethod\n    def _create_col_metadata(\n        cls, series: pd.Series, block: ShmRef, arr: np.ndarray | None = None, **params\n    ) -&gt; ShmSeriesMetadata:\n        pd_dtype = series.dtype\n\n        # Decide what ndarray is actually stored in SHM\n        if isinstance(pd_dtype, pd.CategoricalDtype):\n            # store dtype params\n            params[\"categories\"] = pd_dtype.categories.to_numpy(dtype=object).tolist()\n            params[\"ordered\"] = bool(pd_dtype.ordered)\n            params[\"categories_dtype\"] = pd_dtype.categories.dtype.name\n\n            # IMPORTANT: store integer codes, not values\n            # -1 means missing\n            array = series.cat.codes.to_numpy(copy=False)\n        elif arr is not None:\n            assert isinstance(arr, np.ndarray)\n            array = arr\n        else:\n            # for numeric-only SHM: require a real numpy array output here\n            array = series.to_numpy(copy=False)\n\n        # Optional param dtypes you mentioned (only if you support them)\n        if isinstance(pd_dtype, pd.PeriodDtype):\n            params[\"freq\"] = str(pd_dtype.freq)\n\n        if isinstance(pd_dtype, pd.IntervalDtype):\n            params[\"subtype\"] = np.dtype(pd_dtype.subtype).str\n            params[\"closed\"] = str(pd_dtype.closed)  # type: ignore[attr-defined]\n\n        meta: ShmSeriesMetadata = {\n            \"name\": series.name,\n            \"np_dtype\": str(array.dtype),\n            \"pd_dtype\": str(pd_dtype.name),\n            \"block\": block,\n            \"params\": params,\n        }\n\n        if np.dtype(meta[\"np_dtype\"]) == np.dtype(\"O\"):\n            # Sanity check. If this goes wrong, it will be frustrating to debug\n            if ShmArray.is_string_object(array, sample=25):\n                raise Exception(\n                    f\"{series.name} column is string, but stored as object!\"\n                )\n\n        return meta\n\n    def _set_col_raw(self, col: str, value) -&gt; None:\n        # bypass our __setitem__\n        pd.DataFrame.__setitem__(self, col, value)\n\n    def _set_shm_metadata(self, meta: dict[str, ShmSeriesMetadata]):\n        self._shm_metadata = meta\n\n    @classmethod\n    def _put_col_in_shm(\n        cls, df: \"ShmDataFrameColumns\", col: str, shm_pool: Any, replace=False\n    ):\n        vals = df[col].to_numpy(copy=False)\n        if (\n            isinstance(vals, ShmArray)\n            and hasattr(vals, \"_shm_metadata\")\n            and not replace\n        ):\n            pass\n        elif isinstance(vals, np.ndarray):\n            if col in df._shm_metadata:\n                del df._shm_metadata[col]\n            arr_modified, ref, dtype, shape, order = ShmArray.to_shm(df[col], shm_pool)\n\n            if arr_modified is not None:\n                # Only needed for string-object normalization; for numeric/codes it's None\n                df._set_col_raw(\n                    col, pd.Series(arr_modified, index=df.index, name=col, copy=False)\n                )\n            df._shm_metadata[col] = cls._create_col_metadata(df[col], ref, arr_modified)\n            return\n        else:\n            print(\n                f\"Failed to update shm metadata for column '{col}' dtype {vals.dtype}\"\n            )\n            return\n\n    @classmethod\n    def _reconstruct_series(\n        cls,\n        meta: ShmSeriesMetadata,\n        block: ShmBlock,\n        nrows: int,\n        index: list | None,\n    ) -&gt; pd.Series:\n        col_name = meta[\"name\"]\n        col_name = str(col_name)\n        dtype = np.dtype(meta[\"np_dtype\"])\n        pd_dtype = meta[\"pd_dtype\"]\n        params = meta[\"params\"]\n\n        arr = ShmArray.from_block(block=block, shape=(nrows,), dtype=dtype, order=\"C\")\n\n        if pd_dtype == \"category\":\n            cats = params.get(\"categories\", None)\n            ordered = bool(params.get(\"ordered\", False))\n\n            if cats is None:\n                raise ValueError(\"category dtype requires params['categories']\")\n\n            cats_pd_dtype = params.get(\"categories_dtype\")\n            if cats_pd_dtype is not None:\n                cats_index = pd.Index(cats, dtype=str(cats_pd_dtype))\n            else:\n                cats_index = pd.Index(cats)\n\n            cat_dtype = pd.CategoricalDtype(categories=cats_index, ordered=ordered)\n\n            # arr should hold integer codes\n            # If arr holds codes: build categorical from codes without copying codes.\n            # Pandas uses -1 for missing.\n            cat = pd.Categorical.from_codes(cast(Sequence[int], arr), dtype=cat_dtype)\n            return pd.Series(cat, name=col_name, index=index)\n\n        # 2) tz-aware datetimes\n        # Expect arr to be int64 ns timestamps\n        if pd_dtype.startswith(\"datetime64[ns,\") or pd_dtype == \"datetime64[ns, tz]\":\n            tz = params.get(\"tz\")\n            if not tz:\n                # if stored as a plain datetime64[ns] string, just fall through\n                pass\n            else:\n                dt = pd.to_datetime(arr, unit=\"ns\", utc=True).tz_convert(tz)\n                return pd.Series(dt, name=col_name, index=index)\n\n        return pd.Series(arr, name=col_name, index=index)\n\n    def __setitem__(self, key, value):\n        is_existing = key in self.columns\n\n        super().__setitem__(key, value)\n\n        if is_existing:\n            self._on_column_replaced(key)\n        else:\n            self._on_column_added(key)\n\n    def _on_column_added(self, col: str):\n        from brmspy._singleton._shm_singleton import _get_shm\n\n        shm = _get_shm()\n        if not shm:\n            return\n        self._put_col_in_shm(self, col, shm)\n\n    def _on_column_replaced(self, col: str):\n        from brmspy._singleton._shm_singleton import _get_shm\n\n        shm = _get_shm()\n        if not shm:\n            return\n        self._put_col_in_shm(self, col, shm, replace=True)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns._metadata","title":"<code>_metadata = ['_shm_metadata']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns._shm_metadata","title":"<code>_shm_metadata</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns._constructor","title":"<code>_constructor</code>  <code>property</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns-functions","title":"Functions","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns._create_col_metadata","title":"<code>_create_col_metadata(series, block, arr=None, **params)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef _create_col_metadata(\n    cls, series: pd.Series, block: ShmRef, arr: np.ndarray | None = None, **params\n) -&gt; ShmSeriesMetadata:\n    pd_dtype = series.dtype\n\n    # Decide what ndarray is actually stored in SHM\n    if isinstance(pd_dtype, pd.CategoricalDtype):\n        # store dtype params\n        params[\"categories\"] = pd_dtype.categories.to_numpy(dtype=object).tolist()\n        params[\"ordered\"] = bool(pd_dtype.ordered)\n        params[\"categories_dtype\"] = pd_dtype.categories.dtype.name\n\n        # IMPORTANT: store integer codes, not values\n        # -1 means missing\n        array = series.cat.codes.to_numpy(copy=False)\n    elif arr is not None:\n        assert isinstance(arr, np.ndarray)\n        array = arr\n    else:\n        # for numeric-only SHM: require a real numpy array output here\n        array = series.to_numpy(copy=False)\n\n    # Optional param dtypes you mentioned (only if you support them)\n    if isinstance(pd_dtype, pd.PeriodDtype):\n        params[\"freq\"] = str(pd_dtype.freq)\n\n    if isinstance(pd_dtype, pd.IntervalDtype):\n        params[\"subtype\"] = np.dtype(pd_dtype.subtype).str\n        params[\"closed\"] = str(pd_dtype.closed)  # type: ignore[attr-defined]\n\n    meta: ShmSeriesMetadata = {\n        \"name\": series.name,\n        \"np_dtype\": str(array.dtype),\n        \"pd_dtype\": str(pd_dtype.name),\n        \"block\": block,\n        \"params\": params,\n    }\n\n    if np.dtype(meta[\"np_dtype\"]) == np.dtype(\"O\"):\n        # Sanity check. If this goes wrong, it will be frustrating to debug\n        if ShmArray.is_string_object(array, sample=25):\n            raise Exception(\n                f\"{series.name} column is string, but stored as object!\"\n            )\n\n    return meta\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns._set_col_raw","title":"<code>_set_col_raw(col, value)</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>def _set_col_raw(self, col: str, value) -&gt; None:\n    # bypass our __setitem__\n    pd.DataFrame.__setitem__(self, col, value)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns._set_shm_metadata","title":"<code>_set_shm_metadata(meta)</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>def _set_shm_metadata(self, meta: dict[str, ShmSeriesMetadata]):\n    self._shm_metadata = meta\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns._put_col_in_shm","title":"<code>_put_col_in_shm(df, col, shm_pool, replace=False)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef _put_col_in_shm(\n    cls, df: \"ShmDataFrameColumns\", col: str, shm_pool: Any, replace=False\n):\n    vals = df[col].to_numpy(copy=False)\n    if (\n        isinstance(vals, ShmArray)\n        and hasattr(vals, \"_shm_metadata\")\n        and not replace\n    ):\n        pass\n    elif isinstance(vals, np.ndarray):\n        if col in df._shm_metadata:\n            del df._shm_metadata[col]\n        arr_modified, ref, dtype, shape, order = ShmArray.to_shm(df[col], shm_pool)\n\n        if arr_modified is not None:\n            # Only needed for string-object normalization; for numeric/codes it's None\n            df._set_col_raw(\n                col, pd.Series(arr_modified, index=df.index, name=col, copy=False)\n            )\n        df._shm_metadata[col] = cls._create_col_metadata(df[col], ref, arr_modified)\n        return\n    else:\n        print(\n            f\"Failed to update shm metadata for column '{col}' dtype {vals.dtype}\"\n        )\n        return\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns._reconstruct_series","title":"<code>_reconstruct_series(meta, block, nrows, index)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef _reconstruct_series(\n    cls,\n    meta: ShmSeriesMetadata,\n    block: ShmBlock,\n    nrows: int,\n    index: list | None,\n) -&gt; pd.Series:\n    col_name = meta[\"name\"]\n    col_name = str(col_name)\n    dtype = np.dtype(meta[\"np_dtype\"])\n    pd_dtype = meta[\"pd_dtype\"]\n    params = meta[\"params\"]\n\n    arr = ShmArray.from_block(block=block, shape=(nrows,), dtype=dtype, order=\"C\")\n\n    if pd_dtype == \"category\":\n        cats = params.get(\"categories\", None)\n        ordered = bool(params.get(\"ordered\", False))\n\n        if cats is None:\n            raise ValueError(\"category dtype requires params['categories']\")\n\n        cats_pd_dtype = params.get(\"categories_dtype\")\n        if cats_pd_dtype is not None:\n            cats_index = pd.Index(cats, dtype=str(cats_pd_dtype))\n        else:\n            cats_index = pd.Index(cats)\n\n        cat_dtype = pd.CategoricalDtype(categories=cats_index, ordered=ordered)\n\n        # arr should hold integer codes\n        # If arr holds codes: build categorical from codes without copying codes.\n        # Pandas uses -1 for missing.\n        cat = pd.Categorical.from_codes(cast(Sequence[int], arr), dtype=cat_dtype)\n        return pd.Series(cat, name=col_name, index=index)\n\n    # 2) tz-aware datetimes\n    # Expect arr to be int64 ns timestamps\n    if pd_dtype.startswith(\"datetime64[ns,\") or pd_dtype == \"datetime64[ns, tz]\":\n        tz = params.get(\"tz\")\n        if not tz:\n            # if stored as a plain datetime64[ns] string, just fall through\n            pass\n        else:\n            dt = pd.to_datetime(arr, unit=\"ns\", utc=True).tz_convert(tz)\n            return pd.Series(dt, name=col_name, index=index)\n\n    return pd.Series(arr, name=col_name, index=index)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>def __setitem__(self, key, value):\n    is_existing = key in self.columns\n\n    super().__setitem__(key, value)\n\n    if is_existing:\n        self._on_column_replaced(key)\n    else:\n        self._on_column_added(key)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns._on_column_added","title":"<code>_on_column_added(col)</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>def _on_column_added(self, col: str):\n    from brmspy._singleton._shm_singleton import _get_shm\n\n    shm = _get_shm()\n    if not shm:\n        return\n    self._put_col_in_shm(self, col, shm)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameColumns._on_column_replaced","title":"<code>_on_column_replaced(col)</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>def _on_column_replaced(self, col: str):\n    from brmspy._singleton._shm_singleton import _get_shm\n\n    shm = _get_shm()\n    if not shm:\n        return\n    self._put_col_in_shm(self, col, shm, replace=True)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameSimple","title":"<code>ShmDataFrameSimple</code>","text":"<p>               Bases: <code>DataFrame</code></p> <p>pandas DataFrame backed by a single shared-memory block (numeric only).</p> <p>Attributes:</p> Name Type Description <code>block</code> <code>ShmRef</code> <p>Reference to the shared-memory block backing the DataFrame's values.</p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>class ShmDataFrameSimple(pd.DataFrame):\n    \"\"\"\n    pandas DataFrame backed by a single shared-memory block (numeric only).\n\n    Attributes\n    ----------\n    block : ShmRef\n        Reference to the shared-memory block backing the DataFrame's values.\n    \"\"\"\n\n    _metadata = [\"_shm_metadata\"]\n    _shm_metadata: ShmRef\n\n    @classmethod\n    def from_block(\n        cls,\n        block: ShmBlock,\n        nrows: int,\n        ncols: int,\n        columns: list[Any] | None,\n        index: list[Any] | None,\n        dtype: str | np.dtype,\n    ) -&gt; \"ShmDataFrameSimple\":\n        \"\"\"\n        Construct a DataFrame backed by a single SHM block.\n\n        Parameters\n        ----------\n        block : ShmBlock\n            Attached shared-memory block containing a contiguous 2D numeric matrix.\n        nrows, ncols : int\n            DataFrame shape.\n        columns, index : list[Any] or None\n            Column/index labels.\n        dtype : str or numpy.dtype\n            Dtype of the matrix stored in the block.\n\n        Returns\n        -------\n        ShmDataFrameSimple\n        \"\"\"\n        _dtype = np.dtype(dtype)\n        arr = ShmArray.from_block(shape=(ncols, nrows), dtype=_dtype, block=block)\n\n        df = ShmDataFrameSimple(data=arr.T, index=index, columns=columns)\n        df._set_shm_metadata(block.to_ref())\n        return df\n\n    def _set_shm_metadata(self, meta: ShmRef):\n        self._shm_metadata = meta\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameSimple-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameSimple._metadata","title":"<code>_metadata = ['_shm_metadata']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameSimple._shm_metadata","title":"<code>_shm_metadata</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameSimple-functions","title":"Functions","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameSimple.from_block","title":"<code>from_block(block, nrows, ncols, columns, index, dtype)</code>  <code>classmethod</code>","text":"<p>Construct a DataFrame backed by a single SHM block.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>ShmBlock</code> <p>Attached shared-memory block containing a contiguous 2D numeric matrix.</p> required <code>nrows</code> <code>int</code> <p>DataFrame shape.</p> required <code>ncols</code> <code>int</code> <p>DataFrame shape.</p> required <code>columns</code> <code>list[Any] or None</code> <p>Column/index labels.</p> required <code>index</code> <code>list[Any] or None</code> <p>Column/index labels.</p> required <code>dtype</code> <code>str or dtype</code> <p>Dtype of the matrix stored in the block.</p> required <p>Returns:</p> Type Description <code>ShmDataFrameSimple</code> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef from_block(\n    cls,\n    block: ShmBlock,\n    nrows: int,\n    ncols: int,\n    columns: list[Any] | None,\n    index: list[Any] | None,\n    dtype: str | np.dtype,\n) -&gt; \"ShmDataFrameSimple\":\n    \"\"\"\n    Construct a DataFrame backed by a single SHM block.\n\n    Parameters\n    ----------\n    block : ShmBlock\n        Attached shared-memory block containing a contiguous 2D numeric matrix.\n    nrows, ncols : int\n        DataFrame shape.\n    columns, index : list[Any] or None\n        Column/index labels.\n    dtype : str or numpy.dtype\n        Dtype of the matrix stored in the block.\n\n    Returns\n    -------\n    ShmDataFrameSimple\n    \"\"\"\n    _dtype = np.dtype(dtype)\n    arr = ShmArray.from_block(shape=(ncols, nrows), dtype=_dtype, block=block)\n\n    df = ShmDataFrameSimple(data=arr.T, index=index, columns=columns)\n    df._set_shm_metadata(block.to_ref())\n    return df\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmDataFrameSimple._set_shm_metadata","title":"<code>_set_shm_metadata(meta)</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>def _set_shm_metadata(self, meta: ShmRef):\n    self._shm_metadata = meta\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmBlock","title":"<code>ShmBlock</code>  <code>dataclass</code>","text":"<p>Attached shared-memory block (name/size + live <code>SharedMemory</code> handle).</p> Notes <p>This object owns a <code>SharedMemory</code> handle and must be closed when no longer needed. In brmspy this is managed by a <code>ShmPool</code> implementation.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>@dataclass\nclass ShmBlock:\n    \"\"\"\n    Attached shared-memory block (name/size + live `SharedMemory` handle).\n\n    Notes\n    -----\n    This object owns a `SharedMemory` handle and must be closed when no longer\n    needed. In brmspy this is managed by a `ShmPool` implementation.\n    \"\"\"\n\n    name: str\n    size: int\n    content_size: int\n    shm: SharedMemory\n    temporary: bool\n\n    def to_ref(self) -&gt; ShmRef:\n        return {\n            \"name\": self.name,\n            \"size\": self.size,\n            \"content_size\": self.content_size,\n            \"temporary\": self.temporary,\n        }\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmBlock-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmBlock.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmBlock.size","title":"<code>size</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmBlock.content_size","title":"<code>content_size</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmBlock.shm","title":"<code>shm</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmBlock.temporary","title":"<code>temporary</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmBlock-functions","title":"Functions","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmBlock.to_ref","title":"<code>to_ref()</code>","text":"Source code in <code>brmspy/types/shm.py</code> <pre><code>def to_ref(self) -&gt; ShmRef:\n    return {\n        \"name\": self.name,\n        \"size\": self.size,\n        \"content_size\": self.content_size,\n        \"temporary\": self.temporary,\n    }\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmBlock.__init__","title":"<code>__init__(name, size, content_size, shm, temporary)</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmRef","title":"<code>ShmRef</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Reference to a shared-memory block sent over IPC.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Shared memory block name (as assigned by <code>SharedMemoryManager</code>).</p> <code>size</code> <code>int</code> <p>Allocated block size in bytes.</p> <code>content_size</code> <code>int</code> <p>Actual used size</p> <code>temporary</code> <code>bool</code> <p>Whether this buffer can be GC-d immediately after use or should it be attached to object its constructed into.</p> Notes <p>Codecs may store a logical payload smaller than <code>size</code>. In that case, the codec metadata must include the logical <code>nbytes</code>/length so that decoders can slice the buffer appropriately.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>class ShmRef(TypedDict):\n    \"\"\"\n    Reference to a shared-memory block sent over IPC.\n\n    Attributes\n    ----------\n    name : str\n        Shared memory block name (as assigned by `SharedMemoryManager`).\n    size : int\n        Allocated block size in bytes.\n    content_size : int\n        Actual used size\n    temporary : bool\n        Whether this buffer can be GC-d immediately after use or should it be attached to object its constructed into.\n\n    Notes\n    -----\n    Codecs may store a logical payload smaller than `size`. In that case, the\n    codec metadata must include the logical `nbytes`/length so that decoders can\n    slice the buffer appropriately.\n    \"\"\"\n\n    name: str\n    size: int\n    content_size: int\n    temporary: bool\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmRef-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmRef.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmRef.size","title":"<code>size</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmRef.content_size","title":"<code>content_size</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.ShmRef.temporary","title":"<code>temporary</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.NumpyArrayCodec","title":"<code>NumpyArrayCodec</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>SHM-backed codec for <code>numpy.ndarray</code>.</p> Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>class NumpyArrayCodec(Encoder):\n    \"\"\"SHM-backed codec for [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html).\"\"\"\n\n    def can_encode(self, obj: Any) -&gt; bool:\n        return isinstance(obj, np.ndarray)\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n        _, ref, dtype, shape, order = ShmArray.to_shm(obj, shm_pool)\n        return EncodeResult(\n            codec=type(self).__name__,\n            meta={\"dtype\": dtype, \"shape\": shape, \"order\": order},\n            buffers=[ref],\n        )\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        get_buf: Callable[[ShmRef], GetBufContext],\n        *args,\n    ) -&gt; Any:\n        with get_buf(payload[\"buffers\"][0]) as (buf, _):\n            return ShmArray.from_metadata(payload[\"meta\"], buf)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.NumpyArrayCodec-functions","title":"Functions","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.NumpyArrayCodec.can_encode","title":"<code>can_encode(obj)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def can_encode(self, obj: Any) -&gt; bool:\n    return isinstance(obj, np.ndarray)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.NumpyArrayCodec.encode","title":"<code>encode(obj, shm_pool)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n    _, ref, dtype, shape, order = ShmArray.to_shm(obj, shm_pool)\n    return EncodeResult(\n        codec=type(self).__name__,\n        meta={\"dtype\": dtype, \"shape\": shape, \"order\": order},\n        buffers=[ref],\n    )\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.NumpyArrayCodec.decode","title":"<code>decode(payload, get_buf, *args)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    get_buf: Callable[[ShmRef], GetBufContext],\n    *args,\n) -&gt; Any:\n    with get_buf(payload[\"buffers\"][0]) as (buf, _):\n        return ShmArray.from_metadata(payload[\"meta\"], buf)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PandasDFCodec","title":"<code>PandasDFCodec</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>SHM-backed codec for numeric-only <code>pandas.DataFrame</code>.</p> <p>Object-dtype columns are intentionally rejected to avoid surprising implicit conversions; those cases fall back to pickle.</p> Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>class PandasDFCodec(Encoder):\n    \"\"\"\n    SHM-backed codec for numeric-only [`pandas.DataFrame`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).\n\n    Object-dtype columns are intentionally rejected to avoid surprising implicit\n    conversions; those cases fall back to pickle.\n    \"\"\"\n\n    def can_encode(self, obj: Any) -&gt; bool:\n        if not isinstance(obj, pd.DataFrame):\n            return False\n\n        return True\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n        assert isinstance(obj, pd.DataFrame)  # assert type\n\n        meta: dict[str, Any] = {\n            \"columns\": list(obj.columns),\n            \"index\": pickle.dumps(obj.index, protocol=pickle.HIGHEST_PROTOCOL),\n            \"variant\": \"single\",\n        }\n        buffers: list[ShmRef] = []\n\n        if obj.empty:\n            meta[\"variant\"] = \"empty\"\n        elif isinstance(obj, ShmDataFrameSimple):\n            # single dtype matrix\n            meta[\"variant\"] = \"single\"\n            meta[\"dtype\"] = str(obj.values.dtype)\n            meta[\"order\"] = ShmArray.array_order(obj.values)\n            buffers.append(obj._shm_metadata)\n        elif isinstance(obj, ShmDataFrameColumns):\n            # per column buffers\n            meta[\"variant\"] = \"columnar\"\n            meta[\"order\"] = \"F\"\n            meta[\"columns\"] = obj._shm_metadata\n        else:\n            # Fallback: put each column in its own SHM block\n            meta[\"variant\"] = \"columnar\"\n            meta[\"order\"] = \"C\"\n            columns: dict[str, ShmSeriesMetadata] = {}\n\n            for col_name in obj.columns:\n                col = obj[col_name]\n\n                arr_modified, spec, dtype, shape, order = ShmArray.to_shm(col, shm_pool)\n\n                columns[col_name] = ShmDataFrameColumns._create_col_metadata(\n                    obj[col_name], spec, arr_modified\n                )\n            meta[\"columns\"] = columns\n\n        return EncodeResult(codec=type(self).__name__, meta=meta, buffers=buffers)\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        get_buf: Callable[[ShmRef], GetBufContext],\n        *args,\n    ) -&gt; Any:\n        meta = payload[\"meta\"]\n        if meta.get(\"variant\") == \"empty\":\n            return pd.DataFrame({})\n\n        buffer_specs = payload[\"buffers\"]\n\n        index = pickle.loads(meta[\"index\"])\n\n        if meta.get(\"variant\") == \"single\":\n            spec = buffer_specs[0]\n            with get_buf(buffer_specs[0]) as (buf, memview):\n                dtype = np.dtype(meta[\"dtype\"])\n                nbytes = spec[\"size\"]\n                order = meta[\"order\"]\n\n                columns = meta[\"columns\"]\n                shape = (len(index), len(columns))\n\n                # Only use the slice that actually holds array data\n                view = memview[:nbytes]\n                arr = np.ndarray(shape=shape, dtype=dtype, buffer=view, order=order)\n\n                df = ShmDataFrameSimple(data=arr, index=index, columns=columns)\n                df._set_shm_metadata(spec)\n\n                return df\n        elif meta.get(\"variant\") == \"columnar\":\n            columns_metadata: dict[str, ShmSeriesMetadata] = meta[\"columns\"]\n            nrows = len(index)\n\n            columns = list(columns_metadata.keys())\n\n            data: dict[str, pd.Series] = {}\n\n            for i, col_name in enumerate(columns):\n                metadata = columns_metadata[col_name]\n                spec = metadata[\"block\"]\n                dtype = metadata[\"np_dtype\"]\n                with get_buf(spec) as (buf, view):\n                    data[col_name] = ShmDataFrameColumns._reconstruct_series(\n                        metadata, buf, nrows, index\n                    )\n\n            df = ShmDataFrameColumns(data=data)\n            df._set_shm_metadata(columns_metadata)\n\n            return df\n        else:\n            raise Exception(f\"Unknown DataFrame variant {meta.get('variant')}\")\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PandasDFCodec-functions","title":"Functions","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PandasDFCodec.can_encode","title":"<code>can_encode(obj)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def can_encode(self, obj: Any) -&gt; bool:\n    if not isinstance(obj, pd.DataFrame):\n        return False\n\n    return True\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PandasDFCodec.encode","title":"<code>encode(obj, shm_pool)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n    assert isinstance(obj, pd.DataFrame)  # assert type\n\n    meta: dict[str, Any] = {\n        \"columns\": list(obj.columns),\n        \"index\": pickle.dumps(obj.index, protocol=pickle.HIGHEST_PROTOCOL),\n        \"variant\": \"single\",\n    }\n    buffers: list[ShmRef] = []\n\n    if obj.empty:\n        meta[\"variant\"] = \"empty\"\n    elif isinstance(obj, ShmDataFrameSimple):\n        # single dtype matrix\n        meta[\"variant\"] = \"single\"\n        meta[\"dtype\"] = str(obj.values.dtype)\n        meta[\"order\"] = ShmArray.array_order(obj.values)\n        buffers.append(obj._shm_metadata)\n    elif isinstance(obj, ShmDataFrameColumns):\n        # per column buffers\n        meta[\"variant\"] = \"columnar\"\n        meta[\"order\"] = \"F\"\n        meta[\"columns\"] = obj._shm_metadata\n    else:\n        # Fallback: put each column in its own SHM block\n        meta[\"variant\"] = \"columnar\"\n        meta[\"order\"] = \"C\"\n        columns: dict[str, ShmSeriesMetadata] = {}\n\n        for col_name in obj.columns:\n            col = obj[col_name]\n\n            arr_modified, spec, dtype, shape, order = ShmArray.to_shm(col, shm_pool)\n\n            columns[col_name] = ShmDataFrameColumns._create_col_metadata(\n                obj[col_name], spec, arr_modified\n            )\n        meta[\"columns\"] = columns\n\n    return EncodeResult(codec=type(self).__name__, meta=meta, buffers=buffers)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PandasDFCodec.decode","title":"<code>decode(payload, get_buf, *args)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    get_buf: Callable[[ShmRef], GetBufContext],\n    *args,\n) -&gt; Any:\n    meta = payload[\"meta\"]\n    if meta.get(\"variant\") == \"empty\":\n        return pd.DataFrame({})\n\n    buffer_specs = payload[\"buffers\"]\n\n    index = pickle.loads(meta[\"index\"])\n\n    if meta.get(\"variant\") == \"single\":\n        spec = buffer_specs[0]\n        with get_buf(buffer_specs[0]) as (buf, memview):\n            dtype = np.dtype(meta[\"dtype\"])\n            nbytes = spec[\"size\"]\n            order = meta[\"order\"]\n\n            columns = meta[\"columns\"]\n            shape = (len(index), len(columns))\n\n            # Only use the slice that actually holds array data\n            view = memview[:nbytes]\n            arr = np.ndarray(shape=shape, dtype=dtype, buffer=view, order=order)\n\n            df = ShmDataFrameSimple(data=arr, index=index, columns=columns)\n            df._set_shm_metadata(spec)\n\n            return df\n    elif meta.get(\"variant\") == \"columnar\":\n        columns_metadata: dict[str, ShmSeriesMetadata] = meta[\"columns\"]\n        nrows = len(index)\n\n        columns = list(columns_metadata.keys())\n\n        data: dict[str, pd.Series] = {}\n\n        for i, col_name in enumerate(columns):\n            metadata = columns_metadata[col_name]\n            spec = metadata[\"block\"]\n            dtype = metadata[\"np_dtype\"]\n            with get_buf(spec) as (buf, view):\n                data[col_name] = ShmDataFrameColumns._reconstruct_series(\n                    metadata, buf, nrows, index\n                )\n\n        df = ShmDataFrameColumns(data=data)\n        df._set_shm_metadata(columns_metadata)\n\n        return df\n    else:\n        raise Exception(f\"Unknown DataFrame variant {meta.get('variant')}\")\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PickleCodec","title":"<code>PickleCodec</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>Pickle fallback codec (internal).</p> <p>Always encodes successfully, so it must be registered last. The pickled bytes are still stored in SHM to keep pipe traffic small and bounded.</p> Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>class PickleCodec(Encoder):\n    \"\"\"\n    Pickle fallback codec (internal).\n\n    Always encodes successfully, so it must be registered last. The pickled bytes\n    are still stored in SHM to keep pipe traffic small and bounded.\n    \"\"\"\n\n    def can_encode(self, obj: Any) -&gt; bool:\n        # Fallback \u2013 always True\n        return True\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n        if obj is None:\n            return EncodeResult(\n                codec=type(self).__name__,\n                meta={},\n                buffers=[],\n            )\n\n        data = pickle.dumps(obj, protocol=pickle.HIGHEST_PROTOCOL)\n        block = shm_pool.alloc(len(data), temporary=True)\n        block.shm.buf[: len(data)] = data\n\n        # dont waste SHM, use meta instead of buffer\n        meta: dict[str, Any] = {\"length\": len(data)}\n\n        size_bytes = len(data)\n        if size_bytes &gt; ONE_MB * 10:\n            size_mb = size_bytes / ONE_MB\n            log_warning(\n                f\"PickleCodec encoding large object: type={type(obj)}, size={size_mb:,.2f} MB\"\n            )\n\n        return EncodeResult(\n            codec=type(self).__name__,\n            meta=meta,\n            buffers=[block.to_ref()],\n        )\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        get_buf: Callable[[ShmRef], GetBufContext],\n        *args,\n    ) -&gt; Any:\n        specs = payload[\"buffers\"]\n        if len(specs) == 0:\n            return None\n\n        with get_buf(specs[0]) as (block, buf):\n            length = block.content_size\n            b = bytes(buf[:length])\n            return pickle.loads(b)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PickleCodec-functions","title":"Functions","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PickleCodec.can_encode","title":"<code>can_encode(obj)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def can_encode(self, obj: Any) -&gt; bool:\n    # Fallback \u2013 always True\n    return True\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PickleCodec.encode","title":"<code>encode(obj, shm_pool)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n    if obj is None:\n        return EncodeResult(\n            codec=type(self).__name__,\n            meta={},\n            buffers=[],\n        )\n\n    data = pickle.dumps(obj, protocol=pickle.HIGHEST_PROTOCOL)\n    block = shm_pool.alloc(len(data), temporary=True)\n    block.shm.buf[: len(data)] = data\n\n    # dont waste SHM, use meta instead of buffer\n    meta: dict[str, Any] = {\"length\": len(data)}\n\n    size_bytes = len(data)\n    if size_bytes &gt; ONE_MB * 10:\n        size_mb = size_bytes / ONE_MB\n        log_warning(\n            f\"PickleCodec encoding large object: type={type(obj)}, size={size_mb:,.2f} MB\"\n        )\n\n    return EncodeResult(\n        codec=type(self).__name__,\n        meta=meta,\n        buffers=[block.to_ref()],\n    )\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.PickleCodec.decode","title":"<code>decode(payload, get_buf, *args)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    get_buf: Callable[[ShmRef], GetBufContext],\n    *args,\n) -&gt; Any:\n    specs = payload[\"buffers\"]\n    if len(specs) == 0:\n        return None\n\n    with get_buf(specs[0]) as (block, buf):\n        length = block.content_size\n        b = bytes(buf[:length])\n        return pickle.loads(b)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.InferenceDataCodec","title":"<code>InferenceDataCodec</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>Encode arviz.InferenceData by pushing its underlying arrays into shm.</p> Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>class InferenceDataCodec(Encoder):\n    \"\"\"Encode arviz.InferenceData by pushing its underlying arrays into shm.\"\"\"\n\n    def can_encode(self, obj: Any) -&gt; bool:\n        return isinstance(obj, az.InferenceData)\n\n    def encode(self, obj: az.InferenceData, shm_pool: Any) -&gt; EncodeResult:\n        buffers: list[ShmRef] = []\n        groups_meta: dict[str, Any] = {}\n        total_bytes = 0\n\n        # Walk each group: posterior, posterior_predictive, etc.\n        for group_name in obj.groups():\n            ds: xr.Dataset = getattr(obj, group_name)\n            g_meta: dict[str, Any] = {\n                \"data_vars\": {},\n                \"coords\": {},\n            }\n\n            # COORDS: generally smaller, but can be arrays.\n            for cname, coord in ds.coords.items():\n                values = np.asarray(coord.values)\n                if values.dtype.kind in \"iufb\":  # numeric-ish\n                    data = values.tobytes(order=\"C\")\n                    nbytes = len(data)\n                    block = shm_pool.alloc(nbytes)\n                    block.shm.buf[:nbytes] = data\n\n                    buffer_idx = len(buffers)\n                    buffers.append(block.to_ref())\n                    total_bytes += nbytes\n\n                    g_meta[\"coords\"][cname] = {\n                        \"kind\": \"array\",\n                        \"buffer_idx\": buffer_idx,\n                        \"dtype\": str(values.dtype),\n                        \"shape\": list(values.shape),\n                        \"dims\": list(coord.dims),\n                        \"nbytes\": nbytes,\n                    }\n                else:\n                    # Non-numeric / object coords: keep them small &amp; pickle in meta.\n                    g_meta[\"coords\"][cname] = {\n                        \"kind\": \"pickle\",\n                        \"dims\": list(coord.dims),\n                        \"payload\": pickle.dumps(\n                            coord.values, protocol=pickle.HIGHEST_PROTOCOL\n                        ),\n                    }\n\n            # DATA VARS: main heavy arrays\n            for vname, da in ds.data_vars.items():\n                arr = np.asarray(da.data)\n                _, spec, dtype, shape, order = ShmArray.to_shm(arr, shm_pool)\n                meta = {\"dtype\": dtype, \"shape\": shape, \"order\": order}\n                nbytes = spec[\"content_size\"]\n\n                buffer_idx = len(buffers)\n                buffers.append(spec)\n                total_bytes += nbytes\n\n                g_meta[\"data_vars\"][vname] = {\n                    \"buffer_idx\": buffer_idx,\n                    \"dtype\": str(meta[\"dtype\"]),\n                    \"shape\": list(meta[\"shape\"]),\n                    \"dims\": list(da.dims),\n                    \"nbytes\": nbytes,\n                }\n\n            groups_meta[group_name] = g_meta\n\n        meta: dict[str, Any] = {\n            \"groups\": groups_meta,\n            \"codec_version\": 1,\n        }\n\n        return EncodeResult(\n            codec=type(self).__name__,\n            meta=meta,\n            buffers=buffers,\n        )\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        get_buf: Callable[[ShmRef], GetBufContext],\n        *args,\n    ) -&gt; Any:\n        meta = payload[\"meta\"]\n        specs = payload[\"buffers\"]\n        groups_meta = meta[\"groups\"]\n        groups: dict[str, xr.Dataset] = {}\n\n        for group_name, g_meta in groups_meta.items():\n            data_vars = {}\n            coords = {}\n\n            # Rebuild coords\n            for cname, cmeta in g_meta[\"coords\"].items():\n                kind = cmeta[\"kind\"]\n                if kind == \"array\":\n                    spec = specs[cmeta[\"buffer_idx\"]]\n                    with get_buf(spec) as (block, _):\n                        arr = ShmArray.from_block(\n                            block, shape=cmeta[\"shape\"], dtype=np.dtype(cmeta[\"dtype\"])\n                        )\n                        coords[cname] = (tuple(cmeta[\"dims\"]), arr)\n                elif kind == \"pickle\":\n                    values = pickle.loads(cmeta[\"payload\"])\n                    coords[cname] = (tuple(cmeta[\"dims\"]), values)\n                else:\n                    raise ValueError(f\"Unknown coord kind: {kind!r}\")\n\n            # Rebuild data_vars\n            for vname, vmeta in g_meta[\"data_vars\"].items():\n                spec = specs[vmeta[\"buffer_idx\"]]\n                with get_buf(spec) as (block, _):\n                    arr = ShmArray.from_block(\n                        block, vmeta[\"shape\"], dtype=np.dtype(vmeta[\"dtype\"])\n                    )\n                    data_vars[vname] = (tuple(vmeta[\"dims\"]), arr)\n\n            ds = xr.Dataset(\n                data_vars=data_vars,\n                coords=coords,\n            )\n            groups[group_name] = ds\n\n        # Construct InferenceData from datasets\n        idata = az.InferenceData(**groups, warn_on_custom_groups=False)\n        return idata\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.InferenceDataCodec-functions","title":"Functions","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.InferenceDataCodec.can_encode","title":"<code>can_encode(obj)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def can_encode(self, obj: Any) -&gt; bool:\n    return isinstance(obj, az.InferenceData)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.InferenceDataCodec.encode","title":"<code>encode(obj, shm_pool)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def encode(self, obj: az.InferenceData, shm_pool: Any) -&gt; EncodeResult:\n    buffers: list[ShmRef] = []\n    groups_meta: dict[str, Any] = {}\n    total_bytes = 0\n\n    # Walk each group: posterior, posterior_predictive, etc.\n    for group_name in obj.groups():\n        ds: xr.Dataset = getattr(obj, group_name)\n        g_meta: dict[str, Any] = {\n            \"data_vars\": {},\n            \"coords\": {},\n        }\n\n        # COORDS: generally smaller, but can be arrays.\n        for cname, coord in ds.coords.items():\n            values = np.asarray(coord.values)\n            if values.dtype.kind in \"iufb\":  # numeric-ish\n                data = values.tobytes(order=\"C\")\n                nbytes = len(data)\n                block = shm_pool.alloc(nbytes)\n                block.shm.buf[:nbytes] = data\n\n                buffer_idx = len(buffers)\n                buffers.append(block.to_ref())\n                total_bytes += nbytes\n\n                g_meta[\"coords\"][cname] = {\n                    \"kind\": \"array\",\n                    \"buffer_idx\": buffer_idx,\n                    \"dtype\": str(values.dtype),\n                    \"shape\": list(values.shape),\n                    \"dims\": list(coord.dims),\n                    \"nbytes\": nbytes,\n                }\n            else:\n                # Non-numeric / object coords: keep them small &amp; pickle in meta.\n                g_meta[\"coords\"][cname] = {\n                    \"kind\": \"pickle\",\n                    \"dims\": list(coord.dims),\n                    \"payload\": pickle.dumps(\n                        coord.values, protocol=pickle.HIGHEST_PROTOCOL\n                    ),\n                }\n\n        # DATA VARS: main heavy arrays\n        for vname, da in ds.data_vars.items():\n            arr = np.asarray(da.data)\n            _, spec, dtype, shape, order = ShmArray.to_shm(arr, shm_pool)\n            meta = {\"dtype\": dtype, \"shape\": shape, \"order\": order}\n            nbytes = spec[\"content_size\"]\n\n            buffer_idx = len(buffers)\n            buffers.append(spec)\n            total_bytes += nbytes\n\n            g_meta[\"data_vars\"][vname] = {\n                \"buffer_idx\": buffer_idx,\n                \"dtype\": str(meta[\"dtype\"]),\n                \"shape\": list(meta[\"shape\"]),\n                \"dims\": list(da.dims),\n                \"nbytes\": nbytes,\n            }\n\n        groups_meta[group_name] = g_meta\n\n    meta: dict[str, Any] = {\n        \"groups\": groups_meta,\n        \"codec_version\": 1,\n    }\n\n    return EncodeResult(\n        codec=type(self).__name__,\n        meta=meta,\n        buffers=buffers,\n    )\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.InferenceDataCodec.decode","title":"<code>decode(payload, get_buf, *args)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    get_buf: Callable[[ShmRef], GetBufContext],\n    *args,\n) -&gt; Any:\n    meta = payload[\"meta\"]\n    specs = payload[\"buffers\"]\n    groups_meta = meta[\"groups\"]\n    groups: dict[str, xr.Dataset] = {}\n\n    for group_name, g_meta in groups_meta.items():\n        data_vars = {}\n        coords = {}\n\n        # Rebuild coords\n        for cname, cmeta in g_meta[\"coords\"].items():\n            kind = cmeta[\"kind\"]\n            if kind == \"array\":\n                spec = specs[cmeta[\"buffer_idx\"]]\n                with get_buf(spec) as (block, _):\n                    arr = ShmArray.from_block(\n                        block, shape=cmeta[\"shape\"], dtype=np.dtype(cmeta[\"dtype\"])\n                    )\n                    coords[cname] = (tuple(cmeta[\"dims\"]), arr)\n            elif kind == \"pickle\":\n                values = pickle.loads(cmeta[\"payload\"])\n                coords[cname] = (tuple(cmeta[\"dims\"]), values)\n            else:\n                raise ValueError(f\"Unknown coord kind: {kind!r}\")\n\n        # Rebuild data_vars\n        for vname, vmeta in g_meta[\"data_vars\"].items():\n            spec = specs[vmeta[\"buffer_idx\"]]\n            with get_buf(spec) as (block, _):\n                arr = ShmArray.from_block(\n                    block, vmeta[\"shape\"], dtype=np.dtype(vmeta[\"dtype\"])\n                )\n                data_vars[vname] = (tuple(vmeta[\"dims\"]), arr)\n\n        ds = xr.Dataset(\n            data_vars=data_vars,\n            coords=coords,\n        )\n        groups[group_name] = ds\n\n    # Construct InferenceData from datasets\n    idata = az.InferenceData(**groups, warn_on_custom_groups=False)\n    return idata\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.GenericDataClassCodec","title":"<code>GenericDataClassCodec</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>Generic codec for dataclasses (internal).</p> <p>Encodes each <code>init=True</code> field by delegating to a <code>CodecRegistry</code>. Use <code>skip_fields</code> to exclude fields that must not cross the boundary.</p> Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>class GenericDataClassCodec(Encoder):\n    \"\"\"\n    Generic codec for dataclasses (internal).\n\n    Encodes each `init=True` field by delegating to a\n    [`CodecRegistry`][brmspy._session.codec.base.CodecRegistry]. Use `skip_fields` to exclude\n    fields that must not cross the boundary.\n    \"\"\"\n\n    def __init__(\n        self,\n        cls: type[Any],\n        registry: CodecRegistry,\n        *,\n        skip_fields: set[str] | None = None,\n    ) -&gt; None:\n        if not is_dataclass(cls):\n            raise TypeError(f\"{cls!r} is not a dataclass\")\n\n        self._cls = cls\n        self._registry = registry\n        self.codec = f\"dataclass::{cls.__module__}.{cls.__qualname__}\"\n\n        self._skip_fields = skip_fields or set()\n        self._field_names: list[str] = []\n\n        # Precompute which fields we actually encode\n        for f in dc_fields(cls):\n            if not f.init:\n                continue\n            if f.name in self._skip_fields:\n                continue\n            self._field_names.append(f.name)\n\n    def can_encode(self, obj: Any) -&gt; bool:\n        return isinstance(obj, self._cls)\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n        buffers: list[ShmRef] = []\n        fields_meta: dict[str, Any] = {}\n\n        for field_name in self._field_names:\n            value = getattr(obj, field_name)\n\n            # Delegate to registry; chooses right encoder for the actual *runtime* type\n            res = self._registry.encode(value, shm_pool)\n\n            start = len(buffers)\n            count = len(res.buffers)\n\n            fields_meta[field_name] = {\n                \"codec\": res.codec,\n                \"meta\": res.meta,\n                \"start\": start,\n                \"count\": count,\n            }\n\n            buffers.extend(res.buffers)\n\n        meta: dict[str, Any] = {\n            \"module\": self._cls.__module__,\n            \"qualname\": self._cls.__qualname__,\n            \"fields\": fields_meta,\n        }\n\n        return EncodeResult(\n            codec=self.codec,\n            meta=meta,\n            buffers=buffers,\n        )\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        get_buf: Callable[[ShmRef], GetBufContext],\n        *args,\n    ) -&gt; Any:\n        meta = payload[\"meta\"]\n        fields_meta: dict[str, Any] = meta[\"fields\"]\n        kwargs: dict[str, Any] = {}\n\n        assert len(args) &gt; 0\n        pool = args[0]\n\n        specs = payload[\"buffers\"]\n\n        for field_name, fmeta in fields_meta.items():\n            codec_name = fmeta[\"codec\"]\n            start = fmeta[\"start\"]\n            count = fmeta[\"count\"]\n\n            subpayload: PayloadRef = {\n                \"codec\": codec_name,\n                \"meta\": fmeta[\"meta\"],\n                \"buffers\": specs[start : start + count],\n            }\n\n            # IMPORTANT: slice buffer_specs in the same way as buffers\n            value = self._registry.decode(subpayload, pool)\n            kwargs[field_name] = value\n\n        return self._cls(**kwargs)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.GenericDataClassCodec-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.GenericDataClassCodec._cls","title":"<code>_cls = cls</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.GenericDataClassCodec._registry","title":"<code>_registry = registry</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.GenericDataClassCodec.codec","title":"<code>codec = f'dataclass::{cls.__module__}.{cls.__qualname__}'</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.GenericDataClassCodec._skip_fields","title":"<code>_skip_fields = skip_fields or set()</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.GenericDataClassCodec._field_names","title":"<code>_field_names = []</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.GenericDataClassCodec-functions","title":"Functions","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.GenericDataClassCodec.__init__","title":"<code>__init__(cls, registry, *, skip_fields=None)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def __init__(\n    self,\n    cls: type[Any],\n    registry: CodecRegistry,\n    *,\n    skip_fields: set[str] | None = None,\n) -&gt; None:\n    if not is_dataclass(cls):\n        raise TypeError(f\"{cls!r} is not a dataclass\")\n\n    self._cls = cls\n    self._registry = registry\n    self.codec = f\"dataclass::{cls.__module__}.{cls.__qualname__}\"\n\n    self._skip_fields = skip_fields or set()\n    self._field_names: list[str] = []\n\n    # Precompute which fields we actually encode\n    for f in dc_fields(cls):\n        if not f.init:\n            continue\n        if f.name in self._skip_fields:\n            continue\n        self._field_names.append(f.name)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.GenericDataClassCodec.can_encode","title":"<code>can_encode(obj)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def can_encode(self, obj: Any) -&gt; bool:\n    return isinstance(obj, self._cls)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.GenericDataClassCodec.encode","title":"<code>encode(obj, shm_pool)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n    buffers: list[ShmRef] = []\n    fields_meta: dict[str, Any] = {}\n\n    for field_name in self._field_names:\n        value = getattr(obj, field_name)\n\n        # Delegate to registry; chooses right encoder for the actual *runtime* type\n        res = self._registry.encode(value, shm_pool)\n\n        start = len(buffers)\n        count = len(res.buffers)\n\n        fields_meta[field_name] = {\n            \"codec\": res.codec,\n            \"meta\": res.meta,\n            \"start\": start,\n            \"count\": count,\n        }\n\n        buffers.extend(res.buffers)\n\n    meta: dict[str, Any] = {\n        \"module\": self._cls.__module__,\n        \"qualname\": self._cls.__qualname__,\n        \"fields\": fields_meta,\n    }\n\n    return EncodeResult(\n        codec=self.codec,\n        meta=meta,\n        buffers=buffers,\n    )\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.GenericDataClassCodec.decode","title":"<code>decode(payload, get_buf, *args)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    get_buf: Callable[[ShmRef], GetBufContext],\n    *args,\n) -&gt; Any:\n    meta = payload[\"meta\"]\n    fields_meta: dict[str, Any] = meta[\"fields\"]\n    kwargs: dict[str, Any] = {}\n\n    assert len(args) &gt; 0\n    pool = args[0]\n\n    specs = payload[\"buffers\"]\n\n    for field_name, fmeta in fields_meta.items():\n        codec_name = fmeta[\"codec\"]\n        start = fmeta[\"start\"]\n        count = fmeta[\"count\"]\n\n        subpayload: PayloadRef = {\n            \"codec\": codec_name,\n            \"meta\": fmeta[\"meta\"],\n            \"buffers\": specs[start : start + count],\n        }\n\n        # IMPORTANT: slice buffer_specs in the same way as buffers\n        value = self._registry.decode(subpayload, pool)\n        kwargs[field_name] = value\n\n    return self._cls(**kwargs)\n</code></pre>"},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin-functions","title":"Functions","text":""},{"location":"internals/_session/codec/builtin/#brmspy._session.codec.builtin.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/_session/codec/dataclass/","title":"dataclass","text":"<p>Dataclass codec registration (internal).</p> <p>This module registers <code>GenericDataClassCodec</code> for the public dataclasses that may cross the main\u2194worker boundary (primarily result container types and formula DSL nodes).</p> <p>The registry is populated at process startup via <code>get_default_registry()</code>.</p>"},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass._generics","title":"<code>_generics = [_all_types.RListVectorExtension]</code>  <code>module-attribute</code>","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass._classes","title":"<code>_classes = [t for name, t in (_all_types.__dict__.items()) if isinstance(t, type) and is_dataclass(t) and t not in _generics]</code>  <code>module-attribute</code>","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass-classes","title":"Classes","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.CodecRegistry","title":"<code>CodecRegistry</code>","text":"<p>Ordered registry of encoders used for IPC serialization.</p> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>class CodecRegistry:\n    \"\"\"Ordered registry of encoders used for IPC serialization.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._by_codec: dict[str, Encoder] = {}\n        self._encoders: list[Encoder] = []\n\n    def register(self, encoder: Encoder) -&gt; None:\n        \"\"\"\n        Register an encoder instance.\n\n        Parameters\n        ----------\n        encoder : brmspy.types.session.Encoder\n            Encoder to register. Its `codec` attribute is used as the key when present,\n            otherwise the class name is used.\n        \"\"\"\n        if hasattr(encoder, \"codec\") and encoder.codec:  # type: ignore\n            codec_name = encoder.codec  # type: ignore\n        else:\n            codec_name = type(encoder).__name__\n        self._by_codec[codec_name] = encoder\n        encoder.codec = codec_name  # type: ignore\n        self._encoders.append(encoder)\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n        \"\"\"\n        Encode an object by selecting the first encoder that accepts it.\n\n        Parameters\n        ----------\n        obj : Any\n            Value to encode.\n        shm_pool : Any\n            SHM pool used by codecs for allocating buffers.\n\n        Returns\n        -------\n        brmspy.types.session.EncodeResult\n        \"\"\"\n        for enc in self._encoders:\n            if enc.can_encode(obj):\n                res = enc.encode(obj, shm_pool)\n                if not res.codec:\n                    res.codec = type(enc).__name__\n                return res\n\n        # fallback to pickle\n        if \"PickleCodec\" not in self._by_codec:\n            raise RuntimeError(\"No pickle codec registered\")\n        return self._by_codec[\"PickleCodec\"].encode(obj, shm_pool)\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        shm_pool: Any,\n    ) -&gt; Any:\n        \"\"\"\n        Decode a payload using a named codec.\n\n        Parameters\n        ----------\n        codec : str\n            Codec identifier previously returned by `encode()`.\n        meta : dict[str, Any]\n            Codec metadata.\n        buffers : list[memoryview]\n            Memoryviews for attached SHM buffers.\n        buffer_specs : list[dict]\n            Original buffer specs (name/size) corresponding to `buffers`.\n        shm_pool : Any\n            SHM pool (some codecs may attach additional buffers).\n\n        Returns\n        -------\n        Any\n        \"\"\"\n        codec = payload[\"codec\"]\n        if codec not in self._by_codec:\n            raise ValueError(\n                f\"Unknown codec: {codec}, available: {list(self._by_codec.keys())}\"\n            )\n\n        buffers = []\n\n        @contextmanager\n        def get_buf(ref: ShmRef) -&gt; Iterator[tuple[ShmBlock, memoryview]]:\n            buf = shm_pool.attach(ref)\n            memview = memoryview(buf.shm.buf)\n            view = memview[: ref[\"content_size\"]].cast(\"B\")\n\n            try:\n                if not ref[\"temporary\"]:\n                    # non-temporary buffers are associated with columns / objects\n                    buffers.append(buf)\n\n                yield buf, view\n\n            finally:\n                # deterministic cleanup for temporary buffers\n                if ref[\"temporary\"]:\n                    # IMPORTANT: release view before closing shm\n                    try:\n                        view.release()\n                        memview.release()\n                        shm_pool.gc(ref[\"name\"])\n                        buf.shm.close()\n                    except:\n                        pass\n\n        value = self._by_codec[codec].decode(payload, get_buf, shm_pool)\n        self._attach_shm_lifetime(value, buffers)\n\n        return value\n\n    @classmethod\n    def _attach_shm_lifetime(cls, obj: Any, shms: list[ShmBlock]) -&gt; None:\n        \"\"\"Keep SHM blocks alive as long as `obj` is alive.\"\"\"\n        if not shms:\n            return\n        if obj is None or isinstance(obj, (bool, str, int, float)):\n            return\n\n        try:\n            weakref.finalize(obj, _noop, tuple(shms))\n        except:\n            return\n</code></pre>"},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.CodecRegistry-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.CodecRegistry._by_codec","title":"<code>_by_codec = {}</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.CodecRegistry._encoders","title":"<code>_encoders = []</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.CodecRegistry-functions","title":"Functions","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.CodecRegistry.__init__","title":"<code>__init__()</code>","text":"Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._by_codec: dict[str, Encoder] = {}\n    self._encoders: list[Encoder] = []\n</code></pre>"},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.CodecRegistry.register","title":"<code>register(encoder)</code>","text":"<p>Register an encoder instance.</p> <p>Parameters:</p> Name Type Description Default <code>encoder</code> <code>Encoder</code> <p>Encoder to register. Its <code>codec</code> attribute is used as the key when present, otherwise the class name is used.</p> required Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def register(self, encoder: Encoder) -&gt; None:\n    \"\"\"\n    Register an encoder instance.\n\n    Parameters\n    ----------\n    encoder : brmspy.types.session.Encoder\n        Encoder to register. Its `codec` attribute is used as the key when present,\n        otherwise the class name is used.\n    \"\"\"\n    if hasattr(encoder, \"codec\") and encoder.codec:  # type: ignore\n        codec_name = encoder.codec  # type: ignore\n    else:\n        codec_name = type(encoder).__name__\n    self._by_codec[codec_name] = encoder\n    encoder.codec = codec_name  # type: ignore\n    self._encoders.append(encoder)\n</code></pre>"},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.CodecRegistry.encode","title":"<code>encode(obj, shm_pool)</code>","text":"<p>Encode an object by selecting the first encoder that accepts it.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Value to encode.</p> required <code>shm_pool</code> <code>Any</code> <p>SHM pool used by codecs for allocating buffers.</p> required <p>Returns:</p> Type Description <code>EncodeResult</code> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n    \"\"\"\n    Encode an object by selecting the first encoder that accepts it.\n\n    Parameters\n    ----------\n    obj : Any\n        Value to encode.\n    shm_pool : Any\n        SHM pool used by codecs for allocating buffers.\n\n    Returns\n    -------\n    brmspy.types.session.EncodeResult\n    \"\"\"\n    for enc in self._encoders:\n        if enc.can_encode(obj):\n            res = enc.encode(obj, shm_pool)\n            if not res.codec:\n                res.codec = type(enc).__name__\n            return res\n\n    # fallback to pickle\n    if \"PickleCodec\" not in self._by_codec:\n        raise RuntimeError(\"No pickle codec registered\")\n    return self._by_codec[\"PickleCodec\"].encode(obj, shm_pool)\n</code></pre>"},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.CodecRegistry.decode","title":"<code>decode(payload, shm_pool)</code>","text":"<p>Decode a payload using a named codec.</p> <p>Parameters:</p> Name Type Description Default <code>codec</code> <code>str</code> <p>Codec identifier previously returned by <code>encode()</code>.</p> required <code>meta</code> <code>dict[str, Any]</code> <p>Codec metadata.</p> required <code>buffers</code> <code>list[memoryview]</code> <p>Memoryviews for attached SHM buffers.</p> required <code>buffer_specs</code> <code>list[dict]</code> <p>Original buffer specs (name/size) corresponding to <code>buffers</code>.</p> required <code>shm_pool</code> <code>Any</code> <p>SHM pool (some codecs may attach additional buffers).</p> required <p>Returns:</p> Type Description <code>Any</code> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    shm_pool: Any,\n) -&gt; Any:\n    \"\"\"\n    Decode a payload using a named codec.\n\n    Parameters\n    ----------\n    codec : str\n        Codec identifier previously returned by `encode()`.\n    meta : dict[str, Any]\n        Codec metadata.\n    buffers : list[memoryview]\n        Memoryviews for attached SHM buffers.\n    buffer_specs : list[dict]\n        Original buffer specs (name/size) corresponding to `buffers`.\n    shm_pool : Any\n        SHM pool (some codecs may attach additional buffers).\n\n    Returns\n    -------\n    Any\n    \"\"\"\n    codec = payload[\"codec\"]\n    if codec not in self._by_codec:\n        raise ValueError(\n            f\"Unknown codec: {codec}, available: {list(self._by_codec.keys())}\"\n        )\n\n    buffers = []\n\n    @contextmanager\n    def get_buf(ref: ShmRef) -&gt; Iterator[tuple[ShmBlock, memoryview]]:\n        buf = shm_pool.attach(ref)\n        memview = memoryview(buf.shm.buf)\n        view = memview[: ref[\"content_size\"]].cast(\"B\")\n\n        try:\n            if not ref[\"temporary\"]:\n                # non-temporary buffers are associated with columns / objects\n                buffers.append(buf)\n\n            yield buf, view\n\n        finally:\n            # deterministic cleanup for temporary buffers\n            if ref[\"temporary\"]:\n                # IMPORTANT: release view before closing shm\n                try:\n                    view.release()\n                    memview.release()\n                    shm_pool.gc(ref[\"name\"])\n                    buf.shm.close()\n                except:\n                    pass\n\n    value = self._by_codec[codec].decode(payload, get_buf, shm_pool)\n    self._attach_shm_lifetime(value, buffers)\n\n    return value\n</code></pre>"},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.CodecRegistry._attach_shm_lifetime","title":"<code>_attach_shm_lifetime(obj, shms)</code>  <code>classmethod</code>","text":"<p>Keep SHM blocks alive as long as <code>obj</code> is alive.</p> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>@classmethod\ndef _attach_shm_lifetime(cls, obj: Any, shms: list[ShmBlock]) -&gt; None:\n    \"\"\"Keep SHM blocks alive as long as `obj` is alive.\"\"\"\n    if not shms:\n        return\n    if obj is None or isinstance(obj, (bool, str, int, float)):\n        return\n\n    try:\n        weakref.finalize(obj, _noop, tuple(shms))\n    except:\n        return\n</code></pre>"},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.GenericDataClassCodec","title":"<code>GenericDataClassCodec</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>Generic codec for dataclasses (internal).</p> <p>Encodes each <code>init=True</code> field by delegating to a <code>CodecRegistry</code>. Use <code>skip_fields</code> to exclude fields that must not cross the boundary.</p> Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>class GenericDataClassCodec(Encoder):\n    \"\"\"\n    Generic codec for dataclasses (internal).\n\n    Encodes each `init=True` field by delegating to a\n    [`CodecRegistry`][brmspy._session.codec.base.CodecRegistry]. Use `skip_fields` to exclude\n    fields that must not cross the boundary.\n    \"\"\"\n\n    def __init__(\n        self,\n        cls: type[Any],\n        registry: CodecRegistry,\n        *,\n        skip_fields: set[str] | None = None,\n    ) -&gt; None:\n        if not is_dataclass(cls):\n            raise TypeError(f\"{cls!r} is not a dataclass\")\n\n        self._cls = cls\n        self._registry = registry\n        self.codec = f\"dataclass::{cls.__module__}.{cls.__qualname__}\"\n\n        self._skip_fields = skip_fields or set()\n        self._field_names: list[str] = []\n\n        # Precompute which fields we actually encode\n        for f in dc_fields(cls):\n            if not f.init:\n                continue\n            if f.name in self._skip_fields:\n                continue\n            self._field_names.append(f.name)\n\n    def can_encode(self, obj: Any) -&gt; bool:\n        return isinstance(obj, self._cls)\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n        buffers: list[ShmRef] = []\n        fields_meta: dict[str, Any] = {}\n\n        for field_name in self._field_names:\n            value = getattr(obj, field_name)\n\n            # Delegate to registry; chooses right encoder for the actual *runtime* type\n            res = self._registry.encode(value, shm_pool)\n\n            start = len(buffers)\n            count = len(res.buffers)\n\n            fields_meta[field_name] = {\n                \"codec\": res.codec,\n                \"meta\": res.meta,\n                \"start\": start,\n                \"count\": count,\n            }\n\n            buffers.extend(res.buffers)\n\n        meta: dict[str, Any] = {\n            \"module\": self._cls.__module__,\n            \"qualname\": self._cls.__qualname__,\n            \"fields\": fields_meta,\n        }\n\n        return EncodeResult(\n            codec=self.codec,\n            meta=meta,\n            buffers=buffers,\n        )\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        get_buf: Callable[[ShmRef], GetBufContext],\n        *args,\n    ) -&gt; Any:\n        meta = payload[\"meta\"]\n        fields_meta: dict[str, Any] = meta[\"fields\"]\n        kwargs: dict[str, Any] = {}\n\n        assert len(args) &gt; 0\n        pool = args[0]\n\n        specs = payload[\"buffers\"]\n\n        for field_name, fmeta in fields_meta.items():\n            codec_name = fmeta[\"codec\"]\n            start = fmeta[\"start\"]\n            count = fmeta[\"count\"]\n\n            subpayload: PayloadRef = {\n                \"codec\": codec_name,\n                \"meta\": fmeta[\"meta\"],\n                \"buffers\": specs[start : start + count],\n            }\n\n            # IMPORTANT: slice buffer_specs in the same way as buffers\n            value = self._registry.decode(subpayload, pool)\n            kwargs[field_name] = value\n\n        return self._cls(**kwargs)\n</code></pre>"},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.GenericDataClassCodec-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.GenericDataClassCodec._cls","title":"<code>_cls = cls</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.GenericDataClassCodec._registry","title":"<code>_registry = registry</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.GenericDataClassCodec.codec","title":"<code>codec = f'dataclass::{cls.__module__}.{cls.__qualname__}'</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.GenericDataClassCodec._skip_fields","title":"<code>_skip_fields = skip_fields or set()</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.GenericDataClassCodec._field_names","title":"<code>_field_names = []</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.GenericDataClassCodec-functions","title":"Functions","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.GenericDataClassCodec.__init__","title":"<code>__init__(cls, registry, *, skip_fields=None)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def __init__(\n    self,\n    cls: type[Any],\n    registry: CodecRegistry,\n    *,\n    skip_fields: set[str] | None = None,\n) -&gt; None:\n    if not is_dataclass(cls):\n        raise TypeError(f\"{cls!r} is not a dataclass\")\n\n    self._cls = cls\n    self._registry = registry\n    self.codec = f\"dataclass::{cls.__module__}.{cls.__qualname__}\"\n\n    self._skip_fields = skip_fields or set()\n    self._field_names: list[str] = []\n\n    # Precompute which fields we actually encode\n    for f in dc_fields(cls):\n        if not f.init:\n            continue\n        if f.name in self._skip_fields:\n            continue\n        self._field_names.append(f.name)\n</code></pre>"},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.GenericDataClassCodec.can_encode","title":"<code>can_encode(obj)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def can_encode(self, obj: Any) -&gt; bool:\n    return isinstance(obj, self._cls)\n</code></pre>"},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.GenericDataClassCodec.encode","title":"<code>encode(obj, shm_pool)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n    buffers: list[ShmRef] = []\n    fields_meta: dict[str, Any] = {}\n\n    for field_name in self._field_names:\n        value = getattr(obj, field_name)\n\n        # Delegate to registry; chooses right encoder for the actual *runtime* type\n        res = self._registry.encode(value, shm_pool)\n\n        start = len(buffers)\n        count = len(res.buffers)\n\n        fields_meta[field_name] = {\n            \"codec\": res.codec,\n            \"meta\": res.meta,\n            \"start\": start,\n            \"count\": count,\n        }\n\n        buffers.extend(res.buffers)\n\n    meta: dict[str, Any] = {\n        \"module\": self._cls.__module__,\n        \"qualname\": self._cls.__qualname__,\n        \"fields\": fields_meta,\n    }\n\n    return EncodeResult(\n        codec=self.codec,\n        meta=meta,\n        buffers=buffers,\n    )\n</code></pre>"},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.GenericDataClassCodec.decode","title":"<code>decode(payload, get_buf, *args)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    get_buf: Callable[[ShmRef], GetBufContext],\n    *args,\n) -&gt; Any:\n    meta = payload[\"meta\"]\n    fields_meta: dict[str, Any] = meta[\"fields\"]\n    kwargs: dict[str, Any] = {}\n\n    assert len(args) &gt; 0\n    pool = args[0]\n\n    specs = payload[\"buffers\"]\n\n    for field_name, fmeta in fields_meta.items():\n        codec_name = fmeta[\"codec\"]\n        start = fmeta[\"start\"]\n        count = fmeta[\"count\"]\n\n        subpayload: PayloadRef = {\n            \"codec\": codec_name,\n            \"meta\": fmeta[\"meta\"],\n            \"buffers\": specs[start : start + count],\n        }\n\n        # IMPORTANT: slice buffer_specs in the same way as buffers\n        value = self._registry.decode(subpayload, pool)\n        kwargs[field_name] = value\n\n    return self._cls(**kwargs)\n</code></pre>"},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass-functions","title":"Functions","text":""},{"location":"internals/_session/codec/dataclass/#brmspy._session.codec.dataclass.register_dataclasses","title":"<code>register_dataclasses(registry)</code>","text":"<p>Register codecs for known dataclass types.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>CodecRegistry</code> <p>Registry to populate.</p> required Source code in <code>brmspy/_session/codec/dataclass.py</code> <pre><code>def register_dataclasses(registry: CodecRegistry) -&gt; None:\n    \"\"\"\n    Register codecs for known dataclass types.\n\n    Parameters\n    ----------\n    registry : brmspy._session.codec.base.CodecRegistry\n        Registry to populate.\n    \"\"\"\n    for _cls in _classes:\n        codec = GenericDataClassCodec(cls=_cls, registry=registry)\n        registry.register(codec)\n</code></pre>"},{"location":"internals/_session/codec/registry/","title":"registry","text":"<p>Codec registry construction helpers (internal).</p> <p>The session layer uses a single default <code>CodecRegistry</code> instance per process. The registry is ordered: the first codec that accepts a value wins, so the registration order is significant.</p> <p>Important invariants: - SHM-backed codecs should be registered before pickle. - Pickle fallback MUST be registered last.</p>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry._default_registry","title":"<code>_default_registry = None</code>  <code>module-attribute</code>","text":""},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry-classes","title":"Classes","text":""},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.CodecRegistry","title":"<code>CodecRegistry</code>","text":"<p>Ordered registry of encoders used for IPC serialization.</p> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>class CodecRegistry:\n    \"\"\"Ordered registry of encoders used for IPC serialization.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._by_codec: dict[str, Encoder] = {}\n        self._encoders: list[Encoder] = []\n\n    def register(self, encoder: Encoder) -&gt; None:\n        \"\"\"\n        Register an encoder instance.\n\n        Parameters\n        ----------\n        encoder : brmspy.types.session.Encoder\n            Encoder to register. Its `codec` attribute is used as the key when present,\n            otherwise the class name is used.\n        \"\"\"\n        if hasattr(encoder, \"codec\") and encoder.codec:  # type: ignore\n            codec_name = encoder.codec  # type: ignore\n        else:\n            codec_name = type(encoder).__name__\n        self._by_codec[codec_name] = encoder\n        encoder.codec = codec_name  # type: ignore\n        self._encoders.append(encoder)\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n        \"\"\"\n        Encode an object by selecting the first encoder that accepts it.\n\n        Parameters\n        ----------\n        obj : Any\n            Value to encode.\n        shm_pool : Any\n            SHM pool used by codecs for allocating buffers.\n\n        Returns\n        -------\n        brmspy.types.session.EncodeResult\n        \"\"\"\n        for enc in self._encoders:\n            if enc.can_encode(obj):\n                res = enc.encode(obj, shm_pool)\n                if not res.codec:\n                    res.codec = type(enc).__name__\n                return res\n\n        # fallback to pickle\n        if \"PickleCodec\" not in self._by_codec:\n            raise RuntimeError(\"No pickle codec registered\")\n        return self._by_codec[\"PickleCodec\"].encode(obj, shm_pool)\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        shm_pool: Any,\n    ) -&gt; Any:\n        \"\"\"\n        Decode a payload using a named codec.\n\n        Parameters\n        ----------\n        codec : str\n            Codec identifier previously returned by `encode()`.\n        meta : dict[str, Any]\n            Codec metadata.\n        buffers : list[memoryview]\n            Memoryviews for attached SHM buffers.\n        buffer_specs : list[dict]\n            Original buffer specs (name/size) corresponding to `buffers`.\n        shm_pool : Any\n            SHM pool (some codecs may attach additional buffers).\n\n        Returns\n        -------\n        Any\n        \"\"\"\n        codec = payload[\"codec\"]\n        if codec not in self._by_codec:\n            raise ValueError(\n                f\"Unknown codec: {codec}, available: {list(self._by_codec.keys())}\"\n            )\n\n        buffers = []\n\n        @contextmanager\n        def get_buf(ref: ShmRef) -&gt; Iterator[tuple[ShmBlock, memoryview]]:\n            buf = shm_pool.attach(ref)\n            memview = memoryview(buf.shm.buf)\n            view = memview[: ref[\"content_size\"]].cast(\"B\")\n\n            try:\n                if not ref[\"temporary\"]:\n                    # non-temporary buffers are associated with columns / objects\n                    buffers.append(buf)\n\n                yield buf, view\n\n            finally:\n                # deterministic cleanup for temporary buffers\n                if ref[\"temporary\"]:\n                    # IMPORTANT: release view before closing shm\n                    try:\n                        view.release()\n                        memview.release()\n                        shm_pool.gc(ref[\"name\"])\n                        buf.shm.close()\n                    except:\n                        pass\n\n        value = self._by_codec[codec].decode(payload, get_buf, shm_pool)\n        self._attach_shm_lifetime(value, buffers)\n\n        return value\n\n    @classmethod\n    def _attach_shm_lifetime(cls, obj: Any, shms: list[ShmBlock]) -&gt; None:\n        \"\"\"Keep SHM blocks alive as long as `obj` is alive.\"\"\"\n        if not shms:\n            return\n        if obj is None or isinstance(obj, (bool, str, int, float)):\n            return\n\n        try:\n            weakref.finalize(obj, _noop, tuple(shms))\n        except:\n            return\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.CodecRegistry-attributes","title":"Attributes","text":""},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.CodecRegistry._by_codec","title":"<code>_by_codec = {}</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.CodecRegistry._encoders","title":"<code>_encoders = []</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.CodecRegistry-functions","title":"Functions","text":""},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.CodecRegistry.__init__","title":"<code>__init__()</code>","text":"Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._by_codec: dict[str, Encoder] = {}\n    self._encoders: list[Encoder] = []\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.CodecRegistry.register","title":"<code>register(encoder)</code>","text":"<p>Register an encoder instance.</p> <p>Parameters:</p> Name Type Description Default <code>encoder</code> <code>Encoder</code> <p>Encoder to register. Its <code>codec</code> attribute is used as the key when present, otherwise the class name is used.</p> required Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def register(self, encoder: Encoder) -&gt; None:\n    \"\"\"\n    Register an encoder instance.\n\n    Parameters\n    ----------\n    encoder : brmspy.types.session.Encoder\n        Encoder to register. Its `codec` attribute is used as the key when present,\n        otherwise the class name is used.\n    \"\"\"\n    if hasattr(encoder, \"codec\") and encoder.codec:  # type: ignore\n        codec_name = encoder.codec  # type: ignore\n    else:\n        codec_name = type(encoder).__name__\n    self._by_codec[codec_name] = encoder\n    encoder.codec = codec_name  # type: ignore\n    self._encoders.append(encoder)\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.CodecRegistry.encode","title":"<code>encode(obj, shm_pool)</code>","text":"<p>Encode an object by selecting the first encoder that accepts it.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Value to encode.</p> required <code>shm_pool</code> <code>Any</code> <p>SHM pool used by codecs for allocating buffers.</p> required <p>Returns:</p> Type Description <code>EncodeResult</code> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n    \"\"\"\n    Encode an object by selecting the first encoder that accepts it.\n\n    Parameters\n    ----------\n    obj : Any\n        Value to encode.\n    shm_pool : Any\n        SHM pool used by codecs for allocating buffers.\n\n    Returns\n    -------\n    brmspy.types.session.EncodeResult\n    \"\"\"\n    for enc in self._encoders:\n        if enc.can_encode(obj):\n            res = enc.encode(obj, shm_pool)\n            if not res.codec:\n                res.codec = type(enc).__name__\n            return res\n\n    # fallback to pickle\n    if \"PickleCodec\" not in self._by_codec:\n        raise RuntimeError(\"No pickle codec registered\")\n    return self._by_codec[\"PickleCodec\"].encode(obj, shm_pool)\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.CodecRegistry.decode","title":"<code>decode(payload, shm_pool)</code>","text":"<p>Decode a payload using a named codec.</p> <p>Parameters:</p> Name Type Description Default <code>codec</code> <code>str</code> <p>Codec identifier previously returned by <code>encode()</code>.</p> required <code>meta</code> <code>dict[str, Any]</code> <p>Codec metadata.</p> required <code>buffers</code> <code>list[memoryview]</code> <p>Memoryviews for attached SHM buffers.</p> required <code>buffer_specs</code> <code>list[dict]</code> <p>Original buffer specs (name/size) corresponding to <code>buffers</code>.</p> required <code>shm_pool</code> <code>Any</code> <p>SHM pool (some codecs may attach additional buffers).</p> required <p>Returns:</p> Type Description <code>Any</code> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    shm_pool: Any,\n) -&gt; Any:\n    \"\"\"\n    Decode a payload using a named codec.\n\n    Parameters\n    ----------\n    codec : str\n        Codec identifier previously returned by `encode()`.\n    meta : dict[str, Any]\n        Codec metadata.\n    buffers : list[memoryview]\n        Memoryviews for attached SHM buffers.\n    buffer_specs : list[dict]\n        Original buffer specs (name/size) corresponding to `buffers`.\n    shm_pool : Any\n        SHM pool (some codecs may attach additional buffers).\n\n    Returns\n    -------\n    Any\n    \"\"\"\n    codec = payload[\"codec\"]\n    if codec not in self._by_codec:\n        raise ValueError(\n            f\"Unknown codec: {codec}, available: {list(self._by_codec.keys())}\"\n        )\n\n    buffers = []\n\n    @contextmanager\n    def get_buf(ref: ShmRef) -&gt; Iterator[tuple[ShmBlock, memoryview]]:\n        buf = shm_pool.attach(ref)\n        memview = memoryview(buf.shm.buf)\n        view = memview[: ref[\"content_size\"]].cast(\"B\")\n\n        try:\n            if not ref[\"temporary\"]:\n                # non-temporary buffers are associated with columns / objects\n                buffers.append(buf)\n\n            yield buf, view\n\n        finally:\n            # deterministic cleanup for temporary buffers\n            if ref[\"temporary\"]:\n                # IMPORTANT: release view before closing shm\n                try:\n                    view.release()\n                    memview.release()\n                    shm_pool.gc(ref[\"name\"])\n                    buf.shm.close()\n                except:\n                    pass\n\n    value = self._by_codec[codec].decode(payload, get_buf, shm_pool)\n    self._attach_shm_lifetime(value, buffers)\n\n    return value\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.CodecRegistry._attach_shm_lifetime","title":"<code>_attach_shm_lifetime(obj, shms)</code>  <code>classmethod</code>","text":"<p>Keep SHM blocks alive as long as <code>obj</code> is alive.</p> Source code in <code>brmspy/_session/codec/base.py</code> <pre><code>@classmethod\ndef _attach_shm_lifetime(cls, obj: Any, shms: list[ShmBlock]) -&gt; None:\n    \"\"\"Keep SHM blocks alive as long as `obj` is alive.\"\"\"\n    if not shms:\n        return\n    if obj is None or isinstance(obj, (bool, str, int, float)):\n        return\n\n    try:\n        weakref.finalize(obj, _noop, tuple(shms))\n    except:\n        return\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.InferenceDataCodec","title":"<code>InferenceDataCodec</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>Encode arviz.InferenceData by pushing its underlying arrays into shm.</p> Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>class InferenceDataCodec(Encoder):\n    \"\"\"Encode arviz.InferenceData by pushing its underlying arrays into shm.\"\"\"\n\n    def can_encode(self, obj: Any) -&gt; bool:\n        return isinstance(obj, az.InferenceData)\n\n    def encode(self, obj: az.InferenceData, shm_pool: Any) -&gt; EncodeResult:\n        buffers: list[ShmRef] = []\n        groups_meta: dict[str, Any] = {}\n        total_bytes = 0\n\n        # Walk each group: posterior, posterior_predictive, etc.\n        for group_name in obj.groups():\n            ds: xr.Dataset = getattr(obj, group_name)\n            g_meta: dict[str, Any] = {\n                \"data_vars\": {},\n                \"coords\": {},\n            }\n\n            # COORDS: generally smaller, but can be arrays.\n            for cname, coord in ds.coords.items():\n                values = np.asarray(coord.values)\n                if values.dtype.kind in \"iufb\":  # numeric-ish\n                    data = values.tobytes(order=\"C\")\n                    nbytes = len(data)\n                    block = shm_pool.alloc(nbytes)\n                    block.shm.buf[:nbytes] = data\n\n                    buffer_idx = len(buffers)\n                    buffers.append(block.to_ref())\n                    total_bytes += nbytes\n\n                    g_meta[\"coords\"][cname] = {\n                        \"kind\": \"array\",\n                        \"buffer_idx\": buffer_idx,\n                        \"dtype\": str(values.dtype),\n                        \"shape\": list(values.shape),\n                        \"dims\": list(coord.dims),\n                        \"nbytes\": nbytes,\n                    }\n                else:\n                    # Non-numeric / object coords: keep them small &amp; pickle in meta.\n                    g_meta[\"coords\"][cname] = {\n                        \"kind\": \"pickle\",\n                        \"dims\": list(coord.dims),\n                        \"payload\": pickle.dumps(\n                            coord.values, protocol=pickle.HIGHEST_PROTOCOL\n                        ),\n                    }\n\n            # DATA VARS: main heavy arrays\n            for vname, da in ds.data_vars.items():\n                arr = np.asarray(da.data)\n                _, spec, dtype, shape, order = ShmArray.to_shm(arr, shm_pool)\n                meta = {\"dtype\": dtype, \"shape\": shape, \"order\": order}\n                nbytes = spec[\"content_size\"]\n\n                buffer_idx = len(buffers)\n                buffers.append(spec)\n                total_bytes += nbytes\n\n                g_meta[\"data_vars\"][vname] = {\n                    \"buffer_idx\": buffer_idx,\n                    \"dtype\": str(meta[\"dtype\"]),\n                    \"shape\": list(meta[\"shape\"]),\n                    \"dims\": list(da.dims),\n                    \"nbytes\": nbytes,\n                }\n\n            groups_meta[group_name] = g_meta\n\n        meta: dict[str, Any] = {\n            \"groups\": groups_meta,\n            \"codec_version\": 1,\n        }\n\n        return EncodeResult(\n            codec=type(self).__name__,\n            meta=meta,\n            buffers=buffers,\n        )\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        get_buf: Callable[[ShmRef], GetBufContext],\n        *args,\n    ) -&gt; Any:\n        meta = payload[\"meta\"]\n        specs = payload[\"buffers\"]\n        groups_meta = meta[\"groups\"]\n        groups: dict[str, xr.Dataset] = {}\n\n        for group_name, g_meta in groups_meta.items():\n            data_vars = {}\n            coords = {}\n\n            # Rebuild coords\n            for cname, cmeta in g_meta[\"coords\"].items():\n                kind = cmeta[\"kind\"]\n                if kind == \"array\":\n                    spec = specs[cmeta[\"buffer_idx\"]]\n                    with get_buf(spec) as (block, _):\n                        arr = ShmArray.from_block(\n                            block, shape=cmeta[\"shape\"], dtype=np.dtype(cmeta[\"dtype\"])\n                        )\n                        coords[cname] = (tuple(cmeta[\"dims\"]), arr)\n                elif kind == \"pickle\":\n                    values = pickle.loads(cmeta[\"payload\"])\n                    coords[cname] = (tuple(cmeta[\"dims\"]), values)\n                else:\n                    raise ValueError(f\"Unknown coord kind: {kind!r}\")\n\n            # Rebuild data_vars\n            for vname, vmeta in g_meta[\"data_vars\"].items():\n                spec = specs[vmeta[\"buffer_idx\"]]\n                with get_buf(spec) as (block, _):\n                    arr = ShmArray.from_block(\n                        block, vmeta[\"shape\"], dtype=np.dtype(vmeta[\"dtype\"])\n                    )\n                    data_vars[vname] = (tuple(vmeta[\"dims\"]), arr)\n\n            ds = xr.Dataset(\n                data_vars=data_vars,\n                coords=coords,\n            )\n            groups[group_name] = ds\n\n        # Construct InferenceData from datasets\n        idata = az.InferenceData(**groups, warn_on_custom_groups=False)\n        return idata\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.InferenceDataCodec-functions","title":"Functions","text":""},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.InferenceDataCodec.can_encode","title":"<code>can_encode(obj)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def can_encode(self, obj: Any) -&gt; bool:\n    return isinstance(obj, az.InferenceData)\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.InferenceDataCodec.encode","title":"<code>encode(obj, shm_pool)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def encode(self, obj: az.InferenceData, shm_pool: Any) -&gt; EncodeResult:\n    buffers: list[ShmRef] = []\n    groups_meta: dict[str, Any] = {}\n    total_bytes = 0\n\n    # Walk each group: posterior, posterior_predictive, etc.\n    for group_name in obj.groups():\n        ds: xr.Dataset = getattr(obj, group_name)\n        g_meta: dict[str, Any] = {\n            \"data_vars\": {},\n            \"coords\": {},\n        }\n\n        # COORDS: generally smaller, but can be arrays.\n        for cname, coord in ds.coords.items():\n            values = np.asarray(coord.values)\n            if values.dtype.kind in \"iufb\":  # numeric-ish\n                data = values.tobytes(order=\"C\")\n                nbytes = len(data)\n                block = shm_pool.alloc(nbytes)\n                block.shm.buf[:nbytes] = data\n\n                buffer_idx = len(buffers)\n                buffers.append(block.to_ref())\n                total_bytes += nbytes\n\n                g_meta[\"coords\"][cname] = {\n                    \"kind\": \"array\",\n                    \"buffer_idx\": buffer_idx,\n                    \"dtype\": str(values.dtype),\n                    \"shape\": list(values.shape),\n                    \"dims\": list(coord.dims),\n                    \"nbytes\": nbytes,\n                }\n            else:\n                # Non-numeric / object coords: keep them small &amp; pickle in meta.\n                g_meta[\"coords\"][cname] = {\n                    \"kind\": \"pickle\",\n                    \"dims\": list(coord.dims),\n                    \"payload\": pickle.dumps(\n                        coord.values, protocol=pickle.HIGHEST_PROTOCOL\n                    ),\n                }\n\n        # DATA VARS: main heavy arrays\n        for vname, da in ds.data_vars.items():\n            arr = np.asarray(da.data)\n            _, spec, dtype, shape, order = ShmArray.to_shm(arr, shm_pool)\n            meta = {\"dtype\": dtype, \"shape\": shape, \"order\": order}\n            nbytes = spec[\"content_size\"]\n\n            buffer_idx = len(buffers)\n            buffers.append(spec)\n            total_bytes += nbytes\n\n            g_meta[\"data_vars\"][vname] = {\n                \"buffer_idx\": buffer_idx,\n                \"dtype\": str(meta[\"dtype\"]),\n                \"shape\": list(meta[\"shape\"]),\n                \"dims\": list(da.dims),\n                \"nbytes\": nbytes,\n            }\n\n        groups_meta[group_name] = g_meta\n\n    meta: dict[str, Any] = {\n        \"groups\": groups_meta,\n        \"codec_version\": 1,\n    }\n\n    return EncodeResult(\n        codec=type(self).__name__,\n        meta=meta,\n        buffers=buffers,\n    )\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.InferenceDataCodec.decode","title":"<code>decode(payload, get_buf, *args)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    get_buf: Callable[[ShmRef], GetBufContext],\n    *args,\n) -&gt; Any:\n    meta = payload[\"meta\"]\n    specs = payload[\"buffers\"]\n    groups_meta = meta[\"groups\"]\n    groups: dict[str, xr.Dataset] = {}\n\n    for group_name, g_meta in groups_meta.items():\n        data_vars = {}\n        coords = {}\n\n        # Rebuild coords\n        for cname, cmeta in g_meta[\"coords\"].items():\n            kind = cmeta[\"kind\"]\n            if kind == \"array\":\n                spec = specs[cmeta[\"buffer_idx\"]]\n                with get_buf(spec) as (block, _):\n                    arr = ShmArray.from_block(\n                        block, shape=cmeta[\"shape\"], dtype=np.dtype(cmeta[\"dtype\"])\n                    )\n                    coords[cname] = (tuple(cmeta[\"dims\"]), arr)\n            elif kind == \"pickle\":\n                values = pickle.loads(cmeta[\"payload\"])\n                coords[cname] = (tuple(cmeta[\"dims\"]), values)\n            else:\n                raise ValueError(f\"Unknown coord kind: {kind!r}\")\n\n        # Rebuild data_vars\n        for vname, vmeta in g_meta[\"data_vars\"].items():\n            spec = specs[vmeta[\"buffer_idx\"]]\n            with get_buf(spec) as (block, _):\n                arr = ShmArray.from_block(\n                    block, vmeta[\"shape\"], dtype=np.dtype(vmeta[\"dtype\"])\n                )\n                data_vars[vname] = (tuple(vmeta[\"dims\"]), arr)\n\n        ds = xr.Dataset(\n            data_vars=data_vars,\n            coords=coords,\n        )\n        groups[group_name] = ds\n\n    # Construct InferenceData from datasets\n    idata = az.InferenceData(**groups, warn_on_custom_groups=False)\n    return idata\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.NumpyArrayCodec","title":"<code>NumpyArrayCodec</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>SHM-backed codec for <code>numpy.ndarray</code>.</p> Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>class NumpyArrayCodec(Encoder):\n    \"\"\"SHM-backed codec for [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html).\"\"\"\n\n    def can_encode(self, obj: Any) -&gt; bool:\n        return isinstance(obj, np.ndarray)\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n        _, ref, dtype, shape, order = ShmArray.to_shm(obj, shm_pool)\n        return EncodeResult(\n            codec=type(self).__name__,\n            meta={\"dtype\": dtype, \"shape\": shape, \"order\": order},\n            buffers=[ref],\n        )\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        get_buf: Callable[[ShmRef], GetBufContext],\n        *args,\n    ) -&gt; Any:\n        with get_buf(payload[\"buffers\"][0]) as (buf, _):\n            return ShmArray.from_metadata(payload[\"meta\"], buf)\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.NumpyArrayCodec-functions","title":"Functions","text":""},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.NumpyArrayCodec.can_encode","title":"<code>can_encode(obj)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def can_encode(self, obj: Any) -&gt; bool:\n    return isinstance(obj, np.ndarray)\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.NumpyArrayCodec.encode","title":"<code>encode(obj, shm_pool)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n    _, ref, dtype, shape, order = ShmArray.to_shm(obj, shm_pool)\n    return EncodeResult(\n        codec=type(self).__name__,\n        meta={\"dtype\": dtype, \"shape\": shape, \"order\": order},\n        buffers=[ref],\n    )\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.NumpyArrayCodec.decode","title":"<code>decode(payload, get_buf, *args)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    get_buf: Callable[[ShmRef], GetBufContext],\n    *args,\n) -&gt; Any:\n    with get_buf(payload[\"buffers\"][0]) as (buf, _):\n        return ShmArray.from_metadata(payload[\"meta\"], buf)\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.PandasDFCodec","title":"<code>PandasDFCodec</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>SHM-backed codec for numeric-only <code>pandas.DataFrame</code>.</p> <p>Object-dtype columns are intentionally rejected to avoid surprising implicit conversions; those cases fall back to pickle.</p> Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>class PandasDFCodec(Encoder):\n    \"\"\"\n    SHM-backed codec for numeric-only [`pandas.DataFrame`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).\n\n    Object-dtype columns are intentionally rejected to avoid surprising implicit\n    conversions; those cases fall back to pickle.\n    \"\"\"\n\n    def can_encode(self, obj: Any) -&gt; bool:\n        if not isinstance(obj, pd.DataFrame):\n            return False\n\n        return True\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n        assert isinstance(obj, pd.DataFrame)  # assert type\n\n        meta: dict[str, Any] = {\n            \"columns\": list(obj.columns),\n            \"index\": pickle.dumps(obj.index, protocol=pickle.HIGHEST_PROTOCOL),\n            \"variant\": \"single\",\n        }\n        buffers: list[ShmRef] = []\n\n        if obj.empty:\n            meta[\"variant\"] = \"empty\"\n        elif isinstance(obj, ShmDataFrameSimple):\n            # single dtype matrix\n            meta[\"variant\"] = \"single\"\n            meta[\"dtype\"] = str(obj.values.dtype)\n            meta[\"order\"] = ShmArray.array_order(obj.values)\n            buffers.append(obj._shm_metadata)\n        elif isinstance(obj, ShmDataFrameColumns):\n            # per column buffers\n            meta[\"variant\"] = \"columnar\"\n            meta[\"order\"] = \"F\"\n            meta[\"columns\"] = obj._shm_metadata\n        else:\n            # Fallback: put each column in its own SHM block\n            meta[\"variant\"] = \"columnar\"\n            meta[\"order\"] = \"C\"\n            columns: dict[str, ShmSeriesMetadata] = {}\n\n            for col_name in obj.columns:\n                col = obj[col_name]\n\n                arr_modified, spec, dtype, shape, order = ShmArray.to_shm(col, shm_pool)\n\n                columns[col_name] = ShmDataFrameColumns._create_col_metadata(\n                    obj[col_name], spec, arr_modified\n                )\n            meta[\"columns\"] = columns\n\n        return EncodeResult(codec=type(self).__name__, meta=meta, buffers=buffers)\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        get_buf: Callable[[ShmRef], GetBufContext],\n        *args,\n    ) -&gt; Any:\n        meta = payload[\"meta\"]\n        if meta.get(\"variant\") == \"empty\":\n            return pd.DataFrame({})\n\n        buffer_specs = payload[\"buffers\"]\n\n        index = pickle.loads(meta[\"index\"])\n\n        if meta.get(\"variant\") == \"single\":\n            spec = buffer_specs[0]\n            with get_buf(buffer_specs[0]) as (buf, memview):\n                dtype = np.dtype(meta[\"dtype\"])\n                nbytes = spec[\"size\"]\n                order = meta[\"order\"]\n\n                columns = meta[\"columns\"]\n                shape = (len(index), len(columns))\n\n                # Only use the slice that actually holds array data\n                view = memview[:nbytes]\n                arr = np.ndarray(shape=shape, dtype=dtype, buffer=view, order=order)\n\n                df = ShmDataFrameSimple(data=arr, index=index, columns=columns)\n                df._set_shm_metadata(spec)\n\n                return df\n        elif meta.get(\"variant\") == \"columnar\":\n            columns_metadata: dict[str, ShmSeriesMetadata] = meta[\"columns\"]\n            nrows = len(index)\n\n            columns = list(columns_metadata.keys())\n\n            data: dict[str, pd.Series] = {}\n\n            for i, col_name in enumerate(columns):\n                metadata = columns_metadata[col_name]\n                spec = metadata[\"block\"]\n                dtype = metadata[\"np_dtype\"]\n                with get_buf(spec) as (buf, view):\n                    data[col_name] = ShmDataFrameColumns._reconstruct_series(\n                        metadata, buf, nrows, index\n                    )\n\n            df = ShmDataFrameColumns(data=data)\n            df._set_shm_metadata(columns_metadata)\n\n            return df\n        else:\n            raise Exception(f\"Unknown DataFrame variant {meta.get('variant')}\")\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.PandasDFCodec-functions","title":"Functions","text":""},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.PandasDFCodec.can_encode","title":"<code>can_encode(obj)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def can_encode(self, obj: Any) -&gt; bool:\n    if not isinstance(obj, pd.DataFrame):\n        return False\n\n    return True\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.PandasDFCodec.encode","title":"<code>encode(obj, shm_pool)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n    assert isinstance(obj, pd.DataFrame)  # assert type\n\n    meta: dict[str, Any] = {\n        \"columns\": list(obj.columns),\n        \"index\": pickle.dumps(obj.index, protocol=pickle.HIGHEST_PROTOCOL),\n        \"variant\": \"single\",\n    }\n    buffers: list[ShmRef] = []\n\n    if obj.empty:\n        meta[\"variant\"] = \"empty\"\n    elif isinstance(obj, ShmDataFrameSimple):\n        # single dtype matrix\n        meta[\"variant\"] = \"single\"\n        meta[\"dtype\"] = str(obj.values.dtype)\n        meta[\"order\"] = ShmArray.array_order(obj.values)\n        buffers.append(obj._shm_metadata)\n    elif isinstance(obj, ShmDataFrameColumns):\n        # per column buffers\n        meta[\"variant\"] = \"columnar\"\n        meta[\"order\"] = \"F\"\n        meta[\"columns\"] = obj._shm_metadata\n    else:\n        # Fallback: put each column in its own SHM block\n        meta[\"variant\"] = \"columnar\"\n        meta[\"order\"] = \"C\"\n        columns: dict[str, ShmSeriesMetadata] = {}\n\n        for col_name in obj.columns:\n            col = obj[col_name]\n\n            arr_modified, spec, dtype, shape, order = ShmArray.to_shm(col, shm_pool)\n\n            columns[col_name] = ShmDataFrameColumns._create_col_metadata(\n                obj[col_name], spec, arr_modified\n            )\n        meta[\"columns\"] = columns\n\n    return EncodeResult(codec=type(self).__name__, meta=meta, buffers=buffers)\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.PandasDFCodec.decode","title":"<code>decode(payload, get_buf, *args)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    get_buf: Callable[[ShmRef], GetBufContext],\n    *args,\n) -&gt; Any:\n    meta = payload[\"meta\"]\n    if meta.get(\"variant\") == \"empty\":\n        return pd.DataFrame({})\n\n    buffer_specs = payload[\"buffers\"]\n\n    index = pickle.loads(meta[\"index\"])\n\n    if meta.get(\"variant\") == \"single\":\n        spec = buffer_specs[0]\n        with get_buf(buffer_specs[0]) as (buf, memview):\n            dtype = np.dtype(meta[\"dtype\"])\n            nbytes = spec[\"size\"]\n            order = meta[\"order\"]\n\n            columns = meta[\"columns\"]\n            shape = (len(index), len(columns))\n\n            # Only use the slice that actually holds array data\n            view = memview[:nbytes]\n            arr = np.ndarray(shape=shape, dtype=dtype, buffer=view, order=order)\n\n            df = ShmDataFrameSimple(data=arr, index=index, columns=columns)\n            df._set_shm_metadata(spec)\n\n            return df\n    elif meta.get(\"variant\") == \"columnar\":\n        columns_metadata: dict[str, ShmSeriesMetadata] = meta[\"columns\"]\n        nrows = len(index)\n\n        columns = list(columns_metadata.keys())\n\n        data: dict[str, pd.Series] = {}\n\n        for i, col_name in enumerate(columns):\n            metadata = columns_metadata[col_name]\n            spec = metadata[\"block\"]\n            dtype = metadata[\"np_dtype\"]\n            with get_buf(spec) as (buf, view):\n                data[col_name] = ShmDataFrameColumns._reconstruct_series(\n                    metadata, buf, nrows, index\n                )\n\n        df = ShmDataFrameColumns(data=data)\n        df._set_shm_metadata(columns_metadata)\n\n        return df\n    else:\n        raise Exception(f\"Unknown DataFrame variant {meta.get('variant')}\")\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.PickleCodec","title":"<code>PickleCodec</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>Pickle fallback codec (internal).</p> <p>Always encodes successfully, so it must be registered last. The pickled bytes are still stored in SHM to keep pipe traffic small and bounded.</p> Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>class PickleCodec(Encoder):\n    \"\"\"\n    Pickle fallback codec (internal).\n\n    Always encodes successfully, so it must be registered last. The pickled bytes\n    are still stored in SHM to keep pipe traffic small and bounded.\n    \"\"\"\n\n    def can_encode(self, obj: Any) -&gt; bool:\n        # Fallback \u2013 always True\n        return True\n\n    def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n        if obj is None:\n            return EncodeResult(\n                codec=type(self).__name__,\n                meta={},\n                buffers=[],\n            )\n\n        data = pickle.dumps(obj, protocol=pickle.HIGHEST_PROTOCOL)\n        block = shm_pool.alloc(len(data), temporary=True)\n        block.shm.buf[: len(data)] = data\n\n        # dont waste SHM, use meta instead of buffer\n        meta: dict[str, Any] = {\"length\": len(data)}\n\n        size_bytes = len(data)\n        if size_bytes &gt; ONE_MB * 10:\n            size_mb = size_bytes / ONE_MB\n            log_warning(\n                f\"PickleCodec encoding large object: type={type(obj)}, size={size_mb:,.2f} MB\"\n            )\n\n        return EncodeResult(\n            codec=type(self).__name__,\n            meta=meta,\n            buffers=[block.to_ref()],\n        )\n\n    def decode(\n        self,\n        payload: PayloadRef,\n        get_buf: Callable[[ShmRef], GetBufContext],\n        *args,\n    ) -&gt; Any:\n        specs = payload[\"buffers\"]\n        if len(specs) == 0:\n            return None\n\n        with get_buf(specs[0]) as (block, buf):\n            length = block.content_size\n            b = bytes(buf[:length])\n            return pickle.loads(b)\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.PickleCodec-functions","title":"Functions","text":""},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.PickleCodec.can_encode","title":"<code>can_encode(obj)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def can_encode(self, obj: Any) -&gt; bool:\n    # Fallback \u2013 always True\n    return True\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.PickleCodec.encode","title":"<code>encode(obj, shm_pool)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def encode(self, obj: Any, shm_pool: Any) -&gt; EncodeResult:\n    if obj is None:\n        return EncodeResult(\n            codec=type(self).__name__,\n            meta={},\n            buffers=[],\n        )\n\n    data = pickle.dumps(obj, protocol=pickle.HIGHEST_PROTOCOL)\n    block = shm_pool.alloc(len(data), temporary=True)\n    block.shm.buf[: len(data)] = data\n\n    # dont waste SHM, use meta instead of buffer\n    meta: dict[str, Any] = {\"length\": len(data)}\n\n    size_bytes = len(data)\n    if size_bytes &gt; ONE_MB * 10:\n        size_mb = size_bytes / ONE_MB\n        log_warning(\n            f\"PickleCodec encoding large object: type={type(obj)}, size={size_mb:,.2f} MB\"\n        )\n\n    return EncodeResult(\n        codec=type(self).__name__,\n        meta=meta,\n        buffers=[block.to_ref()],\n    )\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.PickleCodec.decode","title":"<code>decode(payload, get_buf, *args)</code>","text":"Source code in <code>brmspy/_session/codec/builtin.py</code> <pre><code>def decode(\n    self,\n    payload: PayloadRef,\n    get_buf: Callable[[ShmRef], GetBufContext],\n    *args,\n) -&gt; Any:\n    specs = payload[\"buffers\"]\n    if len(specs) == 0:\n        return None\n\n    with get_buf(specs[0]) as (block, buf):\n        length = block.content_size\n        b = bytes(buf[:length])\n        return pickle.loads(b)\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry-functions","title":"Functions","text":""},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.register_dataclasses","title":"<code>register_dataclasses(registry)</code>","text":"<p>Register codecs for known dataclass types.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>CodecRegistry</code> <p>Registry to populate.</p> required Source code in <code>brmspy/_session/codec/dataclass.py</code> <pre><code>def register_dataclasses(registry: CodecRegistry) -&gt; None:\n    \"\"\"\n    Register codecs for known dataclass types.\n\n    Parameters\n    ----------\n    registry : brmspy._session.codec.base.CodecRegistry\n        Registry to populate.\n    \"\"\"\n    for _cls in _classes:\n        codec = GenericDataClassCodec(cls=_cls, registry=registry)\n        registry.register(codec)\n</code></pre>"},{"location":"internals/_session/codec/registry/#brmspy._session.codec.registry.get_default_registry","title":"<code>get_default_registry()</code>","text":"<p>Return the process-global default codec registry.</p> <p>Returns:</p> Type Description <code>CodecRegistry</code> <p>Registry with SHM-first codecs registered, plus a pickle fallback.</p> Source code in <code>brmspy/_session/codec/registry.py</code> <pre><code>def get_default_registry() -&gt; CodecRegistry:\n    \"\"\"\n    Return the process-global default codec registry.\n\n    Returns\n    -------\n    brmspy._session.codec.base.CodecRegistry\n        Registry with SHM-first codecs registered, plus a pickle fallback.\n    \"\"\"\n    global _default_registry\n    if _default_registry is None:\n        reg = CodecRegistry()\n        reg.register(NumpyArrayCodec())\n        reg.register(InferenceDataCodec())\n        reg.register(PandasDFCodec())\n\n        register_dataclasses(reg)\n\n        # MUST BE LAST\n        reg.register(PickleCodec())\n\n        _default_registry = reg\n    return _default_registry\n</code></pre>"},{"location":"internals/_session/worker/logging/","title":"logging","text":"<p>Worker-side logging/printing integration (internal).</p> <p>The parent process owns the main logging configuration. The worker routes its own logging records and <code>print()</code> output into the parent's log queue, so users see a single unified stream.</p>"},{"location":"internals/_session/worker/logging/#brmspy._session.worker.logging-functions","title":"Functions","text":""},{"location":"internals/_session/worker/logging/#brmspy._session.worker.logging.get_logger","title":"<code>get_logger()</code>","text":"<p>Get or create the brmspy logger instance.</p> <p>Returns a configured logger with a custom formatter that outputs messages in the format: <code>[brmspy][method_name] msg here</code></p> <p>Returns:</p> Type Description <code>Logger</code> <p>Configured brmspy logger instance</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy.helpers.log import get_logger\n&gt;&gt;&gt; logger = get_logger()\n&gt;&gt;&gt; logger.info(\"Starting process\")  # Prints: [brmspy][&lt;module&gt;] Starting process\n</code></pre> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def get_logger() -&gt; logging.Logger:\n    \"\"\"\n    Get or create the brmspy logger instance.\n\n    Returns a configured logger with a custom formatter that outputs\n    messages in the format: `[brmspy][method_name] msg here`\n\n    Returns\n    -------\n    logging.Logger\n        Configured brmspy logger instance\n\n    Examples\n    --------\n    &gt;&gt;&gt; from brmspy.helpers.log import get_logger\n    &gt;&gt;&gt; logger = get_logger()\n    &gt;&gt;&gt; logger.info(\"Starting process\")  # Prints: [brmspy][&lt;module&gt;] Starting process\n    \"\"\"\n    global _logger\n\n    if _logger is None:\n        _logger = logging.getLogger(\"brmspy\")\n        _logger.setLevel(logging.INFO)\n\n        if not _logger.handlers:\n            # Handler for \"normal\" logs\n            normal_handler = logging.StreamHandler()\n            normal_handler.setFormatter(BrmspyFormatter())\n            normal_handler.addFilter(NonPrintFilter())\n            _logger.addHandler(normal_handler)\n\n            # print logs: preserve control chars and explicit \\n/\\r\n            print_handler = logging.StreamHandler()\n            print_handler.setFormatter(logging.Formatter(\"%(message)s\"))\n            print_handler.addFilter(PrintOnlyFilter())\n            print_handler.terminator = \"\"\n            _logger.addHandler(print_handler)\n\n        if _running_under_pytest():\n            _logger.propagate = True\n        else:\n            _logger.propagate = False\n\n    return _logger\n</code></pre>"},{"location":"internals/_session/worker/logging/#brmspy._session.worker.logging.setup_worker_logging","title":"<code>setup_worker_logging(log_queue, level=None)</code>","text":"<p>Configure worker logging to forward into the parent's log queue.</p> <p>Parameters:</p> Name Type Description Default <code>log_queue</code> <code>Queue</code> <p>Queue owned by the parent; the worker will emit <code>logging</code> records into it.</p> required <code>level</code> <code>int | None</code> <p>Root log level for the worker process. Defaults to <code>logging.INFO</code>.</p> <code>None</code> Notes <p>When <code>BRMSPY_WORKER=1</code>, the worker replaces <code>builtins.print</code> to preserve raw control characters and line endings produced by R/cmdstan.</p> Source code in <code>brmspy/_session/worker/logging.py</code> <pre><code>def setup_worker_logging(log_queue: Queue, level: int | None = None) -&gt; None:\n    \"\"\"\n    Configure worker logging to forward into the parent's log queue.\n\n    Parameters\n    ----------\n    log_queue : multiprocessing.queues.Queue\n        Queue owned by the parent; the worker will emit `logging` records into it.\n    level : int | None, optional\n        Root log level for the worker process. Defaults to `logging.INFO`.\n\n    Notes\n    -----\n    When `BRMSPY_WORKER=1`, the worker replaces [`builtins.print`](https://docs.python.org/3/library/functions.html#print)\n    to preserve raw control characters and line endings produced by R/cmdstan.\n    \"\"\"\n    root = logging.getLogger()\n    root.handlers.clear()\n    root.setLevel(level or logging.INFO)\n    root.addHandler(QueueHandler(log_queue))\n\n    logger = get_logger()\n\n    def _print(*values: object, **kwargs):\n        sep = kwargs.get(\"sep\", \" \")\n        end = kwargs.get(\"end\", \"\\n\")\n\n        # Preserve raw control chars and end exactly as R/cmdstan intended\n        msg = sep.join(str(v) for v in values) + end\n\n        if msg == \"\":\n            return\n\n        logger.info(\n            msg,\n            extra={\n                \"method_name\": \"_print\",\n                \"no_prefix\": True,\n                \"from_print\": True,  # important for filters\n            },\n        )\n\n    if os.environ.get(\"BRMSPY_WORKER\") == \"1\":\n        builtins.print = _print\n</code></pre>"},{"location":"internals/_session/worker/setup/","title":"setup","text":"<p>Worker startup helpers (internal).</p> <p>This module contains the worker-side initialization routines that must run inside the spawned worker process before any heavy brms/rpy2 work:</p> <ul> <li>apply \"safer embedded R\" configuration (ABI mode, disabling unsafe fork parallelism)</li> <li>optionally run R startup scripts (user-configured)</li> <li>activate/deactivate a brmspy runtime and prepend the environment user library to   R <code>.libPaths()</code>.</li> </ul> <p>The main process should not import rpy2; all embedded-R initialization happens here.</p>"},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup-attributes","title":"Attributes","text":""},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.__all__","title":"<code>__all__ = ['run_startup_scripts', '_check_r_setup', '_initialise_r_safe', 'activate']</code>  <code>module-attribute</code>","text":""},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup-classes","title":"Classes","text":""},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.EnvironmentConfig","title":"<code>EnvironmentConfig</code>  <code>dataclass</code>","text":"<p>Worker environment configuration.</p> <p>This configuration is applied in the worker before importing/using brms.</p> <p>Parameters:</p> Name Type Description Default <code>r_home</code> <code>str or None</code> <p>Override for <code>R_HOME</code>. If None, the worker will rely on system detection.</p> <code>None</code> <code>startup_scripts</code> <code>list[str]</code> <p>R code snippets executed in the worker after initialization.</p> <code>list()</code> <code>environment_name</code> <code>str</code> <p>brmspy environment name (used to determine <code>~/.brmspy/environment/&lt;name&gt;/Rlib</code>).</p> <code>'default'</code> <code>runtime_path</code> <code>str or None</code> <p>Path to a brmspy runtime bundle to activate in the worker.</p> <code>None</code> <code>env</code> <code>dict[str, str]</code> <p>Extra environment variables applied when spawning the worker.</p> <code>dict()</code> Source code in <code>brmspy/types/session.py</code> <pre><code>@dataclass\nclass EnvironmentConfig:\n    \"\"\"\n    Worker environment configuration.\n\n    This configuration is applied in the worker before importing/using brms.\n\n    Parameters\n    ----------\n    r_home : str or None\n        Override for `R_HOME`. If None, the worker will rely on system detection.\n    startup_scripts : list[str]\n        R code snippets executed in the worker after initialization.\n    environment_name : str\n        brmspy environment name (used to determine `~/.brmspy/environment/&lt;name&gt;/Rlib`).\n    runtime_path : str or None\n        Path to a brmspy runtime bundle to activate in the worker.\n    env : dict[str, str]\n        Extra environment variables applied when spawning the worker.\n    \"\"\"\n\n    r_home: None | str = None\n    startup_scripts: list[str] = field(default_factory=list)\n    environment_name: str = \"default\"\n    runtime_path: None | str = None\n    env: dict[str, str] = field(default_factory=dict)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Serialize configuration for persistence to JSON.\"\"\"\n        return {\n            \"environment_name\": self.environment_name,\n            \"r_home\": self.r_home,\n            \"startup_scripts\": self.startup_scripts or [],\n            \"runtime_path\": self.runtime_path,\n            \"env\": self.env,\n        }\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any]) -&gt; EnvironmentConfig:\n        \"\"\"Deserialize configuration from a JSON object.\"\"\"\n        return cls(\n            r_home=obj[\"r_home\"],\n            startup_scripts=obj[\"startup_scripts\"],\n            environment_name=obj[\"environment_name\"],\n            runtime_path=obj[\"runtime_path\"],\n            env=obj[\"env\"],\n        )\n\n    @classmethod\n    def from_obj(\n        cls, obj: None | dict[str, Any] | EnvironmentConfig\n    ) -&gt; EnvironmentConfig:\n        \"\"\"Normalize `None | dict | EnvironmentConfig` into an `EnvironmentConfig`.\"\"\"\n        if obj is None:\n            return cls()\n        if isinstance(obj, dict):\n            return cls.from_dict(obj)\n        return obj\n</code></pre>"},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.EnvironmentConfig-attributes","title":"Attributes","text":""},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.EnvironmentConfig.r_home","title":"<code>r_home = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.EnvironmentConfig.startup_scripts","title":"<code>startup_scripts = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.EnvironmentConfig.environment_name","title":"<code>environment_name = 'default'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.EnvironmentConfig.runtime_path","title":"<code>runtime_path = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.EnvironmentConfig.env","title":"<code>env = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.EnvironmentConfig-functions","title":"Functions","text":""},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.EnvironmentConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize configuration for persistence to JSON.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Serialize configuration for persistence to JSON.\"\"\"\n    return {\n        \"environment_name\": self.environment_name,\n        \"r_home\": self.r_home,\n        \"startup_scripts\": self.startup_scripts or [],\n        \"runtime_path\": self.runtime_path,\n        \"env\": self.env,\n    }\n</code></pre>"},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.EnvironmentConfig.from_dict","title":"<code>from_dict(obj)</code>  <code>classmethod</code>","text":"<p>Deserialize configuration from a JSON object.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any]) -&gt; EnvironmentConfig:\n    \"\"\"Deserialize configuration from a JSON object.\"\"\"\n    return cls(\n        r_home=obj[\"r_home\"],\n        startup_scripts=obj[\"startup_scripts\"],\n        environment_name=obj[\"environment_name\"],\n        runtime_path=obj[\"runtime_path\"],\n        env=obj[\"env\"],\n    )\n</code></pre>"},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.EnvironmentConfig.from_obj","title":"<code>from_obj(obj)</code>  <code>classmethod</code>","text":"<p>Normalize <code>None | dict | EnvironmentConfig</code> into an <code>EnvironmentConfig</code>.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@classmethod\ndef from_obj(\n    cls, obj: None | dict[str, Any] | EnvironmentConfig\n) -&gt; EnvironmentConfig:\n    \"\"\"Normalize `None | dict | EnvironmentConfig` into an `EnvironmentConfig`.\"\"\"\n    if obj is None:\n        return cls()\n    if isinstance(obj, dict):\n        return cls.from_dict(obj)\n    return obj\n</code></pre>"},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.EnvironmentConfig.__init__","title":"<code>__init__(r_home=None, startup_scripts=list(), environment_name='default', runtime_path=None, env=dict())</code>","text":""},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup-functions","title":"Functions","text":""},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.get_environment_userlibs_dir","title":"<code>get_environment_userlibs_dir(name)</code>","text":"<p>Return the per-environment user library directory: <code>.../&lt;name&gt;/Rlib</code>.</p> Source code in <code>brmspy/_session/environment.py</code> <pre><code>def get_environment_userlibs_dir(name: str) -&gt; Path:\n    \"\"\"Return the per-environment user library directory: `.../&lt;name&gt;/Rlib`.\"\"\"\n    return get_environment_dir(name=name) / \"Rlib\"\n</code></pre>"},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.run_startup_scripts","title":"<code>run_startup_scripts(env_conf)</code>","text":"<p>Execute configured R startup scripts in the worker.</p> <p>Parameters:</p> Name Type Description Default <code>env_conf</code> <code>EnvironmentConfig</code> <p>Environment configuration. If <code>startup_scripts</code> is empty/None, this is a no-op.</p> required Source code in <code>brmspy/_session/worker/setup.py</code> <pre><code>def run_startup_scripts(env_conf: EnvironmentConfig) -&gt; None:\n    \"\"\"\n    Execute configured R startup scripts in the worker.\n\n    Parameters\n    ----------\n    env_conf : brmspy.types.session.EnvironmentConfig\n        Environment configuration. If `startup_scripts` is empty/None, this is a no-op.\n    \"\"\"\n    if not env_conf.startup_scripts:\n        return\n    scripts: list[str] = env_conf.startup_scripts\n\n    import rpy2.robjects as ro\n\n    for code in scripts:\n        ro.r(code)\n</code></pre>"},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup._check_r_setup","title":"<code>_check_r_setup(verbose=False)</code>","text":"<p>Run lightweight diagnostics to detect common embedded-R misconfiguration.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, prints human-readable info/warnings.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[bool, list[str]]</code> <p><code>(ok, messages)</code> where <code>ok=False</code> indicates potential misconfiguration and <code>messages</code> contains warning strings.</p> Source code in <code>brmspy/_session/worker/setup.py</code> <pre><code>def _check_r_setup(verbose: bool = False) -&gt; tuple[bool, list[str]]:\n    \"\"\"\n    Run lightweight diagnostics to detect common embedded-R misconfiguration.\n\n    Parameters\n    ----------\n    verbose : bool, optional\n        If True, prints human-readable info/warnings.\n\n    Returns\n    -------\n    tuple[bool, list[str]]\n        `(ok, messages)` where `ok=False` indicates potential misconfiguration and\n        `messages` contains warning strings.\n    \"\"\"\n    import os\n    import platform\n    import shutil\n    import subprocess\n\n    ok = True\n    messages: list[str] = []\n\n    def info(msg: str) -&gt; None:\n        if verbose:\n            print(f\"[brmspy][INFO] {msg}\")\n\n    def warn(msg: str) -&gt; None:\n        nonlocal ok\n        ok = False\n        messages.append(msg)\n        if verbose:\n            print(f\"[brmspy][WARNING] {msg}\")\n\n    # --- 1. Try to locate R and RHOME via the R executable -----------------\n    r_exec = shutil.which(\"R\")\n    r_home_cmd: str | None = None\n\n    if not r_exec:\n        # Not necessarily fatal if rpy2 was compiled with an absolute R_HOME,\n        # but very suspicious for anything reproducible.\n        warn(\"R executable `R` not found on PATH; this is a fragile setup.\")\n    else:\n        try:\n            proc = subprocess.run(\n                [r_exec, \"RHOME\"], check=True, capture_output=True, text=True\n            )\n            r_home_cmd = proc.stdout.strip()\n            if not r_home_cmd:\n                warn(\"`R RHOME` returned an empty value.\")\n            else:\n                info(f\"RHOME (from `R RHOME`): {r_home_cmd}\")\n        except Exception as e:\n            warn(f\"`R RHOME` failed: {e!r}\")\n\n    # --- 2. Look at env vars, but treat them as advisory -------------------\n    r_home_env = os.environ.get(\"R_HOME\")\n    if r_home_env:\n        info(f\"R_HOME env: {r_home_env}\")\n    else:\n        info(\"R_HOME env var not set; relying on rpy2 / system defaults.\")\n\n    if platform.system() != \"Windows\":\n        ld = os.environ.get(\"LD_LIBRARY_PATH\")\n        if not ld:\n            info(\n                \"LD_LIBRARY_PATH not set; assuming system linker config \"\n                \"already knows where libR.so lives.\"\n            )\n        else:\n            info(f\"LD_LIBRARY_PATH is set (length {len(ld)} chars).\")\n\n    # --- 3. Try to import rpy2 and talk to R --------------------------------\n    try:\n        import rpy2.robjects as ro  # type: ignore[import]\n    except Exception as e:\n        warn(f\"Failed to import rpy2.robjects: {e!r}\")\n        return ok, messages\n\n    try:\n        r_version = str(cast(ro.ListVector, ro.r(\"R.version\"))[0])\n        lib_paths = [str(p) for p in cast(ro.ListVector, ro.r(\".libPaths()\"))]\n        info(f\"R version: {r_version}\")\n        info(f\".libPaths(): {lib_paths}\")\n    except Exception as e:\n        warn(f\"rpy2 could not initialize R / run basic code: {e!r}\")\n        return ok, messages\n\n    return ok, messages\n</code></pre>"},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup._initialise_r_safe","title":"<code>_initialise_r_safe()</code>","text":"<p>Configure R for safer embedded execution.</p> <ul> <li>Try to enforce rpy2 ABI mode (must be set before importing rpy2)</li> <li>Disable fork-based R parallelism (future::multicore, mclapply)</li> <li>Use future::plan(sequential) if future is available</li> <li>Leave cmdstanr multi-core sampling alone</li> </ul> Source code in <code>brmspy/_session/worker/setup.py</code> <pre><code>def _initialise_r_safe() -&gt; None:\n    \"\"\"\n    Configure R for safer embedded execution.\n\n    - Try to enforce rpy2 ABI mode (must be set before importing rpy2)\n    - Disable fork-based R parallelism (future::multicore, mclapply)\n    - Use future::plan(sequential) if future is available\n    - Leave cmdstanr multi-core sampling alone\n    \"\"\"\n\n    import os\n    import sys\n\n    # CFFI MODE\n    if \"rpy2\" in sys.modules:\n        if os.environ.get(\"RPY2_CFFI_MODE\") != \"ABI\":\n            print(\n                \"[brmspy][WARNING] rpy2 was imported before brmspy; cannot enforce \"\n                \"RPY2_CFFI_MODE (env var). API and BOTH mode are known to cause \"\n                \"instability, ABI is recommended.\"\n            )\n    elif os.environ.get(\"RPY2_CFFI_MODE\") in (\"BOTH\", \"API\"):\n        print(\n            \"[brmspy][WARNING] RPY2_CFFI_MODE (env var) is set to API/BOTH. \"\n            \"These modes are known to cause instability and segfaults; \"\n            \"ABI is recommended.\"\n        )\n    os.environ.setdefault(\"RPY2_CFFI_MODE\", \"ABI\")\n\n    # THREAD SAFETY\n    # Could also lead to undefined behaviour if &gt;1\n    os.environ.setdefault(\"OMP_NUM_THREADS\", \"1\")\n    os.environ.setdefault(\"OPENBLAS_NUM_THREADS\", \"1\")\n\n    ok, messages = _check_r_setup()\n    if not ok:\n        print(\"[brmspy][WARNING] R environment diagnostics reported problems.\")\n        for message in messages:\n            print(f\"[brmspy][WARNING]   {message}\")\n\n    import rpy2.robjects as ro\n\n    ro.r(\n        r\"\"\"\n        # Disable fork-based mechanisms that are unsafe in embedded R\n        options(\n          mc.cores = 1L,             # parallel::mclapply -&gt; serial\n          future.fork.enable = FALSE, # disable future::multicore\n          loo.cores = 1L # deprecated but still respected, for now.\n        )\n\n        # If 'future' is installed, force sequential backend\n        if (requireNamespace(\"future\", quietly = TRUE)) {\n          future::plan(future::sequential)\n        }\n        \"\"\"\n    )\n</code></pre>"},{"location":"internals/_session/worker/setup/#brmspy._session.worker.setup.activate","title":"<code>activate(env_conf)</code>","text":"<p>Apply runtime + environment library configuration in the worker.</p> <p>This may activate/deactivate a brmspy runtime (prebuilt bundle) and ensures the per-environment user library is at the front of R <code>.libPaths()</code>.</p> Notes <p>This is intentionally worker-only: it imports runtime helpers and mutates the embedded R process state.</p> Source code in <code>brmspy/_session/worker/setup.py</code> <pre><code>def activate(env_conf: EnvironmentConfig) -&gt; None:\n    \"\"\"\n    Apply runtime + environment library configuration in the worker.\n\n    This may activate/deactivate a brmspy runtime (prebuilt bundle) and ensures the\n    per-environment user library is at the front of R `.libPaths()`.\n\n    Notes\n    -----\n    This is intentionally worker-only: it imports runtime helpers and mutates the\n    embedded R process state.\n    \"\"\"\n    from brmspy._runtime import _r_env, activate_runtime, deactivate_runtime, status\n\n    _status = status()\n\n    if env_conf.runtime_path:\n        if _status.active_runtime and _status.is_activated:\n            if not _status.active_runtime.samefile(env_conf.runtime_path):\n                if os.environ.get(\"BRMSPY_AUTOLOAD\") == \"1\":\n                    raise Exception(\n                        \"Can't unload environments when autoload is enabled!\"\n                    )\n                deactivate_runtime()\n                activate_runtime(env_conf.runtime_path)\n    else:\n        if _status.active_runtime and _status.is_activated:\n            if os.environ.get(\"BRMSPY_AUTOLOAD\") == \"1\":\n                raise Exception(\"Can't unload environments when autoload is enabled!\")\n            deactivate_runtime()\n\n    userlib_path = get_environment_userlibs_dir(env_conf.environment_name)\n    lib_paths = _r_env.get_lib_paths()\n    lib_paths = [\n        p\n        for p in lib_paths\n        if \".brmspy/environment/\" not in p and \".brmspy\\\\environment\\\\\" not in p\n    ]\n    lib_paths.insert(0, userlib_path.as_posix())\n    _r_env.set_lib_paths(lib_paths)\n</code></pre>"},{"location":"internals/_session/worker/sexp_cache/","title":"sexp_cache","text":"<p>Worker-side cache for rpy2 <code>Sexp</code> objects (internal).</p> <p>The main process must not hold live rpy2 objects. Instead, the worker replaces R objects with lightweight <code>SexpWrapper</code> handles and stores the real <code>Sexp</code> in a local cache keyed by <code>rid</code>.</p> <p>This module also installs pickle reducers so that any accidental pickling of a <code>Sexp</code> turns into a wrapper rather than attempting to serialize the R object.</p>"},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache-attributes","title":"Attributes","text":""},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache._SEXP_CACHE","title":"<code>_SEXP_CACHE = {}</code>  <code>module-attribute</code>","text":""},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache-classes","title":"Classes","text":""},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache.SexpWrapper","title":"<code>SexpWrapper</code>  <code>dataclass</code>","text":"<p>Lightweight handle for an R object stored in the worker.</p> <p>The worker keeps the real rpy2 <code>Sexp</code> in an internal cache and replaces it in results with this wrapper. When passed back to the worker, the wrapper is resolved to the original <code>Sexp</code> again.</p> Notes <ul> <li><code>SexpWrapper</code> instances are only meaningful within the lifetime of the   worker process that produced them. After a worker restart, previously   returned wrappers can no longer be reattached.</li> <li>This type exists to keep the main process free of rpy2 / embedded-R state.</li> </ul> Source code in <code>brmspy/types/session.py</code> <pre><code>@dataclass\nclass SexpWrapper:\n    \"\"\"\n    Lightweight handle for an R object stored in the worker.\n\n    The worker keeps the real rpy2 `Sexp` in an internal cache and replaces it in\n    results with this wrapper. When passed back to the worker, the wrapper is\n    resolved to the original `Sexp` again.\n\n    Notes\n    -----\n    - `SexpWrapper` instances are only meaningful within the lifetime of the\n      worker process that produced them. After a worker restart, previously\n      returned wrappers can no longer be reattached.\n    - This type exists to keep the main process free of rpy2 / embedded-R state.\n    \"\"\"\n\n    _rid: int\n    _repr: str\n\n    def __str__(self) -&gt; str:\n        return self._repr\n\n    def __repr__(self) -&gt; str:\n        return self._repr\n</code></pre>"},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache.SexpWrapper-attributes","title":"Attributes","text":""},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache.SexpWrapper._rid","title":"<code>_rid</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache.SexpWrapper._repr","title":"<code>_repr</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache.SexpWrapper-functions","title":"Functions","text":""},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache.SexpWrapper.__str__","title":"<code>__str__()</code>","text":"Source code in <code>brmspy/types/session.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self._repr\n</code></pre>"},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache.SexpWrapper.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/session.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self._repr\n</code></pre>"},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache.SexpWrapper.__init__","title":"<code>__init__(_rid, _repr)</code>","text":""},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache-functions","title":"Functions","text":""},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache.get_sexp","title":"<code>get_sexp(rid)</code>","text":"<p>Fetch a cached <code>Sexp</code> by rid.</p> <p>Returns <code>NULL</code> when the rid is not present.</p> Source code in <code>brmspy/_session/worker/sexp_cache.py</code> <pre><code>def get_sexp(rid: int) -&gt; Sexp:\n    \"\"\"\n    Fetch a cached `Sexp` by rid.\n\n    Returns `NULL` when the rid is not present.\n    \"\"\"\n    if rid in _SEXP_CACHE:\n        return _SEXP_CACHE[rid]\n    return NULL\n</code></pre>"},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache._cache_single","title":"<code>_cache_single(obj)</code>","text":"<p>Store <code>obj</code> in the cache and return a lightweight wrapper for IPC.</p> Source code in <code>brmspy/_session/worker/sexp_cache.py</code> <pre><code>def _cache_single(obj: Sexp) -&gt; SexpWrapper:\n    \"\"\"Store `obj` in the cache and return a lightweight wrapper for IPC.\"\"\"\n    _SEXP_CACHE[obj.rid] = obj\n    _repr = str(obj)\n    if len(_repr) &gt; 16384:\n        _repr = _repr[:16384]\n    return SexpWrapper(_rid=obj.rid, _repr=_repr)\n</code></pre>"},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache._extract_sexp","title":"<code>_extract_sexp(o)</code>","text":"Source code in <code>brmspy/_session/worker/sexp_cache.py</code> <pre><code>def _extract_sexp(o: Any) -&gt; Sexp | None:\n    # Fast path: already a low-level Sexp\n    if isinstance(o, Sexp):\n        return o\n\n    # robjects wrappers (Vector/Matrix/etc.) are not instances of Sexp,\n    # but usually expose the underlying Sexp via __sexp__ or _sexp.\n    sexp = getattr(o, \"__sexp__\", None)\n    if isinstance(sexp, Sexp):\n        return sexp\n\n    sexp = getattr(o, \"_sexp\", None)\n    if isinstance(sexp, Sexp):\n        return sexp\n\n    return None\n</code></pre>"},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache.cache_sexp","title":"<code>cache_sexp(obj)</code>","text":"<p>Replace any embedded-R objects inside <code>obj</code> with <code>SexpWrapper</code> handles.</p> <p>Supports: - plain <code>rpy2.rinterface_lib.sexp.Sexp</code> - rpy2.robjects wrappers (e.g. vectors/matrices), by extracting the underlying Sexp - objects with an <code>.r</code> attribute - list/dict containers (recursively)</p> <p>This keeps the main process free of rpy2/embedded-R objects.</p> Source code in <code>brmspy/_session/worker/sexp_cache.py</code> <pre><code>def cache_sexp(obj: Any) -&gt; Any:\n    \"\"\"\n    Replace any embedded-R objects inside `obj` with `SexpWrapper` handles.\n\n    Supports:\n    - plain `rpy2.rinterface_lib.sexp.Sexp`\n    - rpy2.robjects wrappers (e.g. vectors/matrices), by extracting the underlying Sexp\n    - objects with an `.r` attribute\n    - list/dict containers (recursively)\n\n    This keeps the main process free of rpy2/embedded-R objects.\n    \"\"\"\n\n    sexp = _extract_sexp(obj)\n    if sexp is not None:\n        return _cache_single(sexp)\n\n    if hasattr(obj, \"r\"):\n        obj.r = cache_sexp(obj.r)\n\n    if isinstance(obj, list):\n        return [cache_sexp(o) for o in obj]\n    if isinstance(obj, dict):\n        return {k: cache_sexp(v) for k, v in obj.items()}\n\n    return obj\n</code></pre>"},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache.reattach_sexp","title":"<code>reattach_sexp(obj)</code>","text":"<p>Replace any <code>SexpWrapper</code> handles inside <code>obj</code> with the cached <code>Sexp</code>.</p> <p>If a wrapper cannot be resolved (rid not in cache), the wrapper is replaced with <code>None</code>.</p> Source code in <code>brmspy/_session/worker/sexp_cache.py</code> <pre><code>def reattach_sexp(obj: Any) -&gt; Any:\n    \"\"\"\n    Replace any `SexpWrapper` handles inside `obj` with the cached `Sexp`.\n\n    If a wrapper cannot be resolved (rid not in cache), the wrapper is replaced\n    with `None`.\n    \"\"\"\n    if isinstance(obj, list):\n        return [reattach_sexp(v) for v in obj]\n    elif isinstance(obj, dict):\n        return {k: reattach_sexp(v) for k, v in obj.items()}\n    elif hasattr(obj, \"r\"):\n        obj.r = reattach_sexp(obj.r)\n    elif isinstance(obj, SexpWrapper):\n        if obj._rid in _SEXP_CACHE:\n            return _SEXP_CACHE[obj._rid]\n        else:\n            return None\n    return obj\n</code></pre>"},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache._reduce_sexp","title":"<code>_reduce_sexp(obj)</code>","text":"<p>Pickle reducer for <code>Sexp</code> (worker-side).</p> <p>Converts the <code>Sexp</code> into a cached <code>SexpWrapper</code> so the main process never receives a live rpy2 object.</p> Source code in <code>brmspy/_session/worker/sexp_cache.py</code> <pre><code>def _reduce_sexp(obj: Sexp) -&gt; tuple[Callable[..., Any], tuple[Any, ...]]:\n    \"\"\"\n    Pickle reducer for `Sexp` (worker-side).\n\n    Converts the `Sexp` into a cached [`SexpWrapper`][brmspy.types.session.SexpWrapper] so\n    the main process never receives a live rpy2 object.\n    \"\"\"\n    wrapper = _cache_single(obj)\n    return (SexpWrapper, (wrapper._rid, wrapper._repr))\n</code></pre>"},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache._reduce_sexpwrapper","title":"<code>_reduce_sexpwrapper(obj)</code>","text":"<p>Pickle reducer for <code>SexpWrapper</code> (worker-side).</p> <p>On unpickle, attempts to resolve back to a cached <code>Sexp</code> via <code>get_sexp()</code>.</p> Source code in <code>brmspy/_session/worker/sexp_cache.py</code> <pre><code>def _reduce_sexpwrapper(obj: SexpWrapper) -&gt; tuple[Callable[..., Any], tuple[Any, ...]]:\n    \"\"\"\n    Pickle reducer for `SexpWrapper` (worker-side).\n\n    On unpickle, attempts to resolve back to a cached `Sexp` via `get_sexp()`.\n    \"\"\"\n    return (get_sexp, (obj._rid,))\n</code></pre>"},{"location":"internals/_session/worker/sexp_cache/#brmspy._session.worker.sexp_cache.register_global_pickle_overrides","title":"<code>register_global_pickle_overrides()</code>","text":"<p>Register global pickle reducers for <code>Sexp</code> and <code>SexpWrapper</code>.</p> Source code in <code>brmspy/_session/worker/sexp_cache.py</code> <pre><code>def register_global_pickle_overrides() -&gt; None:\n    \"\"\"Register global pickle reducers for `Sexp` and `SexpWrapper`.\"\"\"\n    copyreg.pickle(Sexp, _reduce_sexp)\n    copyreg.pickle(SexpWrapper, _reduce_sexpwrapper)\n</code></pre>"},{"location":"internals/_session/worker/worker/","title":"worker","text":"<p>Worker process entrypoint and request loop (internal).</p> <p>This module runs inside the spawned Python worker process and is responsible for:</p> <ul> <li>connecting to the parent-owned <code>SharedMemoryManager</code></li> <li>initializing a safe embedded-R configuration (see <code>_initialise_r_safe()</code>)</li> <li>decoding incoming IPC requests, executing a resolved target, and encoding results</li> <li>converting rpy2 <code>Sexp</code> objects to lightweight wrappers via the Sexp cache</li> </ul> <p>The main process should not import rpy2; all embedded-R work happens here.</p>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker-attributes","title":"Attributes","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.ctx","title":"<code>ctx = mp.get_context('spawn')</code>  <code>module-attribute</code>","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker-classes","title":"Classes","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.EnvironmentConfig","title":"<code>EnvironmentConfig</code>  <code>dataclass</code>","text":"<p>Worker environment configuration.</p> <p>This configuration is applied in the worker before importing/using brms.</p> <p>Parameters:</p> Name Type Description Default <code>r_home</code> <code>str or None</code> <p>Override for <code>R_HOME</code>. If None, the worker will rely on system detection.</p> <code>None</code> <code>startup_scripts</code> <code>list[str]</code> <p>R code snippets executed in the worker after initialization.</p> <code>list()</code> <code>environment_name</code> <code>str</code> <p>brmspy environment name (used to determine <code>~/.brmspy/environment/&lt;name&gt;/Rlib</code>).</p> <code>'default'</code> <code>runtime_path</code> <code>str or None</code> <p>Path to a brmspy runtime bundle to activate in the worker.</p> <code>None</code> <code>env</code> <code>dict[str, str]</code> <p>Extra environment variables applied when spawning the worker.</p> <code>dict()</code> Source code in <code>brmspy/types/session.py</code> <pre><code>@dataclass\nclass EnvironmentConfig:\n    \"\"\"\n    Worker environment configuration.\n\n    This configuration is applied in the worker before importing/using brms.\n\n    Parameters\n    ----------\n    r_home : str or None\n        Override for `R_HOME`. If None, the worker will rely on system detection.\n    startup_scripts : list[str]\n        R code snippets executed in the worker after initialization.\n    environment_name : str\n        brmspy environment name (used to determine `~/.brmspy/environment/&lt;name&gt;/Rlib`).\n    runtime_path : str or None\n        Path to a brmspy runtime bundle to activate in the worker.\n    env : dict[str, str]\n        Extra environment variables applied when spawning the worker.\n    \"\"\"\n\n    r_home: None | str = None\n    startup_scripts: list[str] = field(default_factory=list)\n    environment_name: str = \"default\"\n    runtime_path: None | str = None\n    env: dict[str, str] = field(default_factory=dict)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Serialize configuration for persistence to JSON.\"\"\"\n        return {\n            \"environment_name\": self.environment_name,\n            \"r_home\": self.r_home,\n            \"startup_scripts\": self.startup_scripts or [],\n            \"runtime_path\": self.runtime_path,\n            \"env\": self.env,\n        }\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any]) -&gt; EnvironmentConfig:\n        \"\"\"Deserialize configuration from a JSON object.\"\"\"\n        return cls(\n            r_home=obj[\"r_home\"],\n            startup_scripts=obj[\"startup_scripts\"],\n            environment_name=obj[\"environment_name\"],\n            runtime_path=obj[\"runtime_path\"],\n            env=obj[\"env\"],\n        )\n\n    @classmethod\n    def from_obj(\n        cls, obj: None | dict[str, Any] | EnvironmentConfig\n    ) -&gt; EnvironmentConfig:\n        \"\"\"Normalize `None | dict | EnvironmentConfig` into an `EnvironmentConfig`.\"\"\"\n        if obj is None:\n            return cls()\n        if isinstance(obj, dict):\n            return cls.from_dict(obj)\n        return obj\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.EnvironmentConfig-attributes","title":"Attributes","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.EnvironmentConfig.r_home","title":"<code>r_home = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.EnvironmentConfig.startup_scripts","title":"<code>startup_scripts = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.EnvironmentConfig.environment_name","title":"<code>environment_name = 'default'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.EnvironmentConfig.runtime_path","title":"<code>runtime_path = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.EnvironmentConfig.env","title":"<code>env = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.EnvironmentConfig-functions","title":"Functions","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.EnvironmentConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize configuration for persistence to JSON.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Serialize configuration for persistence to JSON.\"\"\"\n    return {\n        \"environment_name\": self.environment_name,\n        \"r_home\": self.r_home,\n        \"startup_scripts\": self.startup_scripts or [],\n        \"runtime_path\": self.runtime_path,\n        \"env\": self.env,\n    }\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.EnvironmentConfig.from_dict","title":"<code>from_dict(obj)</code>  <code>classmethod</code>","text":"<p>Deserialize configuration from a JSON object.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any]) -&gt; EnvironmentConfig:\n    \"\"\"Deserialize configuration from a JSON object.\"\"\"\n    return cls(\n        r_home=obj[\"r_home\"],\n        startup_scripts=obj[\"startup_scripts\"],\n        environment_name=obj[\"environment_name\"],\n        runtime_path=obj[\"runtime_path\"],\n        env=obj[\"env\"],\n    )\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.EnvironmentConfig.from_obj","title":"<code>from_obj(obj)</code>  <code>classmethod</code>","text":"<p>Normalize <code>None | dict | EnvironmentConfig</code> into an <code>EnvironmentConfig</code>.</p> Source code in <code>brmspy/types/session.py</code> <pre><code>@classmethod\ndef from_obj(\n    cls, obj: None | dict[str, Any] | EnvironmentConfig\n) -&gt; EnvironmentConfig:\n    \"\"\"Normalize `None | dict | EnvironmentConfig` into an `EnvironmentConfig`.\"\"\"\n    if obj is None:\n        return cls()\n    if isinstance(obj, dict):\n        return cls.from_dict(obj)\n    return obj\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.EnvironmentConfig.__init__","title":"<code>__init__(r_home=None, startup_scripts=list(), environment_name='default', runtime_path=None, env=dict())</code>","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.PayloadRef","title":"<code>PayloadRef</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Encoded argument/result payload sent over the control pipe.</p> <p>A payload is:</p> <ul> <li><code>codec</code>: the codec identifier used by the registry</li> <li><code>meta</code>: JSON-serializable metadata needed to reconstruct the value</li> <li><code>buffers</code>: shared-memory buffer references backing the payload</li> </ul> Source code in <code>brmspy/types/session.py</code> <pre><code>class PayloadRef(TypedDict):\n    \"\"\"\n    Encoded argument/result payload sent over the control pipe.\n\n    A payload is:\n\n    - `codec`: the codec identifier used by the registry\n    - `meta`: JSON-serializable metadata needed to reconstruct the value\n    - `buffers`: shared-memory buffer references backing the payload\n    \"\"\"\n\n    codec: str\n    meta: dict[str, Any]\n    buffers: list[ShmRef]\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.PayloadRef-attributes","title":"Attributes","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.PayloadRef.codec","title":"<code>codec</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.PayloadRef.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.PayloadRef.buffers","title":"<code>buffers</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.ShmPool","title":"<code>ShmPool</code>","text":"<p>               Bases: <code>ShmPool</code></p> <p>Concrete shared-memory pool implementation that temporarily tracks attached blocks.</p> <p>_blocks dict keeps references to shm buffers TEMPORARILY and is cleaned up before each 'responding to main' or 'sending new message to worker'. This allows the in-between processing of shm buffers to rely on the buffers not being garbage collected.</p> <p>After reconstructing an object from a shm buffer, it's the CodecRegistrys role to take over the reference by initiating a weakref between the reconstructed object and buffer (or skipping if the object is temporary).</p> <p>This helps ensure that a minimal amount of shm buffers are actively mapped and garbage collection can remove file descriptors no longer needed.</p> Source code in <code>brmspy/_session/transport.py</code> <pre><code>class ShmPool(_ShmPool):\n    \"\"\"\n    Concrete shared-memory pool implementation that temporarily tracks attached blocks.\n\n    _blocks dict keeps references to shm buffers TEMPORARILY and is cleaned up\n    before each 'responding to main' or 'sending new message to worker'. This\n    allows the in-between processing of shm buffers to rely on the buffers not\n    being garbage collected.\n\n    After reconstructing an object from a shm buffer, it's the CodecRegistrys role\n    to take over the reference by initiating a weakref between the reconstructed\n    object and buffer (or skipping if the object is temporary).\n\n    This helps ensure that a minimal amount of shm buffers are actively mapped\n    and garbage collection can remove file descriptors no longer needed.\n    \"\"\"\n\n    def __init__(self, manager: SharedMemoryManager) -&gt; None:\n        self._manager = manager\n        self._blocks: dict[str, ShmBlock] = {}\n\n    def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n        # print(f\"alloc {'temp' if temporary else ''}\")\n        shm = self._manager.SharedMemory(size=size)\n        block = ShmBlock(\n            name=shm.name,\n            size=shm.size,\n            shm=shm,\n            content_size=size,\n            temporary=temporary,\n        )\n        self._blocks[block.name] = block\n        return block\n\n    def attach(self, ref: ShmRef) -&gt; ShmBlock:\n        if ref[\"name\"] in self._blocks:\n            return self._blocks[ref[\"name\"]]\n        shm = SharedMemory(name=ref[\"name\"])\n        block = ShmBlock(\n            name=ref[\"name\"],\n            size=ref[\"size\"],\n            shm=shm,\n            content_size=ref[\"content_size\"],\n            temporary=ref[\"temporary\"],\n        )\n        self._blocks[ref[\"name\"]] = block\n        return block\n\n    def close_all(self) -&gt; None:\n        for block in self._blocks.values():\n            block.shm.close()\n        self._blocks.clear()\n\n    def gc(self, name: str | None = None):\n        if name is not None:\n            b = self._blocks.pop(name, None)\n            if b is not None:\n                b.shm.close()\n            return\n\n        for key in list(self._blocks.keys()):\n            b = self._blocks[key]\n            if b.temporary:\n                b.shm.close()\n            del self._blocks[key]\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.ShmPool-attributes","title":"Attributes","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.ShmPool._manager","title":"<code>_manager = manager</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.ShmPool._blocks","title":"<code>_blocks = {}</code>  <code>instance-attribute</code>","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.ShmPool-functions","title":"Functions","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.ShmPool.__init__","title":"<code>__init__(manager)</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def __init__(self, manager: SharedMemoryManager) -&gt; None:\n    self._manager = manager\n    self._blocks: dict[str, ShmBlock] = {}\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.ShmPool.alloc","title":"<code>alloc(size, temporary=False)</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n    # print(f\"alloc {'temp' if temporary else ''}\")\n    shm = self._manager.SharedMemory(size=size)\n    block = ShmBlock(\n        name=shm.name,\n        size=shm.size,\n        shm=shm,\n        content_size=size,\n        temporary=temporary,\n    )\n    self._blocks[block.name] = block\n    return block\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.ShmPool.attach","title":"<code>attach(ref)</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def attach(self, ref: ShmRef) -&gt; ShmBlock:\n    if ref[\"name\"] in self._blocks:\n        return self._blocks[ref[\"name\"]]\n    shm = SharedMemory(name=ref[\"name\"])\n    block = ShmBlock(\n        name=ref[\"name\"],\n        size=ref[\"size\"],\n        shm=shm,\n        content_size=ref[\"content_size\"],\n        temporary=ref[\"temporary\"],\n    )\n    self._blocks[ref[\"name\"]] = block\n    return block\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.ShmPool.close_all","title":"<code>close_all()</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def close_all(self) -&gt; None:\n    for block in self._blocks.values():\n        block.shm.close()\n    self._blocks.clear()\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.ShmPool.gc","title":"<code>gc(name=None)</code>","text":"Source code in <code>brmspy/_session/transport.py</code> <pre><code>def gc(self, name: str | None = None):\n    if name is not None:\n        b = self._blocks.pop(name, None)\n        if b is not None:\n            b.shm.close()\n        return\n\n    for key in list(self._blocks.keys()):\n        b = self._blocks[key]\n        if b.temporary:\n            b.shm.close()\n        del self._blocks[key]\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker-functions","title":"Functions","text":""},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.get_default_registry","title":"<code>get_default_registry()</code>","text":"<p>Return the process-global default codec registry.</p> <p>Returns:</p> Type Description <code>CodecRegistry</code> <p>Registry with SHM-first codecs registered, plus a pickle fallback.</p> Source code in <code>brmspy/_session/codec/registry.py</code> <pre><code>def get_default_registry() -&gt; CodecRegistry:\n    \"\"\"\n    Return the process-global default codec registry.\n\n    Returns\n    -------\n    brmspy._session.codec.base.CodecRegistry\n        Registry with SHM-first codecs registered, plus a pickle fallback.\n    \"\"\"\n    global _default_registry\n    if _default_registry is None:\n        reg = CodecRegistry()\n        reg.register(NumpyArrayCodec())\n        reg.register(InferenceDataCodec())\n        reg.register(PandasDFCodec())\n\n        register_dataclasses(reg)\n\n        # MUST BE LAST\n        reg.register(PickleCodec())\n\n        _default_registry = reg\n    return _default_registry\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.setup_worker_logging","title":"<code>setup_worker_logging(log_queue, level=None)</code>","text":"<p>Configure worker logging to forward into the parent's log queue.</p> <p>Parameters:</p> Name Type Description Default <code>log_queue</code> <code>Queue</code> <p>Queue owned by the parent; the worker will emit <code>logging</code> records into it.</p> required <code>level</code> <code>int | None</code> <p>Root log level for the worker process. Defaults to <code>logging.INFO</code>.</p> <code>None</code> Notes <p>When <code>BRMSPY_WORKER=1</code>, the worker replaces <code>builtins.print</code> to preserve raw control characters and line endings produced by R/cmdstan.</p> Source code in <code>brmspy/_session/worker/logging.py</code> <pre><code>def setup_worker_logging(log_queue: Queue, level: int | None = None) -&gt; None:\n    \"\"\"\n    Configure worker logging to forward into the parent's log queue.\n\n    Parameters\n    ----------\n    log_queue : multiprocessing.queues.Queue\n        Queue owned by the parent; the worker will emit `logging` records into it.\n    level : int | None, optional\n        Root log level for the worker process. Defaults to `logging.INFO`.\n\n    Notes\n    -----\n    When `BRMSPY_WORKER=1`, the worker replaces [`builtins.print`](https://docs.python.org/3/library/functions.html#print)\n    to preserve raw control characters and line endings produced by R/cmdstan.\n    \"\"\"\n    root = logging.getLogger()\n    root.handlers.clear()\n    root.setLevel(level or logging.INFO)\n    root.addHandler(QueueHandler(log_queue))\n\n    logger = get_logger()\n\n    def _print(*values: object, **kwargs):\n        sep = kwargs.get(\"sep\", \" \")\n        end = kwargs.get(\"end\", \"\\n\")\n\n        # Preserve raw control chars and end exactly as R/cmdstan intended\n        msg = sep.join(str(v) for v in values) + end\n\n        if msg == \"\":\n            return\n\n        logger.info(\n            msg,\n            extra={\n                \"method_name\": \"_print\",\n                \"no_prefix\": True,\n                \"from_print\": True,  # important for filters\n            },\n        )\n\n    if os.environ.get(\"BRMSPY_WORKER\") == \"1\":\n        builtins.print = _print\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker._initialise_r_safe","title":"<code>_initialise_r_safe()</code>","text":"<p>Configure R for safer embedded execution.</p> <ul> <li>Try to enforce rpy2 ABI mode (must be set before importing rpy2)</li> <li>Disable fork-based R parallelism (future::multicore, mclapply)</li> <li>Use future::plan(sequential) if future is available</li> <li>Leave cmdstanr multi-core sampling alone</li> </ul> Source code in <code>brmspy/_session/worker/setup.py</code> <pre><code>def _initialise_r_safe() -&gt; None:\n    \"\"\"\n    Configure R for safer embedded execution.\n\n    - Try to enforce rpy2 ABI mode (must be set before importing rpy2)\n    - Disable fork-based R parallelism (future::multicore, mclapply)\n    - Use future::plan(sequential) if future is available\n    - Leave cmdstanr multi-core sampling alone\n    \"\"\"\n\n    import os\n    import sys\n\n    # CFFI MODE\n    if \"rpy2\" in sys.modules:\n        if os.environ.get(\"RPY2_CFFI_MODE\") != \"ABI\":\n            print(\n                \"[brmspy][WARNING] rpy2 was imported before brmspy; cannot enforce \"\n                \"RPY2_CFFI_MODE (env var). API and BOTH mode are known to cause \"\n                \"instability, ABI is recommended.\"\n            )\n    elif os.environ.get(\"RPY2_CFFI_MODE\") in (\"BOTH\", \"API\"):\n        print(\n            \"[brmspy][WARNING] RPY2_CFFI_MODE (env var) is set to API/BOTH. \"\n            \"These modes are known to cause instability and segfaults; \"\n            \"ABI is recommended.\"\n        )\n    os.environ.setdefault(\"RPY2_CFFI_MODE\", \"ABI\")\n\n    # THREAD SAFETY\n    # Could also lead to undefined behaviour if &gt;1\n    os.environ.setdefault(\"OMP_NUM_THREADS\", \"1\")\n    os.environ.setdefault(\"OPENBLAS_NUM_THREADS\", \"1\")\n\n    ok, messages = _check_r_setup()\n    if not ok:\n        print(\"[brmspy][WARNING] R environment diagnostics reported problems.\")\n        for message in messages:\n            print(f\"[brmspy][WARNING]   {message}\")\n\n    import rpy2.robjects as ro\n\n    ro.r(\n        r\"\"\"\n        # Disable fork-based mechanisms that are unsafe in embedded R\n        options(\n          mc.cores = 1L,             # parallel::mclapply -&gt; serial\n          future.fork.enable = FALSE, # disable future::multicore\n          loo.cores = 1L # deprecated but still respected, for now.\n        )\n\n        # If 'future' is installed, force sequential backend\n        if (requireNamespace(\"future\", quietly = TRUE)) {\n          future::plan(future::sequential)\n        }\n        \"\"\"\n    )\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.activate","title":"<code>activate(env_conf)</code>","text":"<p>Apply runtime + environment library configuration in the worker.</p> <p>This may activate/deactivate a brmspy runtime (prebuilt bundle) and ensures the per-environment user library is at the front of R <code>.libPaths()</code>.</p> Notes <p>This is intentionally worker-only: it imports runtime helpers and mutates the embedded R process state.</p> Source code in <code>brmspy/_session/worker/setup.py</code> <pre><code>def activate(env_conf: EnvironmentConfig) -&gt; None:\n    \"\"\"\n    Apply runtime + environment library configuration in the worker.\n\n    This may activate/deactivate a brmspy runtime (prebuilt bundle) and ensures the\n    per-environment user library is at the front of R `.libPaths()`.\n\n    Notes\n    -----\n    This is intentionally worker-only: it imports runtime helpers and mutates the\n    embedded R process state.\n    \"\"\"\n    from brmspy._runtime import _r_env, activate_runtime, deactivate_runtime, status\n\n    _status = status()\n\n    if env_conf.runtime_path:\n        if _status.active_runtime and _status.is_activated:\n            if not _status.active_runtime.samefile(env_conf.runtime_path):\n                if os.environ.get(\"BRMSPY_AUTOLOAD\") == \"1\":\n                    raise Exception(\n                        \"Can't unload environments when autoload is enabled!\"\n                    )\n                deactivate_runtime()\n                activate_runtime(env_conf.runtime_path)\n    else:\n        if _status.active_runtime and _status.is_activated:\n            if os.environ.get(\"BRMSPY_AUTOLOAD\") == \"1\":\n                raise Exception(\"Can't unload environments when autoload is enabled!\")\n            deactivate_runtime()\n\n    userlib_path = get_environment_userlibs_dir(env_conf.environment_name)\n    lib_paths = _r_env.get_lib_paths()\n    lib_paths = [\n        p\n        for p in lib_paths\n        if \".brmspy/environment/\" not in p and \".brmspy\\\\environment\\\\\" not in p\n    ]\n    lib_paths.insert(0, userlib_path.as_posix())\n    _r_env.set_lib_paths(lib_paths)\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.run_startup_scripts","title":"<code>run_startup_scripts(env_conf)</code>","text":"<p>Execute configured R startup scripts in the worker.</p> <p>Parameters:</p> Name Type Description Default <code>env_conf</code> <code>EnvironmentConfig</code> <p>Environment configuration. If <code>startup_scripts</code> is empty/None, this is a no-op.</p> required Source code in <code>brmspy/_session/worker/setup.py</code> <pre><code>def run_startup_scripts(env_conf: EnvironmentConfig) -&gt; None:\n    \"\"\"\n    Execute configured R startup scripts in the worker.\n\n    Parameters\n    ----------\n    env_conf : brmspy.types.session.EnvironmentConfig\n        Environment configuration. If `startup_scripts` is empty/None, this is a no-op.\n    \"\"\"\n    if not env_conf.startup_scripts:\n        return\n    scripts: list[str] = env_conf.startup_scripts\n\n    import rpy2.robjects as ro\n\n    for code in scripts:\n        ro.r(code)\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.cache_sexp","title":"<code>cache_sexp(obj)</code>","text":"<p>Replace any embedded-R objects inside <code>obj</code> with <code>SexpWrapper</code> handles.</p> <p>Supports: - plain <code>rpy2.rinterface_lib.sexp.Sexp</code> - rpy2.robjects wrappers (e.g. vectors/matrices), by extracting the underlying Sexp - objects with an <code>.r</code> attribute - list/dict containers (recursively)</p> <p>This keeps the main process free of rpy2/embedded-R objects.</p> Source code in <code>brmspy/_session/worker/sexp_cache.py</code> <pre><code>def cache_sexp(obj: Any) -&gt; Any:\n    \"\"\"\n    Replace any embedded-R objects inside `obj` with `SexpWrapper` handles.\n\n    Supports:\n    - plain `rpy2.rinterface_lib.sexp.Sexp`\n    - rpy2.robjects wrappers (e.g. vectors/matrices), by extracting the underlying Sexp\n    - objects with an `.r` attribute\n    - list/dict containers (recursively)\n\n    This keeps the main process free of rpy2/embedded-R objects.\n    \"\"\"\n\n    sexp = _extract_sexp(obj)\n    if sexp is not None:\n        return _cache_single(sexp)\n\n    if hasattr(obj, \"r\"):\n        obj.r = cache_sexp(obj.r)\n\n    if isinstance(obj, list):\n        return [cache_sexp(o) for o in obj]\n    if isinstance(obj, dict):\n        return {k: cache_sexp(v) for k, v in obj.items()}\n\n    return obj\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.reattach_sexp","title":"<code>reattach_sexp(obj)</code>","text":"<p>Replace any <code>SexpWrapper</code> handles inside <code>obj</code> with the cached <code>Sexp</code>.</p> <p>If a wrapper cannot be resolved (rid not in cache), the wrapper is replaced with <code>None</code>.</p> Source code in <code>brmspy/_session/worker/sexp_cache.py</code> <pre><code>def reattach_sexp(obj: Any) -&gt; Any:\n    \"\"\"\n    Replace any `SexpWrapper` handles inside `obj` with the cached `Sexp`.\n\n    If a wrapper cannot be resolved (rid not in cache), the wrapper is replaced\n    with `None`.\n    \"\"\"\n    if isinstance(obj, list):\n        return [reattach_sexp(v) for v in obj]\n    elif isinstance(obj, dict):\n        return {k: reattach_sexp(v) for k, v in obj.items()}\n    elif hasattr(obj, \"r\"):\n        obj.r = reattach_sexp(obj.r)\n    elif isinstance(obj, SexpWrapper):\n        if obj._rid in _SEXP_CACHE:\n            return _SEXP_CACHE[obj._rid]\n        else:\n            return None\n    return obj\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker.worker_main","title":"<code>worker_main(conn, mgr_address, mgr_authkey, runtime_conf, log_queue)</code>","text":"<p>Worker entrypoint.</p> <ul> <li>Connects to the already-running SharedMemoryManager (started in parent)</li> <li>Optionally configures R env via <code>runtime_conf</code></li> <li>Receives CALL/SHUTDOWN commands over <code>conn</code></li> <li>Executes Python functions in modules inside this worker.   Those modules are free to use rpy2 / brms / cmdstanr however they like.</li> </ul> Source code in <code>brmspy/_session/worker/worker.py</code> <pre><code>def worker_main(\n    conn: Connection,\n    mgr_address: str | None,\n    mgr_authkey: bytes | None,\n    runtime_conf: EnvironmentConfig,\n    log_queue: mp.Queue,\n) -&gt; None:\n    \"\"\"\n    Worker entrypoint.\n\n    - Connects to the already-running SharedMemoryManager (started in parent)\n    - Optionally configures R env via `runtime_conf`\n    - Receives CALL/SHUTDOWN commands over `conn`\n    - Executes *Python* functions in modules inside this worker.\n      Those modules are free to use rpy2 / brms / cmdstanr however they like.\n    \"\"\"\n\n    setup_worker_logging(log_queue)\n\n    import os\n\n    os.environ[\"BRMSPY_WORKER\"] = \"1\"\n\n    _initialise_r_safe()\n\n    # 1. Connect to SHM manager\n    smm = SharedMemoryManager(address=mgr_address, authkey=mgr_authkey, ctx=ctx)\n    smm.connect()\n\n    # 2. Optional environment init (R_HOME, R_LIBS_USER, etc.)\n    activate(runtime_conf)\n    run_startup_scripts(runtime_conf)\n\n    shm_pool = ShmPool(smm)\n    reg = get_default_registry()\n\n    module_cache: dict[str, Any] = {}\n\n    import rpy2.rinterface_lib.callbacks\n    from rpy2.rinterface_lib.sexp import Sexp\n\n    rpy2.rinterface_lib.callbacks._WRITECONSOLE_EXCEPTION_LOG = (\n        \"[R]: {exception} {exc_value} {traceback}\"\n    )\n\n    from ..._singleton._shm_singleton import _set_shm\n\n    _set_shm(shm_pool)\n\n    try:\n        while True:\n            req = conn.recv()\n            cmd = req[\"cmd\"]\n            req_id = req[\"id\"]\n\n            shm_pool.gc()\n\n            try:\n                if cmd == \"SHUTDOWN\":\n                    conn.send(\n                        {\n                            \"id\": req_id,\n                            \"ok\": True,\n                            \"result\": None,\n                            \"error\": None,\n                            \"traceback\": None,\n                        }\n                    )\n                    break\n\n                elif cmd == \"PING\":\n                    conn.send(\n                        {\n                            \"id\": req_id,\n                            \"ok\": True,\n                            \"result\": None,\n                            \"error\": None,\n                            \"traceback\": None,\n                        }\n                    )\n                    continue\n\n                elif cmd == \"CALL\":\n                    # decode Python args\n                    args = [reg.decode(p, shm_pool=shm_pool) for p in req[\"args\"]]\n                    kwargs = {\n                        k: reg.decode(p, shm_pool=shm_pool)\n                        for k, p in req[\"kwargs\"].items()\n                    }\n                    args: list[Any] = reattach_sexp(args)\n                    kwargs: dict[str, Any] = reattach_sexp(kwargs)\n\n                    # resolve \"mod:pkg.module.func\"\n                    target = _resolve_module_target(req[\"target\"], module_cache)\n                    out = target(*args, **kwargs)\n                    out = cache_sexp(out)\n\n                    # encode result\n                    enc = reg.encode(out, shm_pool)\n                    result_payload: PayloadRef = {\n                        \"codec\": enc.codec,\n                        \"meta\": enc.meta,\n                        \"buffers\": enc.buffers,\n                    }\n\n                    conn.send(\n                        {\n                            \"id\": req_id,\n                            \"ok\": True,\n                            \"result\": result_payload,\n                            \"error\": None,\n                            \"traceback\": None,\n                        }\n                    )\n\n                elif cmd == \"_RUN_TEST_BY_NAME\":\n                    module = req[\"kwargs\"][\"module\"]\n                    classname = req[\"kwargs\"][\"class\"]\n                    funcname = req[\"kwargs\"][\"func\"]\n\n                    try:\n                        mod = importlib.import_module(module)\n\n                        if classname:\n                            cls = getattr(mod, classname)\n                            inst = cls()\n                            fn = getattr(inst, funcname)\n                        else:\n                            fn = getattr(mod, funcname)\n\n                        result = fn()\n\n                        enc = reg.encode(result, shm_pool)\n                        conn.send(\n                            {\n                                \"id\": req_id,\n                                \"ok\": True,\n                                \"result\": {\n                                    \"codec\": enc.codec,\n                                    \"meta\": enc.meta,\n                                    \"buffers\": enc.buffers,\n                                },\n                                \"error\": None,\n                                \"traceback\": None,\n                            }\n                        )\n\n                    except Exception as e:\n                        import traceback\n\n                        conn.send(\n                            {\n                                \"id\": req_id,\n                                \"ok\": False,\n                                \"result\": None,\n                                \"error\": str(e),\n                                \"traceback\": traceback.format_exc(),\n                            }\n                        )\n\n                else:\n                    raise ValueError(f\"Unknown command: {cmd!r}\")\n\n            except RRuntimeError as e:\n                import traceback\n                import rpy2.robjects as ro\n\n                tb = \"\".join(traceback.format_exception(type(e), e, e.__traceback__))\n                full_msg = str(e)\n\n                ignore_msgs = [\"Can't show last error because no error was recorded\"]\n\n                try:\n\n                    # traceback() prints and returns a pairlist -&gt; coerce to something nice\n                    r_tb = \"\\n\".join(\n                        list(\n                            str(v)\n                            for v in cast(ro.ListVector, ro.r(\"unlist(traceback())\"))\n                        )\n                    )\n                    tb = r_tb\n                except Exception as tb_exc:\n                    pass\n\n                # Full base R error message\n                try:\n                    # full rlang error message (can be multi-line, with bullets etc.)\n                    _msg = str(\n                        cast(\n                            ro.ListVector,\n                            ro.r(\"rlang::format_error_bullets(rlang::last_error())\"),\n                        )[0]\n                    )\n                    if _msg and not any(part in _msg for part in ignore_msgs):\n                        full_msg = _msg\n                    else:\n                        raise\n                except Exception:\n                    # fallback to base R\n                    try:\n                        _msg = str(cast(ro.ListVector, ro.r(\"geterrmessage()\"))[0])\n                        if _msg and not any(part in _msg for part in ignore_msgs):\n                            full_msg = _msg\n                        else:\n                            raise\n                    except Exception:\n                        pass\n\n                conn.send(\n                    {\n                        \"id\": req_id,\n                        \"ok\": False,\n                        \"result\": None,\n                        \"error\": str(full_msg),\n                        \"traceback\": tb,\n                    }\n                )\n\n            except Exception as e:\n                import traceback\n\n                tb = \"\".join(traceback.format_exception(type(e), e, e.__traceback__))\n                conn.send(\n                    {\n                        \"id\": req_id,\n                        \"ok\": False,\n                        \"result\": None,\n                        \"error\": str(e),\n                        \"traceback\": tb,\n                    }\n                )\n    finally:\n        pass\n</code></pre>"},{"location":"internals/_session/worker/worker/#brmspy._session.worker.worker._resolve_module_target","title":"<code>_resolve_module_target(target, module_cache)</code>","text":"<p>Resolve a worker-call target.</p> <p>Supported target formats:</p> <ul> <li> <p>Module function format:     mod:pkg.module.func</p> </li> <li> <p>Attribute-chain format (for class-based surfaces, etc):     mod:pkg.module::Attr.chain.to.callable</p> </li> </ul> <p>Example:     mod:brmspy.brms._build_module::BuildModule.collect_runtime_metadata</p> Source code in <code>brmspy/_session/worker/worker.py</code> <pre><code>def _resolve_module_target(target: str, module_cache: dict[str, Any]):\n    \"\"\"\n    Resolve a worker-call target.\n\n    Supported target formats:\n\n    - Module function format:\n        mod:pkg.module.func\n\n    - Attribute-chain format (for class-based surfaces, etc):\n        mod:pkg.module::Attr.chain.to.callable\n\n      Example:\n        mod:brmspy.brms._build_module::BuildModule.collect_runtime_metadata\n    \"\"\"\n    if not target.startswith(\"mod:\"):\n        raise ValueError(f\"Unknown target kind: {target!r}\")\n\n    spec = target[len(\"mod:\") :]  # strip \"mod:\"\n\n    # Module + attribute chain separator\n    if \"::\" in spec:\n        mod_name, attr_chain = spec.split(\"::\", 1)\n        mod_name = mod_name.strip()\n        attr_chain = attr_chain.strip()\n\n        if not mod_name or not attr_chain:\n            raise ValueError(f\"Invalid module target: {target!r}\")\n\n        mod = module_cache.get(mod_name)\n        if mod is None:\n            mod = importlib.import_module(mod_name)\n            module_cache[mod_name] = mod\n\n        obj: Any = mod\n        for part in attr_chain.split(\".\"):\n            if not part:\n                raise ValueError(f\"Invalid module target: {target!r}\")\n            if not hasattr(obj, part):\n                raise AttributeError(\n                    f\"Target {target!r} missing attribute {part!r} on {obj!r}\"\n                )\n            obj = getattr(obj, part)\n\n        return obj\n    else:\n        # Module level resolution\n        if \".\" not in spec:\n            raise ValueError(f\"Invalid module target: {target!r}\")\n\n        mod_name, func_name = spec.rsplit(\".\", 1)\n\n        mod = module_cache.get(mod_name)\n        if mod is None:\n            mod = importlib.import_module(mod_name)\n            module_cache[mod_name] = mod\n\n        if not hasattr(mod, func_name):\n            raise AttributeError(f\"Module {mod_name!r} has no attribute {func_name!r}\")\n        return getattr(mod, func_name)\n</code></pre>"},{"location":"internals/_singleton/_brms/","title":"_brms","text":""},{"location":"internals/_singleton/_brms/#brmspy._singleton._brms-functions","title":"Functions","text":""},{"location":"internals/_singleton/_brms/#brmspy._singleton._brms.active","title":"<code>active()</code>","text":"Source code in <code>brmspy/_singleton/_brms.py</code> <pre><code>def active():\n    from brmspy import brms\n\n    return brms\n</code></pre>"},{"location":"internals/_singleton/_shm_singleton/","title":"_shm_singleton","text":""},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton-attributes","title":"Attributes","text":""},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton._shm","title":"<code>_shm = None</code>  <code>module-attribute</code>","text":""},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton.__all__","title":"<code>__all__ = ['_get_shm', '_set_shm']</code>  <code>module-attribute</code>","text":""},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton-classes","title":"Classes","text":""},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton.ShmPool","title":"<code>ShmPool</code>","text":"<p>Minimal interface for allocating and attaching shared-memory blocks.</p> <p>The concrete implementation lives in <code>brmspy._session.transport.ShmPool</code> and tracks blocks so they can be closed on teardown.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>class ShmPool:\n    \"\"\"\n    Minimal interface for allocating and attaching shared-memory blocks.\n\n    The concrete implementation lives in\n    [`brmspy._session.transport.ShmPool`][brmspy._session.transport.ShmPool] and tracks\n    blocks so they can be closed on teardown.\n    \"\"\"\n\n    def __init__(self, manager: SharedMemoryManager) -&gt; None:\n        \"\"\"\n        Create a pool bound to an existing `SharedMemoryManager`.\n\n        Parameters\n        ----------\n        manager : multiprocessing.managers.SharedMemoryManager\n            Manager used to allocate blocks.\n        \"\"\"\n        ...\n\n    def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n        \"\"\"\n        Allocate a new shared-memory block.\n\n        Parameters\n        ----------\n        size : int\n            Size in bytes.\n\n        Returns\n        -------\n        ShmBlock\n            Newly allocated block.\n        \"\"\"\n        ...\n\n    def attach(self, ref: ShmRef) -&gt; ShmBlock:\n        \"\"\"\n        Attach to an existing shared-memory block by name.\n\n        Returns\n        -------\n        ShmBlock\n            Attached block.\n        \"\"\"\n        ...\n\n    def close_all(self) -&gt; None:\n        \"\"\"\n        Close all tracked shared-memory handles owned by this pool.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        ...\n\n    def gc(self, name: str | None = None) -&gt; None: ...\n</code></pre>"},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton.ShmPool-functions","title":"Functions","text":""},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton.ShmPool.__init__","title":"<code>__init__(manager)</code>","text":"<p>Create a pool bound to an existing <code>SharedMemoryManager</code>.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SharedMemoryManager</code> <p>Manager used to allocate blocks.</p> required Source code in <code>brmspy/types/shm.py</code> <pre><code>def __init__(self, manager: SharedMemoryManager) -&gt; None:\n    \"\"\"\n    Create a pool bound to an existing `SharedMemoryManager`.\n\n    Parameters\n    ----------\n    manager : multiprocessing.managers.SharedMemoryManager\n        Manager used to allocate blocks.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton.ShmPool.alloc","title":"<code>alloc(size, temporary=False)</code>","text":"<p>Allocate a new shared-memory block.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size in bytes.</p> required <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Newly allocated block.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n    \"\"\"\n    Allocate a new shared-memory block.\n\n    Parameters\n    ----------\n    size : int\n        Size in bytes.\n\n    Returns\n    -------\n    ShmBlock\n        Newly allocated block.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton.ShmPool.attach","title":"<code>attach(ref)</code>","text":"<p>Attach to an existing shared-memory block by name.</p> <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Attached block.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>def attach(self, ref: ShmRef) -&gt; ShmBlock:\n    \"\"\"\n    Attach to an existing shared-memory block by name.\n\n    Returns\n    -------\n    ShmBlock\n        Attached block.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton.ShmPool.close_all","title":"<code>close_all()</code>","text":"<p>Close all tracked shared-memory handles owned by this pool.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>brmspy/types/shm.py</code> <pre><code>def close_all(self) -&gt; None:\n    \"\"\"\n    Close all tracked shared-memory handles owned by this pool.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton.ShmPool.gc","title":"<code>gc(name=None)</code>","text":"Source code in <code>brmspy/types/shm.py</code> <pre><code>def gc(self, name: str | None = None) -&gt; None: ...\n</code></pre>"},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton-functions","title":"Functions","text":""},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton._get_shm","title":"<code>_get_shm()</code>","text":"Source code in <code>brmspy/_singleton/_shm_singleton.py</code> <pre><code>def _get_shm() -&gt; ShmPool | None:\n    global _shm\n    return _shm\n</code></pre>"},{"location":"internals/_singleton/_shm_singleton/#brmspy._singleton._shm_singleton._set_shm","title":"<code>_set_shm(shm)</code>","text":"Source code in <code>brmspy/_singleton/_shm_singleton.py</code> <pre><code>def _set_shm(shm: ShmPool | None):\n    global _shm\n    _shm = shm\n</code></pre>"},{"location":"internals/brms/_brms_module/","title":"_brms_module","text":"<p>Main brms module with Pythonic API.</p>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FitResult","title":"<code>FitResult = IDResult[IDBrm]</code>  <code>module-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module-classes","title":"Classes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDResult","title":"<code>IDResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T_idata]</code>, <code>RListVectorExtension</code></p> <p>Generic result container with arviz and R objects.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData object</p> <code>r</code> <code>ListVector</code> <p>R object from brms</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass\nclass IDResult(Generic[T_idata], RListVectorExtension):\n    \"\"\"Generic result container with arviz and R objects.\n\n    Attributes\n    ----------\n    idata : arviz.InferenceData\n        arviz InferenceData object\n    r : robjects.ListVector\n        R object from brms\n    \"\"\"\n\n    idata: T_idata\n\n    def __repr__(self) -&gt; str:\n        return repr(self.idata)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDResult-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDResult.idata","title":"<code>idata</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDResult-functions","title":"Functions","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDResult.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/brms_results.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return repr(self.idata)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDResult.__init__","title":"<code>__init__(r, idata)</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult","title":"<code>LooResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Parsed <code>brms::loo()</code> result.</p> <p>Attributes:</p> Name Type Description <code>estimates, pointwise, diagnostics</code> <code>DataFrame</code> <p>LOO tables.</p> <code>psis_object</code> <code>Any or None</code> <p>PSIS object (if present). May be an R-handle wrapper depending on conversion.</p> <code>elpd_loo, p_loo, looic</code> <code>float</code> <p>Key scalar metrics.</p> <code>se_elpd_loo, se_p_loo, se_looic</code> <code>float</code> <p>Standard errors for the corresponding scalars.</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass\nclass LooResult(RListVectorExtension):\n    \"\"\"\n    Parsed `brms::loo()` result.\n\n    Attributes\n    ----------\n    estimates, pointwise, diagnostics : pandas.DataFrame\n        LOO tables.\n    psis_object : Any or None\n        PSIS object (if present). May be an R-handle wrapper depending on conversion.\n    elpd_loo, p_loo, looic : float\n        Key scalar metrics.\n    se_elpd_loo, se_p_loo, se_looic : float\n        Standard errors for the corresponding scalars.\n    \"\"\"\n\n    estimates: pd.DataFrame\n    pointwise: pd.DataFrame\n    diagnostics: pd.DataFrame\n    psis_object: Any | None\n    elpd_loo: float\n    p_loo: float\n    looic: float\n    se_elpd_loo: float\n    se_p_loo: float\n    se_looic: float\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Pretty print LOO-CV results.\"\"\"\n        lines = []\n        lines.append(\"LOO-CV Results\")\n        lines.append(\"=\" * 50)\n        lines.append(f\"ELPD LOO:  {self.elpd_loo:&gt;10.2f}  (SE: {self.se_elpd_loo:.2f})\")\n        lines.append(f\"p_loo:     {self.p_loo:&gt;10.2f}  (SE: {self.se_p_loo:.2f})\")\n        lines.append(f\"LOOIC:     {self.looic:&gt;10.2f}  (SE: {self.se_looic:.2f})\")\n        lines.append(\"\")\n\n        # Show Pareto k diagnostic summary if available\n        if isinstance(self.diagnostics, pd.DataFrame) and not self.diagnostics.empty:\n            if \"pareto_k\" in self.diagnostics.columns:\n                k_vals = self.diagnostics[\"pareto_k\"]\n                lines.append(\"Pareto k Diagnostics:\")\n                lines.append(\n                    f\"  Good (k &lt; 0.5):       {(k_vals &lt; 0.5).sum():&gt;5} observations\"\n                )\n                lines.append(\n                    f\"  OK (0.5 \u2264 k &lt; 0.7):   {((k_vals &gt;= 0.5) &amp; (k_vals &lt; 0.7)).sum():&gt;5} observations\"\n                )\n                lines.append(\n                    f\"  Bad (0.7 \u2264 k &lt; 1):    {((k_vals &gt;= 0.7) &amp; (k_vals &lt; 1)).sum():&gt;5} observations\"\n                )\n                lines.append(\n                    f\"  Very bad (k \u2265 1):     {(k_vals &gt;= 1).sum():&gt;5} observations\"\n                )\n\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult.estimates","title":"<code>estimates</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult.pointwise","title":"<code>pointwise</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult.diagnostics","title":"<code>diagnostics</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult.psis_object","title":"<code>psis_object</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult.elpd_loo","title":"<code>elpd_loo</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult.p_loo","title":"<code>p_loo</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult.looic","title":"<code>looic</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult.se_elpd_loo","title":"<code>se_elpd_loo</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult.se_p_loo","title":"<code>se_p_loo</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult.se_looic","title":"<code>se_looic</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult-functions","title":"Functions","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult.__repr__","title":"<code>__repr__()</code>","text":"<p>Pretty print LOO-CV results.</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Pretty print LOO-CV results.\"\"\"\n    lines = []\n    lines.append(\"LOO-CV Results\")\n    lines.append(\"=\" * 50)\n    lines.append(f\"ELPD LOO:  {self.elpd_loo:&gt;10.2f}  (SE: {self.se_elpd_loo:.2f})\")\n    lines.append(f\"p_loo:     {self.p_loo:&gt;10.2f}  (SE: {self.se_p_loo:.2f})\")\n    lines.append(f\"LOOIC:     {self.looic:&gt;10.2f}  (SE: {self.se_looic:.2f})\")\n    lines.append(\"\")\n\n    # Show Pareto k diagnostic summary if available\n    if isinstance(self.diagnostics, pd.DataFrame) and not self.diagnostics.empty:\n        if \"pareto_k\" in self.diagnostics.columns:\n            k_vals = self.diagnostics[\"pareto_k\"]\n            lines.append(\"Pareto k Diagnostics:\")\n            lines.append(\n                f\"  Good (k &lt; 0.5):       {(k_vals &lt; 0.5).sum():&gt;5} observations\"\n            )\n            lines.append(\n                f\"  OK (0.5 \u2264 k &lt; 0.7):   {((k_vals &gt;= 0.5) &amp; (k_vals &lt; 0.7)).sum():&gt;5} observations\"\n            )\n            lines.append(\n                f\"  Bad (0.7 \u2264 k &lt; 1):    {((k_vals &gt;= 0.7) &amp; (k_vals &lt; 1)).sum():&gt;5} observations\"\n            )\n            lines.append(\n                f\"  Very bad (k \u2265 1):     {(k_vals &gt;= 1).sum():&gt;5} observations\"\n            )\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooResult.__init__","title":"<code>__init__(r, estimates, pointwise, diagnostics, psis_object, elpd_loo, p_loo, looic, se_elpd_loo, se_p_loo, se_looic)</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooCompareResult","title":"<code>LooCompareResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result of comparing models by a LOO-style criterion.</p> <p>Attributes:</p> Name Type Description <code>table</code> <code>DataFrame</code> <p>Comparison table.</p> <code>criterion</code> <code>str</code> <p>Criterion name (e.g. <code>\"loo\"</code>).</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass\nclass LooCompareResult(RListVectorExtension):\n    \"\"\"\n    Result of comparing models by a LOO-style criterion.\n\n    Attributes\n    ----------\n    table : pandas.DataFrame\n        Comparison table.\n    criterion : str\n        Criterion name (e.g. ``\"loo\"``).\n    \"\"\"\n\n    table: pd.DataFrame\n    criterion: str\n\n    def __repr__(self) -&gt; str:\n        header = f\"Model comparison ({self.criterion.upper()})\"\n        lines = [header, \"=\" * len(header)]\n        lines.append(self.table.to_string())\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooCompareResult-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooCompareResult.table","title":"<code>table</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooCompareResult.criterion","title":"<code>criterion</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooCompareResult-functions","title":"Functions","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooCompareResult.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/brms_results.py</code> <pre><code>def __repr__(self) -&gt; str:\n    header = f\"Model comparison ({self.criterion.upper()})\"\n    lines = [header, \"=\" * len(header)]\n    lines.append(self.table.to_string())\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.LooCompareResult.__init__","title":"<code>__init__(r, table, criterion)</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDPosterior","title":"<code>IDPosterior</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .posterior extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDPosterior(IDConstantData):\n    \"\"\"Typed .posterior extension to idata\"\"\"\n\n    posterior: xr.Dataset\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDPosterior-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDPosterior.posterior","title":"<code>posterior</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDPosteriorPredictive","title":"<code>IDPosteriorPredictive</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .posterior_predictive extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDPosteriorPredictive(IDConstantData):\n    \"\"\"Typed .posterior_predictive extension to idata\"\"\"\n\n    posterior_predictive: xr.Dataset\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDPosteriorPredictive-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDPosteriorPredictive.posterior_predictive","title":"<code>posterior_predictive</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDPredictions","title":"<code>IDPredictions</code>","text":"<p>               Bases: <code>IDPredictionsConstantData</code></p> <p>Typed .predictions extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDPredictions(IDPredictionsConstantData):\n    \"\"\"Typed .predictions extension to idata\"\"\"\n\n    predictions: xr.Dataset\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDPredictions-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDPredictions.predictions","title":"<code>predictions</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDLogLikelihoodInsample","title":"<code>IDLogLikelihoodInsample</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .log_likelihood extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDLogLikelihoodInsample(IDConstantData):\n    \"\"\"Typed .log_likelihood extension to idata\"\"\"\n\n    log_likelihood: xr.Dataset\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDLogLikelihoodInsample-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDLogLikelihoodInsample.log_likelihood","title":"<code>log_likelihood</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDLogLikelihoodOutsample","title":"<code>IDLogLikelihoodOutsample</code>","text":"<p>               Bases: <code>IDPredictionsConstantData</code></p> <p>Typed .log_likelihood extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDLogLikelihoodOutsample(IDPredictionsConstantData):\n    \"\"\"Typed .log_likelihood extension to idata\"\"\"\n\n    log_likelihood: xr.Dataset\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDLogLikelihoodOutsample-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDLogLikelihoodOutsample.log_likelihood","title":"<code>log_likelihood</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDObservedData","title":"<code>IDObservedData</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed .posterior extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDObservedData(IDConstantData):\n    \"\"\"Typed .posterior extension to idata\"\"\"\n\n    observed_data: xr.Dataset\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDObservedData-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDObservedData.observed_data","title":"<code>observed_data</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDConstantData","title":"<code>IDConstantData</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed .constant_data extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDConstantData(az.InferenceData):\n    \"\"\"Typed .constant_data extension to idata\"\"\"\n\n    constant_data: xr.Dataset\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDConstantData-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDConstantData.constant_data","title":"<code>constant_data</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDPredictionsConstantData","title":"<code>IDPredictionsConstantData</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed .predictions_constant_data extension to idata</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDPredictionsConstantData(az.InferenceData):\n    \"\"\"Typed .predictions_constant_data extension to idata\"\"\"\n\n    predictions_constant_data: xr.Dataset\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDPredictionsConstantData-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDPredictionsConstantData.predictions_constant_data","title":"<code>predictions_constant_data</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.RListVectorExtension","title":"<code>RListVectorExtension</code>  <code>dataclass</code>","text":"<p>Generic result container with R objects.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R object from brms</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass\nclass RListVectorExtension:\n    \"\"\"Generic result container with R objects.\n\n    Attributes\n    ----------\n    r : robjects.ListVector\n        R object from brms\n    \"\"\"\n\n    r: ProxyListSexpVector\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.RListVectorExtension-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.RListVectorExtension.r","title":"<code>r</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.RListVectorExtension-functions","title":"Functions","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.RListVectorExtension.__init__","title":"<code>__init__(r)</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDBrm","title":"<code>IDBrm</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed <code>arviz.InferenceData</code> for fitted brms models.</p> <p>Extends <code>arviz.InferenceData</code> with type hints for IDE autocomplete. In brmspy, the fitted model result typically exposes an <code>.idata</code> attribute of this type.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Posterior samples of model parameters.</p> <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (with observation noise).</p> <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation.</p> <code>observed_data</code> <code>Dataset</code> <p>Original observed response data.</p> <code>coords</code> <code>dict</code> <p>Coordinate mappings for dimensions (inherited from <code>arviz.InferenceData</code>).</p> <code>dims</code> <code>dict</code> <p>Dimension specifications for variables (inherited from <code>arviz.InferenceData</code>).</p> See Also <p>brmspy.brms.brm : Creates fitted model results (alias: <code>brmspy.brms.fit</code>). arviz.InferenceData : Base class documentation.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.brm(\"y ~ x\", data=df, chains=4)\n\n# Type checking and autocomplete\nassert isinstance(model.idata, IDFit)\nprint(model.idata.posterior)\n</code></pre> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDBrm(IDConstantData):\n    \"\"\"\n    Typed `arviz.InferenceData` for fitted brms models.\n\n    Extends `arviz.InferenceData` with type hints for IDE autocomplete. In brmspy,\n    the fitted model result typically exposes an `.idata` attribute of this type.\n\n    Attributes\n    ----------\n    posterior : xr.Dataset\n        Posterior samples of model parameters.\n    posterior_predictive : xr.Dataset\n        Posterior predictive samples (with observation noise).\n    log_likelihood : xr.Dataset\n        Log-likelihood values for each observation.\n    observed_data : xr.Dataset\n        Original observed response data.\n    coords : dict\n        Coordinate mappings for dimensions (inherited from `arviz.InferenceData`).\n    dims : dict\n        Dimension specifications for variables (inherited from `arviz.InferenceData`).\n\n    See Also\n    --------\n    brmspy.brms.brm : Creates fitted model results (alias: `brmspy.brms.fit`).\n    arviz.InferenceData : Base class documentation.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    model = brms.brm(\"y ~ x\", data=df, chains=4)\n\n    # Type checking and autocomplete\n    assert isinstance(model.idata, IDFit)\n    print(model.idata.posterior)\n    ```\n    \"\"\"\n\n    posterior: xr.Dataset\n    posterior_predictive: xr.Dataset\n    log_likelihood: xr.Dataset\n    observed_data: xr.Dataset\n    coords: xr.Dataset\n    dims: xr.Dataset\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDBrm-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDBrm.posterior","title":"<code>posterior</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDBrm.posterior_predictive","title":"<code>posterior_predictive</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDBrm.log_likelihood","title":"<code>log_likelihood</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDBrm.observed_data","title":"<code>observed_data</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDBrm.coords","title":"<code>coords</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.IDBrm.dims","title":"<code>dims</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec","title":"<code>PriorSpec</code>  <code>dataclass</code>","text":"<p>Python representation of a brms prior specification.</p> <p>This dataclass provides a typed interface to <code>brms::prior_string()</code> arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the <code>prior()</code> factory function to create instances.</p> <p>Attributes:</p> Name Type Description <code>prior</code> <code>str</code> <p>Prior distribution as string (e.g., <code>\"normal(0, 1)\"</code>, <code>\"exponential(2)\"</code>).</p> <code>class_</code> <code>(str, optional)</code> <p>Parameter class: <code>\"b\"</code> (fixed effects), <code>\"sd\"</code> (group SD), <code>\"Intercept\"</code>, <code>\"sigma\"</code>, <code>\"cor\"</code>, etc.</p> <code>coef</code> <code>(str, optional)</code> <p>Specific coefficient name for class-level priors.</p> <code>group</code> <code>(str, optional)</code> <p>Grouping variable for hierarchical effects.</p> <code>dpar</code> <code>(str, optional)</code> <p>Distributional parameter (e.g., <code>\"sigma\"</code>, <code>\"phi\"</code>, <code>\"zi\"</code>).</p> <code>resp</code> <code>(str, optional)</code> <p>Response variable for multivariate models.</p> <code>nlpar</code> <code>(str, optional)</code> <p>Non-linear parameter name.</p> <code>lb</code> <code>(float, optional)</code> <p>Lower bound for truncated priors.</p> <code>ub</code> <code>(float, optional)</code> <p>Upper bound for truncated priors.</p> See Also <p>prior : Factory function to create <code>PriorSpec</code> instances. brms::prior_string : R documentation</p> <p>Examples:</p> <p>Create prior specifications (prefer using <code>prior()</code>):</p> <pre><code>from brmspy.types import PriorSpec\n\n# Fixed effect prior\np1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n# Group-level SD prior\np2 = PriorSpec(prior=\"exponential(2)\", class_=\"sd\", group=\"patient\")\n\n# Coefficient-specific prior with bounds\np3 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\", coef=\"age\", lb=0)\n</code></pre> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass(frozen=True)\nclass PriorSpec:\n    \"\"\"\n    Python representation of a brms prior specification.\n\n    This dataclass provides a typed interface to `brms::prior_string()` arguments,\n    allowing Python developers to specify priors with IDE autocomplete and type\n    checking. Use the [`prior()`][brmspy.brms.prior] factory function to create\n    instances.\n\n    Attributes\n    ----------\n    prior : str\n        Prior distribution as string (e.g., ``\"normal(0, 1)\"``, ``\"exponential(2)\"``).\n    class_ : str, optional\n        Parameter class: ``\"b\"`` (fixed effects), ``\"sd\"`` (group SD),\n        ``\"Intercept\"``, ``\"sigma\"``, ``\"cor\"``, etc.\n    coef : str, optional\n        Specific coefficient name for class-level priors.\n    group : str, optional\n        Grouping variable for hierarchical effects.\n    dpar : str, optional\n        Distributional parameter (e.g., ``\"sigma\"``, ``\"phi\"``, ``\"zi\"``).\n    resp : str, optional\n        Response variable for multivariate models.\n    nlpar : str, optional\n        Non-linear parameter name.\n    lb : float, optional\n        Lower bound for truncated priors.\n    ub : float, optional\n        Upper bound for truncated priors.\n\n    See Also\n    --------\n    prior : Factory function to create `PriorSpec` instances.\n    brms::prior_string : [R documentation](https://paulbuerkner.com/brms/reference/prior_string.html)\n\n    Examples\n    --------\n    Create prior specifications (prefer using [`prior()`][brmspy.brms.prior]):\n\n    ```python\n    from brmspy.types import PriorSpec\n\n    # Fixed effect prior\n    p1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n    # Group-level SD prior\n    p2 = PriorSpec(prior=\"exponential(2)\", class_=\"sd\", group=\"patient\")\n\n    # Coefficient-specific prior with bounds\n    p3 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\", coef=\"age\", lb=0)\n    ```\n    \"\"\"\n\n    prior: str\n    class_: str | None = None\n    coef: str | None = None\n    group: str | None = None\n    dpar: str | None = None\n    resp: str | None = None\n    nlpar: str | None = None\n    lb: float | None = None\n    ub: float | None = None\n\n    def to_brms_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Convert PriorSpec to keyword arguments for brms::prior_string().\n\n        Maps Python dataclass fields to R function arguments, handling\n        the `class_` -&gt; `class` parameter name conversion.\n\n        Returns\n        -------\n        dict\n            Keyword arguments ready for brms::prior_string()\n\n        Examples\n        --------\n        ```python\n        from brmspy import prior\n        p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n        kwargs = p.to_brms_kwargs()\n        print(kwargs)\n        # {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n        ```\n        \"\"\"\n        out: dict[str, Any] = {\"prior\": self.prior}\n        if self.class_ is not None:\n            out[\"class\"] = self.class_\n        if self.coef is not None:\n            out[\"coef\"] = self.coef\n        if self.group is not None:\n            out[\"group\"] = self.group\n        if self.dpar is not None:\n            out[\"dpar\"] = self.dpar\n        if self.resp is not None:\n            out[\"resp\"] = self.resp\n        if self.nlpar is not None:\n            out[\"nlpar\"] = self.nlpar\n        if self.lb is not None:\n            out[\"lb\"] = self.lb\n        if self.ub is not None:\n            out[\"ub\"] = self.ub\n        return out\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec.prior","title":"<code>prior</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec.class_","title":"<code>class_ = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec.coef","title":"<code>coef = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec.group","title":"<code>group = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec.dpar","title":"<code>dpar = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec.resp","title":"<code>resp = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec.nlpar","title":"<code>nlpar = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec.lb","title":"<code>lb = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec.ub","title":"<code>ub = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec-functions","title":"Functions","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec.to_brms_kwargs","title":"<code>to_brms_kwargs()</code>","text":"<p>Convert PriorSpec to keyword arguments for brms::prior_string().</p> <p>Maps Python dataclass fields to R function arguments, handling the <code>class_</code> -&gt; <code>class</code> parameter name conversion.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keyword arguments ready for brms::prior_string()</p> <p>Examples:</p> <pre><code>from brmspy import prior\np = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\nkwargs = p.to_brms_kwargs()\nprint(kwargs)\n# {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n</code></pre> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>def to_brms_kwargs(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert PriorSpec to keyword arguments for brms::prior_string().\n\n    Maps Python dataclass fields to R function arguments, handling\n    the `class_` -&gt; `class` parameter name conversion.\n\n    Returns\n    -------\n    dict\n        Keyword arguments ready for brms::prior_string()\n\n    Examples\n    --------\n    ```python\n    from brmspy import prior\n    p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n    kwargs = p.to_brms_kwargs()\n    print(kwargs)\n    # {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n    ```\n    \"\"\"\n    out: dict[str, Any] = {\"prior\": self.prior}\n    if self.class_ is not None:\n        out[\"class\"] = self.class_\n    if self.coef is not None:\n        out[\"coef\"] = self.coef\n    if self.group is not None:\n        out[\"group\"] = self.group\n    if self.dpar is not None:\n        out[\"dpar\"] = self.dpar\n    if self.resp is not None:\n        out[\"resp\"] = self.resp\n    if self.nlpar is not None:\n        out[\"nlpar\"] = self.nlpar\n    if self.lb is not None:\n        out[\"lb\"] = self.lb\n    if self.ub is not None:\n        out[\"ub\"] = self.ub\n    return out\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.PriorSpec.__init__","title":"<code>__init__(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None)</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct","title":"<code>FormulaConstruct</code>  <code>dataclass</code>","text":"<p>A composite formula expression built from parts.</p> <p><code>FormulaConstruct</code> stores a tree of nodes (<code>FormulaPart</code> and/or R objects) representing expressions combined with <code>+</code>. It is primarily created by calling the public formula helpers exposed by <code>brmspy.brms</code>.</p> Notes <p>The <code>+</code> operator supports grouping:</p> <ul> <li><code>a + b + c</code> becomes a single summand (one \u201cgroup\u201d)</li> <li><code>(a + b) + (a + b)</code> becomes two summands (two \u201cgroups\u201d)</li> </ul> <p>Use <code>iter_summands()</code> to iterate over these groups in a deterministic way.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@dataclass\nclass FormulaConstruct:\n    \"\"\"\n    A composite formula expression built from parts.\n\n    `FormulaConstruct` stores a tree of nodes (`FormulaPart` and/or R objects)\n    representing expressions combined with `+`. It is primarily created by\n    calling the public formula helpers exposed by [`brmspy.brms`][brmspy.brms].\n\n    Notes\n    -----\n    The `+` operator supports grouping:\n\n    - `a + b + c` becomes a single summand (one \u201cgroup\u201d)\n    - `(a + b) + (a + b)` becomes two summands (two \u201cgroups\u201d)\n\n    Use [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands]\n    to iterate over these groups in a deterministic way.\n    \"\"\"\n\n    _parts: list[Node]\n\n    @classmethod\n    def _formula_parse(cls, obj: Other) -&gt; \"FormulaConstruct\":\n        \"\"\"\n        Convert a supported value into a `FormulaConstruct`.\n\n        Parameters\n        ----------\n        obj\n            One of: `FormulaConstruct`, `FormulaPart`, string (interpreted as `bf(&lt;string&gt;)`),\n            or `ProxyListSexpVector`.\n\n        Returns\n        -------\n        FormulaConstruct\n        \"\"\"\n        if isinstance(obj, FormulaConstruct):\n            return obj\n        if isinstance(obj, ProxyListSexpVector):\n            return FormulaConstruct(_parts=[obj])\n        if isinstance(obj, FormulaPart):\n            return FormulaConstruct(_parts=[obj])\n        if isinstance(obj, str):\n            part = FormulaPart(_fun=\"bf\", _args=[obj], _kwargs={})\n            return FormulaConstruct(_parts=[part])\n        raise TypeError(\n            f\"Cannot parse object of type {type(obj)!r} into FormulaConstruct\"\n        )\n\n    def __add__(self, other: Other):\n        \"\"\"\n        Combine two formula expressions with `+`.\n\n        Parameters\n        ----------\n        other\n            Value to add. Strings are treated as `bf(&lt;string&gt;)`.\n\n        Returns\n        -------\n        FormulaConstruct\n            New combined expression.\n        \"\"\"\n        if isinstance(other, (FormulaPart, str, ProxyListSexpVector)):\n            other = FormulaConstruct._formula_parse(other)\n\n        if not isinstance(other, FormulaConstruct):\n            raise ArithmeticError(\n                \"When adding values to formula, they must be FormulaConstruct or parseable to FormulaConstruct\"\n            )\n\n        if len(other._parts) &lt;= 1:\n            return FormulaConstruct(_parts=self._parts + other._parts)\n        else:\n            return FormulaConstruct(_parts=[self._parts, other._parts])\n\n    def __radd__(self, other: Other) -&gt; \"FormulaConstruct\":\n        \"\"\"Support `\"y ~ x\" + bf(\"z ~ 1\")` by coercing the left operand.\"\"\"\n        return self._formula_parse(other) + self\n\n    def iter_summands(self) -&gt; Iterator[Summand]:\n        \"\"\"\n        Iterate over arithmetic groups (summands).\n\n        Returns\n        -------\n        Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]\n            Each yielded tuple represents one summand/group.\n\n        Examples\n        --------\n        ```python\n        from brmspy.brms import bf, gaussian, set_rescor\n\n        f = bf(\"y ~ x\") + gaussian() + set_rescor(True)\n        for summand in f.iter_summands():\n            print(summand)\n        ```\n        \"\"\"\n\n        def _groups(node: Node) -&gt; Iterator[list[FormulaPart | ProxyListSexpVector]]:\n            # Leaf node: single bf/family/etc\n            if isinstance(node, (FormulaPart, ProxyListSexpVector)):\n                return ([node],)  # one group with one element\n\n            if isinstance(node, list):\n                # If any child is a list, this node represents a \"+\"\n                # between sub-expressions, so recurse into each child.\n                if any(isinstance(child, list) for child in node):\n                    for child in node:\n                        yield from _groups(child)\n                else:\n                    # All children are leaves -&gt; one summand\n                    out: list[FormulaPart | ProxyListSexpVector] = []\n                    for child in node:\n                        if isinstance(child, (FormulaPart, ProxyListSexpVector, Sexp)):\n                            child = cast(FormulaPart | ProxyListSexpVector, child)\n                            out.append(child)\n                        else:\n                            raise TypeError(\n                                f\"Unexpected leaf node type in FormulaConstruct: {type(child)!r}\"\n                            )\n                    yield out\n                return\n\n            raise TypeError(f\"Unexpected node type in FormulaConstruct: {type(node)!r}\")\n\n        # self._parts is always a list[Node]\n        for group in _groups(self._parts):\n            yield tuple(group)\n\n    # Make __iter__ return summands by default\n    def __iter__(self) -&gt; Iterator[Summand]:\n        \"\"\"Alias for [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands].\"\"\"\n        return self.iter_summands()\n\n    def iterate(self) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n        \"\"\"\n        Iterate over all leaf nodes in left-to-right order.\n\n        This flattens the expression tree, unlike\n        [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands], which\n        respects grouping.\n\n        Returns\n        -------\n        Iterator[FormulaPart | ProxyListSexpVector]\n        \"\"\"\n\n        def _walk(node: Node) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n            if isinstance(node, FormulaPart):\n                yield node\n            elif isinstance(node, ProxyListSexpVector):\n                yield node\n            elif isinstance(node, list):\n                for child in node:\n                    yield from _walk(child)\n            else:\n                raise TypeError(\n                    f\"Unexpected node type in FormulaConstruct: {type(node)!r}\"\n                )\n\n        for root in self._parts:\n            yield from _walk(root)\n\n    def __str__(self) -&gt; str:\n        return self._pretty(self._parts)\n\n    def _pretty(self, node, _outer=True) -&gt; str:\n        if isinstance(node, FormulaPart):\n            return str(node)\n\n        if isinstance(node, (ProxyListSexpVector, Sexp)):\n            return _sexp_to_str(node)\n\n        if isinstance(node, list):\n            # Pretty-print each child\n            rendered = [self._pretty(child, _outer=False) for child in node]\n\n            # If only one child, no parentheses needed\n            if len(rendered) == 1:\n                return rendered[0]\n\n            # Multiple children \u2192 join with \" + \"\n            inner = \" + \".join(rendered)\n            if _outer:\n                return inner\n            else:\n                return f\"({inner})\"\n\n        raise TypeError(f\"Unexpected node type {type(node)!r} in pretty-printer\")\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct._parts","title":"<code>_parts</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct-functions","title":"Functions","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct._formula_parse","title":"<code>_formula_parse(obj)</code>  <code>classmethod</code>","text":"<p>Convert a supported value into a <code>FormulaConstruct</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Other</code> <p>One of: <code>FormulaConstruct</code>, <code>FormulaPart</code>, string (interpreted as <code>bf(&lt;string&gt;)</code>), or <code>ProxyListSexpVector</code>.</p> required <p>Returns:</p> Type Description <code>FormulaConstruct</code> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@classmethod\ndef _formula_parse(cls, obj: Other) -&gt; \"FormulaConstruct\":\n    \"\"\"\n    Convert a supported value into a `FormulaConstruct`.\n\n    Parameters\n    ----------\n    obj\n        One of: `FormulaConstruct`, `FormulaPart`, string (interpreted as `bf(&lt;string&gt;)`),\n        or `ProxyListSexpVector`.\n\n    Returns\n    -------\n    FormulaConstruct\n    \"\"\"\n    if isinstance(obj, FormulaConstruct):\n        return obj\n    if isinstance(obj, ProxyListSexpVector):\n        return FormulaConstruct(_parts=[obj])\n    if isinstance(obj, FormulaPart):\n        return FormulaConstruct(_parts=[obj])\n    if isinstance(obj, str):\n        part = FormulaPart(_fun=\"bf\", _args=[obj], _kwargs={})\n        return FormulaConstruct(_parts=[part])\n    raise TypeError(\n        f\"Cannot parse object of type {type(obj)!r} into FormulaConstruct\"\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct.__add__","title":"<code>__add__(other)</code>","text":"<p>Combine two formula expressions with <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Other</code> <p>Value to add. Strings are treated as <code>bf(&lt;string&gt;)</code>.</p> required <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>New combined expression.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __add__(self, other: Other):\n    \"\"\"\n    Combine two formula expressions with `+`.\n\n    Parameters\n    ----------\n    other\n        Value to add. Strings are treated as `bf(&lt;string&gt;)`.\n\n    Returns\n    -------\n    FormulaConstruct\n        New combined expression.\n    \"\"\"\n    if isinstance(other, (FormulaPart, str, ProxyListSexpVector)):\n        other = FormulaConstruct._formula_parse(other)\n\n    if not isinstance(other, FormulaConstruct):\n        raise ArithmeticError(\n            \"When adding values to formula, they must be FormulaConstruct or parseable to FormulaConstruct\"\n        )\n\n    if len(other._parts) &lt;= 1:\n        return FormulaConstruct(_parts=self._parts + other._parts)\n    else:\n        return FormulaConstruct(_parts=[self._parts, other._parts])\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Support <code>\"y ~ x\" + bf(\"z ~ 1\")</code> by coercing the left operand.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __radd__(self, other: Other) -&gt; \"FormulaConstruct\":\n    \"\"\"Support `\"y ~ x\" + bf(\"z ~ 1\")` by coercing the left operand.\"\"\"\n    return self._formula_parse(other) + self\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct.iter_summands","title":"<code>iter_summands()</code>","text":"<p>Iterate over arithmetic groups (summands).</p> <p>Returns:</p> Type Description <code>Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]</code> <p>Each yielded tuple represents one summand/group.</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, gaussian, set_rescor\n\nf = bf(\"y ~ x\") + gaussian() + set_rescor(True)\nfor summand in f.iter_summands():\n    print(summand)\n</code></pre> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def iter_summands(self) -&gt; Iterator[Summand]:\n    \"\"\"\n    Iterate over arithmetic groups (summands).\n\n    Returns\n    -------\n    Iterator[tuple[FormulaPart | ProxyListSexpVector, ...]]\n        Each yielded tuple represents one summand/group.\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, gaussian, set_rescor\n\n    f = bf(\"y ~ x\") + gaussian() + set_rescor(True)\n    for summand in f.iter_summands():\n        print(summand)\n    ```\n    \"\"\"\n\n    def _groups(node: Node) -&gt; Iterator[list[FormulaPart | ProxyListSexpVector]]:\n        # Leaf node: single bf/family/etc\n        if isinstance(node, (FormulaPart, ProxyListSexpVector)):\n            return ([node],)  # one group with one element\n\n        if isinstance(node, list):\n            # If any child is a list, this node represents a \"+\"\n            # between sub-expressions, so recurse into each child.\n            if any(isinstance(child, list) for child in node):\n                for child in node:\n                    yield from _groups(child)\n            else:\n                # All children are leaves -&gt; one summand\n                out: list[FormulaPart | ProxyListSexpVector] = []\n                for child in node:\n                    if isinstance(child, (FormulaPart, ProxyListSexpVector, Sexp)):\n                        child = cast(FormulaPart | ProxyListSexpVector, child)\n                        out.append(child)\n                    else:\n                        raise TypeError(\n                            f\"Unexpected leaf node type in FormulaConstruct: {type(child)!r}\"\n                        )\n                yield out\n            return\n\n        raise TypeError(f\"Unexpected node type in FormulaConstruct: {type(node)!r}\")\n\n    # self._parts is always a list[Node]\n    for group in _groups(self._parts):\n        yield tuple(group)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct.__iter__","title":"<code>__iter__()</code>","text":"<p>Alias for <code>iter_summands()</code>.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Summand]:\n    \"\"\"Alias for [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands].\"\"\"\n    return self.iter_summands()\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct.iterate","title":"<code>iterate()</code>","text":"<p>Iterate over all leaf nodes in left-to-right order.</p> <p>This flattens the expression tree, unlike <code>iter_summands()</code>, which respects grouping.</p> <p>Returns:</p> Type Description <code>Iterator[FormulaPart | ProxyListSexpVector]</code> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def iterate(self) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n    \"\"\"\n    Iterate over all leaf nodes in left-to-right order.\n\n    This flattens the expression tree, unlike\n    [`iter_summands()`][brmspy.types.formula_dsl.FormulaConstruct.iter_summands], which\n    respects grouping.\n\n    Returns\n    -------\n    Iterator[FormulaPart | ProxyListSexpVector]\n    \"\"\"\n\n    def _walk(node: Node) -&gt; Iterator[FormulaPart | ProxyListSexpVector]:\n        if isinstance(node, FormulaPart):\n            yield node\n        elif isinstance(node, ProxyListSexpVector):\n            yield node\n        elif isinstance(node, list):\n            for child in node:\n                yield from _walk(child)\n        else:\n            raise TypeError(\n                f\"Unexpected node type in FormulaConstruct: {type(node)!r}\"\n            )\n\n    for root in self._parts:\n        yield from _walk(root)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct.__str__","title":"<code>__str__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self._pretty(self._parts)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct._pretty","title":"<code>_pretty(node, _outer=True)</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def _pretty(self, node, _outer=True) -&gt; str:\n    if isinstance(node, FormulaPart):\n        return str(node)\n\n    if isinstance(node, (ProxyListSexpVector, Sexp)):\n        return _sexp_to_str(node)\n\n    if isinstance(node, list):\n        # Pretty-print each child\n        rendered = [self._pretty(child, _outer=False) for child in node]\n\n        # If only one child, no parentheses needed\n        if len(rendered) == 1:\n            return rendered[0]\n\n        # Multiple children \u2192 join with \" + \"\n        inner = \" + \".join(rendered)\n        if _outer:\n            return inner\n        else:\n            return f\"({inner})\"\n\n    raise TypeError(f\"Unexpected node type {type(node)!r} in pretty-printer\")\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self.__str__()\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaConstruct.__init__","title":"<code>__init__(_parts)</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaPart","title":"<code>FormulaPart</code>  <code>dataclass</code>","text":"<p>A single formula helper invocation.</p> <p>Instances of this type represent a call like <code>bf(\"y ~ x\")</code> or <code>set_rescor(True)</code> without executing anything. They are primarily used as nodes inside a <code>FormulaConstruct</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_fun</code> <code>Literal[...]</code> <p>Whitelisted formula helper name.</p> required <code>_args</code> <code>Sequence[Primitive]</code> <p>Positional arguments for the helper.</p> required <code>_kwargs</code> <code>Mapping[str, Primitive]</code> <p>Keyword arguments for the helper.</p> required Notes <p>This is a low-level type. Most users should construct these via the public helper functions in <code>brmspy.brms</code>.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@dataclass\nclass FormulaPart:\n    \"\"\"\n    A single formula helper invocation.\n\n    Instances of this type represent a call like `bf(\"y ~ x\")` or `set_rescor(True)`\n    without executing anything. They are primarily used as nodes inside a\n    [`FormulaConstruct`][brmspy.types.formula_dsl.FormulaConstruct].\n\n    Parameters\n    ----------\n    _fun : Literal[...]\n        Whitelisted formula helper name.\n    _args : Sequence[Primitive]\n        Positional arguments for the helper.\n    _kwargs : Mapping[str, Primitive]\n        Keyword arguments for the helper.\n\n    Notes\n    -----\n    This is a low-level type. Most users should construct these via the public\n    helper functions in [`brmspy.brms`][brmspy.brms].\n    \"\"\"\n\n    _fun: _FORMULA_FUNCTION_WHITELIST\n    _args: Sequence[Primitive]\n    _kwargs: Mapping[str, Primitive]\n\n    def __post_init__(self):\n        \"\"\"Validate `_fun`, `_args`, and `_kwargs` types after construction.\"\"\"\n        # Validate function name first\n        if self._fun not in get_args(_FORMULA_FUNCTION_WHITELIST):\n            raise ValueError(\n                f\"FormulaPart._fun must be one of {_FORMULA_FUNCTION_WHITELIST!r}, \"\n                f\"got {self._fun!r}\"\n            )\n\n        # Enforce _args is a list\n        if not isinstance(self._args, Sequence):\n            raise TypeError(\n                f\"FormulaPart._args must be a Sequence, got {type(self._args).__name__}\"\n            )\n\n        # Enforce _kwargs is a dict\n        if not isinstance(self._kwargs, Mapping):\n            raise TypeError(\n                f\"FormulaPart._kwargs must be a Mapping, got {type(self._kwargs).__name__}\"\n            )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Render a readable `fun(arg1, ..., kw=...)` representation.\"\"\"\n        args = \", \".join(repr(a) for a in self._args)\n        kwargs = \", \".join(f\"{k}={v!r}\" for k, v in self._kwargs.items())\n        inner = \", \".join(x for x in (args, kwargs) if x)\n        return f\"{self._fun}({inner})\"\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaPart-attributes","title":"Attributes","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaPart._fun","title":"<code>_fun</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaPart._args","title":"<code>_args</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaPart._kwargs","title":"<code>_kwargs</code>  <code>instance-attribute</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaPart-functions","title":"Functions","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaPart.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate <code>_fun</code>, <code>_args</code>, and <code>_kwargs</code> types after construction.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validate `_fun`, `_args`, and `_kwargs` types after construction.\"\"\"\n    # Validate function name first\n    if self._fun not in get_args(_FORMULA_FUNCTION_WHITELIST):\n        raise ValueError(\n            f\"FormulaPart._fun must be one of {_FORMULA_FUNCTION_WHITELIST!r}, \"\n            f\"got {self._fun!r}\"\n        )\n\n    # Enforce _args is a list\n    if not isinstance(self._args, Sequence):\n        raise TypeError(\n            f\"FormulaPart._args must be a Sequence, got {type(self._args).__name__}\"\n        )\n\n    # Enforce _kwargs is a dict\n    if not isinstance(self._kwargs, Mapping):\n        raise TypeError(\n            f\"FormulaPart._kwargs must be a Mapping, got {type(self._kwargs).__name__}\"\n        )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaPart.__str__","title":"<code>__str__()</code>","text":"<p>Render a readable <code>fun(arg1, ..., kw=...)</code> representation.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Render a readable `fun(arg1, ..., kw=...)` representation.\"\"\"\n    args = \", \".join(repr(a) for a in self._args)\n    kwargs = \", \".join(f\"{k}={v!r}\" for k, v in self._kwargs.items())\n    inner = \", \".join(x for x in (args, kwargs) if x)\n    return f\"{self._fun}({inner})\"\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaPart.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self.__str__()\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.FormulaPart.__init__","title":"<code>__init__(_fun, _args, _kwargs)</code>","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module-functions","title":"Functions","text":""},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.log","title":"<code>log(*msg, method_name=None, level=logging.INFO)</code>","text":"<p>Log a message with automatic method name detection.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log</p> <code>()</code> <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> <code>level</code> <code>int</code> <p>Logging level (default: logging.INFO)</p> <code>INFO</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log(*msg: str, method_name: str | None = None, level: int = logging.INFO):\n    \"\"\"\n    Log a message with automatic method name detection.\n\n    Parameters\n    ----------\n    msg : str\n        The message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n    level : int, optional\n        Logging level (default: logging.INFO)\n    \"\"\"\n    if method_name is None:\n        method_name = _get_caller_name()\n\n    msg_str = \" \".join(str(v) for v in msg)\n\n    logger = get_logger()\n    logger.log(level, msg_str, extra={\"method_name\": method_name})\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module._get_brms","title":"<code>_get_brms()</code>","text":"<p>Get brms R package, importing on first access.</p> Source code in <code>brmspy/_runtime/_state.py</code> <pre><code>def get_brms() -&gt; Any:\n    \"\"\"Get brms R package, importing on first access.\"\"\"\n    global _brms\n    if _brms is None:\n        try:\n            from rpy2.robjects.packages import importr\n            import rpy2.robjects as ro\n\n            _brms = importr(\"brms\")\n            ro.r(\"library(brms)\")\n        except Exception as e:\n            raise ImportError(\n                \"brms R package not found. Install it using:\\n\\n\"\n                \"  import brmspy\\n\"\n                \"  brmspy.install_brms(use_prebuilt=True)  # for prebuilt binaries\\n\\n\"\n                \"Or install from source:\\n\"\n                \"  brmspy.install_brms()\\n\"\n            ) from e\n    return _brms\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.get_brms_data","title":"<code>get_brms_data(dataset_name, **kwargs)</code>","text":"<p>Load an example dataset from the R <code>brms</code> package.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Dataset name (for example <code>\"epilepsy\"</code> or <code>\"kidney\"</code>).</p> required <code>**kwargs</code> <p>Forwarded to R <code>utils::data()</code> via <code>get_data()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset converted to a DataFrame.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nassert epilepsy.shape[0] &gt; 0\n</code></pre> Source code in <code>brmspy/_brms_functions/io.py</code> <pre><code>def get_brms_data(dataset_name: str, **kwargs) -&gt; pd.DataFrame:\n    \"\"\"\n    Load an example dataset from the R ``brms`` package.\n\n    Parameters\n    ----------\n    dataset_name : str\n        Dataset name (for example ``\"epilepsy\"`` or ``\"kidney\"``).\n    **kwargs\n        Forwarded to R ``utils::data()`` via `get_data()`.\n\n    Returns\n    -------\n    pandas.DataFrame\n        Dataset converted to a DataFrame.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    epilepsy = brms.get_brms_data(\"epilepsy\")\n    assert epilepsy.shape[0] &gt; 0\n    ```\n    \"\"\"\n    return get_data(dataset_name, package=\"brms\", **kwargs)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.read_rds_fit","title":"<code>read_rds_fit(file, **kwargs)</code>","text":"<p>Load a saved brms model from an <code>.rds</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Input path containing a saved brmsfit.</p> required <code>**kwargs</code> <p>Forwarded to R <code>readRDS()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p><code>FitResult</code> containing ArviZ <code>InferenceData</code> and an underlying R handle.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.read_rds_fit(\"model.rds\")\nfit.idata.posterior\n</code></pre> Source code in <code>brmspy/_brms_functions/io.py</code> <pre><code>def read_rds_fit(file: str, **kwargs) -&gt; FitResult:\n    \"\"\"\n    Load a saved brms model from an ``.rds`` file.\n\n    Parameters\n    ----------\n    file : str\n        Input path containing a saved brmsfit.\n    **kwargs\n        Forwarded to R ``readRDS()``.\n\n    Returns\n    -------\n    FitResult\n        `FitResult` containing ArviZ `InferenceData` and an underlying R handle.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    fit = brms.read_rds_fit(\"model.rds\")\n    fit.idata.posterior\n    ```\n    \"\"\"\n    brmsfit = read_rds_raw(file, **kwargs)\n    idata = brmsfit_to_idata(brmsfit)\n\n    return FitResult(idata=idata, r=brmsfit)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.read_rds_raw","title":"<code>read_rds_raw(file, **kwargs)</code>","text":"<p>Load an R object from an <code>.rds</code> file via R <code>readRDS()</code>.</p> <p>This returns the raw R object handle.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Input path.</p> required <code>**kwargs</code> <p>Forwarded to R <code>readRDS()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ListSexpVector</code> <p>Raw R object.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nobj = brms.read_rds_raw(\"model.rds\")\n</code></pre> Source code in <code>brmspy/_brms_functions/io.py</code> <pre><code>def read_rds_raw(file: str, **kwargs) -&gt; ListSexpVector:\n    \"\"\"\n    Load an R object from an ``.rds`` file via R ``readRDS()``.\n\n    This returns the raw R object handle.\n\n    Parameters\n    ----------\n    file : str\n        Input path.\n    **kwargs\n        Forwarded to R ``readRDS()``.\n\n    Returns\n    -------\n    rpy2.rinterface.ListSexpVector\n        Raw R object.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    obj = brms.read_rds_raw(\"model.rds\")\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    r_read_rds = typing.cast(typing.Callable, ro.r(\"readRDS\"))\n\n    kwargs = kwargs_r(kwargs)\n    brmsobject = r_read_rds(file, **kwargs)\n    return brmsobject\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.save_rds","title":"<code>save_rds(object, file, **kwargs)</code>","text":"<p>Save an R object to an <code>.rds</code> file via R <code>saveRDS()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>RListVectorExtension or ProxyListSexpVector</code> <p>Object to save. If you pass a <code>FitResult</code>, the underlying brmsfit is saved.</p> required <code>file</code> <code>str</code> <p>Output path.</p> required <code>**kwargs</code> <p>Forwarded to R <code>saveRDS()</code> (for example <code>compress=\"xz\"</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.brm(\"y ~ x\", data=df, chains=4)\nbrms.save_rds(model, \"model.rds\")\n</code></pre> Source code in <code>brmspy/_brms_functions/io.py</code> <pre><code>def save_rds(\n    object: RListVectorExtension | ProxyListSexpVector, file: str, **kwargs\n) -&gt; None:\n    \"\"\"\n    Save an R object to an ``.rds`` file via R ``saveRDS()``.\n\n    Parameters\n    ----------\n    object : RListVectorExtension or ProxyListSexpVector\n        Object to save. If you pass a `FitResult`, the underlying brmsfit is saved.\n    file : str\n        Output path.\n    **kwargs\n        Forwarded to R ``saveRDS()`` (for example ``compress=\"xz\"``).\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    model = brms.brm(\"y ~ x\", data=df, chains=4)\n    brms.save_rds(model, \"model.rds\")\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if isinstance(object, RListVectorExtension):\n        brmsfit = object.r\n    else:\n        brmsfit = object\n\n    kwargs = kwargs_r(kwargs)\n\n    r_save_rds = typing.cast(typing.Callable, ro.r(\"saveRDS\"))\n    r_save_rds(brmsfit, file, **kwargs)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.get_data","title":"<code>get_data(dataset_name, **kwargs)</code>","text":"<p>Load an R dataset and return it as a pandas DataFrame.</p> <p>This is a thin wrapper around R's <code>data()</code> that loads the object into the R global environment and converts it to a :class:<code>pandas.DataFrame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Name of the dataset as used in R (e.g. <code>\"BTdata\"</code>).</p> required <code>**kwargs</code> <p>Additional keyword arguments forwarded to R's <code>data()</code> function, for example <code>package=\"MCMCglmm\"</code> or other arguments supported by <code>utils::data()</code> in R.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset converted to a pandas DataFrame.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the dataset is not found in the R global environment after calling <code>data()</code>.</p> <code>RuntimeError</code> <p>If conversion from the R object to a pandas DataFrame fails.</p> See Also <p>get_brms_data     Convenience wrapper for datasets from the <code>brms</code> package.</p> Source code in <code>brmspy/_brms_functions/io.py</code> <pre><code>def get_data(dataset_name: str, **kwargs) -&gt; pd.DataFrame:\n    \"\"\"\n    Load an R dataset and return it as a pandas DataFrame.\n\n    This is a thin wrapper around R's ``data()`` that loads the object\n    into the R global environment and converts it to a\n    :class:`pandas.DataFrame`.\n\n    Parameters\n    ----------\n    dataset_name : str\n        Name of the dataset as used in R (e.g. ``\"BTdata\"``).\n    **kwargs\n        Additional keyword arguments forwarded to R's ``data()`` function,\n        for example ``package=\"MCMCglmm\"`` or other arguments supported\n        by ``utils::data()`` in R.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataset converted to a pandas DataFrame.\n\n    Raises\n    ------\n    KeyError\n        If the dataset is not found in the R global environment after\n        calling ``data()``.\n    RuntimeError\n        If conversion from the R object to a pandas DataFrame fails.\n\n    See Also\n    --------\n    get_brms_data\n        Convenience wrapper for datasets from the ``brms`` package.\n    \"\"\"\n    import rpy2.robjects as ro\n\n    r_kwargs = kwargs_r(kwargs)\n\n    r_data = typing.cast(typing.Callable, ro.r[\"data\"])\n    r_data(dataset_name, **r_kwargs)\n    r_obj = ro.globalenv[dataset_name]\n\n    return typing.cast(pd.DataFrame, r_to_py(r_obj))\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.prior","title":"<code>prior(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None, **kwargs)</code>","text":"<p>Create a brms-style prior specification.</p> <p>This function mirrors the behavior of <code>brms::prior_string()</code> and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of <code>prior_string()</code> in brms.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>str</code> <p>The prior definition as a string, exactly as brms expects it. Examples include ::</p> <pre><code>\"normal(0, 1)\"\n\"student_t(3, 0, 1.5)\"\n\"exponential(2)\"\n\"lkj(2)\"\n</code></pre> required <code>class_</code> <code>str</code> <p>Parameter class (e.g. <code>\"b\"</code>, <code>\"sd\"</code>, <code>\"Intercept\"</code>). This corresponds to <code>class</code> in brms. <code>class</code> cannot be used as a parameter in Python (reserved keyword), so <code>class_</code> is used instead.</p> <code>None</code> <code>coef</code> <code>str</code> <p>Coefficient name for class-level effects.</p> <code>None</code> <code>group</code> <code>str</code> <p>Grouping variable for hierarchical/multilevel effects.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Distributional parameter (e.g. <code>\"sigma\"</code> or <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response variable name for multivariate models.</p> <code>None</code> <code>nlpar</code> <code>str</code> <p>Nonlinear parameter name if using nonlinear formulas.</p> <code>None</code> <code>lb</code> <code>float</code> <p>Lower bound for truncated priors.</p> <code>None</code> <code>ub</code> <code>float</code> <p>Upper bound for truncated priors.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Any additional keyword arguments supported by <code>brms::prior_string()</code>. These are forwarded unchanged.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriorSpec</code> <p>A typed prior specification object used by <code>brmspy.brms.brm()</code> and <code>brmspy.brms.make_stancode()</code>.</p> See Also <p>brms::prior_string : R documentation</p> Notes <p>This function does not validate the prior expression string itself \u2014 validation occurs inside brms.</p> <p>Examples:</p> <pre><code>from brmspy.brms import prior\n\np_intercept = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\")\np_slope = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\np_sd = prior(\"exponential(2)\", class_=\"sd\", group=\"region\")\np_trunc = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0)\n</code></pre> Source code in <code>brmspy/_brms_functions/prior.py</code> <pre><code>def prior(\n    prior: str,\n    class_: str | None = None,\n    coef: str | None = None,\n    group: str | None = None,\n    dpar: str | None = None,\n    resp: str | None = None,\n    nlpar: str | None = None,\n    lb: float | None = None,\n    ub: float | None = None,\n    **kwargs: Any,\n) -&gt; PriorSpec:\n    \"\"\"\n    Create a brms-style prior specification.\n\n    This function mirrors the behavior of ``brms::prior_string()`` and allows\n    specifying priors for regression parameters, group-level effects, nonlinear\n    parameters, distributional parameters, and more \u2014 using a typed Python\n    interface. All arguments correspond directly to the parameters of\n    ``prior_string()`` in brms.\n\n    Parameters\n    ----------\n    prior : str\n        The prior definition as a string, exactly as brms expects it.\n        Examples include ::\n\n            \"normal(0, 1)\"\n            \"student_t(3, 0, 1.5)\"\n            \"exponential(2)\"\n            \"lkj(2)\"\n\n    class_ : str, optional\n        Parameter class (e.g. ``\"b\"``, ``\"sd\"``, ``\"Intercept\"``).\n        This corresponds to ``class`` in brms. ``class`` cannot be used as a\n        parameter in Python (reserved keyword), so ``class_`` is used instead.\n\n    coef : str, optional\n        Coefficient name for class-level effects.\n\n    group : str, optional\n        Grouping variable for hierarchical/multilevel effects.\n\n    dpar : str, optional\n        Distributional parameter (e.g. ``\"sigma\"`` or ``\"phi\"``).\n\n    resp : str, optional\n        Response variable name for multivariate models.\n\n    nlpar : str, optional\n        Nonlinear parameter name if using nonlinear formulas.\n\n    lb : float, optional\n        Lower bound for truncated priors.\n\n    ub : float, optional\n        Upper bound for truncated priors.\n\n    **kwargs\n        Any additional keyword arguments supported by ``brms::prior_string()``.\n        These are forwarded unchanged.\n\n    Returns\n    -------\n    PriorSpec\n        A typed prior specification object used by `brmspy.brms.brm()` and\n        `brmspy.brms.make_stancode()`.\n\n    See Also\n    --------\n    brms::prior_string : [R documentation](https://paulbuerkner.com/brms/reference/prior_string.html)\n\n    Notes\n    -----\n    This function does **not** validate the prior expression string itself \u2014\n    validation occurs inside brms.\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import prior\n\n    p_intercept = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\")\n    p_slope = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n    p_sd = prior(\"exponential(2)\", class_=\"sd\", group=\"region\")\n    p_trunc = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0)\n    ```\n    \"\"\"\n    if \"class\" in kwargs:\n        kwargs[\"class_\"] = kwargs[\"class\"]\n\n    return PriorSpec(\n        prior=prior,\n        class_=class_,\n        coef=coef,\n        group=group,\n        dpar=dpar,\n        resp=resp,\n        nlpar=nlpar,\n        lb=lb,\n        ub=ub,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.get_prior","title":"<code>get_prior(formula, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for a model specification.</p> <p>Wrapper around R <code>brms::get_prior()</code>.</p> <p>Returns a DataFrame with default priors for each parameter class in the specified brms model. Useful for reviewing and customizing priors before fitting.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula (e.g. <code>\"y ~ x + (1|group)\"</code>) or a composed formula.</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListSexpVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\")</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row represents a parameter or parameter class that can have a custom prior.</p> See Also <p>default_prior : Generic function for getting default priors prior : Create custom prior specifications brms::get_prior : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms import prior\n\npriors_df = brms.get_prior(\"y ~ x\", data=df)\n\ncustom_priors = [\n    prior(\"normal(0, 0.5)\", class_=\"b\"),\n    prior(\"exponential(2)\", class_=\"sigma\"),\n]\n\nfit = brms.brm(\"y ~ x\", data=df, priors=custom_priors, chains=4)\n</code></pre> Source code in <code>brmspy/_brms_functions/prior.py</code> <pre><code>def get_prior(\n    formula: str | FormulaConstruct, data=None, family=\"gaussian\", **kwargs\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Get default priors for a model specification.\n\n    Wrapper around R ``brms::get_prior()``.\n\n    Returns a DataFrame with default priors for each parameter class in the specified\n    brms model. Useful for reviewing and customizing priors before fitting.\n\n    Parameters\n    ----------\n    formula : str or FormulaConstruct\n        Model formula (e.g. ``\"y ~ x + (1|group)\"``) or a composed formula.\n    data : pd.DataFrame or dict, optional\n        Dataset containing model variables. Required for data-dependent priors\n    family : str or ListSexpVector, default=\"gaussian\"\n        Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\")\n    **kwargs\n        Additional arguments passed to brms::get_prior()\n        (e.g., autocor, data2, knots, drop_unused_levels)\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source.\n        Each row represents a parameter or parameter class that can have a custom prior.\n\n    See Also\n    --------\n    default_prior : Generic function for getting default priors\n    prior : Create custom prior specifications\n    brms::get_prior : [R documentation](https://paulbuerkner.com/brms/reference/get_prior.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n    from brmspy.brms import prior\n\n    priors_df = brms.get_prior(\"y ~ x\", data=df)\n\n    custom_priors = [\n        prior(\"normal(0, 0.5)\", class_=\"b\"),\n        prior(\"exponential(2)\", class_=\"sigma\"),\n    ]\n\n    fit = brms.brm(\"y ~ x\", data=df, priors=custom_priors, chains=4)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    formula_obj = _execute_formula(formula)\n\n    r_get_prior = cast(Callable, ro.r(\"brms::get_prior\"))\n    collected_args = kwargs_r(\n        {\"formula\": formula_obj, \"data\": data, \"family\": family, **kwargs}\n    )\n\n    df_r = r_get_prior(**collected_args)\n    df = pd.DataFrame(cast(Any, r_to_py(df_r)))\n\n    return df\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.default_prior","title":"<code>default_prior(object, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for brms model parameters (generic function).</p> <p>Wrapper around R <code>brms::default_prior()</code>.</p> <p>Generic function to retrieve default prior specifications for all parameters in a brms model. Accepts formula objects, brmsformula objects, or other model specification objects. This is the generic version of get_prior().</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>str, FormulaResult, or ListSexpVector</code> <p>Model specification: formula string, brmsformula object, mvbrmsformula, or any object that can be coerced to these classes</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListSexpVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\"). Can be a list of families for multivariate models</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels, sparse)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row specifies a parameter class with its default prior. The 'prior' column is empty except for internal defaults.</p> See Also <p>get_prior : Convenience function with formula parameter prior : Create custom prior specifications brms::default_prior : R documentation</p> <p>Examples:</p> <p>Get default priors for a Poisson model:</p> <pre><code>from brmspy import brms\n\npriors = brms.default_prior(\n    object=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\nprint(priors)\n</code></pre> <p>Use with formula object:</p> <pre><code>from brmspy import brms\n\nf = brms.formula(\"y ~ x + (1|group)\")\npriors = brms.default_prior(f, data=df, family=\"gaussian\")\n</code></pre> Source code in <code>brmspy/_brms_functions/prior.py</code> <pre><code>def default_prior(\n    object: RListVectorExtension | ListSexpVector | FormulaConstruct | str,\n    data=None,\n    family=\"gaussian\",\n    **kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Get default priors for brms model parameters (generic function).\n\n    Wrapper around R ``brms::default_prior()``.\n\n    Generic function to retrieve default prior specifications for all parameters\n    in a brms model. Accepts formula objects, brmsformula objects, or other model\n    specification objects. This is the generic version of get_prior().\n\n    Parameters\n    ----------\n    object : str, FormulaResult, or ListSexpVector\n        Model specification: formula string, brmsformula object, mvbrmsformula,\n        or any object that can be coerced to these classes\n    data : pd.DataFrame or dict, optional\n        Dataset containing model variables. Required for data-dependent priors\n    family : str or ListSexpVector, default=\"gaussian\"\n        Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\").\n        Can be a list of families for multivariate models\n    **kwargs\n        Additional arguments passed to brms::get_prior()\n        (e.g., autocor, data2, knots, drop_unused_levels, sparse)\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source.\n        Each row specifies a parameter class with its default prior. The 'prior' column\n        is empty except for internal defaults.\n\n    See Also\n    --------\n    get_prior : Convenience function with formula parameter\n    prior : Create custom prior specifications\n    brms::default_prior : [R documentation](https://paulbuerkner.com/brms/reference/default_prior.html)\n\n    Examples\n    --------\n    Get default priors for a Poisson model:\n\n    ```python\n    from brmspy import brms\n\n    priors = brms.default_prior(\n        object=\"count ~ zAge + zBase * Trt + (1|patient)\",\n        data=epilepsy,\n        family=\"poisson\"\n    )\n    print(priors)\n    ```\n\n    Use with formula object:\n\n    ```python\n    from brmspy import brms\n\n    f = brms.formula(\"y ~ x + (1|group)\")\n    priors = brms.default_prior(f, data=df, family=\"gaussian\")\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    r_get_prior = cast(Callable, ro.r(\"brms::get_prior\"))\n    collected_args = kwargs_r({\"data\": data, \"family\": family, **kwargs})\n\n    obj_resolved = object\n    if isinstance(object, FormulaConstruct):\n        obj_resolved = _execute_formula(object)\n\n    df_r = r_get_prior(py_to_r(obj_resolved), **collected_args)\n    df = pd.DataFrame(cast(Any, r_to_py(df_r)))\n\n    return df\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.brm","title":"<code>brm(formula, data, priors=None, family='gaussian', sample_prior='no', sample=True, backend='cmdstanr', formula_args=None, cores=2, *, return_idata=True, **brm_args)</code>","text":"<pre><code>brm(formula: FormulaConstruct | ProxyListSexpVector | str, data: dict | pd.DataFrame, priors: Sequence[PriorSpec] | None = ..., family: str | ListSexpVector | None = ..., sample_prior: str = ..., sample: bool = ..., backend: str = ..., formula_args: dict | None = ..., cores: int | None = ..., *, return_idata: Literal[True] = True, **brm_args: Any) -&gt; FitResult\n</code></pre><pre><code>brm(formula: FormulaConstruct | ProxyListSexpVector | str, data: dict | pd.DataFrame, priors: Sequence[PriorSpec] | None = ..., family: str | ListSexpVector | None = ..., sample_prior: str = ..., sample: bool = ..., backend: str = ..., formula_args: dict | None = ..., cores: int | None = ..., *, return_idata: Literal[False], **brm_args: Any) -&gt; ProxyListSexpVector\n</code></pre> <p>Fit a Bayesian regression model with brms.</p> <p>This is a thin wrapper around R <code>brms::brm()</code> that returns a structured <code>FitResult</code> (including an ArviZ <code>InferenceData</code>).</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula. Accepts a plain brms formula string (e.g. <code>\"y ~ x + (1|g)\"</code>) or a composed formula created via <code>brmspy.brms.bf()</code> / <code>brmspy.brms.lf()</code> (typically imported as <code>from brmspy.brms import bf, lf</code>).</p> required <code>data</code> <code>dict or DataFrame</code> <p>Model data.</p> required <code>priors</code> <code>Sequence[PriorSpec] or None</code> <p>Optional prior specifications created via <code>brmspy.brms.prior()</code>.</p> <code>None</code> <code>family</code> <code>str or ListSexpVector or None</code> <p>brms family specification (e.g. <code>\"gaussian\"</code>, <code>\"poisson\"</code>).</p> <code>\"gaussian\"</code> <code>sample_prior</code> <code>str</code> <p>Passed to brms. Common values: <code>\"no\"</code>, <code>\"yes\"</code>, <code>\"only\"</code>.</p> <code>\"no\"</code> <code>sample</code> <code>bool</code> <p>If <code>False</code>, compile the model without sampling (brms <code>empty=TRUE</code>).</p> <code>True</code> <code>backend</code> <code>str</code> <p>Stan backend. Common values: <code>\"cmdstanr\"</code> or <code>\"rstan\"</code>.</p> <code>\"cmdstanr\"</code> <code>formula_args</code> <code>dict or None</code> <p>Reserved for future use. Currently ignored.</p> <code>None</code> <code>cores</code> <code>int or None</code> <p>Number of cores for brms/cmdstanr.</p> <code>2</code> <code>return_idata</code> <code>bool</code> <p>When working with large datasets, you might not want the full idata. when False, you get the R object proxy which can be forwarded to posterior_epred or other functions</p> <code>True</code> <code>**brm_args</code> <p>Additional keyword arguments passed to R <code>brms::brm()</code> (e.g. <code>chains</code>, <code>iter</code>, <code>warmup</code>, <code>seed</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Result object with <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::brm : R documentation</p> Warnings <p>Using <code>cores &lt;= 1</code> can be unstable in embedded R sessions and may crash the worker process. Prefer <code>cores &gt;= 2</code>.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x + (1|g)\", data=df, family=\"gaussian\", chains=4, cores=4)\n\nfit.idata.posterior\n</code></pre> Source code in <code>brmspy/_brms_functions/brm.py</code> <pre><code>def brm(\n    formula: FormulaConstruct | ProxyListSexpVector | str,\n    data: dict | pd.DataFrame,\n    priors: Sequence[PriorSpec] | None = None,\n    family: str | ListSexpVector | None = \"gaussian\",\n    sample_prior: str = \"no\",\n    sample: bool = True,\n    backend: str = \"cmdstanr\",\n    formula_args: dict | None = None,\n    cores: int | None = 2,\n    *,\n    return_idata: bool = True,\n    **brm_args,\n) -&gt; FitResult | ProxyListSexpVector:\n    \"\"\"\n    Fit a Bayesian regression model with brms.\n\n    This is a thin wrapper around R ``brms::brm()`` that returns a structured\n    `FitResult` (including an ArviZ `InferenceData`).\n\n    Parameters\n    ----------\n    formula : str or FormulaConstruct\n        Model formula. Accepts a plain brms formula string (e.g. ``\"y ~ x + (1|g)\"``)\n        or a composed formula created via `brmspy.brms.bf()` / `brmspy.brms.lf()`\n        (typically imported as ``from brmspy.brms import bf, lf``).\n    data : dict or pandas.DataFrame\n        Model data.\n    priors : Sequence[PriorSpec] or None, default=None\n        Optional prior specifications created via `brmspy.brms.prior()`.\n    family : str or rpy2.rinterface.ListSexpVector or None, default=\"gaussian\"\n        brms family specification (e.g. ``\"gaussian\"``, ``\"poisson\"``).\n    sample_prior : str, default=\"no\"\n        Passed to brms. Common values: ``\"no\"``, ``\"yes\"``, ``\"only\"``.\n    sample : bool, default=True\n        If ``False``, compile the model without sampling (brms ``empty=TRUE``).\n    backend : str, default=\"cmdstanr\"\n        Stan backend. Common values: ``\"cmdstanr\"`` or ``\"rstan\"``.\n    formula_args : dict or None, default=None\n        Reserved for future use. Currently ignored.\n    cores : int or None, default=2\n        Number of cores for brms/cmdstanr.\n    return_idata : bool, default True\n        When working with large datasets, you might not want the full idata.\n        when False, you get the R object proxy which can be forwarded to posterior_epred\n        or other functions\n    **brm_args\n        Additional keyword arguments passed to R ``brms::brm()`` (e.g. ``chains``,\n        ``iter``, ``warmup``, ``seed``).\n\n    Returns\n    -------\n    FitResult\n        Result object with `idata` (ArviZ `InferenceData`) and an underlying R handle.\n\n    See Also\n    --------\n    brms::brm : [R documentation](https://paulbuerkner.com/brms/reference/brm.html)\n\n    Warnings\n    --------\n    Using ``cores &lt;= 1`` can be unstable in embedded R sessions and may crash the\n    worker process. Prefer ``cores &gt;= 2``.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    fit = brms.brm(\"y ~ x + (1|g)\", data=df, family=\"gaussian\", chains=4, cores=4)\n\n    fit.idata.posterior\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n    import rpy2.robjects.packages as packages\n\n    fun_brm = cast(Callable, ro.r(\"brms::brm\"))\n\n    if backend == \"cmdstanr\":\n        try:\n            cmdstanr = packages.importr(\"cmdstanr\")\n        except:\n            cmdstanr = None\n        if cmdstanr is None:\n            raise RuntimeError(\n                \"cmdstanr backend is not installed! Please run install_brms(install_cmdstanr=True)\"\n            )\n\n    if backend == \"rstan\":\n        try:\n            rstan = packages.importr(\"rstan\")\n        except:\n            rstan = None\n        if rstan is None:\n            raise RuntimeError(\n                \"rstan backend is not installed! Please run install_brms(install_rstan=True)\"\n            )\n\n    # Formula checks. These should never be reached in the first place\n    # if they are, the library is calling brm() from main directly without remote call\n    assert not isinstance(formula, SexpWrapper)\n    assert formula is not None\n    if formula_args and isinstance(formula, str):\n        formula = bf(formula, **formula_args)\n\n    formula_obj = _execute_formula(formula)\n\n    # Convert data to R format\n    data_r = py_to_r(data)\n\n    # Setup priors\n    brms_prior = _build_priors(priors)\n\n    # Prepare brm() arguments\n    brm_kwargs: dict[str, Any] = {\n        \"formula\": formula_obj,\n        \"data\": data_r,\n        \"family\": family,\n        \"sample_prior\": sample_prior,\n        \"backend\": backend,\n        \"cores\": cores,\n    }\n\n    # Add priors if specified\n    if len(brms_prior) &gt; 0:\n        brm_kwargs[\"prior\"] = brms_prior\n\n    # Add user-specified arguments\n    brm_kwargs.update(brm_args)\n\n    brm_kwargs = kwargs_r(brm_kwargs)\n\n    # Set empty=TRUE if not sampling\n    if not sample:\n        brm_kwargs[\"empty\"] = True\n        log(\"Creating empty r object (no sampling)...\")\n    else:\n        log(f\"Fitting model with brms (backend: {backend})...\")\n\n    # Call brms::brm() with all arguments\n    fit = fun_brm(**brm_kwargs)\n\n    log(\"Fit done!\")\n\n    # Handle return type conversion\n    if not return_idata:\n        return fit\n\n    if not sample:\n        return FitResult(idata=IDBrm(), r=fit)\n\n    idata = brmsfit_to_idata(fit)\n    return FitResult(idata=idata, r=fit)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.fit","title":"<code>fit(formula, data, priors=None, family='gaussian', sample_prior='no', sample=True, backend='cmdstanr', formula_args=None, cores=2, *, return_idata=True, **brm_args)</code>","text":"<pre><code>brm(formula: FormulaConstruct | ProxyListSexpVector | str, data: dict | pd.DataFrame, priors: Sequence[PriorSpec] | None = ..., family: str | ListSexpVector | None = ..., sample_prior: str = ..., sample: bool = ..., backend: str = ..., formula_args: dict | None = ..., cores: int | None = ..., *, return_idata: Literal[True] = True, **brm_args: Any) -&gt; FitResult\n</code></pre><pre><code>brm(formula: FormulaConstruct | ProxyListSexpVector | str, data: dict | pd.DataFrame, priors: Sequence[PriorSpec] | None = ..., family: str | ListSexpVector | None = ..., sample_prior: str = ..., sample: bool = ..., backend: str = ..., formula_args: dict | None = ..., cores: int | None = ..., *, return_idata: Literal[False], **brm_args: Any) -&gt; ProxyListSexpVector\n</code></pre> <p>Fit a Bayesian regression model with brms.</p> <p>This is a thin wrapper around R <code>brms::brm()</code> that returns a structured <code>FitResult</code> (including an ArviZ <code>InferenceData</code>).</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula. Accepts a plain brms formula string (e.g. <code>\"y ~ x + (1|g)\"</code>) or a composed formula created via <code>brmspy.brms.bf()</code> / <code>brmspy.brms.lf()</code> (typically imported as <code>from brmspy.brms import bf, lf</code>).</p> required <code>data</code> <code>dict or DataFrame</code> <p>Model data.</p> required <code>priors</code> <code>Sequence[PriorSpec] or None</code> <p>Optional prior specifications created via <code>brmspy.brms.prior()</code>.</p> <code>None</code> <code>family</code> <code>str or ListSexpVector or None</code> <p>brms family specification (e.g. <code>\"gaussian\"</code>, <code>\"poisson\"</code>).</p> <code>\"gaussian\"</code> <code>sample_prior</code> <code>str</code> <p>Passed to brms. Common values: <code>\"no\"</code>, <code>\"yes\"</code>, <code>\"only\"</code>.</p> <code>\"no\"</code> <code>sample</code> <code>bool</code> <p>If <code>False</code>, compile the model without sampling (brms <code>empty=TRUE</code>).</p> <code>True</code> <code>backend</code> <code>str</code> <p>Stan backend. Common values: <code>\"cmdstanr\"</code> or <code>\"rstan\"</code>.</p> <code>\"cmdstanr\"</code> <code>formula_args</code> <code>dict or None</code> <p>Reserved for future use. Currently ignored.</p> <code>None</code> <code>cores</code> <code>int or None</code> <p>Number of cores for brms/cmdstanr.</p> <code>2</code> <code>return_idata</code> <code>bool</code> <p>When working with large datasets, you might not want the full idata. when False, you get the R object proxy which can be forwarded to posterior_epred or other functions</p> <code>True</code> <code>**brm_args</code> <p>Additional keyword arguments passed to R <code>brms::brm()</code> (e.g. <code>chains</code>, <code>iter</code>, <code>warmup</code>, <code>seed</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Result object with <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::brm : R documentation</p> Warnings <p>Using <code>cores &lt;= 1</code> can be unstable in embedded R sessions and may crash the worker process. Prefer <code>cores &gt;= 2</code>.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x + (1|g)\", data=df, family=\"gaussian\", chains=4, cores=4)\n\nfit.idata.posterior\n</code></pre> Source code in <code>brmspy/_brms_functions/brm.py</code> <pre><code>def brm(\n    formula: FormulaConstruct | ProxyListSexpVector | str,\n    data: dict | pd.DataFrame,\n    priors: Sequence[PriorSpec] | None = None,\n    family: str | ListSexpVector | None = \"gaussian\",\n    sample_prior: str = \"no\",\n    sample: bool = True,\n    backend: str = \"cmdstanr\",\n    formula_args: dict | None = None,\n    cores: int | None = 2,\n    *,\n    return_idata: bool = True,\n    **brm_args,\n) -&gt; FitResult | ProxyListSexpVector:\n    \"\"\"\n    Fit a Bayesian regression model with brms.\n\n    This is a thin wrapper around R ``brms::brm()`` that returns a structured\n    `FitResult` (including an ArviZ `InferenceData`).\n\n    Parameters\n    ----------\n    formula : str or FormulaConstruct\n        Model formula. Accepts a plain brms formula string (e.g. ``\"y ~ x + (1|g)\"``)\n        or a composed formula created via `brmspy.brms.bf()` / `brmspy.brms.lf()`\n        (typically imported as ``from brmspy.brms import bf, lf``).\n    data : dict or pandas.DataFrame\n        Model data.\n    priors : Sequence[PriorSpec] or None, default=None\n        Optional prior specifications created via `brmspy.brms.prior()`.\n    family : str or rpy2.rinterface.ListSexpVector or None, default=\"gaussian\"\n        brms family specification (e.g. ``\"gaussian\"``, ``\"poisson\"``).\n    sample_prior : str, default=\"no\"\n        Passed to brms. Common values: ``\"no\"``, ``\"yes\"``, ``\"only\"``.\n    sample : bool, default=True\n        If ``False``, compile the model without sampling (brms ``empty=TRUE``).\n    backend : str, default=\"cmdstanr\"\n        Stan backend. Common values: ``\"cmdstanr\"`` or ``\"rstan\"``.\n    formula_args : dict or None, default=None\n        Reserved for future use. Currently ignored.\n    cores : int or None, default=2\n        Number of cores for brms/cmdstanr.\n    return_idata : bool, default True\n        When working with large datasets, you might not want the full idata.\n        when False, you get the R object proxy which can be forwarded to posterior_epred\n        or other functions\n    **brm_args\n        Additional keyword arguments passed to R ``brms::brm()`` (e.g. ``chains``,\n        ``iter``, ``warmup``, ``seed``).\n\n    Returns\n    -------\n    FitResult\n        Result object with `idata` (ArviZ `InferenceData`) and an underlying R handle.\n\n    See Also\n    --------\n    brms::brm : [R documentation](https://paulbuerkner.com/brms/reference/brm.html)\n\n    Warnings\n    --------\n    Using ``cores &lt;= 1`` can be unstable in embedded R sessions and may crash the\n    worker process. Prefer ``cores &gt;= 2``.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    fit = brms.brm(\"y ~ x + (1|g)\", data=df, family=\"gaussian\", chains=4, cores=4)\n\n    fit.idata.posterior\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n    import rpy2.robjects.packages as packages\n\n    fun_brm = cast(Callable, ro.r(\"brms::brm\"))\n\n    if backend == \"cmdstanr\":\n        try:\n            cmdstanr = packages.importr(\"cmdstanr\")\n        except:\n            cmdstanr = None\n        if cmdstanr is None:\n            raise RuntimeError(\n                \"cmdstanr backend is not installed! Please run install_brms(install_cmdstanr=True)\"\n            )\n\n    if backend == \"rstan\":\n        try:\n            rstan = packages.importr(\"rstan\")\n        except:\n            rstan = None\n        if rstan is None:\n            raise RuntimeError(\n                \"rstan backend is not installed! Please run install_brms(install_rstan=True)\"\n            )\n\n    # Formula checks. These should never be reached in the first place\n    # if they are, the library is calling brm() from main directly without remote call\n    assert not isinstance(formula, SexpWrapper)\n    assert formula is not None\n    if formula_args and isinstance(formula, str):\n        formula = bf(formula, **formula_args)\n\n    formula_obj = _execute_formula(formula)\n\n    # Convert data to R format\n    data_r = py_to_r(data)\n\n    # Setup priors\n    brms_prior = _build_priors(priors)\n\n    # Prepare brm() arguments\n    brm_kwargs: dict[str, Any] = {\n        \"formula\": formula_obj,\n        \"data\": data_r,\n        \"family\": family,\n        \"sample_prior\": sample_prior,\n        \"backend\": backend,\n        \"cores\": cores,\n    }\n\n    # Add priors if specified\n    if len(brms_prior) &gt; 0:\n        brm_kwargs[\"prior\"] = brms_prior\n\n    # Add user-specified arguments\n    brm_kwargs.update(brm_args)\n\n    brm_kwargs = kwargs_r(brm_kwargs)\n\n    # Set empty=TRUE if not sampling\n    if not sample:\n        brm_kwargs[\"empty\"] = True\n        log(\"Creating empty r object (no sampling)...\")\n    else:\n        log(f\"Fitting model with brms (backend: {backend})...\")\n\n    # Call brms::brm() with all arguments\n    fit = fun_brm(**brm_kwargs)\n\n    log(\"Fit done!\")\n\n    # Handle return type conversion\n    if not return_idata:\n        return fit\n\n    if not sample:\n        return FitResult(idata=IDBrm(), r=fit)\n\n    idata = brmsfit_to_idata(fit)\n    return FitResult(idata=idata, r=fit)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.summary","title":"<code>summary(model, **kwargs)</code>","text":"<p>Generate comprehensive summary statistics for a fitted brms model.</p> <p>Returns a <code>SummaryResult</code> dataclass containing model information, parameter estimates, and diagnostic information. The SummaryResult object provides pretty printing via <code>str()</code> or <code>print()</code> and structured access to all components.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code>.</p> required <code>**kwargs</code> <p>Additional arguments passed to brms::summary(), such as: - probs: Quantiles for credible intervals, e.g., <code>probs=(0.025, 0.975)</code> - robust: Use robust estimates (median, MAD), default False</p> <code>{}</code> <p>Returns:</p> Type Description <code>SummaryResult</code> <p>A dataclass containing:</p> <ul> <li>formula (str): Model formula as string</li> <li>data_name (str): Name of the data object used</li> <li>group (str): Grouping structure information</li> <li>nobs (int): Number of observations</li> <li>ngrps (Dict[str, int]): Number of groups per grouping variable</li> <li>autocor (Optional[dict]): Autocorrelation structure if present</li> <li>prior (pd.DataFrame): Prior specifications used</li> <li>algorithm (str): Sampling algorithm (e.g., \"sampling\")</li> <li>sampler (str): Sampler specification (e.g., \"sample(hmc)\")</li> <li>total_ndraws (int): Total number of post-warmup draws</li> <li>chains (float): Number of chains</li> <li>iter (float): Iterations per chain</li> <li>warmup (float): Warmup iterations per chain</li> <li>thin (float): Thinning interval</li> <li>has_rhat (bool): Whether Rhat diagnostics are reported</li> <li>fixed (pd.DataFrame): Population-level (fixed) effects estimates</li> <li>spec_pars (pd.DataFrame): Family-specific parameters (e.g., sigma)</li> <li>cor_pars (pd.DataFrame): Correlation parameters if present</li> <li>random (dict): Group-level (random) effects by grouping variable</li> </ul> See Also <p>brms::summary.brmsfit : R documentation</p> <p>Examples:</p> <p>Basic usage with pretty printing:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x\", data=data, chains=4)\nsummary = brmspy.summary(model)\n\n# Pretty print full summary\nprint(summary)\n</code></pre> <p>Access specific components:</p> <pre><code># Get population-level effects as DataFrame\nfixed_effects = summary.fixed\nprint(fixed_effects)\n\n# Get family-specific parameters (e.g., sigma)\nspec_params = summary.spec_pars\nprint(spec_params)\n\n# Access random effects (if present)\nrandom_effects = summary.random\nfor group_name, group_df in random_effects.items():\n    print(f\"Random effects for {group_name}:\")\n    print(group_df)\n\n# Check model metadata\nprint(f\"Formula: {summary.formula}\")\nprint(f\"Total draws: {summary.total_ndraws}\")\nprint(f\"Rhat reported: {summary.has_rhat}\")\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Use 90% credible intervals instead of default 95%\nsummary_90 = brmspy.summary(model, probs=(0.05, 0.95))\nprint(summary_90.fixed)\n</code></pre> Source code in <code>brmspy/_brms_functions/diagnostics.py</code> <pre><code>def summary(model: FitResult, **kwargs) -&gt; SummaryResult:\n    \"\"\"\n    Generate comprehensive summary statistics for a fitted brms model.\n\n    Returns a `SummaryResult` dataclass containing model information,\n    parameter estimates, and diagnostic information. The SummaryResult object provides\n    pretty printing via `str()` or `print()` and structured access to all components.\n\n    [BRMS documentation and parameters](https://paulbuerkner.com/brms/reference/summary.brmsfit.html)\n\n    Parameters\n    ----------\n    model : FitResult\n        Fitted model returned by `brmspy.brms.brm()`.\n    **kwargs\n        Additional arguments passed to brms::summary(), such as:\n        - probs: Quantiles for credible intervals, e.g., `probs=(0.025, 0.975)`\n        - robust: Use robust estimates (median, MAD), default False\n\n    Returns\n    -------\n    SummaryResult\n        A dataclass containing:\n\n        - **formula** (str): Model formula as string\n        - **data_name** (str): Name of the data object used\n        - **group** (str): Grouping structure information\n        - **nobs** (int): Number of observations\n        - **ngrps** (Dict[str, int]): Number of groups per grouping variable\n        - **autocor** (Optional[dict]): Autocorrelation structure if present\n        - **prior** (pd.DataFrame): Prior specifications used\n        - **algorithm** (str): Sampling algorithm (e.g., \"sampling\")\n        - **sampler** (str): Sampler specification (e.g., \"sample(hmc)\")\n        - **total_ndraws** (int): Total number of post-warmup draws\n        - **chains** (float): Number of chains\n        - **iter** (float): Iterations per chain\n        - **warmup** (float): Warmup iterations per chain\n        - **thin** (float): Thinning interval\n        - **has_rhat** (bool): Whether Rhat diagnostics are reported\n        - **fixed** (pd.DataFrame): Population-level (fixed) effects estimates\n        - **spec_pars** (pd.DataFrame): Family-specific parameters (e.g., sigma)\n        - **cor_pars** (pd.DataFrame): Correlation parameters if present\n        - **random** (dict): Group-level (random) effects by grouping variable\n\n    See Also\n    --------\n    brms::summary.brmsfit : [R documentation](https://paulbuerkner.com/brms/reference/summary.brmsfit.html)\n\n    Examples\n    --------\n    Basic usage with pretty printing:\n\n    ```python\n    import brmspy\n\n    model = brmspy.fit(\"y ~ x\", data=data, chains=4)\n    summary = brmspy.summary(model)\n\n    # Pretty print full summary\n    print(summary)\n    ```\n\n    Access specific components:\n\n    ```python\n    # Get population-level effects as DataFrame\n    fixed_effects = summary.fixed\n    print(fixed_effects)\n\n    # Get family-specific parameters (e.g., sigma)\n    spec_params = summary.spec_pars\n    print(spec_params)\n\n    # Access random effects (if present)\n    random_effects = summary.random\n    for group_name, group_df in random_effects.items():\n        print(f\"Random effects for {group_name}:\")\n        print(group_df)\n\n    # Check model metadata\n    print(f\"Formula: {summary.formula}\")\n    print(f\"Total draws: {summary.total_ndraws}\")\n    print(f\"Rhat reported: {summary.has_rhat}\")\n    ```\n\n    Custom credible intervals:\n\n    ```python\n    # Use 90% credible intervals instead of default 95%\n    summary_90 = brmspy.summary(model, probs=(0.05, 0.95))\n    print(summary_90.fixed)\n    ```\n    \"\"\"\n\n    import rpy2.robjects as ro\n\n    kwargs = kwargs_r(kwargs)\n    r_summary = cast(Callable, ro.r(\"summary\"))\n    summary_r = r_summary(model.r, **kwargs)\n\n    _default_get_r = lambda param: f\"function(x) x${param}\"\n    _get_methods_r: dict[str, Callable[[str], str]] = {\n        # Extract a clean formula string: \"y ~ x1 + x2 + ...\"\n        \"formula\": lambda param: (\n            \"function(x) { paste(deparse(x$formula$formula), collapse = ' ') }\"\n        ),\n    }\n\n    names = summary_r.names\n    get = lambda param: r_to_py(\n        cast(Callable, ro.r(_get_methods_r.get(param, _default_get_r)(param)))(\n            summary_r\n        )\n    )\n    out = iterate_robject_to_dataclass(\n        names=names, get=get, target_dataclass=SummaryResult, r=summary_r\n    )\n\n    return cast(SummaryResult, out)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.fixef","title":"<code>fixef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, **kwargs)</code>","text":"<p>Extract population-level (fixed) effects estimates from a fitted brms model.</p> <p>Returns a pandas DataFrame containing estimates and uncertainty intervals for all population-level parameters (fixed effects). By default, returns summary statistics (mean, standard error, credible intervals). Can also return raw posterior samples when <code>summary=False</code>.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListSexpVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>summary</code> <code>bool</code> <p>If True, return summary statistics (mean/median, SE/MAD, credible intervals). If False, return matrix of posterior samples (iterations \u00d7 parameters).</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics. Only used when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>list of str</code> <p>Specific parameter names to extract. If None, returns all fixed effects. Useful for subsetting when you only need specific coefficients.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::fixef()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>When <code>summary=True</code> (default):     DataFrame with parameters as rows and columns for Estimate, Est.Error,     Q2.5, Q97.5 (or other quantiles specified in <code>probs</code>), and optionally     Rhat and Bulk_ESS/Tail_ESS diagnostics.</p> <p>When <code>summary=False</code>:     DataFrame with posterior samples where rows are iterations and columns     are parameters. Shape is (n_iterations \u00d7 n_parameters).</p> See Also <p>brms::fixef.brmsfit : R documentation summary() : Full model summary with all parameter types</p> <p>Examples:</p> <p>Basic usage with summary statistics:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=data, chains=4)\n\n# Get fixed effects summary\nfixed_effects = brmspy.fixef(model)\nprint(fixed_effects)\n#             Estimate  Est.Error      Q2.5     Q97.5\n# Intercept  10.234567   0.123456  9.992345  10.47689\n# x1          0.456789   0.098765  0.263456   0.65012\n# x2         -0.234567   0.087654 -0.406789  -0.06234\n</code></pre> <p>Get specific parameters only:</p> <pre><code># Extract only specific coefficients\nx1_x2_effects = brmspy.fixef(model, pars=[\"x1\", \"x2\"])\nprint(x1_x2_effects)\n</code></pre> <p>Use robust estimates (median and MAD):</p> <pre><code># Use median and MAD instead of mean and SD\nrobust_effects = brmspy.fixef(model, robust=True)\nprint(robust_effects)\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Get 90% credible intervals\neffects_90 = brmspy.fixef(model, probs=(0.05, 0.95))\nprint(effects_90)\n</code></pre> <p>Get raw posterior samples:</p> <pre><code># Get full posterior samples matrix\nsamples = brmspy.fixef(model, summary=False)\nprint(samples.shape)  # (n_iterations, n_parameters)\n\n# Can then compute custom statistics\nimport numpy as np\ncustom_quantile = np.percentile(samples[\"x1\"], 90)\n</code></pre> Source code in <code>brmspy/_brms_functions/diagnostics.py</code> <pre><code>def fixef(\n    object: FitResult | ListSexpVector,\n    summary=True,\n    robust=False,\n    probs=(0.025, 0.975),\n    pars=None,\n    **kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Extract population-level (fixed) effects estimates from a fitted brms model.\n\n    Returns a pandas DataFrame containing estimates and uncertainty intervals for\n    all population-level parameters (fixed effects). By default, returns summary\n    statistics (mean, standard error, credible intervals). Can also return raw\n    posterior samples when `summary=False`.\n\n    [BRMS documentation](https://paulbuerkner.com/brms/reference/fixef.brmsfit.html)\n\n    Parameters\n    ----------\n    object : FitResult or ListSexpVector\n        Fitted model returned by `brmspy.brms.brm()` or an R brmsfit object.\n    summary : bool, default=True\n        If True, return summary statistics (mean/median, SE/MAD, credible intervals).\n        If False, return matrix of posterior samples (iterations \u00d7 parameters).\n    robust : bool, default=False\n        If True, use median and MAD instead of mean and SD for summary statistics.\n        Only used when `summary=True`.\n    probs : tuple of float, default=(0.025, 0.975)\n        Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals.\n        Only used when `summary=True`.\n    pars : list of str, optional\n        Specific parameter names to extract. If None, returns all fixed effects.\n        Useful for subsetting when you only need specific coefficients.\n    **kwargs\n        Additional arguments passed to brms::fixef()\n\n    Returns\n    -------\n    pd.DataFrame\n        When `summary=True` (default):\n            DataFrame with parameters as rows and columns for Estimate, Est.Error,\n            Q2.5, Q97.5 (or other quantiles specified in `probs`), and optionally\n            Rhat and Bulk_ESS/Tail_ESS diagnostics.\n\n        When `summary=False`:\n            DataFrame with posterior samples where rows are iterations and columns\n            are parameters. Shape is (n_iterations \u00d7 n_parameters).\n\n    See Also\n    --------\n    brms::fixef.brmsfit : [R documentation](https://paulbuerkner.com/brms/reference/fixef.brmsfit.html)\n    summary() : Full model summary with all parameter types\n\n    Examples\n    --------\n    Basic usage with summary statistics:\n\n    ```python\n    import brmspy\n\n    model = brmspy.fit(\"y ~ x1 + x2\", data=data, chains=4)\n\n    # Get fixed effects summary\n    fixed_effects = brmspy.fixef(model)\n    print(fixed_effects)\n    #             Estimate  Est.Error      Q2.5     Q97.5\n    # Intercept  10.234567   0.123456  9.992345  10.47689\n    # x1          0.456789   0.098765  0.263456   0.65012\n    # x2         -0.234567   0.087654 -0.406789  -0.06234\n    ```\n\n    Get specific parameters only:\n\n    ```python\n    # Extract only specific coefficients\n    x1_x2_effects = brmspy.fixef(model, pars=[\"x1\", \"x2\"])\n    print(x1_x2_effects)\n    ```\n\n    Use robust estimates (median and MAD):\n\n    ```python\n    # Use median and MAD instead of mean and SD\n    robust_effects = brmspy.fixef(model, robust=True)\n    print(robust_effects)\n    ```\n\n    Custom credible intervals:\n\n    ```python\n    # Get 90% credible intervals\n    effects_90 = brmspy.fixef(model, probs=(0.05, 0.95))\n    print(effects_90)\n    ```\n\n    Get raw posterior samples:\n\n    ```python\n    # Get full posterior samples matrix\n    samples = brmspy.fixef(model, summary=False)\n    print(samples.shape)  # (n_iterations, n_parameters)\n\n    # Can then compute custom statistics\n    import numpy as np\n    custom_quantile = np.percentile(samples[\"x1\"], 90)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    obj_r = py_to_r(object)\n    kwargs = kwargs_r(\n        {\"summary\": summary, \"robust\": robust, \"probs\": probs, \"pars\": pars, **kwargs}\n    )\n    r_fixef = cast(Callable, ro.r(\"brms::fixef\"))\n    r_df = r_fixef(obj_r, **kwargs)\n    return cast(pd.DataFrame, r_to_py(r_df))\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.ranef","title":"<code>ranef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, groups=None, **kwargs)</code>","text":"<p>Extract group-level (random) effects as xarray DataArrays.</p> <p>This is a wrapper around <code>brms::ranef()</code>. For <code>summary=True</code> (default), each grouping factor is returned as a 3D array with dimensions <code>(\"group\", \"stat\", \"coef\")</code>. For <code>summary=False</code>, each factor is returned as <code>(\"draw\", \"group\", \"coef\")</code> with one slice per posterior draw.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model returned by :func:<code>brmspy.brms.fit</code> or an R <code>brmsfit</code> object / summary list.</p> required <code>summary</code> <code>bool</code> <p>If True, return posterior summaries for the group-level effects (means, errors, intervals). If False, return per-draw random effects.</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use robust summaries (median and MAD) instead of mean and SD. Passed through to <code>brms::ranef()</code> when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Central posterior interval probabilities, as in <code>brms::ranef()</code>. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>str or sequence of str</code> <p>Subset of group-level parameters to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>groups</code> <code>str or sequence of str</code> <p>Subset of grouping factors to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments forwarded to <code>brms::ranef()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, DataArray]</code> <p>Mapping from grouping-factor name (e.g. <code>\"patient\"</code>) to a <code>DataArray</code>:</p> <ul> <li><code>summary=True</code>: dims <code>(\"group\", \"stat\", \"coef\")</code>,   with <code>stat</code> typically containing   <code>[\"Estimate\", \"Est.Error\", \"Q2.5\", \"Q97.5\"]</code>.</li> <li><code>summary=False</code>: dims <code>(\"draw\", \"group\", \"coef\")</code>,   where <code>draw</code> indexes posterior samples.</li> </ul> <p>Examples:</p> <p>Compute summary random effects and inspect all coefficients for a single group level:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms import ranef\n\nfit = brms.fit(\"count ~ zAge + zBase * Trt + (1 + zBase + Trt | patient)\",\n               data=data, family=\"poisson\")\n\nre = ranef(fit)  # summary=True by default\npatient_re = re[\"patient\"].sel(group=\"1\", stat=\"Estimate\")\n</code></pre> <p>Extract per-draw random effects for downstream MCMC analysis:</p> <pre><code>re_draws = ranef(fit, summary=False)\npatient_draws = re_draws[\"patient\"]       # dims: (\"draw\", \"group\", \"coef\")\nfirst_draw = patient_draws.sel(draw=0)\n</code></pre> Source code in <code>brmspy/_brms_functions/diagnostics.py</code> <pre><code>def ranef(\n    object: FitResult | ListSexpVector,\n    summary: bool = True,\n    robust: bool = False,\n    probs=(0.025, 0.975),\n    pars=None,\n    groups=None,\n    **kwargs,\n) -&gt; dict[str, xr.DataArray]:\n    \"\"\"\n    Extract group-level (random) effects as xarray DataArrays.\n\n    This is a wrapper around ``brms::ranef()``. For ``summary=True`` (default),\n    each grouping factor is returned as a 3D array with dimensions\n    ``(\"group\", \"stat\", \"coef\")``. For ``summary=False``, each factor is\n    returned as ``(\"draw\", \"group\", \"coef\")`` with one slice per posterior draw.\n\n    Parameters\n    ----------\n    object : FitResult or rpy2.robjects.ListVector\n        Fitted model returned by :func:`brmspy.brms.fit` or an R ``brmsfit``\n        object / summary list.\n    summary : bool, default True\n        If True, return posterior summaries for the group-level effects\n        (means, errors, intervals). If False, return per-draw random effects.\n    robust : bool, default False\n        If True, use robust summaries (median and MAD) instead of mean and SD.\n        Passed through to ``brms::ranef()`` when ``summary=True``.\n    probs : tuple of float, default (0.025, 0.975)\n        Central posterior interval probabilities, as in ``brms::ranef()``.\n        Only used when ``summary=True``.\n    pars : str or sequence of str, optional\n        Subset of group-level parameters to include. Passed to ``brms::ranef()``.\n    groups : str or sequence of str, optional\n        Subset of grouping factors to include. Passed to ``brms::ranef()``.\n    **kwargs\n        Additional keyword arguments forwarded to ``brms::ranef()``.\n\n    Returns\n    -------\n    dict[str, xarray.DataArray]\n        Mapping from grouping-factor name (e.g. ``\"patient\"``) to a\n        ``DataArray``:\n\n        * ``summary=True``: dims ``(\"group\", \"stat\", \"coef\")``,\n          with ``stat`` typically containing\n          ``[\"Estimate\", \"Est.Error\", \"Q2.5\", \"Q97.5\"]``.\n        * ``summary=False``: dims ``(\"draw\", \"group\", \"coef\")``,\n          where ``draw`` indexes posterior samples.\n\n    Examples\n    --------\n    Compute summary random effects and inspect all coefficients for a single\n    group level:\n\n    ```python\n    from brmspy import brms\n    from brmspy.brms import ranef\n\n    fit = brms.fit(\"count ~ zAge + zBase * Trt + (1 + zBase + Trt | patient)\",\n                   data=data, family=\"poisson\")\n\n    re = ranef(fit)  # summary=True by default\n    patient_re = re[\"patient\"].sel(group=\"1\", stat=\"Estimate\")\n    ```\n\n    Extract per-draw random effects for downstream MCMC analysis:\n\n    ```python\n    re_draws = ranef(fit, summary=False)\n    patient_draws = re_draws[\"patient\"]       # dims: (\"draw\", \"group\", \"coef\")\n    first_draw = patient_draws.sel(draw=0)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    obj_r = py_to_r(object)\n    kwargs = kwargs_r(\n        {\"summary\": summary, \"robust\": robust, \"probs\": probs, \"pars\": pars, **kwargs}\n    )\n\n    r_ranef = cast(Callable, ro.r(\"brms::ranef\"))\n    r_list = r_ranef(obj_r, **kwargs)\n\n    out: dict[str, xr.DataArray] = {}\n\n    for name in r_list.names:\n        # R 3D array for this grouping factor\n        r_arr = cast(Callable, ro.r(f\"function(x) x${name}\"))(r_list)\n        dims = list(r_arr.do_slot(\"dim\"))  # length-3\n\n        # dimnames is a list of length 3, some entries may be NULL\n        dimnames_r = r_arr.do_slot(\"dimnames\")\n        dimnames: list[list[str] | None] = []\n        for dn in dimnames_r:\n            if dn == ro.NULL:\n                dimnames.append(None)\n            else:\n                dimnames.append(list(cast(Iterable, r_to_py(dn))))\n\n        p_arr = np.asarray(r_arr).reshape(dims)\n\n        if summary:\n            # brms: 1=group levels, 2=stats, 3=coefs\n            groups_dn, stats_dn, coefs_dn = dimnames\n\n            da = xr.DataArray(\n                p_arr,\n                dims=(\"group\", \"stat\", \"coef\"),\n                coords={\n                    \"group\": groups_dn,\n                    \"stat\": stats_dn,\n                    \"coef\": coefs_dn,\n                },\n            )\n        else:\n            # brms: 1=draws, 2=group levels, 3=coefs\n            draws_dn, groups_dn, coefs_dn = dimnames\n            n_draws = dims[0]\n            if draws_dn is None:\n                # brms does not name draws, so create a simple index\n                draws_dn = list(range(n_draws))\n\n            da = xr.DataArray(\n                p_arr,\n                dims=(\"draw\", \"group\", \"coef\"),\n                coords={\n                    \"draw\": draws_dn,\n                    \"group\": groups_dn,\n                    \"coef\": coefs_dn,\n                },\n            )\n\n        out[name] = da\n    return out\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.posterior_summary","title":"<code>posterior_summary(object, variable=None, probs=(0.025, 0.975), robust=False, **kwargs)</code>","text":"<p>Extract posterior summary statistics for all or selected model parameters.</p> <p>Provides a DataFrame with estimates, standard errors, and credible intervals for all parameters in a brms model, including fixed effects, random effects, and auxiliary parameters. More comprehensive than <code>fixef()</code> or <code>ranef()</code> as it covers all parameter types.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListSexpVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>variable</code> <code>str or list of str</code> <p>Specific variable name(s) to extract. If None, returns all parameters. Supports regex patterns for flexible selection.</p> <code>None</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals.</p> <code>(0.025, 0.975)</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments passed to brms::posterior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with parameters as rows and columns for Estimate, Est.Error, and quantiles (e.g., Q2.5, Q97.5). Includes all model parameters: population-level effects, group-level effects, and auxiliary parameters.</p> See Also <p>brms::posterior_summary : R documentation     https://paulbuerkner.com/brms/reference/posterior_summary.brmsfit.html fixef() : Extract only population-level effects ranef() : Extract only group-level effects</p> <p>Examples:</p> <p>Get summary for all parameters:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + (1|group)\", data=data, chains=4)\n\n# Get all parameter summaries\nall_params = brmspy.posterior_summary(model)\nprint(all_params)\n</code></pre> <p>Extract specific parameters:</p> <pre><code># Get summary for specific parameters\nintercept = brmspy.posterior_summary(model, variable=\"b_Intercept\")\nprint(intercept)\n\n# Multiple parameters\nfixed_only = brmspy.posterior_summary(model, variable=[\"b_Intercept\", \"b_x1\"])\nprint(fixed_only)\n</code></pre> <p>Custom credible intervals with robust estimates:</p> <pre><code># 90% intervals with median/MAD\nrobust_summary = brmspy.posterior_summary(\n    model,\n    probs=(0.05, 0.95),\n    robust=True\n)\nprint(robust_summary)\n</code></pre> Source code in <code>brmspy/_brms_functions/diagnostics.py</code> <pre><code>def posterior_summary(\n    object: FitResult | ListSexpVector,\n    variable=None,\n    probs=(0.025, 0.975),\n    robust=False,\n    **kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Extract posterior summary statistics for all or selected model parameters.\n\n    Provides a DataFrame with estimates, standard errors, and credible intervals\n    for all parameters in a brms model, including fixed effects, random effects,\n    and auxiliary parameters. More comprehensive than `fixef()` or `ranef()` as it covers all\n    parameter types.\n\n    [BRMS documentation](https://paulbuerkner.com/brms/reference/posterior_summary.brmsfit.html)\n\n    Parameters\n    ----------\n    object : FitResult or ListSexpVector\n        Fitted model returned by `brmspy.brms.brm()` or an R brmsfit object.\n    variable : str or list of str, optional\n        Specific variable name(s) to extract. If None, returns all parameters.\n        Supports regex patterns for flexible selection.\n    probs : tuple of float, default=(0.025, 0.975)\n        Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals.\n    robust : bool, default=False\n        If True, use median and MAD instead of mean and SD for summary statistics.\n    **kwargs\n        Additional arguments passed to brms::posterior_summary()\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with parameters as rows and columns for Estimate, Est.Error,\n        and quantiles (e.g., Q2.5, Q97.5). Includes all model parameters:\n        population-level effects, group-level effects, and auxiliary parameters.\n\n    See Also\n    --------\n    brms::posterior_summary : R documentation\n        https://paulbuerkner.com/brms/reference/posterior_summary.brmsfit.html\n    fixef() : Extract only population-level effects\n    ranef() : Extract only group-level effects\n\n    Examples\n    --------\n    Get summary for all parameters:\n\n    ```python\n    import brmspy\n\n    model = brmspy.fit(\"y ~ x1 + (1|group)\", data=data, chains=4)\n\n    # Get all parameter summaries\n    all_params = brmspy.posterior_summary(model)\n    print(all_params)\n    ```\n\n    Extract specific parameters:\n\n    ```python\n    # Get summary for specific parameters\n    intercept = brmspy.posterior_summary(model, variable=\"b_Intercept\")\n    print(intercept)\n\n    # Multiple parameters\n    fixed_only = brmspy.posterior_summary(model, variable=[\"b_Intercept\", \"b_x1\"])\n    print(fixed_only)\n    ```\n\n    Custom credible intervals with robust estimates:\n\n    ```python\n    # 90% intervals with median/MAD\n    robust_summary = brmspy.posterior_summary(\n        model,\n        probs=(0.05, 0.95),\n        robust=True\n    )\n    print(robust_summary)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    obj_r = py_to_r(object)\n    kwargs = kwargs_r(\n        {\"variable\": variable, \"probs\": probs, \"robust\": robust, **kwargs}\n    )\n\n    r_fun = cast(Callable, ro.r(\"brms::posterior_summary\"))\n    r_df = r_fun(obj_r, **kwargs)\n    return cast(pd.DataFrame, r_to_py(r_df))\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.prior_summary","title":"<code>prior_summary(object, all=True, **kwargs)</code>","text":"<p>Extract prior specifications used in a fitted brms model.</p> <p>Returns a DataFrame containing all prior distributions that were used (either explicitly set or defaults) when fitting the model. Useful for documenting model specifications and understanding which priors were applied.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>all</code> <code>bool</code> <p>If True, return all priors including default priors. If False, return only explicitly set priors.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to brms::prior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns describing prior specifications: - prior: Prior distribution formula - class: Parameter class (b, sd, Intercept, etc.) - coef: Specific coefficient (if applicable) - group: Grouping factor (if applicable) - resp: Response variable (for multivariate models) - dpar: Distributional parameter (if applicable) - nlpar: Non-linear parameter (if applicable) - lb/ub: Bounds for truncated priors - source: Origin of prior (default, user, etc.)</p> See Also <p>brms::prior_summary : R documentation     https://paulbuerkner.com/brms/reference/prior_summary.brmsfit.html get_prior() : Get prior structure before fitting default_prior() : Get default priors for a model</p> <p>Examples:</p> <p>Get all priors used in a model:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\n    \"y ~ x1 + (1|group)\",\n    data=data,\n    priors=[brmspy.prior(\"normal(0, 1)\", \"b\")],\n    chains=4\n)\n\n# Get all priors (including defaults)\npriors = brmspy.prior_summary(model)\nprint(priors)\n</code></pre> <p>Get only explicitly set priors:</p> <pre><code># Get only user-specified priors\nuser_priors = brmspy.prior_summary(model, all=False)\nprint(user_priors)\n</code></pre> <p>Compare with what would be used before fitting:</p> <pre><code># Before fitting - check default priors\ndefault_priors = brmspy.get_prior(\"y ~ x1\", data=data)\n\n# After fitting - see what was actually used\nused_priors = brmspy.prior_summary(model)\n</code></pre> Source code in <code>brmspy/_brms_functions/diagnostics.py</code> <pre><code>def prior_summary(\n    object: FitResult | ListSexpVector, all=True, **kwargs\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Extract prior specifications used in a fitted brms model.\n\n    Returns a DataFrame containing all prior distributions that were used\n    (either explicitly set or defaults) when fitting the model. Useful for\n    documenting model specifications and understanding which priors were applied.\n\n    [BRMS documentation](https://paulbuerkner.com/brms/reference/prior_summary.brmsfit.html)\n\n    Parameters\n    ----------\n    object : FitResult or ListVector\n        Fitted model returned by `brmspy.brms.brm()` or an R brmsfit object.\n    all : bool, default=True\n        If True, return all priors including default priors.\n        If False, return only explicitly set priors.\n    **kwargs\n        Additional arguments passed to brms::prior_summary()\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with columns describing prior specifications:\n        - prior: Prior distribution formula\n        - class: Parameter class (b, sd, Intercept, etc.)\n        - coef: Specific coefficient (if applicable)\n        - group: Grouping factor (if applicable)\n        - resp: Response variable (for multivariate models)\n        - dpar: Distributional parameter (if applicable)\n        - nlpar: Non-linear parameter (if applicable)\n        - lb/ub: Bounds for truncated priors\n        - source: Origin of prior (default, user, etc.)\n\n    See Also\n    --------\n    brms::prior_summary : R documentation\n        https://paulbuerkner.com/brms/reference/prior_summary.brmsfit.html\n    get_prior() : Get prior structure before fitting\n    default_prior() : Get default priors for a model\n\n    Examples\n    --------\n    Get all priors used in a model:\n\n    ```python\n    import brmspy\n\n    model = brmspy.fit(\n        \"y ~ x1 + (1|group)\",\n        data=data,\n        priors=[brmspy.prior(\"normal(0, 1)\", \"b\")],\n        chains=4\n    )\n\n    # Get all priors (including defaults)\n    priors = brmspy.prior_summary(model)\n    print(priors)\n    ```\n\n    Get only explicitly set priors:\n\n    ```python\n    # Get only user-specified priors\n    user_priors = brmspy.prior_summary(model, all=False)\n    print(user_priors)\n    ```\n\n    Compare with what would be used before fitting:\n\n    ```python\n    # Before fitting - check default priors\n    default_priors = brmspy.get_prior(\"y ~ x1\", data=data)\n\n    # After fitting - see what was actually used\n    used_priors = brmspy.prior_summary(model)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    obj_r = py_to_r(object)\n    kwargs = kwargs_r({\"all\": all, **kwargs})\n\n    r_fun = cast(Callable, ro.r(\"brms::prior_summary\"))\n    r_df = r_fun(obj_r, **kwargs)\n    return cast(pd.DataFrame, r_to_py(r_df))\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.validate_newdata","title":"<code>validate_newdata(newdata, object, re_formula=None, allow_new_levels=False, newdata2=None, resp=None, check_response=True, incl_autocor=True, group_vars=None, req_vars=None, **kwargs)</code>","text":"<p>Validate new data for predictions from a fitted brms model.</p> <p>Ensures that new data contains all required variables and has the correct structure for making predictions. Checks variable types, factor levels, grouping variables, and autocorrelation structures. This function is primarily used internally by prediction methods but can be called directly for debugging or validation purposes.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>DataFrame</code> <p>DataFrame containing new data to be validated against the model. Must include all predictor variables used in the model formula.</p> required <code>object</code> <code>FitResult or ListSexpVector</code> <p>Fitted model returned by <code>brmspy.brms.brm()</code> or an R brmsfit object.</p> required <code>re_formula</code> <code>str</code> <p>Formula string specifying group-level effects to include in validation. If None (default), include all group-level effects. If NA, include no group-level effects.</p> <code>None</code> <code>allow_new_levels</code> <code>bool</code> <p>Whether to allow new levels of grouping variables not present in the original training data. If False, raises an error for new levels.</p> <code>False</code> <code>newdata2</code> <code>DataFrame</code> <p>Additional data that cannot be passed via <code>newdata</code>, such as objects used in autocorrelation structures or stanvars.</p> <code>None</code> <code>resp</code> <code>str or list of str</code> <p>Names of response variables to validate. If specified, validation is performed only for the specified responses (relevant for multivariate models).</p> <code>None</code> <code>check_response</code> <code>bool</code> <p>Whether to check if response variables are present in newdata. Set to False when making predictions where response is not needed.</p> <code>True</code> <code>incl_autocor</code> <code>bool</code> <p>Whether to include autocorrelation structures originally specified in the model. If True, validates autocorrelation-related variables.</p> <code>True</code> <code>group_vars</code> <code>list of str</code> <p>Names of specific grouping variables to validate. If None (default), validates all grouping variables present in the model.</p> <code>None</code> <code>req_vars</code> <code>list of str</code> <p>Names of specific variables required in newdata. If None (default), all variables from the original training data are required (unless excluded by other parameters).</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::validate_newdata()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Validated DataFrame based on newdata, potentially with added or modified columns to ensure compatibility with the model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If newdata is missing required variables</p> <code>ValueError</code> <p>If factor levels in newdata don't match those in training data (when allow_new_levels=False)</p> <code>ValueError</code> <p>If grouping variables have invalid structure</p> See Also <p>brms::validate_newdata : R documentation     https://paulbuerkner.com/brms/reference/validate_newdata.html posterior_predict() : Uses validate_newdata internally posterior_epred() : Uses validate_newdata internally</p> <p>Examples:</p> <p>Basic validation for prediction data:</p> <pre><code>import brmspy\nimport pandas as pd\n\n# Fit model\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=train_data, chains=4)\n\n# Prepare new data\nnew_data = pd.DataFrame({\n    'x1': [1.0, 2.0, 3.0],\n    'x2': [0.5, 1.0, 1.5]\n})\n\n# Validate before prediction\nvalidated_data = brmspy.validate_newdata(new_data, model)\nprint(validated_data)\n</code></pre> <p>Validate with group-level effects:</p> <pre><code># Model with random effects\nmodel = brmspy.fit(\"y ~ x + (1|group)\", data=train_data, chains=4)\n\n# New data with grouping variable\nnew_data = pd.DataFrame({\n    'x': [1.0, 2.0],\n    'group': ['A', 'B']  # Must match training data groups\n})\n\n# Validate - will error if groups A or B weren't in training\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    allow_new_levels=False\n)\n</code></pre> <p>Allow new levels for population-level predictions:</p> <pre><code># Allow new group levels (makes population-level predictions only)\nnew_data_with_new_groups = pd.DataFrame({\n    'x': [3.0, 4.0],\n    'group': ['C', 'D']  # New groups not in training\n})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data_with_new_groups,\n    model,\n    allow_new_levels=True\n)\n</code></pre> <p>Skip response variable checking:</p> <pre><code># When making predictions, response not needed\nnew_data = pd.DataFrame({'x1': [1.0, 2.0]})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    check_response=False\n)\n</code></pre> Source code in <code>brmspy/_brms_functions/diagnostics.py</code> <pre><code>def validate_newdata(\n    newdata: pd.DataFrame,\n    object: ListSexpVector | FitResult,\n    re_formula: str | None = None,\n    allow_new_levels: bool = False,\n    newdata2: pd.DataFrame | None = None,\n    resp=None,\n    check_response=True,\n    incl_autocor=True,\n    group_vars=None,\n    req_vars=None,\n    **kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Validate new data for predictions from a fitted brms model.\n\n    Ensures that new data contains all required variables and has the correct\n    structure for making predictions. Checks variable types, factor levels,\n    grouping variables, and autocorrelation structures. This function is primarily\n    used internally by prediction methods but can be called directly for debugging\n    or validation purposes.\n\n    [BRMS documentation](https://paulbuerkner.com/brms/reference/validate_newdata.html)\n\n    Parameters\n    ----------\n    newdata : pd.DataFrame\n        DataFrame containing new data to be validated against the model.\n        Must include all predictor variables used in the model formula.\n    object : FitResult or ListSexpVector\n        Fitted model returned by `brmspy.brms.brm()` or an R brmsfit object.\n    re_formula : str, optional\n        Formula string specifying group-level effects to include in validation.\n        If None (default), include all group-level effects.\n        If NA, include no group-level effects.\n    allow_new_levels : bool, default=False\n        Whether to allow new levels of grouping variables not present in\n        the original training data. If False, raises an error for new levels.\n    newdata2 : pd.DataFrame, optional\n        Additional data that cannot be passed via `newdata`, such as objects\n        used in autocorrelation structures or stanvars.\n    resp : str or list of str, optional\n        Names of response variables to validate. If specified, validation\n        is performed only for the specified responses (relevant for multivariate models).\n    check_response : bool, default=True\n        Whether to check if response variables are present in newdata.\n        Set to False when making predictions where response is not needed.\n    incl_autocor : bool, default=True\n        Whether to include autocorrelation structures originally specified\n        in the model. If True, validates autocorrelation-related variables.\n    group_vars : list of str, optional\n        Names of specific grouping variables to validate. If None (default),\n        validates all grouping variables present in the model.\n    req_vars : list of str, optional\n        Names of specific variables required in newdata. If None (default),\n        all variables from the original training data are required (unless\n        excluded by other parameters).\n    **kwargs\n        Additional arguments passed to brms::validate_newdata()\n\n    Returns\n    -------\n    pd.DataFrame\n        Validated DataFrame based on newdata, potentially with added or\n        modified columns to ensure compatibility with the model.\n\n    Raises\n    ------\n    ValueError\n        If newdata is missing required variables\n    ValueError\n        If factor levels in newdata don't match those in training data\n        (when allow_new_levels=False)\n    ValueError\n        If grouping variables have invalid structure\n\n    See Also\n    --------\n    brms::validate_newdata : R documentation\n        https://paulbuerkner.com/brms/reference/validate_newdata.html\n    posterior_predict() : Uses validate_newdata internally\n    posterior_epred() : Uses validate_newdata internally\n\n    Examples\n    --------\n    Basic validation for prediction data:\n\n    ```python\n    import brmspy\n    import pandas as pd\n\n    # Fit model\n    model = brmspy.fit(\"y ~ x1 + x2\", data=train_data, chains=4)\n\n    # Prepare new data\n    new_data = pd.DataFrame({\n        'x1': [1.0, 2.0, 3.0],\n        'x2': [0.5, 1.0, 1.5]\n    })\n\n    # Validate before prediction\n    validated_data = brmspy.validate_newdata(new_data, model)\n    print(validated_data)\n    ```\n\n    Validate with group-level effects:\n\n    ```python\n    # Model with random effects\n    model = brmspy.fit(\"y ~ x + (1|group)\", data=train_data, chains=4)\n\n    # New data with grouping variable\n    new_data = pd.DataFrame({\n        'x': [1.0, 2.0],\n        'group': ['A', 'B']  # Must match training data groups\n    })\n\n    # Validate - will error if groups A or B weren't in training\n    validated_data = brmspy.validate_newdata(\n        new_data,\n        model,\n        allow_new_levels=False\n    )\n    ```\n\n    Allow new levels for population-level predictions:\n\n    ```python\n    # Allow new group levels (makes population-level predictions only)\n    new_data_with_new_groups = pd.DataFrame({\n        'x': [3.0, 4.0],\n        'group': ['C', 'D']  # New groups not in training\n    })\n\n    validated_data = brmspy.validate_newdata(\n        new_data_with_new_groups,\n        model,\n        allow_new_levels=True\n    )\n    ```\n\n    Skip response variable checking:\n\n    ```python\n    # When making predictions, response not needed\n    new_data = pd.DataFrame({'x1': [1.0, 2.0]})\n\n    validated_data = brmspy.validate_newdata(\n        new_data,\n        model,\n        check_response=False\n    )\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    r_validate_newdata = cast(Callable, ro.r(\"brms::validate_newdata\"))\n    kwargs = kwargs_r(\n        {\n            \"newdata\": newdata,\n            \"object\": object,\n            \"re_formula\": re_formula,\n            \"allow_new_levels\": allow_new_levels,\n            \"newdata2\": newdata2,\n            \"resp\": resp,\n            \"check_response\": check_response,\n            \"incl_autocor\": incl_autocor,\n            \"group_vars\": group_vars,\n            \"req_vars\": req_vars,\n            **kwargs,\n        }\n    )\n    res_r = r_validate_newdata(**kwargs)\n    return cast(pd.DataFrame, r_to_py(res_r))\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.call","title":"<code>call(function, *args, **kwargs)</code>","text":"<p>Call an R function by name with brmspy type conversion.</p> <p>This is intended as an escape hatch for R/brms functionality that does not yet have a dedicated wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Function name. If not namespaced, brmspy tries <code>brms::&lt;function&gt;</code> first, then falls back to evaluating the name directly (e.g. <code>\"stats::AIC\"</code>).</p> required <code>*args</code> <p>Positional arguments.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Converted return value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; fit = brms.brm(\"y ~ x\", data=df, chains=4)\n&gt;&gt;&gt; aic = brms.call(\"stats::AIC\", fit)\n</code></pre> Source code in <code>brmspy/_brms_functions/generic.py</code> <pre><code>def call(function: str, *args, **kwargs) -&gt; Any:\n    \"\"\"\n    Call an R function by name with brmspy type conversion.\n\n    This is intended as an escape hatch for R/brms functionality that does not\n    yet have a dedicated wrapper.\n\n    Parameters\n    ----------\n    function : str\n        Function name. If not namespaced, brmspy tries ``brms::&lt;function&gt;`` first,\n        then falls back to evaluating the name directly (e.g. ``\"stats::AIC\"``).\n    *args\n        Positional arguments.\n    **kwargs\n        Keyword arguments.\n\n    Returns\n    -------\n    Any\n        Converted return value.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from brmspy import brms\n    &gt;&gt;&gt; fit = brms.brm(\"y ~ x\", data=df, chains=4)\n    &gt;&gt;&gt; aic = brms.call(\"stats::AIC\", fit)\n    \"\"\"\n    import rpy2.robjects as ro\n\n    func_name = sanitised_name(function)\n    args = [py_to_r(arg) for arg in args]\n    kwargs = kwargs_r({**kwargs})\n    try:\n        r_fun = cast(\n            Callable, ro.r(f\"suppressWarnings(suppressMessages(brms::{func_name}))\")\n        )\n    except Exception:\n        r_fun = cast(Callable, ro.r(func_name))\n\n    r_result = r_fun(*args, **kwargs)\n    return r_to_py(r_result)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.bf","title":"<code>bf(*formulas, **formula_args)</code>","text":"<p>Build a brms model formula.</p> <p>This is the primary entrypoint for specifying the mean model and can be combined with other formula parts (e.g. <code>lf</code>, <code>nlf</code>, <code>acformula</code>) using <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str</code> <p>One or more brms formula strings (e.g. <code>\"y ~ x + (1|group)\"</code>). Multiple formulas are commonly used for multivariate models.</p> <code>()</code> <code>**formula_args</code> <p>Keyword arguments forwarded to R <code>brms::brmsformula()</code> (for example <code>decomp=\"QR\"</code>, <code>center=True</code>, <code>sparse=True</code>, <code>nl=True</code>, <code>loop=True</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::brmsformula : R documentation</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>QR decomposition (often helps with collinearity):</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"reaction ~ days + (days|subject)\", decomp=\"QR\")\n</code></pre> <p>Multivariate formula + residual correlation:</p> <pre><code>from brmspy.brms import bf, set_rescor\n\nf = bf(\"mvbind(y1, y2) ~ x\") + set_rescor(True)\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def bf(*formulas: str, **formula_args) -&gt; FormulaConstruct:\n    \"\"\"\n    Build a brms model formula.\n\n    This is the primary entrypoint for specifying the mean model and can be\n    combined with other formula parts (e.g. `lf`, `nlf`, `acformula`) using ``+``.\n\n    Parameters\n    ----------\n    *formulas : str\n        One or more brms formula strings (e.g. ``\"y ~ x + (1|group)\"``). Multiple\n        formulas are commonly used for multivariate models.\n    **formula_args\n        Keyword arguments forwarded to R ``brms::brmsformula()`` (for example\n        ``decomp=\"QR\"``, ``center=True``, ``sparse=True``, ``nl=True``, ``loop=True``).\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::brmsformula : [R documentation](https://paulbuerkner.com/brms/reference/brmsformula.html)\n\n    Examples\n    --------\n    Basic formula:\n\n    ```python\n    from brmspy.brms import bf\n\n    f = bf(\"y ~ x1 + x2 + (1|group)\")\n    ```\n\n    QR decomposition (often helps with collinearity):\n\n    ```python\n    from brmspy.brms import bf\n\n    f = bf(\"reaction ~ days + (days|subject)\", decomp=\"QR\")\n    ```\n\n    Multivariate formula + residual correlation:\n\n    ```python\n    from brmspy.brms import bf, set_rescor\n\n    f = bf(\"mvbind(y1, y2) ~ x\") + set_rescor(True)\n    ```\n    \"\"\"\n    part = FormulaPart(_fun=\"bf\", _args=list(formulas), _kwargs=formula_args)\n    return FormulaConstruct._formula_parse(part)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.lf","title":"<code>lf(*formulas, flist=None, dpar=None, resp=None, center=None, cmc=None, sparse=None, decomp=None)</code>","text":"<p>Add linear formulas for distributional / non-linear parameters.</p> <p>This wraps R <code>brms::lf()</code> and is typically used to model distributional parameters such as <code>sigma</code> (heteroskedasticity) or to specify predictors for non-linear parameters.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str | FormulaConstruct | FormulaPart | ProxyListSexpVector</code> <p>One or more formulas such as <code>\"sigma ~ x\"</code>.</p> <code>()</code> <code>flist</code> <p>Optional list of formulas (advanced; mirrors brms).</p> <code>None</code> <code>dpar</code> <code>str or None</code> <p>Distributional parameter name (e.g. <code>\"sigma\"</code>, <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <code>center</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <code>cmc</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <code>sparse</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <code>decomp</code> <code>bool | None</code> <p>Forwarded to R <code>brms::lf()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification that can be combined using <code>+</code>.</p> See Also <p>brms::lf : R documentation</p> <p>Examples:</p> <p>Model mean + sigma:</p> <pre><code>from brmspy.brms import bf, lf\n\nf = bf(\"y ~ x\") + lf(\"sigma ~ x\", dpar=\"sigma\")\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def lf(\n    *formulas: str | FormulaConstruct | FormulaPart | ProxyListSexpVector,\n    flist=None,\n    dpar: str | None = None,\n    resp: str | None = None,\n    center: bool | None = None,\n    cmc: bool | None = None,\n    sparse: bool | None = None,\n    decomp: str | None = None,\n) -&gt; FormulaConstruct:\n    \"\"\"\n    Add linear formulas for distributional / non-linear parameters.\n\n    This wraps R ``brms::lf()`` and is typically used to model distributional\n    parameters such as ``sigma`` (heteroskedasticity) or to specify predictors\n    for non-linear parameters.\n\n    Parameters\n    ----------\n    *formulas\n        One or more formulas such as ``\"sigma ~ x\"``.\n    flist\n        Optional list of formulas (advanced; mirrors brms).\n    dpar : str or None, default=None\n        Distributional parameter name (e.g. ``\"sigma\"``, ``\"phi\"``).\n    resp : str or None, default=None\n        Response name for multivariate models.\n    center, cmc, sparse, decomp\n        Forwarded to R ``brms::lf()``.\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification that can be combined using ``+``.\n\n    See Also\n    --------\n    brms::lf : [R documentation](https://paulbuerkner.com/brms/reference/lf.html)\n\n    Examples\n    --------\n    Model mean + sigma:\n\n    ```python\n    from brmspy.brms import bf, lf\n\n    f = bf(\"y ~ x\") + lf(\"sigma ~ x\", dpar=\"sigma\")\n    ```\n    \"\"\"\n    formula_args = {\n        \"flist\": flist,\n        \"dpar\": dpar,\n        \"resp\": resp,\n        \"center\": center,\n        \"cmc\": cmc,\n        \"sparse\": sparse,\n        \"decomp\": decomp,\n    }\n    result = FormulaConstruct._formula_parse(\n        FormulaPart(\"lf\", list(formulas), formula_args)\n    )\n    return result\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.nlf","title":"<code>nlf(*formulas, flist=None, dpar=None, resp=None, loop=None)</code>","text":"<p>Add non-linear formulas.</p> <p>Wraps R <code>brms::nlf()</code>. This is used together with <code>set_nl()</code> and parameter definitions in <code>lf()</code> to specify non-linear models.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str | FormulaConstruct | FormulaPart | ProxyListSexpVector</code> <p>One or more non-linear formulas (e.g. <code>\"y ~ a * exp(b * x)\"</code>).</p> <code>()</code> <code>flist</code> <p>Optional list of formulas (advanced; mirrors brms).</p> <code>None</code> <code>dpar</code> <code>str or None</code> <p>Distributional parameter name (optional).</p> <code>None</code> <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <code>loop</code> <code>bool or None</code> <p>Forwarded to R <code>brms::nlf(loop=...)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::nlf : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, nlf, set_nl\n\nf = bf(\"y ~ 1\") + nlf(\"y ~ a * exp(b * x)\") + set_nl()\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def nlf(\n    *formulas: str | FormulaConstruct | FormulaPart | ProxyListSexpVector,\n    flist=None,\n    dpar: str | None = None,\n    resp: str | None = None,\n    loop: bool | None = None,\n) -&gt; FormulaConstruct:\n    \"\"\"\n    Add non-linear formulas.\n\n    Wraps R ``brms::nlf()``. This is used together with `set_nl()` and parameter\n    definitions in `lf()` to specify non-linear models.\n\n    Parameters\n    ----------\n    *formulas\n        One or more non-linear formulas (e.g. ``\"y ~ a * exp(b * x)\"``).\n    flist\n        Optional list of formulas (advanced; mirrors brms).\n    dpar : str or None, default=None\n        Distributional parameter name (optional).\n    resp : str or None, default=None\n        Response name for multivariate models.\n    loop : bool or None, default=None\n        Forwarded to R ``brms::nlf(loop=...)``.\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::nlf : [R documentation](https://paulbuerkner.com/brms/reference/nlf.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, nlf, set_nl\n\n    f = bf(\"y ~ 1\") + nlf(\"y ~ a * exp(b * x)\") + set_nl()\n    ```\n    \"\"\"\n    formula_args = {\n        \"flist\": flist,\n        \"dpar\": dpar,\n        \"resp\": resp,\n        \"loop\": loop,\n    }\n    return FormulaConstruct._formula_parse(FormulaPart(\"nlf\", formulas, formula_args))\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.acformula","title":"<code>acformula(autocor, resp=None)</code>","text":"<p>Add an autocorrelation structure.</p> <p>Wraps R <code>brms::acformula()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>autocor</code> <code>str</code> <p>One-sided autocorrelation formula (e.g. <code>\"~ arma(p = 1, q = 1)\"</code>).</p> required <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::acformula : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, acformula\n\nf = bf(\"y ~ x\") + acformula(\"~ arma(p = 1, q = 1)\")\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def acformula(\n    autocor: str,\n    resp: str | None = None,\n) -&gt; FormulaConstruct:\n    \"\"\"\n    Add an autocorrelation structure.\n\n    Wraps R ``brms::acformula()``.\n\n    Parameters\n    ----------\n    autocor : str\n        One-sided autocorrelation formula (e.g. ``\"~ arma(p = 1, q = 1)\"``).\n    resp : str or None, default=None\n        Response name for multivariate models.\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::acformula : [R documentation](https://paulbuerkner.com/brms/reference/acformula.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, acformula\n\n    f = bf(\"y ~ x\") + acformula(\"~ arma(p = 1, q = 1)\")\n    ```\n    \"\"\"\n    formula_args = {\"resp\": resp}\n    return FormulaConstruct._formula_parse(\n        FormulaPart(\"acformula\", [autocor], formula_args)\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.set_rescor","title":"<code>set_rescor(rescor=True)</code>","text":"<p>Control residual correlations in multivariate models.</p> <p>Wraps R <code>brms::set_rescor()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rescor</code> <code>bool</code> <p>Whether to model residual correlations.</p> <code>True</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::set_rescor : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, set_rescor\n\nf = bf(\"y1 ~ x\") + bf(\"y2 ~ z\") + set_rescor(True)\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def set_rescor(rescor: bool = True) -&gt; FormulaConstruct:\n    \"\"\"\n    Control residual correlations in multivariate models.\n\n    Wraps R ``brms::set_rescor()``.\n\n    Parameters\n    ----------\n    rescor : bool, default=True\n        Whether to model residual correlations.\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::set_rescor : [R documentation](https://paulbuerkner.com/brms/reference/set_rescor.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, set_rescor\n\n    f = bf(\"y1 ~ x\") + bf(\"y2 ~ z\") + set_rescor(True)\n    ```\n    \"\"\"\n    formula_args = {\n        \"rescor\": rescor,\n    }\n    return FormulaConstruct._formula_parse(FormulaPart(\"set_rescor\", [], formula_args))\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.set_mecor","title":"<code>set_mecor(mecor=True)</code>","text":"<p>Control correlations between latent <code>me()</code> terms.</p> <p>Wraps R <code>brms::set_mecor()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mecor</code> <code>bool</code> <p>Whether to model correlations between latent variables introduced by <code>me()</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::set_mecor : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, set_mecor\n\nf = bf(\"y ~ me(x, sdx)\") + set_mecor(True)\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def set_mecor(mecor: bool = True) -&gt; FormulaConstruct:\n    \"\"\"\n    Control correlations between latent ``me()`` terms.\n\n    Wraps R ``brms::set_mecor()``.\n\n    Parameters\n    ----------\n    mecor : bool, default=True\n        Whether to model correlations between latent variables introduced by ``me()``.\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::set_mecor : [R documentation](https://paulbuerkner.com/brms/reference/set_mecor.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, set_mecor\n\n    f = bf(\"y ~ me(x, sdx)\") + set_mecor(True)\n    ```\n    \"\"\"\n    formula_args = {\n        \"mecor\": mecor,\n    }\n    return FormulaConstruct._formula_parse(FormulaPart(\"set_mecor\", [], formula_args))\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.set_nl","title":"<code>set_nl(dpar=None, resp=None)</code>","text":"<p>Mark a model (or part of it) as non-linear.</p> <p>Wraps R <code>brms::set_nl()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dpar</code> <code>str or None</code> <p>Distributional parameter name (if only part of the model is non-linear).</p> <code>None</code> <code>resp</code> <code>str or None</code> <p>Response name for multivariate models.</p> <code>None</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::set_nl : R documentation</p> <p>Examples:</p> <pre><code>from brmspy.brms import bf, lf, set_nl\n\nf = bf(\"y ~ a * inv_logit(x * b)\") + lf(\"a + b ~ z\") + set_nl()\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def set_nl(\n    dpar: str | None = None,\n    resp: str | None = None,\n) -&gt; FormulaConstruct:\n    \"\"\"\n    Mark a model (or part of it) as non-linear.\n\n    Wraps R ``brms::set_nl()``.\n\n    Parameters\n    ----------\n    dpar : str or None, default=None\n        Distributional parameter name (if only part of the model is non-linear).\n    resp : str or None, default=None\n        Response name for multivariate models.\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::set_nl : [R documentation](https://paulbuerkner.com/brms/reference/set_nl.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy.brms import bf, lf, set_nl\n\n    f = bf(\"y ~ a * inv_logit(x * b)\") + lf(\"a + b ~ z\") + set_nl()\n    ```\n    \"\"\"\n    formula_args = {\n        \"dpar\": dpar,\n        \"resp\": resp,\n    }\n    return FormulaConstruct._formula_parse(FormulaPart(\"set_nl\", [], formula_args))\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.formula","title":"<code>formula(*formulas, **formula_args)</code>","text":"<p>Build a brms model formula.</p> <p>This is the primary entrypoint for specifying the mean model and can be combined with other formula parts (e.g. <code>lf</code>, <code>nlf</code>, <code>acformula</code>) using <code>+</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*formulas</code> <code>str</code> <p>One or more brms formula strings (e.g. <code>\"y ~ x + (1|group)\"</code>). Multiple formulas are commonly used for multivariate models.</p> <code>()</code> <code>**formula_args</code> <p>Keyword arguments forwarded to R <code>brms::brmsformula()</code> (for example <code>decomp=\"QR\"</code>, <code>center=True</code>, <code>sparse=True</code>, <code>nl=True</code>, <code>loop=True</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaConstruct</code> <p>A composable formula specification.</p> See Also <p>brms::brmsformula : R documentation</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>QR decomposition (often helps with collinearity):</p> <pre><code>from brmspy.brms import bf\n\nf = bf(\"reaction ~ days + (days|subject)\", decomp=\"QR\")\n</code></pre> <p>Multivariate formula + residual correlation:</p> <pre><code>from brmspy.brms import bf, set_rescor\n\nf = bf(\"mvbind(y1, y2) ~ x\") + set_rescor(True)\n</code></pre> Source code in <code>brmspy/_brms_functions/formula.py</code> <pre><code>def bf(*formulas: str, **formula_args) -&gt; FormulaConstruct:\n    \"\"\"\n    Build a brms model formula.\n\n    This is the primary entrypoint for specifying the mean model and can be\n    combined with other formula parts (e.g. `lf`, `nlf`, `acformula`) using ``+``.\n\n    Parameters\n    ----------\n    *formulas : str\n        One or more brms formula strings (e.g. ``\"y ~ x + (1|group)\"``). Multiple\n        formulas are commonly used for multivariate models.\n    **formula_args\n        Keyword arguments forwarded to R ``brms::brmsformula()`` (for example\n        ``decomp=\"QR\"``, ``center=True``, ``sparse=True``, ``nl=True``, ``loop=True``).\n\n    Returns\n    -------\n    FormulaConstruct\n        A composable formula specification.\n\n    See Also\n    --------\n    brms::brmsformula : [R documentation](https://paulbuerkner.com/brms/reference/brmsformula.html)\n\n    Examples\n    --------\n    Basic formula:\n\n    ```python\n    from brmspy.brms import bf\n\n    f = bf(\"y ~ x1 + x2 + (1|group)\")\n    ```\n\n    QR decomposition (often helps with collinearity):\n\n    ```python\n    from brmspy.brms import bf\n\n    f = bf(\"reaction ~ days + (days|subject)\", decomp=\"QR\")\n    ```\n\n    Multivariate formula + residual correlation:\n\n    ```python\n    from brmspy.brms import bf, set_rescor\n\n    f = bf(\"mvbind(y1, y2) ~ x\") + set_rescor(True)\n    ```\n    \"\"\"\n    part = FormulaPart(_fun=\"bf\", _args=list(formulas), _kwargs=formula_args)\n    return FormulaConstruct._formula_parse(part)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.posterior_epred","title":"<code>posterior_epred(model, newdata=None, **kwargs)</code>","text":"<pre><code>posterior_epred(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None) -&gt; IDResult[IDPosterior]\n</code></pre><pre><code>posterior_epred(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame) -&gt; IDResult[IDPredictions]\n</code></pre> <p>Compute expected posterior predictions (noise-free).</p> <p>Wrapper around R <code>brms::posterior_epred()</code>. This returns draws of the expected value (typically on the response scale), without observation noise.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data for predictions. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::posterior_epred()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorEpredResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::posterior_epred : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nep = brms.posterior_epred(fit)\n\nep.idata.posterior\n</code></pre> Source code in <code>brmspy/_brms_functions/prediction.py</code> <pre><code>def posterior_epred(\n    model: FitResult | ProxyListSexpVector,\n    newdata: pd.DataFrame | None = None,\n    **kwargs,\n) -&gt; IDResult:\n    \"\"\"\n    Compute expected posterior predictions (noise-free).\n\n    Wrapper around R ``brms::posterior_epred()``. This returns draws of the\n    expected value (typically on the response scale), without observation noise.\n\n    Parameters\n    ----------\n    model : FitResult\n        Fitted model.\n    newdata : pandas.DataFrame or None, default=None\n        New data for predictions. If ``None``, uses the training data.\n    **kwargs\n        Forwarded to ``brms::posterior_epred()``.\n\n    Returns\n    -------\n    PosteriorEpredResult\n        Result containing `idata` (ArviZ `InferenceData`) and an underlying R handle.\n\n    See Also\n    --------\n    brms::posterior_epred : [R documentation](https://paulbuerkner.com/brms/reference/posterior_epred.brmsfit.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    fit = brms.brm(\"y ~ x\", data=df, chains=4)\n    ep = brms.posterior_epred(fit)\n\n    ep.idata.posterior\n    ```\n    \"\"\"\n    model_r = py_to_r(model)\n    data_r = py_to_r(newdata)\n    kwargs = kwargs_r(kwargs)\n\n    resp_names = _brmsfit_get_response_names(model_r)\n    dims, coords = _brmsfit_get_dims_and_coords(\n        model_r, resp_names=resp_names, newdata=newdata\n    )\n\n    result, r = _brmsfit_get_predict_generic(\n        model_r,\n        newdata=data_r,\n        function=\"brms::posterior_epred\",\n        resp_names=resp_names,\n        **kwargs,\n    )\n\n    if newdata is None:\n        idata = az.from_dict(posterior=result, coords=coords, dims=dims)\n        idata = cast(IDPosterior, idata)\n    else:\n        idata = az.from_dict(predictions=result, coords=coords, dims=dims)\n        idata = cast(IDPredictions, idata)\n\n    _idata_add_resp_names_suffix(idata, \"_mean\", resp_names)\n\n    # Add constant data\n    constant_data_dict = _brmsfit_get_constant_data(\n        model_r, newdata=newdata, resp_names=resp_names\n    )\n    group_name = \"constant_data\" if newdata is None else \"predictions_constant_data\"\n    _arviz_add_constant_data(idata, constant_data_dict, group_name)\n\n    return IDResult(r=cast(ProxyListSexpVector, r), idata=idata)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.posterior_linpred","title":"<code>posterior_linpred(model, newdata=None, **kwargs)</code>","text":"<pre><code>posterior_linpred(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None, **kwargs) -&gt; IDResult[IDPosterior]\n</code></pre><pre><code>posterior_linpred(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame, **kwargs) -&gt; IDResult[IDPredictions]\n</code></pre> <p>Draw from the linear predictor.</p> <p>Wrapper around R <code>brms::posterior_linpred()</code>. This typically returns draws on the link scale (before applying the inverse link), unless you pass <code>transform=True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data for predictions. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::posterior_linpred()</code> (commonly <code>transform</code> or <code>ndraws</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorLinpredResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::posterior_linpred : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nlp = brms.posterior_linpred(fit, transform=False)\n\nlp.idata.predictions\n</code></pre> Source code in <code>brmspy/_brms_functions/prediction.py</code> <pre><code>def posterior_linpred(\n    model: FitResult | ProxyListSexpVector,\n    newdata: pd.DataFrame | None = None,\n    **kwargs,\n) -&gt; IDResult:\n    \"\"\"\n    Draw from the linear predictor.\n\n    Wrapper around R ``brms::posterior_linpred()``. This typically returns draws\n    on the link scale (before applying the inverse link), unless you pass\n    ``transform=True``.\n\n    Parameters\n    ----------\n    model : FitResult\n        Fitted model.\n    newdata : pandas.DataFrame or None, default=None\n        New data for predictions. If ``None``, uses the training data.\n    **kwargs\n        Forwarded to ``brms::posterior_linpred()`` (commonly ``transform`` or ``ndraws``).\n\n    Returns\n    -------\n    PosteriorLinpredResult\n        Result containing `idata` (ArviZ `InferenceData`) and an underlying R handle.\n\n    See Also\n    --------\n    brms::posterior_linpred : [R documentation](https://paulbuerkner.com/brms/reference/posterior_linpred.brmsfit.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    fit = brms.brm(\"y ~ x\", data=df, chains=4)\n    lp = brms.posterior_linpred(fit, transform=False)\n\n    lp.idata.predictions\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    model_r = py_to_r(model)\n    data_r = py_to_r(newdata)\n    kwargs = kwargs_r(kwargs)\n\n    resp_names = _brmsfit_get_response_names(model_r)\n    dims, coords = _brmsfit_get_dims_and_coords(\n        model_r, resp_names=resp_names, newdata=newdata\n    )\n\n    result, r = _brmsfit_get_predict_generic(\n        model_r,\n        newdata=data_r,\n        function=\"brms::posterior_linpred\",\n        resp_names=resp_names,\n        **kwargs,\n    )\n\n    if newdata is None:\n        idata = az.from_dict(\n            posterior=result,\n            dims=dims,\n            coords=coords,\n        )\n        idata = cast(IDPosterior, idata)\n    else:\n        idata = az.from_dict(\n            predictions=result,\n            dims=dims,\n            coords=coords,\n        )\n        idata = cast(IDPredictions, idata)\n\n    _idata_add_resp_names_suffix(idata, \"_linpred\", resp_names)\n\n    # Add constant data\n    constant_data_dict = _brmsfit_get_constant_data(\n        model_r, newdata=newdata, resp_names=resp_names\n    )\n    group_name = \"constant_data\" if newdata is None else \"predictions_constant_data\"\n    _arviz_add_constant_data(idata, constant_data_dict, group_name)\n\n    return IDResult(r=cast(ProxyListSexpVector, r), idata=idata)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.posterior_predict","title":"<code>posterior_predict(model, newdata=None, **kwargs)</code>","text":"<pre><code>posterior_predict(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None, **kwargs) -&gt; IDResult[IDPosteriorPredictive]\n</code></pre><pre><code>posterior_predict(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame, **kwargs) -&gt; IDResult[IDPredictions]\n</code></pre> <p>Draw from the posterior predictive distribution (includes observation noise).</p> <p>Wrapper around R <code>brms::posterior_predict()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data for predictions. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::posterior_predict()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorPredictResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::posterior_predict : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\npp = brms.posterior_predict(fit)\n\npp.idata.posterior_predictive\n</code></pre> Source code in <code>brmspy/_brms_functions/prediction.py</code> <pre><code>def posterior_predict(\n    model: FitResult | ProxyListSexpVector,\n    newdata: pd.DataFrame | None = None,\n    **kwargs,\n) -&gt; IDResult:\n    \"\"\"\n    Draw from the posterior predictive distribution (includes observation noise).\n\n    Wrapper around R ``brms::posterior_predict()``.\n\n    Parameters\n    ----------\n    model : FitResult\n        Fitted model.\n    newdata : pandas.DataFrame or None, default=None\n        New data for predictions. If ``None``, uses the training data.\n    **kwargs\n        Forwarded to ``brms::posterior_predict()``.\n\n    Returns\n    -------\n    PosteriorPredictResult\n        Result containing `idata` (ArviZ `InferenceData`) and an underlying R handle.\n\n    See Also\n    --------\n    brms::posterior_predict : [R documentation](https://paulbuerkner.com/brms/reference/posterior_predict.brmsfit.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    fit = brms.brm(\"y ~ x\", data=df, chains=4)\n    pp = brms.posterior_predict(fit)\n\n    pp.idata.posterior_predictive\n    ```\n    \"\"\"\n    model_r = py_to_r(model)\n    data_r = py_to_r(newdata)\n    kwargs = kwargs_r(kwargs)\n\n    resp_names = _brmsfit_get_response_names(model_r)\n    dims, coords = _brmsfit_get_dims_and_coords(\n        model_r, resp_names=resp_names, newdata=newdata\n    )\n\n    result, r = _brmsfit_get_predict_generic(\n        model_r,\n        newdata=data_r,\n        function=\"brms::posterior_predict\",\n        resp_names=resp_names,\n        **kwargs,\n    )\n\n    if newdata is None:\n        idata = az.from_dict(\n            posterior_predictive=result,\n            dims=dims,\n            coords=coords,\n        )\n        idata = cast(IDPosteriorPredictive, idata)\n    else:\n        idata = az.from_dict(\n            predictions=result,\n            dims=dims,\n            coords=coords,\n        )\n        idata = cast(IDPredictions, idata)\n\n    # Add constant data\n    constant_data_dict = _brmsfit_get_constant_data(\n        model_r, newdata=newdata, resp_names=resp_names\n    )\n    group_name = \"constant_data\" if newdata is None else \"predictions_constant_data\"\n    _arviz_add_constant_data(idata, constant_data_dict, group_name)\n\n    return IDResult(r=cast(ProxyListSexpVector, r), idata=idata)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.log_lik","title":"<code>log_lik(model, newdata=None, **kwargs)</code>","text":"<pre><code>log_lik(model: FitResult | ProxyListSexpVector, newdata: Literal[None] = None, **kwargs) -&gt; IDResult[IDLogLikelihoodInsample]\n</code></pre><pre><code>log_lik(model: FitResult | ProxyListSexpVector, newdata: pd.DataFrame, **kwargs) -&gt; IDResult[IDLogLikelihoodOutsample]\n</code></pre> <p>Compute pointwise log-likelihood draws.</p> <p>Wrapper around R <code>brms::log_lik()</code>. The result is useful for LOO/WAIC via ArviZ.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>newdata</code> <code>DataFrame or None</code> <p>New data. If <code>None</code>, uses the training data.</p> <code>None</code> <code>**kwargs</code> <p>Forwarded to <code>brms::log_lik()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>LogLikResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> See Also <p>brms::log_lik : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nll = brms.log_lik(fit)\n\naz.loo(ll.idata)\n</code></pre> Source code in <code>brmspy/_brms_functions/prediction.py</code> <pre><code>def log_lik(\n    model: FitResult | ProxyListSexpVector,\n    newdata: pd.DataFrame | None = None,\n    **kwargs,\n) -&gt; IDResult:\n    \"\"\"\n    Compute pointwise log-likelihood draws.\n\n    Wrapper around R ``brms::log_lik()``. The result is useful for LOO/WAIC via ArviZ.\n\n    Parameters\n    ----------\n    model : FitResult\n        Fitted model.\n    newdata : pandas.DataFrame or None, default=None\n        New data. If ``None``, uses the training data.\n    **kwargs\n        Forwarded to ``brms::log_lik()``.\n\n    Returns\n    -------\n    LogLikResult\n        Result containing `idata` (ArviZ `InferenceData`) and an underlying R handle.\n\n    See Also\n    --------\n    brms::log_lik : [R documentation](https://paulbuerkner.com/brms/reference/log_lik.brmsfit.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n    import arviz as az\n\n    fit = brms.brm(\"y ~ x\", data=df, chains=4)\n    ll = brms.log_lik(fit)\n\n    az.loo(ll.idata)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    model_r = py_to_r(model)\n    data_r = py_to_r(newdata)\n    kwargs = kwargs_r(kwargs)\n\n    resp_names = _brmsfit_get_response_names(model_r)\n    dims, coords = _brmsfit_get_dims_and_coords(\n        model_r, resp_names=resp_names, newdata=newdata\n    )\n\n    result, r = _brmsfit_get_predict_generic(\n        model_r,\n        newdata=data_r,\n        function=\"brms::log_lik\",\n        resp_names=resp_names,\n        **kwargs,\n    )\n    if newdata is None:\n        idata = az.from_dict(log_likelihood=result, dims=dims, coords=coords)\n        idata = cast(IDLogLikelihoodInsample, idata)\n    else:\n        idata = az.from_dict(log_likelihood=result, dims=dims, coords=coords)\n        idata = cast(IDLogLikelihoodOutsample, idata)\n\n    # Add constant data\n    constant_data_dict = _brmsfit_get_constant_data(\n        model_r, newdata=newdata, resp_names=resp_names\n    )\n    group_name = \"constant_data\" if newdata is None else \"predictions_constant_data\"\n    _arviz_add_constant_data(idata, constant_data_dict, group_name)\n\n    return IDResult(r=cast(ProxyListSexpVector, r), idata=idata)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.posterior","title":"<code>posterior(model, **kwargs)</code>","text":"<p>Return posterior draws as idata.</p> <p>Wrapper around R <code>posterior::as_draws_df()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model.</p> required <code>**kwargs</code> <p>Forwarded to <code>posterior::as_draws_df()</code>. e.g inc_warmup, regex, variable</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorEpredResult</code> <p>Result containing <code>idata</code> (ArviZ <code>InferenceData</code>) and an underlying R handle.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nfit = brms.brm(\"y ~ x\", data=df, chains=4)\nep = brms.posterior(fit)\n\nep.idata.posterior\n</code></pre> Source code in <code>brmspy/_brms_functions/prediction.py</code> <pre><code>def posterior(\n    model: FitResult | ProxyListSexpVector, **kwargs\n) -&gt; IDResult[IDPosterior]:\n    \"\"\"\n    Return posterior draws as idata.\n\n    Wrapper around R ``posterior::as_draws_df()``.\n\n    Parameters\n    ----------\n    model : FitResult\n        Fitted model.\n    **kwargs\n        Forwarded to ``posterior::as_draws_df()``. e.g inc_warmup, regex, variable\n\n    Returns\n    -------\n    PosteriorEpredResult\n        Result containing `idata` (ArviZ `InferenceData`) and an underlying R handle.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    fit = brms.brm(\"y ~ x\", data=df, chains=4)\n    ep = brms.posterior(fit)\n\n    ep.idata.posterior\n    ```\n    \"\"\"\n    model_r = py_to_r(model)\n    kwargs = kwargs_r(kwargs)\n\n    resp_names = _brmsfit_get_response_names(model_r)\n    dims, coords = _brmsfit_get_dims_and_coords(model_r, resp_names=resp_names)\n\n    result, r = _brmsfit_get_posterior(model_r, **kwargs)\n    idata = az.from_dict(posterior=result, dims=dims, coords=coords)\n\n    # Add constant data\n    constant_data_dict = _brmsfit_get_constant_data(\n        model_r, newdata=None, resp_names=resp_names\n    )\n    _arviz_add_constant_data(\n        idata, constant_data_dict, \"constant_data\", obs_id=coords[\"obs_id\"]\n    )\n\n    return IDResult(r=cast(ProxyListSexpVector, r), idata=cast(IDPosterior, idata))\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.observed_data","title":"<code>observed_data(model)</code>","text":"Source code in <code>brmspy/_brms_functions/prediction.py</code> <pre><code>def observed_data(model: FitResult | ProxyListSexpVector) -&gt; IDResult[IDObservedData]:\n    import rpy2.robjects as ro\n\n    model_r = py_to_r(model)\n\n    resp_names = _brmsfit_get_response_names(model_r)\n    dims, coords = _brmsfit_get_dims_and_coords(model_r, resp_names=resp_names)\n\n    result = _brmsfit_get_observed_data(model_r, resp_names=resp_names)\n    r = cast(Any, ro.NULL)\n\n    idata = az.from_dict(observed_data=result, coords=coords, dims=dims)\n    idata = cast(IDObservedData, idata)\n\n    # Add constant data\n    constant_data_dict = _brmsfit_get_constant_data(\n        model_r, newdata=None, resp_names=resp_names\n    )\n    _arviz_add_constant_data(idata, constant_data_dict, \"constant_data\")\n\n    return IDResult(r=r, idata=idata)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.make_stancode","title":"<code>make_stancode(formula, data, priors=None, family='poisson', sample_prior='no', formula_args=None)</code>","text":"<p>Generate Stan code using R <code>brms::make_stancode()</code>.</p> <p>Useful for inspecting the generated Stan model before fitting.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaConstruct</code> <p>Model formula.</p> required <code>data</code> <code>DataFrame</code> <p>Model data.</p> required <code>priors</code> <code>Sequence[PriorSpec] or None</code> <p>Optional prior specifications created via <code>brmspy.brms.prior()</code>.</p> <code>None</code> <code>family</code> <code>str</code> <p>Distribution family (e.g. <code>\"gaussian\"</code>, <code>\"poisson\"</code>).</p> <code>\"poisson\"</code> <code>sample_prior</code> <code>str</code> <p>Prior sampling mode passed to brms (<code>\"no\"</code>, <code>\"yes\"</code>, <code>\"only\"</code>).</p> <code>\"no\"</code> <code>formula_args</code> <code>dict or None</code> <p>Reserved for future use. Currently ignored.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Complete Stan program as a string.</p> See Also <p>brms::make_stancode : R documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\ncode = brms.make_stancode(\n    \"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n)\n\nassert isinstance(code, str)\n</code></pre> Source code in <code>brmspy/_brms_functions/stan.py</code> <pre><code>def make_stancode(\n    formula: FormulaConstruct | str,\n    data: pd.DataFrame,\n    priors: typing.Sequence[PriorSpec] | None = None,\n    family: str = \"poisson\",\n    sample_prior: str = \"no\",\n    formula_args: dict | None = None,\n) -&gt; str:\n    \"\"\"\n    Generate Stan code using R ``brms::make_stancode()``.\n\n    Useful for inspecting the generated Stan model before fitting.\n\n    Parameters\n    ----------\n    formula : str or FormulaConstruct\n        Model formula.\n    data : pandas.DataFrame\n        Model data.\n    priors : Sequence[PriorSpec] or None, default=None\n        Optional prior specifications created via `brmspy.brms.prior()`.\n    family : str, default=\"poisson\"\n        Distribution family (e.g. ``\"gaussian\"``, ``\"poisson\"``).\n    sample_prior : str, default=\"no\"\n        Prior sampling mode passed to brms (``\"no\"``, ``\"yes\"``, ``\"only\"``).\n    formula_args : dict or None, default=None\n        Reserved for future use. Currently ignored.\n\n    Returns\n    -------\n    str\n        Complete Stan program as a string.\n\n    See Also\n    --------\n    brms::make_stancode : [R documentation](https://paulbuerkner.com/brms/reference/make_stancode.html)\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    epilepsy = brms.get_brms_data(\"epilepsy\")\n    code = brms.make_stancode(\n        \"count ~ zAge + zBase * Trt + (1|patient)\",\n        data=epilepsy,\n        family=\"poisson\",\n    )\n\n    assert isinstance(code, str)\n    ```\n    \"\"\"\n    import rpy2.robjects as ro\n\n    fun_make_stancode = typing.cast(typing.Callable, ro.r(\"brms::make_stancode\"))\n\n    data_r = py_to_r(data)\n    priors_r = _build_priors(priors)\n    if isinstance(formula, FormulaConstruct):\n        formula_obj = _execute_formula(formula)\n    else:\n        if formula_args is None:\n            formula_args = {}\n        formula = FormulaConstruct._formula_parse(formula)\n        formula_obj = _execute_formula(formula)\n\n    if len(priors_r) &gt; 0:\n        return fun_make_stancode(\n            formula=formula_obj,\n            data=data_r,\n            prior=priors_r,\n            family=family,\n            sample_prior=sample_prior,\n        )[0]\n    else:\n        return fun_make_stancode(\n            formula=formula_obj, data=data_r, family=family, sample_prior=sample_prior\n        )[0]\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.brmsfamily","title":"<code>brmsfamily(family, link=None, link_sigma='log', link_shape='log', link_nu='logm1', link_phi='log', link_kappa='log', link_beta='log', link_zi='logit', link_hu='logit', link_zoi='logit', link_coi='logit', link_disc='log', link_bs='log', link_ndt='log', link_bias='logit', link_xi='log1p', link_alpha='identity', link_quantile='logit', threshold='flexible', refcat=None, **kwargs)</code>","text":"<p>Family objects provide a convenient way to specify the details of the models used by many model fitting functions. The family functions presented here are for use with brms only and will not work with other model fitting functions such as glm or glmer. However, the standard family functions as described in family will work with brms.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <p>A character string naming the distribution family of the response variable to be used in the model. Currently, the following families are supported: gaussian, student, binomial, bernoulli, beta-binomial, poisson, negbinomial, geometric, Gamma, skew_normal, lognormal, shifted_lognormal, exgaussian, wiener, inverse.gaussian, exponential, weibull, frechet, Beta, dirichlet, von_mises, asym_laplace, gen_extreme_value, categorical, multinomial, cumulative, cratio, sratio, acat, hurdle_poisson, hurdle_negbinomial, hurdle_gamma, hurdle_lognormal, hurdle_cumulative, zero_inflated_binomial, zero_inflated_beta_binomial, zero_inflated_beta, zero_inflated_negbinomial, zero_inflated_poisson, and zero_one_inflated_beta.</p> required <code>link</code> <code>str | None</code> <p>A specification for the model link function. This can be a name/expression or character string. See the 'Details' section for more information on link functions supported by each family.</p> <code>None</code> <code>link_sigma</code> <code>str</code> <p>Link of auxiliary parameter sigma if being predicted.</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link of auxiliary parameter shape if being predicted.</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link of auxiliary parameter nu if being predicted.</p> <code>'logm1'</code> <code>link_phi</code> <code>str</code> <p>Link of auxiliary parameter phi if being predicted.</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link of auxiliary parameter kappa if being predicted.</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link of auxiliary parameter beta if being predicted.</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link of auxiliary parameter zi if being predicted.</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link of auxiliary parameter hu if being predicted.</p> <code>'logit'</code> <code>link_zoi</code> <code>str</code> <p>Link of auxiliary parameter zoi if being predicted.</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link of auxiliary parameter coi if being predicted.</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link of auxiliary parameter disc if being predicted.</p> <code>'log'</code> <code>link_bs</code> <code>str</code> <p>Link of auxiliary parameter bs if being predicted.</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link of auxiliary parameter ndt if being predicted.</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link of auxiliary parameter bias if being predicted.</p> <code>'logit'</code> <code>link_xi</code> <code>str</code> <p>Link of auxiliary parameter xi if being predicted.</p> <code>'log1p'</code> <code>link_alpha</code> <code>str</code> <p>Link of auxiliary parameter alpha if being predicted.</p> <code>'identity'</code> <code>link_quantile</code> <code>str</code> <p>Link of auxiliary parameter quantile if being predicted.</p> <code>'logit'</code> <code>threshold</code> <code>str</code> <p>A character string indicating the type of thresholds (i.e. intercepts) used in an ordinal model. \"flexible\" provides the standard unstructured thresholds, \"equidistant\" restricts the distance between consecutive thresholds to the same value, and \"sum_to_zero\" ensures the thresholds sum to zero.</p> <code>'flexible'</code> <code>refcat</code> <code>str | None</code> <p>Optional name of the reference response category used in categorical, multinomial, dirichlet and logistic_normal models. If NULL (the default), the first category is used as the reference. If NA, all categories will be predicted, which requires strong priors or carefully specified predictor terms in order to lead to an identified model.</p> <code>None</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def brmsfamily(\n    family,\n    link: str | None = None,\n    link_sigma: str = \"log\",\n    link_shape: str = \"log\",\n    link_nu: str = \"logm1\",\n    link_phi: str = \"log\",\n    link_kappa: str = \"log\",\n    link_beta: str = \"log\",\n    link_zi: str = \"logit\",\n    link_hu: str = \"logit\",\n    link_zoi: str = \"logit\",\n    link_coi: str = \"logit\",\n    link_disc: str = \"log\",\n    link_bs: str = \"log\",\n    link_ndt: str = \"log\",\n    link_bias: str = \"logit\",\n    link_xi: str = \"log1p\",\n    link_alpha: str = \"identity\",\n    link_quantile: str = \"logit\",\n    threshold: str = \"flexible\",\n    refcat: str | None = None,\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"\n    Family objects provide a convenient way to specify the details of the models used by many model fitting functions. The family functions presented here are for use with brms only and will **not** work with other model fitting functions such as glm or glmer. However, the standard family functions as described in family will work with brms.\n\n    Parameters\n    ----------\n    family\n        A character string naming the distribution family of the response variable to be used in the model. Currently, the following families are supported: gaussian, student, binomial, bernoulli, beta-binomial, poisson, negbinomial, geometric, Gamma, skew_normal, lognormal, shifted_lognormal, exgaussian, wiener, inverse.gaussian, exponential, weibull, frechet, Beta, dirichlet, von_mises, asym_laplace, gen_extreme_value, categorical, multinomial, cumulative, cratio, sratio, acat, hurdle_poisson, hurdle_negbinomial, hurdle_gamma, hurdle_lognormal, hurdle_cumulative, zero_inflated_binomial, zero_inflated_beta_binomial, zero_inflated_beta, zero_inflated_negbinomial, zero_inflated_poisson, and zero_one_inflated_beta.\n    link\n        A specification for the model link function. This can be a name/expression or character string. See the 'Details' section for more information on link functions supported by each family.\n    link_sigma\n        Link of auxiliary parameter sigma if being predicted.\n    link_shape\n        Link of auxiliary parameter shape if being predicted.\n    link_nu\n        Link of auxiliary parameter nu if being predicted.\n    link_phi\n        Link of auxiliary parameter phi if being predicted.\n    link_kappa\n        Link of auxiliary parameter kappa if being predicted.\n    link_beta\n        Link of auxiliary parameter beta if being predicted.\n    link_zi\n        Link of auxiliary parameter zi if being predicted.\n    link_hu\n        Link of auxiliary parameter hu if being predicted.\n    link_zoi\n        Link of auxiliary parameter zoi if being predicted.\n    link_coi\n        Link of auxiliary parameter coi if being predicted.\n    link_disc\n        Link of auxiliary parameter disc if being predicted.\n    link_bs\n        Link of auxiliary parameter bs if being predicted.\n    link_ndt\n        Link of auxiliary parameter ndt if being predicted.\n    link_bias\n        Link of auxiliary parameter bias if being predicted.\n    link_xi\n        Link of auxiliary parameter xi if being predicted.\n    link_alpha\n        Link of auxiliary parameter alpha if being predicted.\n    link_quantile\n        Link of auxiliary parameter quantile if being predicted.\n    threshold\n        A character string indicating the type of thresholds (i.e. intercepts) used in an ordinal model. \"flexible\" provides the standard unstructured thresholds, \"equidistant\" restricts the distance between consecutive thresholds to the same value, and \"sum_to_zero\" ensures the thresholds sum to zero.\n    refcat\n        Optional name of the reference response category used in categorical, multinomial, dirichlet and logistic_normal models. If NULL (the default), the first category is used as the reference. If NA, all categories will be predicted, which requires strong priors or carefully specified predictor terms in order to lead to an identified model.\n\n    \"\"\"\n    import rpy2.robjects as ro\n\n    r_brmsfamily = cast(Callable, ro.r(\"brms::brmsfamily\"))\n\n    collected_args = {\n        \"family\": family,\n        \"link\": link,\n        \"link_sigma\": link_sigma,\n        \"link_shape\": link_shape,\n        \"link_nu\": link_nu,\n        \"link_phi\": link_phi,\n        \"link_kappa\": link_kappa,\n        \"link_beta\": link_beta,\n        \"link_zi\": link_zi,\n        \"link_hu\": link_hu,\n        \"link_zoi\": link_zoi,\n        \"link_coi\": link_coi,\n        \"link_disc\": link_disc,\n        \"link_bs\": link_bs,\n        \"link_ndt\": link_ndt,\n        \"link_bias\": link_bias,\n        \"link_xi\": link_xi,\n        \"link_alpha\": link_alpha,\n        \"link_quantile\": link_quantile,\n        \"threshold\": threshold,\n        \"refcat\": refcat,\n        **kwargs,\n    }\n    collected_args = kwargs_r(collected_args)\n\n    return r_brmsfamily(**collected_args)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.family","title":"<code>family(fit, **kwargs)</code>","text":"<p>Extract family object from a fitted model.</p> <p>Parameters:</p> Name Type Description Default <code>fit</code> <code>FitResult or ListSexpVector</code> <p>Fitted brms model</p> required Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def family(fit: FitResult | ListSexpVector, **kwargs) -&gt; ListSexpVector:\n    \"\"\"Extract family object from a fitted model.\n\n    Parameters\n    ----------\n    fit : FitResult or ListSexpVector\n        Fitted brms model\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if isinstance(fit, IDResult):\n        r_fit = fit.r\n    else:\n        r_fit = fit\n\n    r_family = cast(Callable, ro.r(\"family\"))\n    kwargs = kwargs_r(kwargs)\n\n    return r_family(r_fit, **kwargs)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.student","title":"<code>student(link='identity', link_sigma='log', link_nu='logm1', **kwargs)</code>","text":"<p>Student's t distribution for robust regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for degrees of freedom parameter</p> <code>'logm1'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def student(\n    link: str = \"identity\", link_sigma: str = \"log\", link_nu: str = \"logm1\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Student's t distribution for robust regression.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for sigma parameter\n    link_nu : str\n        Link function for degrees of freedom parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"student\",\n        link=link,\n        link_sigma=link_sigma,\n        link_nu=link_nu,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.bernoulli","title":"<code>bernoulli(link='logit', **kwargs)</code>","text":"<p>Bernoulli distribution for binary 0/1 outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def bernoulli(link: str = \"logit\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Bernoulli distribution for binary 0/1 outcomes.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the probability parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"bernoulli\",\n        link=link,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.beta_binomial","title":"<code>beta_binomial(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta-binomial distribution for overdispersed binomial data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def beta_binomial(\n    link: str = \"logit\", link_phi: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Beta-binomial distribution for overdispersed binomial data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the probability parameter\n    link_phi : str\n        Link function for the precision parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"beta_binomial\",\n        link=link,\n        link_phi=link_phi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.negbinomial","title":"<code>negbinomial(link='log', link_shape='log', **kwargs)</code>","text":"<p>Negative binomial distribution for overdispersed count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def negbinomial(link: str = \"log\", link_shape: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Negative binomial distribution for overdispersed count data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_shape : str\n        Link function for the shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"negbinomial\",\n        link=link,\n        link_shape=link_shape,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.negbinomial2","title":"<code>negbinomial2(link='log', link_sigma='log', **kwargs)</code>","text":"Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def negbinomial2(\n    link: str = \"log\", link_sigma: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    return brmsfamily(\n        family=\"negbinomial2\",\n        link=link,\n        link_sigma=link_sigma,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.geometric","title":"<code>geometric(link='log', **kwargs)</code>","text":"<p>Geometric distribution for count data (negative binomial with shape=1).</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def geometric(link: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Geometric distribution for count data (negative binomial with shape=1).\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    \"\"\"\n    return brmsfamily(\n        family=\"geometric\",\n        link=link,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.discrete_weibull","title":"<code>discrete_weibull(link='logit', link_shape='log', **kwargs)</code>","text":"Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def discrete_weibull(\n    link: str = \"logit\", link_shape: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    return brmsfamily(\n        family=\"discrete_weibull\",\n        link=link,\n        link_shape=link_shape,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.com_poisson","title":"<code>com_poisson(link='log', link_shape='log', **kwargs)</code>","text":"Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def com_poisson(link: str = \"log\", link_shape: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    return brmsfamily(\n        family=\"com_poisson\",\n        link=link,\n        link_shape=link_shape,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.lognormal","title":"<code>lognormal(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Lognormal distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean on log scale</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def lognormal(\n    link: str = \"identity\", link_sigma: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Lognormal distribution for positive continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean on log scale\n    link_sigma : str\n        Link function for sigma parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"lognormal\",\n        link=link,\n        link_sigma=link_sigma,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.shifted_lognormal","title":"<code>shifted_lognormal(link='identity', link_sigma='log', link_ndt='log', **kwargs)</code>","text":"<p>Shifted lognormal distribution with non-decision time parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def shifted_lognormal(\n    link: str = \"identity\", link_sigma: str = \"log\", link_ndt: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Shifted lognormal distribution with non-decision time parameter.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for sigma parameter\n    link_ndt : str\n        Link function for non-decision time parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"shifted_lognormal\",\n        link=link,\n        link_sigma=link_sigma,\n        link_ndt=link_ndt,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.skew_normal","title":"<code>skew_normal(link='identity', link_sigma='log', link_alpha='identity', **kwargs)</code>","text":"<p>Skew normal distribution for asymmetric continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_alpha</code> <code>str</code> <p>Link function for skewness parameter</p> <code>'identity'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def skew_normal(\n    link: str = \"identity\",\n    link_sigma: str = \"log\",\n    link_alpha: str = \"identity\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Skew normal distribution for asymmetric continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for sigma parameter\n    link_alpha : str\n        Link function for skewness parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"skew_normal\",\n        link=link,\n        link_sigma=link_sigma,\n        link_alpha=link_alpha,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.exponential","title":"<code>exponential(link='log', **kwargs)</code>","text":"<p>Exponential distribution for time-to-event data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def exponential(link: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Exponential distribution for time-to-event data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the rate parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"exponential\",\n        link=link,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.weibull","title":"<code>weibull(link='log', link_shape='log', **kwargs)</code>","text":"<p>Weibull distribution for survival and reliability analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def weibull(link: str = \"log\", link_shape: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Weibull distribution for survival and reliability analysis.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the scale parameter\n    link_shape : str\n        Link function for the shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"weibull\",\n        link=link,\n        link_shape=link_shape,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.frechet","title":"<code>frechet(link='log', link_nu='logm1', **kwargs)</code>","text":"<p>Frechet distribution for extreme value analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'logm1'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def frechet(link: str = \"log\", link_nu: str = \"logm1\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Frechet distribution for extreme value analysis.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the scale parameter\n    link_nu : str\n        Link function for the shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"frechet\",\n        link=link,\n        link_nu=link_nu,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.gen_extreme_value","title":"<code>gen_extreme_value(link='identity', link_sigma='log', link_xi='log1p', **kwargs)</code>","text":"<p>Generalized extreme value distribution for extreme events.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location parameter</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_xi</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log1p'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def gen_extreme_value(\n    link: str = \"identity\", link_sigma: str = \"log\", link_xi: str = \"log1p\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Generalized extreme value distribution for extreme events.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the location parameter\n    link_sigma : str\n        Link function for the scale parameter\n    link_xi : str\n        Link function for the shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"gen_extreme_value\",\n        link=link,\n        link_sigma=link_sigma,\n        link_xi=link_xi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.exgaussian","title":"<code>exgaussian(link='identity', link_sigma='log', link_beta='log', **kwargs)</code>","text":"<p>Ex-Gaussian distribution for reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for Gaussian SD parameter</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link function for exponential rate parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def exgaussian(\n    link: str = \"identity\", link_sigma: str = \"log\", link_beta: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Ex-Gaussian distribution for reaction time data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for Gaussian SD parameter\n    link_beta : str\n        Link function for exponential rate parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"exgaussian\",\n        link=link,\n        link_sigma=link_sigma,\n        link_beta=link_beta,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.wiener","title":"<code>wiener(link='identity', link_bs='log', link_ndt='log', link_bias='logit', **kwargs)</code>","text":"<p>Wiener diffusion model for two-choice reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for drift rate</p> <code>'identity'</code> <code>link_bs</code> <code>str</code> <p>Link function for boundary separation</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link function for initial bias</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def wiener(\n    link: str = \"identity\",\n    link_bs: str = \"log\",\n    link_ndt: str = \"log\",\n    link_bias: str = \"logit\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Wiener diffusion model for two-choice reaction time data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for drift rate\n    link_bs : str\n        Link function for boundary separation\n    link_ndt : str\n        Link function for non-decision time\n    link_bias : str\n        Link function for initial bias\n    \"\"\"\n    return brmsfamily(\n        family=\"wiener\",\n        link=link,\n        link_bs=link_bs,\n        link_ndt=link_ndt,\n        link_bias=link_bias,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.Beta","title":"<code>Beta(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta distribution for data between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def Beta(link: str = \"logit\", link_phi: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Beta distribution for data between 0 and 1.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_phi : str\n        Link function for the precision parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"beta\",\n        link=link,\n        link_phi=link_phi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.xbeta","title":"<code>xbeta(link='logit', link_phi='log', link_kappa='log', **kwargs)</code>","text":"<p>Extended beta distribution with additional shape parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link function for kappa shape parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def xbeta(\n    link: str = \"logit\", link_phi: str = \"log\", link_kappa: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Extended beta distribution with additional shape parameter.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_phi : str\n        Link function for precision parameter\n    link_kappa : str\n        Link function for kappa shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"xbeta\",\n        link=link,\n        link_phi=link_phi,\n        link_kappa=link_kappa,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.dirichlet","title":"<code>dirichlet(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def dirichlet(\n    link: str = \"logit\", link_phi: str = \"log\", refcat: str | None = None, **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Dirichlet distribution for compositional data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_phi : str\n        Link function for the precision parameter\n    refcat : str, optional\n        Reference category\n    \"\"\"\n    return brmsfamily(\n        family=\"dirichlet\",\n        link=link,\n        link_phi=link_phi,\n        refcat=refcat,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.dirichlet2","title":"<code>dirichlet2(link='log', refcat=None, **kwargs)</code>","text":"Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def dirichlet2(\n    link: str = \"log\",\n    # NOTE: R version uses refcat = NA; here default None\n    refcat: str | None = None,\n    **kwargs,\n) -&gt; ListSexpVector:\n    return brmsfamily(\n        family=\"dirichlet2\",\n        link=link,\n        refcat=refcat,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.logistic_normal","title":"<code>logistic_normal(link='identity', link_sigma='log', refcat=None, **kwargs)</code>","text":"<p>Logistic-normal distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def logistic_normal(\n    link: str = \"identity\",\n    link_sigma: str = \"log\",\n    refcat: str | None = None,\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Logistic-normal distribution for compositional data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for sigma parameter\n    refcat : str, optional\n        Reference category\n    \"\"\"\n    return brmsfamily(\n        family=\"logistic_normal\",\n        link=link,\n        link_sigma=link_sigma,\n        refcat=refcat,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.von_mises","title":"<code>von_mises(link='tan_half', link_kappa='log', **kwargs)</code>","text":"<p>Von Mises distribution for circular/directional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean direction</p> <code>'tan_half'</code> <code>link_kappa</code> <code>str</code> <p>Link function for concentration parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def von_mises(\n    link: str = \"tan_half\", link_kappa: str = \"log\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Von Mises distribution for circular/directional data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean direction\n    link_kappa : str\n        Link function for concentration parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"von_mises\",\n        link=link,\n        link_kappa=link_kappa,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.asym_laplace","title":"<code>asym_laplace(link='identity', link_sigma='log', link_quantile='logit', **kwargs)</code>","text":"<p>Asymmetric Laplace distribution for quantile regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_quantile</code> <code>str</code> <p>Link function for the quantile parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def asym_laplace(\n    link: str = \"identity\",\n    link_sigma: str = \"log\",\n    link_quantile: str = \"logit\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Asymmetric Laplace distribution for quantile regression.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the location\n    link_sigma : str\n        Link function for sigma parameter\n    link_quantile : str\n        Link function for the quantile parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"asym_laplace\",\n        link=link,\n        link_sigma=link_sigma,\n        link_quantile=link_quantile,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.zero_inflated_asym_laplace","title":"<code>zero_inflated_asym_laplace(link='identity', link_sigma='log', link_quantile='logit', link_zi='logit', **kwargs)</code>","text":"Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_inflated_asym_laplace(\n    link: str = \"identity\",\n    link_sigma: str = \"log\",\n    link_quantile: str = \"logit\",\n    link_zi: str = \"logit\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    return brmsfamily(\n        family=\"zero_inflated_asym_laplace\",\n        link=link,\n        link_sigma=link_sigma,\n        link_quantile=link_quantile,\n        link_zi=link_zi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.cox","title":"<code>cox(link='log', **kwargs)</code>","text":"<p>Cox proportional hazards model for survival data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the hazard rate</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def cox(link: str = \"log\", **kwargs) -&gt; ListSexpVector:\n    \"\"\"Cox proportional hazards model for survival data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the hazard rate\n    \"\"\"\n    # original R wrapper doesn't pass slink; brmsfamily doesn't need it\n    return brmsfamily(\n        family=\"cox\",\n        link=link,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.hurdle_poisson","title":"<code>hurdle_poisson(link='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Poisson distribution for zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def hurdle_poisson(\n    link: str = \"log\", link_hu: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Hurdle Poisson distribution for zero-inflated count data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_hu : str\n        Link function for hurdle parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"hurdle_poisson\",\n        link=link,\n        link_hu=link_hu,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.hurdle_negbinomial","title":"<code>hurdle_negbinomial(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle negative binomial for overdispersed zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def hurdle_negbinomial(\n    link: str = \"log\", link_shape: str = \"log\", link_hu: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Hurdle negative binomial for overdispersed zero-inflated count data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_shape : str\n        Link function for shape parameter\n    link_hu : str\n        Link function for hurdle parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"hurdle_negbinomial\",\n        link=link,\n        link_shape=link_shape,\n        link_hu=link_hu,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.hurdle_gamma","title":"<code>hurdle_gamma(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Gamma distribution for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def hurdle_gamma(\n    link: str = \"log\", link_shape: str = \"log\", link_hu: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Hurdle Gamma distribution for zero-inflated positive continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_shape : str\n        Link function for shape parameter\n    link_hu : str\n        Link function for hurdle parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"hurdle_gamma\",\n        link=link,\n        link_shape=link_shape,\n        link_hu=link_hu,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.hurdle_lognormal","title":"<code>hurdle_lognormal(link='identity', link_sigma='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle lognormal for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def hurdle_lognormal(\n    link: str = \"identity\", link_sigma: str = \"log\", link_hu: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Hurdle lognormal for zero-inflated positive continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for sigma parameter\n    link_hu : str\n        Link function for hurdle parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"hurdle_lognormal\",\n        link=link,\n        link_sigma=link_sigma,\n        link_hu=link_hu,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.hurdle_cumulative","title":"<code>hurdle_cumulative(link='logit', link_hu='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Hurdle cumulative for zero-inflated ordinal data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the ordinal response</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def hurdle_cumulative(\n    link: str = \"logit\",\n    link_hu: str = \"logit\",\n    link_disc: str = \"log\",\n    threshold: str = \"flexible\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Hurdle cumulative for zero-inflated ordinal data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the ordinal response\n    link_hu : str\n        Link function for hurdle parameter\n    link_disc : str\n        Link function for discrimination parameter\n    threshold : str\n        Type of threshold structure\n    \"\"\"\n    return brmsfamily(\n        family=\"hurdle_cumulative\",\n        link=link,\n        link_hu=link_hu,\n        link_disc=link_disc,\n        threshold=threshold,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.zero_inflated_beta","title":"<code>zero_inflated_beta(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta for data between 0 and 1 with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_inflated_beta(\n    link: str = \"logit\", link_phi: str = \"log\", link_zi: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Zero-inflated beta for data between 0 and 1 with excess zeros.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_phi : str\n        Link function for precision parameter\n    link_zi : str\n        Link function for zero-inflation parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"zero_inflated_beta\",\n        link=link,\n        link_phi=link_phi,\n        link_zi=link_zi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.zero_one_inflated_beta","title":"<code>zero_one_inflated_beta(link='logit', link_phi='log', link_zoi='logit', link_coi='logit', **kwargs)</code>","text":"<p>Zero-one-inflated beta for data between 0 and 1 with excess zeros and ones.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zoi</code> <code>str</code> <p>Link function for zero-or-one inflation parameter</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link function for conditional one inflation parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_one_inflated_beta(\n    link: str = \"logit\",\n    link_phi: str = \"log\",\n    link_zoi: str = \"logit\",\n    link_coi: str = \"logit\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Zero-one-inflated beta for data between 0 and 1 with excess zeros and ones.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_phi : str\n        Link function for precision parameter\n    link_zoi : str\n        Link function for zero-or-one inflation parameter\n    link_coi : str\n        Link function for conditional one inflation parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"zero_one_inflated_beta\",\n        link=link,\n        link_phi=link_phi,\n        link_zoi=link_zoi,\n        link_coi=link_coi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.zero_inflated_poisson","title":"<code>zero_inflated_poisson(link='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated Poisson for count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_inflated_poisson(\n    link: str = \"log\", link_zi: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Zero-inflated Poisson for count data with excess zeros.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_zi : str\n        Link function for zero-inflation parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"zero_inflated_poisson\",\n        link=link,\n        link_zi=link_zi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.zero_inflated_negbinomial","title":"<code>zero_inflated_negbinomial(link='log', link_shape='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated negative binomial for overdispersed count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_inflated_negbinomial(\n    link: str = \"log\", link_shape: str = \"log\", link_zi: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Zero-inflated negative binomial for overdispersed count data with excess zeros.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_shape : str\n        Link function for shape parameter\n    link_zi : str\n        Link function for zero-inflation parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"zero_inflated_negbinomial\",\n        link=link,\n        link_shape=link_shape,\n        link_zi=link_zi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.zero_inflated_binomial","title":"<code>zero_inflated_binomial(link='logit', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated binomial for binary count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_inflated_binomial(\n    link: str = \"logit\", link_zi: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Zero-inflated binomial for binary count data with excess zeros.\n\n    Parameters\n    ----------\n    link : str\n        Link function for probability parameter\n    link_zi : str\n        Link function for zero-inflation parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"zero_inflated_binomial\",\n        link=link,\n        link_zi=link_zi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.zero_inflated_beta_binomial","title":"<code>zero_inflated_beta_binomial(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta-binomial for overdispersed binomial data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def zero_inflated_beta_binomial(\n    link: str = \"logit\", link_phi: str = \"log\", link_zi: str = \"logit\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Zero-inflated beta-binomial for overdispersed binomial data with excess zeros.\n\n    Parameters\n    ----------\n    link : str\n        Link function for probability parameter\n    link_phi : str\n        Link function for precision parameter\n    link_zi : str\n        Link function for zero-inflation parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"zero_inflated_beta_binomial\",\n        link=link,\n        link_phi=link_phi,\n        link_zi=link_zi,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.categorical","title":"<code>categorical(link='logit', refcat=None, **kwargs)</code>","text":"<p>Categorical distribution for unordered multi-category outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def categorical(\n    link: str = \"logit\", refcat: str | None = None, **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Categorical distribution for unordered multi-category outcomes.\n\n    Parameters\n    ----------\n    link : str\n        Link function for category probabilities\n    refcat : str, optional\n        Reference category\n    \"\"\"\n    return brmsfamily(\n        family=\"categorical\",\n        link=link,\n        refcat=refcat,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.multinomial","title":"<code>multinomial(link='logit', refcat=None, **kwargs)</code>","text":"<p>Multinomial distribution for count data across multiple categories.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def multinomial(\n    link: str = \"logit\", refcat: str | None = None, **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Multinomial distribution for count data across multiple categories.\n\n    Parameters\n    ----------\n    link : str\n        Link function for category probabilities\n    refcat : str, optional\n        Reference category\n    \"\"\"\n    return brmsfamily(\n        family=\"multinomial\",\n        link=link,\n        refcat=refcat,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.dirichlet_multinomial","title":"<code>dirichlet_multinomial(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet-multinomial for overdispersed categorical count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def dirichlet_multinomial(\n    link: str = \"logit\", link_phi: str = \"log\", refcat: str | None = None, **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Dirichlet-multinomial for overdispersed categorical count data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for category probabilities\n    link_phi : str\n        Link function for precision parameter\n    refcat : str, optional\n        Reference category\n    \"\"\"\n    return brmsfamily(\n        family=\"dirichlet_multinomial\",\n        link=link,\n        link_phi=link_phi,\n        refcat=refcat,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.cumulative","title":"<code>cumulative(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Cumulative (proportional odds) model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for cumulative probabilities</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def cumulative(\n    link: str = \"logit\", link_disc: str = \"log\", threshold: str = \"flexible\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Cumulative (proportional odds) model for ordinal outcomes.\n\n    Parameters\n    ----------\n    link : str\n        Link function for cumulative probabilities\n    link_disc : str\n        Link function for discrimination parameter\n    threshold : str\n        Type of threshold structure\n    \"\"\"\n    return brmsfamily(\n        family=\"cumulative\",\n        link=link,\n        link_disc=link_disc,\n        threshold=threshold,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.sratio","title":"<code>sratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Sequential (stopping) ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for sequential ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def sratio(\n    link: str = \"logit\", link_disc: str = \"log\", threshold: str = \"flexible\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Sequential (stopping) ratio model for ordinal outcomes.\n\n    Parameters\n    ----------\n    link : str\n        Link function for sequential ratios\n    link_disc : str\n        Link function for discrimination parameter\n    threshold : str\n        Type of threshold structure\n    \"\"\"\n    return brmsfamily(\n        family=\"sratio\",\n        link=link,\n        link_disc=link_disc,\n        threshold=threshold,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.cratio","title":"<code>cratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Continuation ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for continuation ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def cratio(\n    link: str = \"logit\", link_disc: str = \"log\", threshold: str = \"flexible\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Continuation ratio model for ordinal outcomes.\n\n    Parameters\n    ----------\n    link : str\n        Link function for continuation ratios\n    link_disc : str\n        Link function for discrimination parameter\n    threshold : str\n        Type of threshold structure\n    \"\"\"\n    return brmsfamily(\n        family=\"cratio\",\n        link=link,\n        link_disc=link_disc,\n        threshold=threshold,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.acat","title":"<code>acat(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Adjacent category model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for adjacent category ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def acat(\n    link: str = \"logit\", link_disc: str = \"log\", threshold: str = \"flexible\", **kwargs\n) -&gt; ListSexpVector:\n    \"\"\"Adjacent category model for ordinal outcomes.\n\n    Parameters\n    ----------\n    link : str\n        Link function for adjacent category ratios\n    link_disc : str\n        Link function for discrimination parameter\n    threshold : str\n        Type of threshold structure\n    \"\"\"\n    return brmsfamily(\n        family=\"acat\",\n        link=link,\n        link_disc=link_disc,\n        threshold=threshold,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.gaussian","title":"<code>gaussian(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Gaussian (normal) distribution for continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the standard deviation</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def gaussian(\n    link: str = \"identity\",\n    link_sigma: str = \"log\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Gaussian (normal) distribution for continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_sigma : str\n        Link function for the standard deviation\n    \"\"\"\n    return brmsfamily(\n        family=\"gaussian\",\n        link=link,\n        link_sigma=link_sigma,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.poisson","title":"<code>poisson(link='log', **kwargs)</code>","text":"<p>Poisson distribution for count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def poisson(\n    link: str = \"log\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Poisson distribution for count data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the rate parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"poisson\",\n        link=link,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.binomial","title":"<code>binomial(link='logit', **kwargs)</code>","text":"<p>Binomial distribution for binary count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def binomial(\n    link: str = \"logit\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Binomial distribution for binary count data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the probability parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"binomial\",\n        link=link,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.Gamma","title":"<code>Gamma(link='log', link_shape='log', **kwargs)</code>","text":"<p>Gamma distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def Gamma(\n    link: str = \"log\",\n    link_shape: str = \"log\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Gamma distribution for positive continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_shape : str\n        Link function for the shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"Gamma\",\n        link=link,\n        link_shape=link_shape,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.inverse_gaussian","title":"<code>inverse_gaussian(link='1/mu^2', link_shape='log', **kwargs)</code>","text":"<p>Inverse Gaussian distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'1/mu^2'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code> Source code in <code>brmspy/_brms_functions/families.py</code> <pre><code>def inverse_gaussian(\n    link: str = \"1/mu^2\",\n    link_shape: str = \"log\",\n    **kwargs,\n) -&gt; ListSexpVector:\n    \"\"\"Inverse Gaussian distribution for positive continuous data.\n\n    Parameters\n    ----------\n    link : str\n        Link function for the mean\n    link_shape : str\n        Link function for the shape parameter\n    \"\"\"\n    return brmsfamily(\n        family=\"inverse.gaussian\",\n        link=link,\n        link_shape=link_shape,\n        **kwargs,\n    )\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.get_brms_version","title":"<code>get_brms_version()</code>","text":"<p>Get installed brms R package version.</p> <p>Returns:</p> Type Description <code>str</code> <p>Version object or None</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If brms is not installed</p> <p>Examples:</p> <pre><code>from brmspy import brms\nversion = brms.get_brms_version()\nprint(f\"brms version: {version}\")\n</code></pre> Source code in <code>brmspy/_runtime/__init__.py</code> <pre><code>def get_brms_version() -&gt; Version | None:\n    \"\"\"\n    Get installed brms R package version.\n\n    Returns\n    -------\n    str\n        Version object or None\n\n    Raises\n    ------\n    ImportError\n        If brms is not installed\n\n    Examples\n    --------\n\n    ```python\n    from brmspy import brms\n    version = brms.get_brms_version()\n    print(f\"brms version: {version}\")\n    ```\n    \"\"\"\n    version = status().brms_version\n    if version is None:\n        return None\n    return Version(version)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.find_local_runtime","title":"<code>find_local_runtime()</code>","text":"<p>Find an installed runtime matching the current system fingerprint.</p> <p>Uses <code>system_fingerprint()</code> to compute the current system identity and searches the local runtime store for a matching runtime directory.</p> <p>Returns:</p> Type Description <code>Path or None</code> <p>Path to the matching runtime root directory if found, otherwise <code>None</code>.</p> Notes <p>This function is a pure lookup: it does not install, activate, or modify any runtime state.</p> Source code in <code>brmspy/_runtime/__init__.py</code> <pre><code>def find_local_runtime() -&gt; Path | None:\n    \"\"\"\n    Find an installed runtime matching the current system fingerprint.\n\n    Uses ``system_fingerprint()`` to compute the current system identity and\n    searches the local runtime store for a matching runtime directory.\n\n    Returns\n    -------\n    Path or None\n        Path to the matching runtime root directory if found,\n        otherwise ``None``.\n\n    Notes\n    -----\n    This function is a pure lookup:\n    it does not install, activate, or modify any runtime state.\n    \"\"\"\n    fingerprint = system_fingerprint()\n    return _storage.find_runtime_by_fingerprint(fingerprint)\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.get_active_runtime","title":"<code>get_active_runtime()</code>","text":"<p>Get path to currently active prebuilt runtime.</p> <p>Returns CONFIGURED runtime, not whether it is loaded.</p> <p>Returns:</p> Type Description <code>Path or None</code> <p>Path to active runtime directory, or None if not configured</p> Notes <p>Returns None if: - No runtime configured in config file - Config file doesn't exist - Config file is corrupted</p> <p>Examples:</p> <pre><code>from brmspy import get_active_runtime\n\nruntime_path = get_active_runtime()\nif runtime_path and runtime_path.exists():\n    print(f\"Active runtime: {runtime_path}\")\nelse:\n    print(\"No active runtime configured\")\n</code></pre> Source code in <code>brmspy/_runtime/__init__.py</code> <pre><code>def get_active_runtime() -&gt; Path | None:\n    \"\"\"\n    Get path to currently active prebuilt runtime.\n\n    Returns CONFIGURED runtime, not whether it is loaded.\n\n    Returns\n    -------\n    Path or None\n        Path to active runtime directory, or None if not configured\n\n    Notes\n    -----\n    Returns None if:\n    - No runtime configured in config file\n    - Config file doesn't exist\n    - Config file is corrupted\n\n    Examples\n    --------\n    ```python\n    from brmspy import get_active_runtime\n\n    runtime_path = get_active_runtime()\n    if runtime_path and runtime_path.exists():\n        print(f\"Active runtime: {runtime_path}\")\n    else:\n        print(\"No active runtime configured\")\n    ```\n    \"\"\"\n    _status = status()\n    if not _status:\n        return None\n\n    return _status.active_runtime\n</code></pre>"},{"location":"internals/brms/_brms_module/#brmspy.brms._brms_module.status","title":"<code>status()</code>","text":"<p>Query current runtime status without side effects.</p> <p>Returns:</p> Type Description <code>RuntimeStatus</code> <p>Dataclass with comprehensive state information including:</p> <ul> <li>Active runtime path and activation state</li> <li>System fingerprint and toolchain info</li> <li>Prebuilt compatibility and availability</li> <li>Installed brms/cmdstanr/rstan versions</li> </ul> Source code in <code>brmspy/_runtime/__init__.py</code> <pre><code>def status() -&gt; RuntimeStatus:\n    \"\"\"\n    Query current runtime status without side effects.\n\n    Returns\n    -------\n    RuntimeStatus\n        Dataclass with comprehensive state information including:\n\n        - Active runtime path and activation state\n        - System fingerprint and toolchain info\n        - Prebuilt compatibility and availability\n        - Installed brms/cmdstanr/rstan versions\n    \"\"\"\n    from brmspy._runtime import _config, _platform, _r_packages, _state, _storage\n\n    system = _platform.get_system_info()\n\n    return RuntimeStatus(\n        active_runtime=_config.get_active_runtime_path(),\n        is_activated=_state.has_stored_env(),\n        system=system,\n        can_use_prebuilt=_platform.can_use_prebuilt(),\n        prebuilt_available=_platform.is_prebuilt_available(system.fingerprint),\n        compatibility_issues=tuple(_platform.get_compatibility_issues()),\n        installed_runtimes=tuple(_storage.list_installed_runtimes()),\n        brms_version=_r_packages.get_package_version(\"brms\"),\n        cmdstanr_version=_r_packages.get_package_version(\"cmdstanr\"),\n        rstan_version=_r_packages.get_package_version(\"rstan\"),\n    )\n</code></pre>"},{"location":"internals/brms/_build_module/","title":"_build_module","text":"<p>Surface module for brms._build() context (internal tooling).</p> <p>This module is intended to be imported safely in the main process (no top-level rpy2 imports). Heavy work should be performed in the worker when these functions are called via ModuleProxy.</p> <p>Only names listed in all will be exposed by the _build() context proxy.</p>"},{"location":"internals/brms/_build_module/#brmspy.brms._build_module-attributes","title":"Attributes","text":""},{"location":"internals/brms/_build_module/#brmspy.brms._build_module.__all__","title":"<code>__all__ = ['BuildModule']</code>  <code>module-attribute</code>","text":""},{"location":"internals/brms/_build_module/#brmspy.brms._build_module-classes","title":"Classes","text":""},{"location":"internals/brms/_build_module/#brmspy.brms._build_module.BuildModule","title":"<code>BuildModule</code>","text":"Source code in <code>brmspy/brms/_build_module.py</code> <pre><code>class BuildModule:\n    @staticmethod\n    def is_package_installed(name: str) -&gt; bool:\n        from brmspy._runtime._r_packages import is_package_installed\n\n        return is_package_installed(name)\n\n    @staticmethod\n    def collect_runtime_metadata() -&gt; dict:\n        \"\"\"\n        Collect comprehensive R environment metadata for runtime bundle.\n\n        Executed in worker.\n        \"\"\"\n        from brmspy._build._metadata import collect_runtime_metadata as _collect\n\n        return _collect()\n\n    @staticmethod\n    def stage_runtime_tree(\n        base_dir: Path, metadata: dict, runtime_version: str\n    ) -&gt; Path:\n        \"\"\"\n        Stage runtime tree structure for packing.\n\n        Executed in worker.\n        \"\"\"\n        from brmspy._build._stage import stage_runtime_tree as _stage\n\n        return _stage(base_dir, metadata, runtime_version)\n\n    @staticmethod\n    def pack_runtime(runtime_root: Path, out_dir: Path, runtime_version: str) -&gt; Path:\n        \"\"\"\n        Pack staged runtime into distributable archive.\n\n        Executed in worker.\n        \"\"\"\n        from brmspy._build._pack import pack_runtime as _pack\n\n        return _pack(runtime_root, out_dir, runtime_version)\n</code></pre>"},{"location":"internals/brms/_build_module/#brmspy.brms._build_module.BuildModule-functions","title":"Functions","text":""},{"location":"internals/brms/_build_module/#brmspy.brms._build_module.BuildModule.is_package_installed","title":"<code>is_package_installed(name)</code>  <code>staticmethod</code>","text":"Source code in <code>brmspy/brms/_build_module.py</code> <pre><code>@staticmethod\ndef is_package_installed(name: str) -&gt; bool:\n    from brmspy._runtime._r_packages import is_package_installed\n\n    return is_package_installed(name)\n</code></pre>"},{"location":"internals/brms/_build_module/#brmspy.brms._build_module.BuildModule.collect_runtime_metadata","title":"<code>collect_runtime_metadata()</code>  <code>staticmethod</code>","text":"<p>Collect comprehensive R environment metadata for runtime bundle.</p> <p>Executed in worker.</p> Source code in <code>brmspy/brms/_build_module.py</code> <pre><code>@staticmethod\ndef collect_runtime_metadata() -&gt; dict:\n    \"\"\"\n    Collect comprehensive R environment metadata for runtime bundle.\n\n    Executed in worker.\n    \"\"\"\n    from brmspy._build._metadata import collect_runtime_metadata as _collect\n\n    return _collect()\n</code></pre>"},{"location":"internals/brms/_build_module/#brmspy.brms._build_module.BuildModule.stage_runtime_tree","title":"<code>stage_runtime_tree(base_dir, metadata, runtime_version)</code>  <code>staticmethod</code>","text":"<p>Stage runtime tree structure for packing.</p> <p>Executed in worker.</p> Source code in <code>brmspy/brms/_build_module.py</code> <pre><code>@staticmethod\ndef stage_runtime_tree(\n    base_dir: Path, metadata: dict, runtime_version: str\n) -&gt; Path:\n    \"\"\"\n    Stage runtime tree structure for packing.\n\n    Executed in worker.\n    \"\"\"\n    from brmspy._build._stage import stage_runtime_tree as _stage\n\n    return _stage(base_dir, metadata, runtime_version)\n</code></pre>"},{"location":"internals/brms/_build_module/#brmspy.brms._build_module.BuildModule.pack_runtime","title":"<code>pack_runtime(runtime_root, out_dir, runtime_version)</code>  <code>staticmethod</code>","text":"<p>Pack staged runtime into distributable archive.</p> <p>Executed in worker.</p> Source code in <code>brmspy/brms/_build_module.py</code> <pre><code>@staticmethod\ndef pack_runtime(runtime_root: Path, out_dir: Path, runtime_version: str) -&gt; Path:\n    \"\"\"\n    Pack staged runtime into distributable archive.\n\n    Executed in worker.\n    \"\"\"\n    from brmspy._build._pack import pack_runtime as _pack\n\n    return _pack(runtime_root, out_dir, runtime_version)\n</code></pre>"},{"location":"internals/brms/_manage_module/","title":"_manage_module","text":"<p>Manage brmspy runtimes and R environments.</p> <p>This module defines the surface returned by <code>brmspy.brms.manage()</code>.</p> <p>The file is safe to import in the main Python process (no top-level <code>rpy2.robjects</code> imports). In normal use these methods are invoked through the <code>manage()</code> context, and the actual work executes in the worker process that hosts the embedded R session.</p> <p>Example: <pre><code>env = \"mrp\"\nif not brms.environment_exists(env):\n    with brms.manage(environment_name=env) as ctx:\n        ctx.install_brms(use_prebuilt=True)\n        ctx.install_rpackage(\"MCMCglmm\")\nelse:\n    brms.environment_activate(env)\n</code></pre></p> Notes <ul> <li>Use the context manager to ensure the worker (and its embedded R session) is   started with the desired environment configuration.</li> <li>Calling these methods directly in the main process is unsupported and may   reintroduce the same stability issues that the worker isolation is designed   to avoid.</li> </ul>"},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module-attributes","title":"Attributes","text":""},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.__all__","title":"<code>__all__ = ['ManageModule']</code>  <code>module-attribute</code>","text":""},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module-classes","title":"Classes","text":""},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.ManageModule","title":"<code>ManageModule</code>","text":"<p>Management surface returned by <code>brmspy.brms.manage()</code>.</p> <p>The returned object is a proxy that executes these methods inside the worker process. Use it to install brms/toolchains, manage R packages in the active environment, and query basic runtime state.</p> Notes <p>The worker process must be able to run R and (depending on the installation mode) may require an OS toolchain for compiling packages / CmdStan.</p> Source code in <code>brmspy/brms/_manage_module.py</code> <pre><code>class ManageModule:\n    \"\"\"\n    Management surface returned by `brmspy.brms.manage()`.\n\n    The returned object is a *proxy* that executes these methods inside the\n    worker process. Use it to install brms/toolchains, manage R packages in the\n    active environment, and query basic runtime state.\n\n    Notes\n    -----\n    The worker process must be able to run R and (depending on the installation\n    mode) may require an OS toolchain for compiling packages / CmdStan.\n    \"\"\"\n\n    @staticmethod\n    def install_runtime(*, install_rtools: bool = False) -&gt; Path | None:\n        \"\"\"\n        Install the prebuilt brmspy runtime bundle.\n\n        This is a convenience wrapper around `install_brms(use_prebuilt=True)`.\n        It downloads (if necessary) a precompiled runtime and optionally activates it.\n\n        Parameters\n        ----------\n        install_rtools : bool, default=False\n            If ``True``, install Rtools on Windows if missing.\n\n        Returns\n        -------\n        pathlib.Path or None\n            Path to the installed runtime directory (prebuilt mode). Returns ``None``\n            if no runtime was installed (unexpected for prebuilt mode).\n\n        Raises\n        ------\n        RuntimeError\n            If no compatible prebuilt runtime exists for the current platform.\n\n        Examples\n        --------\n        &gt;&gt;&gt; from brmspy import brms\n        &gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n        ...     runtime = ctx.install_runtime()\n        \"\"\"\n        from brmspy._runtime import install_runtime as _install_runtime\n\n        return _install_runtime(install_rtools=install_rtools)\n\n    @staticmethod\n    def install_brms(\n        *,\n        use_prebuilt: bool = False,\n        install_rtools: bool = False,\n        brms_version: str | None = None,\n        cmdstanr_version: str | None = None,\n        install_rstan: bool = True,\n        install_cmdstanr: bool = True,\n        rstan_version: str | None = None,\n        activate: bool = True,\n    ) -&gt; Path | None:\n        \"\"\"\n        Install brms and its toolchain dependencies.\n\n        In traditional mode (``use_prebuilt=False``), this installs into the active R\n        library (typically the active brmspy environment) and may build CmdStan from\n        source.\n\n        In prebuilt mode (``use_prebuilt=True``), this downloads a brmspy runtime\n        bundle (R packages + CmdStan) and can activate it.\n\n        Parameters\n        ----------\n        use_prebuilt : bool, default=False\n            If ``True``, use a prebuilt runtime bundle instead of installing via R.\n        install_rtools : bool, default=False\n            If ``True``, install Rtools on Windows if missing.\n        brms_version : str or None, default=None\n            Version spec for the brms R package (traditional mode only). ``None`` means\n            \"latest\".\n        cmdstanr_version : str or None, default=None\n            Version spec for cmdstanr (traditional mode only). ``None`` means \"latest\".\n        install_rstan : bool, default=True\n            If ``True``, install rstan (traditional mode).\n        install_cmdstanr : bool, default=True\n            If ``True``, install cmdstanr and CmdStan (traditional mode).\n        rstan_version : str or None, default=None\n            Version spec for rstan (traditional mode only). ``None`` means \"latest\".\n        activate : bool, default=True\n            If ``True`` and ``use_prebuilt=True``, activate the downloaded runtime in the\n            worker's embedded R session.\n\n        Returns\n        -------\n        pathlib.Path or None\n            If ``use_prebuilt=True``, returns the installed runtime directory.\n            If ``use_prebuilt=False``, returns ``None``.\n\n        Raises\n        ------\n        RuntimeError\n            If installation fails (for example missing toolchain, or no compatible\n            prebuilt runtime exists).\n\n        Examples\n        --------\n        Prebuilt (fast) install:\n\n        &gt;&gt;&gt; from brmspy import brms\n        &gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n        ...     ctx.install_brms(use_prebuilt=True)\n\n        Traditional (R installs + builds CmdStan):\n\n        &gt;&gt;&gt; from brmspy import brms\n        &gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n        ...     ctx.install_brms(use_prebuilt=False, install_cmdstanr=True, install_rstan=False)\n        \"\"\"\n        from brmspy._runtime import install_brms as _install_brms\n\n        return _install_brms(\n            use_prebuilt=use_prebuilt,\n            install_rtools=install_rtools,\n            brms_version=brms_version,\n            cmdstanr_version=cmdstanr_version,\n            install_rstan=install_rstan,\n            install_cmdstanr=install_cmdstanr,\n            rstan_version=rstan_version,\n            activate=activate,\n        )\n\n    @staticmethod\n    def install_rpackage(\n        name: str,\n        version: str | None = None,\n        repos_extra: list[str] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Install an R package into the active environment library.\n\n        Parameters\n        ----------\n        name : str\n            R package name (e.g. ``\"MCMCglmm\"``).\n        version : str or None, default=None\n            Optional version spec. ``None`` means \"latest\".\n        repos_extra : list[str] or None, default=None\n            Extra repositories to add (for example R-universe URLs).\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This installs into the *active* R library path (usually the brmspy environment\n        library), not into the system R library tree.\n\n        Examples\n        --------\n        &gt;&gt;&gt; from brmspy import brms\n        &gt;&gt;&gt; with brms.manage(environment_name=\"mrp\") as ctx:\n        ...     ctx.install_rpackage(\"MCMCglmm\")\n        \"\"\"\n        from brmspy._runtime._r_packages import install_package\n\n        return install_package(name, version=version, repos_extra=repos_extra)\n\n    @staticmethod\n    def uninstall_rpackage(name: str) -&gt; bool:\n        \"\"\"\n        Uninstall an R package from the active library paths.\n\n        Parameters\n        ----------\n        name : str\n            R package name.\n\n        Returns\n        -------\n        bool\n            ``True`` if the package appears removed, otherwise ``False``.\n\n        Notes\n        -----\n        Package unloading/removal can be OS-dependent (especially on Windows where DLLs\n        may be locked). This function makes a best effort.\n\n        Examples\n        --------\n        &gt;&gt;&gt; from brmspy import brms\n        &gt;&gt;&gt; with brms.manage(environment_name=\"mrp\") as ctx:\n        ...     ok = ctx.uninstall_rpackage(\"MCMCglmm\")\n        \"\"\"\n        from brmspy._runtime._r_packages import remove_package\n\n        return remove_package(name)\n\n    @staticmethod\n    def import_rpackages(*names: str) -&gt; None:\n        \"\"\"\n        Import (load) one or more R packages into the worker's embedded R session.\n\n        This does *not* install packages. Use `install_rpackage()` first if needed.\n\n        Parameters\n        ----------\n        *names : str\n            One or more package names.\n\n        Returns\n        -------\n        None\n\n        Examples\n        --------\n        &gt;&gt;&gt; from brmspy import brms\n        &gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n        ...     ctx.import_rpackages(\"brms\", \"cmdstanr\")\n        \"\"\"\n        from rpy2.robjects.packages import importr\n\n        for name in names:\n            importr(name)\n\n    @staticmethod\n    def is_rpackage_loaded(name: str) -&gt; bool:\n        \"\"\"\n        Check whether an R package is loaded in the current R session.\n\n        Parameters\n        ----------\n        name : str\n            R package name.\n\n        Returns\n        -------\n        bool\n            ``True`` if the package is loaded (namespace loaded or attached).\n        \"\"\"\n        from brmspy._runtime._r_env import is_namespace_loaded, is_package_attached\n\n        return is_namespace_loaded(name) or is_package_attached(name)\n\n    @staticmethod\n    def get_rpackage_version(name: str) -&gt; str | None:\n        \"\"\"\n        Get installed version of an R package.\n\n        Parameters\n        ----------\n        name : str\n            R package name.\n\n        Returns\n        -------\n        str or None\n            Installed version string, or ``None`` if not installed / not found.\n        \"\"\"\n        from brmspy._runtime._r_packages import get_package_version\n\n        return get_package_version(name)\n\n    @staticmethod\n    def is_rpackage_installed(name: str) -&gt; bool:\n        \"\"\"\n        Check whether an R package is installed in the active library paths.\n\n        Parameters\n        ----------\n        name : str\n            R package name.\n\n        Returns\n        -------\n        bool\n            ``True`` if installed, otherwise ``False``.\n        \"\"\"\n        from brmspy._runtime._r_packages import get_package_version\n\n        return get_package_version(name) is not None\n\n    @staticmethod\n    def _unload_rpackage(name: str) -&gt; bool:\n        \"\"\"\n        Attempt to unload an R package from the current session (advanced).\n\n        This is intentionally private: unloading packages at runtime can be fragile.\n\n        Parameters\n        ----------\n        name : str\n            R package name.\n\n        Returns\n        -------\n        bool\n            ``True`` if the unload attempt was reported as successful.\n        \"\"\"\n        from brmspy._runtime._r_env import unload_package\n\n        return unload_package(name)\n\n    @staticmethod\n    def get_lib_paths() -&gt; list[str]:\n        \"\"\"\n        Get the current R ``.libPaths()`` search paths.\n\n        Returns\n        -------\n        list[str]\n            R library search paths (highest priority first).\n        \"\"\"\n        from brmspy._runtime._r_env import get_lib_paths\n\n        return get_lib_paths()\n\n    @staticmethod\n    def get_cmdstan_path() -&gt; str | None:\n        \"\"\"\n        Get the current CmdStan path configured in cmdstanr.\n\n        Returns\n        -------\n        str or None\n            CmdStan directory path, or ``None`` if not configured / cmdstanr unavailable.\n        \"\"\"\n        from brmspy._runtime._r_env import get_cmdstan_path\n\n        return get_cmdstan_path()\n</code></pre>"},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.ManageModule-functions","title":"Functions","text":""},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.ManageModule.install_runtime","title":"<code>install_runtime(*, install_rtools=False)</code>  <code>staticmethod</code>","text":"<p>Install the prebuilt brmspy runtime bundle.</p> <p>This is a convenience wrapper around <code>install_brms(use_prebuilt=True)</code>. It downloads (if necessary) a precompiled runtime and optionally activates it.</p> <p>Parameters:</p> Name Type Description Default <code>install_rtools</code> <code>bool</code> <p>If <code>True</code>, install Rtools on Windows if missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>Path or None</code> <p>Path to the installed runtime directory (prebuilt mode). Returns <code>None</code> if no runtime was installed (unexpected for prebuilt mode).</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no compatible prebuilt runtime exists for the current platform.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n...     runtime = ctx.install_runtime()\n</code></pre> Source code in <code>brmspy/brms/_manage_module.py</code> <pre><code>@staticmethod\ndef install_runtime(*, install_rtools: bool = False) -&gt; Path | None:\n    \"\"\"\n    Install the prebuilt brmspy runtime bundle.\n\n    This is a convenience wrapper around `install_brms(use_prebuilt=True)`.\n    It downloads (if necessary) a precompiled runtime and optionally activates it.\n\n    Parameters\n    ----------\n    install_rtools : bool, default=False\n        If ``True``, install Rtools on Windows if missing.\n\n    Returns\n    -------\n    pathlib.Path or None\n        Path to the installed runtime directory (prebuilt mode). Returns ``None``\n        if no runtime was installed (unexpected for prebuilt mode).\n\n    Raises\n    ------\n    RuntimeError\n        If no compatible prebuilt runtime exists for the current platform.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from brmspy import brms\n    &gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n    ...     runtime = ctx.install_runtime()\n    \"\"\"\n    from brmspy._runtime import install_runtime as _install_runtime\n\n    return _install_runtime(install_rtools=install_rtools)\n</code></pre>"},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.ManageModule.install_brms","title":"<code>install_brms(*, use_prebuilt=False, install_rtools=False, brms_version=None, cmdstanr_version=None, install_rstan=True, install_cmdstanr=True, rstan_version=None, activate=True)</code>  <code>staticmethod</code>","text":"<p>Install brms and its toolchain dependencies.</p> <p>In traditional mode (<code>use_prebuilt=False</code>), this installs into the active R library (typically the active brmspy environment) and may build CmdStan from source.</p> <p>In prebuilt mode (<code>use_prebuilt=True</code>), this downloads a brmspy runtime bundle (R packages + CmdStan) and can activate it.</p> <p>Parameters:</p> Name Type Description Default <code>use_prebuilt</code> <code>bool</code> <p>If <code>True</code>, use a prebuilt runtime bundle instead of installing via R.</p> <code>False</code> <code>install_rtools</code> <code>bool</code> <p>If <code>True</code>, install Rtools on Windows if missing.</p> <code>False</code> <code>brms_version</code> <code>str or None</code> <p>Version spec for the brms R package (traditional mode only). <code>None</code> means \"latest\".</p> <code>None</code> <code>cmdstanr_version</code> <code>str or None</code> <p>Version spec for cmdstanr (traditional mode only). <code>None</code> means \"latest\".</p> <code>None</code> <code>install_rstan</code> <code>bool</code> <p>If <code>True</code>, install rstan (traditional mode).</p> <code>True</code> <code>install_cmdstanr</code> <code>bool</code> <p>If <code>True</code>, install cmdstanr and CmdStan (traditional mode).</p> <code>True</code> <code>rstan_version</code> <code>str or None</code> <p>Version spec for rstan (traditional mode only). <code>None</code> means \"latest\".</p> <code>None</code> <code>activate</code> <code>bool</code> <p>If <code>True</code> and <code>use_prebuilt=True</code>, activate the downloaded runtime in the worker's embedded R session.</p> <code>True</code> <p>Returns:</p> Type Description <code>Path or None</code> <p>If <code>use_prebuilt=True</code>, returns the installed runtime directory. If <code>use_prebuilt=False</code>, returns <code>None</code>.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If installation fails (for example missing toolchain, or no compatible prebuilt runtime exists).</p> <p>Examples:</p> <p>Prebuilt (fast) install:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n...     ctx.install_brms(use_prebuilt=True)\n</code></pre> <p>Traditional (R installs + builds CmdStan):</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n...     ctx.install_brms(use_prebuilt=False, install_cmdstanr=True, install_rstan=False)\n</code></pre> Source code in <code>brmspy/brms/_manage_module.py</code> <pre><code>@staticmethod\ndef install_brms(\n    *,\n    use_prebuilt: bool = False,\n    install_rtools: bool = False,\n    brms_version: str | None = None,\n    cmdstanr_version: str | None = None,\n    install_rstan: bool = True,\n    install_cmdstanr: bool = True,\n    rstan_version: str | None = None,\n    activate: bool = True,\n) -&gt; Path | None:\n    \"\"\"\n    Install brms and its toolchain dependencies.\n\n    In traditional mode (``use_prebuilt=False``), this installs into the active R\n    library (typically the active brmspy environment) and may build CmdStan from\n    source.\n\n    In prebuilt mode (``use_prebuilt=True``), this downloads a brmspy runtime\n    bundle (R packages + CmdStan) and can activate it.\n\n    Parameters\n    ----------\n    use_prebuilt : bool, default=False\n        If ``True``, use a prebuilt runtime bundle instead of installing via R.\n    install_rtools : bool, default=False\n        If ``True``, install Rtools on Windows if missing.\n    brms_version : str or None, default=None\n        Version spec for the brms R package (traditional mode only). ``None`` means\n        \"latest\".\n    cmdstanr_version : str or None, default=None\n        Version spec for cmdstanr (traditional mode only). ``None`` means \"latest\".\n    install_rstan : bool, default=True\n        If ``True``, install rstan (traditional mode).\n    install_cmdstanr : bool, default=True\n        If ``True``, install cmdstanr and CmdStan (traditional mode).\n    rstan_version : str or None, default=None\n        Version spec for rstan (traditional mode only). ``None`` means \"latest\".\n    activate : bool, default=True\n        If ``True`` and ``use_prebuilt=True``, activate the downloaded runtime in the\n        worker's embedded R session.\n\n    Returns\n    -------\n    pathlib.Path or None\n        If ``use_prebuilt=True``, returns the installed runtime directory.\n        If ``use_prebuilt=False``, returns ``None``.\n\n    Raises\n    ------\n    RuntimeError\n        If installation fails (for example missing toolchain, or no compatible\n        prebuilt runtime exists).\n\n    Examples\n    --------\n    Prebuilt (fast) install:\n\n    &gt;&gt;&gt; from brmspy import brms\n    &gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n    ...     ctx.install_brms(use_prebuilt=True)\n\n    Traditional (R installs + builds CmdStan):\n\n    &gt;&gt;&gt; from brmspy import brms\n    &gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n    ...     ctx.install_brms(use_prebuilt=False, install_cmdstanr=True, install_rstan=False)\n    \"\"\"\n    from brmspy._runtime import install_brms as _install_brms\n\n    return _install_brms(\n        use_prebuilt=use_prebuilt,\n        install_rtools=install_rtools,\n        brms_version=brms_version,\n        cmdstanr_version=cmdstanr_version,\n        install_rstan=install_rstan,\n        install_cmdstanr=install_cmdstanr,\n        rstan_version=rstan_version,\n        activate=activate,\n    )\n</code></pre>"},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.ManageModule.install_rpackage","title":"<code>install_rpackage(name, version=None, repos_extra=None)</code>  <code>staticmethod</code>","text":"<p>Install an R package into the active environment library.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>R package name (e.g. <code>\"MCMCglmm\"</code>).</p> required <code>version</code> <code>str or None</code> <p>Optional version spec. <code>None</code> means \"latest\".</p> <code>None</code> <code>repos_extra</code> <code>list[str] or None</code> <p>Extra repositories to add (for example R-universe URLs).</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Notes <p>This installs into the active R library path (usually the brmspy environment library), not into the system R library tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; with brms.manage(environment_name=\"mrp\") as ctx:\n...     ctx.install_rpackage(\"MCMCglmm\")\n</code></pre> Source code in <code>brmspy/brms/_manage_module.py</code> <pre><code>@staticmethod\ndef install_rpackage(\n    name: str,\n    version: str | None = None,\n    repos_extra: list[str] | None = None,\n) -&gt; None:\n    \"\"\"\n    Install an R package into the active environment library.\n\n    Parameters\n    ----------\n    name : str\n        R package name (e.g. ``\"MCMCglmm\"``).\n    version : str or None, default=None\n        Optional version spec. ``None`` means \"latest\".\n    repos_extra : list[str] or None, default=None\n        Extra repositories to add (for example R-universe URLs).\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This installs into the *active* R library path (usually the brmspy environment\n    library), not into the system R library tree.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from brmspy import brms\n    &gt;&gt;&gt; with brms.manage(environment_name=\"mrp\") as ctx:\n    ...     ctx.install_rpackage(\"MCMCglmm\")\n    \"\"\"\n    from brmspy._runtime._r_packages import install_package\n\n    return install_package(name, version=version, repos_extra=repos_extra)\n</code></pre>"},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.ManageModule.uninstall_rpackage","title":"<code>uninstall_rpackage(name)</code>  <code>staticmethod</code>","text":"<p>Uninstall an R package from the active library paths.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>R package name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the package appears removed, otherwise <code>False</code>.</p> Notes <p>Package unloading/removal can be OS-dependent (especially on Windows where DLLs may be locked). This function makes a best effort.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; with brms.manage(environment_name=\"mrp\") as ctx:\n...     ok = ctx.uninstall_rpackage(\"MCMCglmm\")\n</code></pre> Source code in <code>brmspy/brms/_manage_module.py</code> <pre><code>@staticmethod\ndef uninstall_rpackage(name: str) -&gt; bool:\n    \"\"\"\n    Uninstall an R package from the active library paths.\n\n    Parameters\n    ----------\n    name : str\n        R package name.\n\n    Returns\n    -------\n    bool\n        ``True`` if the package appears removed, otherwise ``False``.\n\n    Notes\n    -----\n    Package unloading/removal can be OS-dependent (especially on Windows where DLLs\n    may be locked). This function makes a best effort.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from brmspy import brms\n    &gt;&gt;&gt; with brms.manage(environment_name=\"mrp\") as ctx:\n    ...     ok = ctx.uninstall_rpackage(\"MCMCglmm\")\n    \"\"\"\n    from brmspy._runtime._r_packages import remove_package\n\n    return remove_package(name)\n</code></pre>"},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.ManageModule.import_rpackages","title":"<code>import_rpackages(*names)</code>  <code>staticmethod</code>","text":"<p>Import (load) one or more R packages into the worker's embedded R session.</p> <p>This does not install packages. Use <code>install_rpackage()</code> first if needed.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>str</code> <p>One or more package names.</p> <code>()</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from brmspy import brms\n&gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n...     ctx.import_rpackages(\"brms\", \"cmdstanr\")\n</code></pre> Source code in <code>brmspy/brms/_manage_module.py</code> <pre><code>@staticmethod\ndef import_rpackages(*names: str) -&gt; None:\n    \"\"\"\n    Import (load) one or more R packages into the worker's embedded R session.\n\n    This does *not* install packages. Use `install_rpackage()` first if needed.\n\n    Parameters\n    ----------\n    *names : str\n        One or more package names.\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    &gt;&gt;&gt; from brmspy import brms\n    &gt;&gt;&gt; with brms.manage(environment_name=\"default\") as ctx:\n    ...     ctx.import_rpackages(\"brms\", \"cmdstanr\")\n    \"\"\"\n    from rpy2.robjects.packages import importr\n\n    for name in names:\n        importr(name)\n</code></pre>"},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.ManageModule.is_rpackage_loaded","title":"<code>is_rpackage_loaded(name)</code>  <code>staticmethod</code>","text":"<p>Check whether an R package is loaded in the current R session.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>R package name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the package is loaded (namespace loaded or attached).</p> Source code in <code>brmspy/brms/_manage_module.py</code> <pre><code>@staticmethod\ndef is_rpackage_loaded(name: str) -&gt; bool:\n    \"\"\"\n    Check whether an R package is loaded in the current R session.\n\n    Parameters\n    ----------\n    name : str\n        R package name.\n\n    Returns\n    -------\n    bool\n        ``True`` if the package is loaded (namespace loaded or attached).\n    \"\"\"\n    from brmspy._runtime._r_env import is_namespace_loaded, is_package_attached\n\n    return is_namespace_loaded(name) or is_package_attached(name)\n</code></pre>"},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.ManageModule.get_rpackage_version","title":"<code>get_rpackage_version(name)</code>  <code>staticmethod</code>","text":"<p>Get installed version of an R package.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>R package name.</p> required <p>Returns:</p> Type Description <code>str or None</code> <p>Installed version string, or <code>None</code> if not installed / not found.</p> Source code in <code>brmspy/brms/_manage_module.py</code> <pre><code>@staticmethod\ndef get_rpackage_version(name: str) -&gt; str | None:\n    \"\"\"\n    Get installed version of an R package.\n\n    Parameters\n    ----------\n    name : str\n        R package name.\n\n    Returns\n    -------\n    str or None\n        Installed version string, or ``None`` if not installed / not found.\n    \"\"\"\n    from brmspy._runtime._r_packages import get_package_version\n\n    return get_package_version(name)\n</code></pre>"},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.ManageModule.is_rpackage_installed","title":"<code>is_rpackage_installed(name)</code>  <code>staticmethod</code>","text":"<p>Check whether an R package is installed in the active library paths.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>R package name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if installed, otherwise <code>False</code>.</p> Source code in <code>brmspy/brms/_manage_module.py</code> <pre><code>@staticmethod\ndef is_rpackage_installed(name: str) -&gt; bool:\n    \"\"\"\n    Check whether an R package is installed in the active library paths.\n\n    Parameters\n    ----------\n    name : str\n        R package name.\n\n    Returns\n    -------\n    bool\n        ``True`` if installed, otherwise ``False``.\n    \"\"\"\n    from brmspy._runtime._r_packages import get_package_version\n\n    return get_package_version(name) is not None\n</code></pre>"},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.ManageModule._unload_rpackage","title":"<code>_unload_rpackage(name)</code>  <code>staticmethod</code>","text":"<p>Attempt to unload an R package from the current session (advanced).</p> <p>This is intentionally private: unloading packages at runtime can be fragile.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>R package name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the unload attempt was reported as successful.</p> Source code in <code>brmspy/brms/_manage_module.py</code> <pre><code>@staticmethod\ndef _unload_rpackage(name: str) -&gt; bool:\n    \"\"\"\n    Attempt to unload an R package from the current session (advanced).\n\n    This is intentionally private: unloading packages at runtime can be fragile.\n\n    Parameters\n    ----------\n    name : str\n        R package name.\n\n    Returns\n    -------\n    bool\n        ``True`` if the unload attempt was reported as successful.\n    \"\"\"\n    from brmspy._runtime._r_env import unload_package\n\n    return unload_package(name)\n</code></pre>"},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.ManageModule.get_lib_paths","title":"<code>get_lib_paths()</code>  <code>staticmethod</code>","text":"<p>Get the current R <code>.libPaths()</code> search paths.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>R library search paths (highest priority first).</p> Source code in <code>brmspy/brms/_manage_module.py</code> <pre><code>@staticmethod\ndef get_lib_paths() -&gt; list[str]:\n    \"\"\"\n    Get the current R ``.libPaths()`` search paths.\n\n    Returns\n    -------\n    list[str]\n        R library search paths (highest priority first).\n    \"\"\"\n    from brmspy._runtime._r_env import get_lib_paths\n\n    return get_lib_paths()\n</code></pre>"},{"location":"internals/brms/_manage_module/#brmspy.brms._manage_module.ManageModule.get_cmdstan_path","title":"<code>get_cmdstan_path()</code>  <code>staticmethod</code>","text":"<p>Get the current CmdStan path configured in cmdstanr.</p> <p>Returns:</p> Type Description <code>str or None</code> <p>CmdStan directory path, or <code>None</code> if not configured / cmdstanr unavailable.</p> Source code in <code>brmspy/brms/_manage_module.py</code> <pre><code>@staticmethod\ndef get_cmdstan_path() -&gt; str | None:\n    \"\"\"\n    Get the current CmdStan path configured in cmdstanr.\n\n    Returns\n    -------\n    str or None\n        CmdStan directory path, or ``None`` if not configured / cmdstanr unavailable.\n    \"\"\"\n    from brmspy._runtime._r_env import get_cmdstan_path\n\n    return get_cmdstan_path()\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/","title":"_conversion","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.__all__","title":"<code>__all__ = ['py_to_r', 'r_to_py']</code>  <code>module-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.TypeDims","title":"<code>TypeDims = dict[str, list[str]]</code>  <code>module-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.TypeCoords","title":"<code>TypeCoords = dict[str, np.ndarray]</code>  <code>module-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion-classes","title":"Classes","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.IDBrm","title":"<code>IDBrm</code>","text":"<p>               Bases: <code>IDConstantData</code></p> <p>Typed <code>arviz.InferenceData</code> for fitted brms models.</p> <p>Extends <code>arviz.InferenceData</code> with type hints for IDE autocomplete. In brmspy, the fitted model result typically exposes an <code>.idata</code> attribute of this type.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Posterior samples of model parameters.</p> <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (with observation noise).</p> <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation.</p> <code>observed_data</code> <code>Dataset</code> <p>Original observed response data.</p> <code>coords</code> <code>dict</code> <p>Coordinate mappings for dimensions (inherited from <code>arviz.InferenceData</code>).</p> <code>dims</code> <code>dict</code> <p>Dimension specifications for variables (inherited from <code>arviz.InferenceData</code>).</p> See Also <p>brmspy.brms.brm : Creates fitted model results (alias: <code>brmspy.brms.fit</code>). arviz.InferenceData : Base class documentation.</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.brm(\"y ~ x\", data=df, chains=4)\n\n# Type checking and autocomplete\nassert isinstance(model.idata, IDFit)\nprint(model.idata.posterior)\n</code></pre> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>class IDBrm(IDConstantData):\n    \"\"\"\n    Typed `arviz.InferenceData` for fitted brms models.\n\n    Extends `arviz.InferenceData` with type hints for IDE autocomplete. In brmspy,\n    the fitted model result typically exposes an `.idata` attribute of this type.\n\n    Attributes\n    ----------\n    posterior : xr.Dataset\n        Posterior samples of model parameters.\n    posterior_predictive : xr.Dataset\n        Posterior predictive samples (with observation noise).\n    log_likelihood : xr.Dataset\n        Log-likelihood values for each observation.\n    observed_data : xr.Dataset\n        Original observed response data.\n    coords : dict\n        Coordinate mappings for dimensions (inherited from `arviz.InferenceData`).\n    dims : dict\n        Dimension specifications for variables (inherited from `arviz.InferenceData`).\n\n    See Also\n    --------\n    brmspy.brms.brm : Creates fitted model results (alias: `brmspy.brms.fit`).\n    arviz.InferenceData : Base class documentation.\n\n    Examples\n    --------\n    ```python\n    from brmspy import brms\n\n    model = brms.brm(\"y ~ x\", data=df, chains=4)\n\n    # Type checking and autocomplete\n    assert isinstance(model.idata, IDFit)\n    print(model.idata.posterior)\n    ```\n    \"\"\"\n\n    posterior: xr.Dataset\n    posterior_predictive: xr.Dataset\n    log_likelihood: xr.Dataset\n    observed_data: xr.Dataset\n    coords: xr.Dataset\n    dims: xr.Dataset\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.IDBrm-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.IDBrm.posterior","title":"<code>posterior</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.IDBrm.posterior_predictive","title":"<code>posterior_predictive</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.IDBrm.log_likelihood","title":"<code>log_likelihood</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.IDBrm.observed_data","title":"<code>observed_data</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.IDBrm.coords","title":"<code>coords</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.IDBrm.dims","title":"<code>dims</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def py_to_r(obj: PyObject) -&gt; Sexp:\n    \"\"\"\n    Convert arbitrary Python objects to R objects via rpy2.\n\n    Comprehensive converter that handles nested structures (dicts, lists),\n    DataFrames, arrays, and scalars. Uses rpy2's converters with special\n    handling for dictionaries (\u2192 R named lists) and lists of dicts.\n\n    Parameters\n    ----------\n    obj : any\n        Python object to convert. Supported types:\n        - None \u2192 R NULL\n        - dict \u2192 R named list (ListVector), recursively\n        - list/tuple of dicts \u2192 R list of named lists\n        - list/tuple (other) \u2192 R vector or list\n        - pd.DataFrame \u2192 R data.frame\n        - np.ndarray \u2192 R vector/matrix\n        - scalars (int, float, str, bool) \u2192 R atomic types\n\n    Returns\n    -------\n    rpy2 R object\n        R representation of the Python object\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **None**: \u2192 R NULL\n    2. **DataFrames**: \u2192 R data.frame (via pandas2ri)\n    3. **Dictionaries**: \u2192 R named list (ListVector), recursively converting values\n    4. **Lists of dicts**: \u2192 R list with 1-based indexed names containing named lists\n    5. **Other lists/tuples**: \u2192 R vectors or lists (via rpy2 default)\n    6. **NumPy arrays**: \u2192 R vectors/matrices (via numpy2ri)\n    7. **Scalars**: \u2192 R atomic values\n\n    **Recursive Conversion:**\n\n    Dictionary values are recursively converted, allowing nested structures:\n    ```python\n    {'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n    ```\n\n    **List of Dicts:**\n\n    Lists containing only dicts are converted to R lists with 1-based indexing:\n    ```python\n    [{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n    ```\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import py_to_r\n    import numpy as np\n    import pandas as pd\n\n    # Scalars\n    py_to_r(5)        # R: 5\n    py_to_r(\"hello\")  # R: \"hello\"\n    py_to_r(None)     # R: NULL\n\n    # Arrays\n    py_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n    # DataFrames\n    df = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\n    py_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n    ```\n\n    See Also\n    --------\n    r_to_py : Convert R objects back to Python\n    kwargs_r : Convert keyword arguments dict for R function calls\n    brmspy.brms.fit : Uses this for converting data to R\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if obj is None:\n        return ro.NULL\n\n    if isinstance(obj, ro.Sexp):\n        return obj\n\n    if isinstance(obj, RListVectorExtension) and isinstance(obj.r, ro.Sexp):\n        return obj.r\n\n    _type = type(obj)\n    converter = None\n\n    if _type in _registry._PY2R_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._PY2R_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._PY2R_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._PY2R_CONVERTERS) &gt; 0, \"NO PY2R CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.r_to_py","title":"<code>r_to_py(obj, shm=None)</code>","text":"<p>Convert R objects to Python objects via rpy2.</p> <p>Comprehensive converter that handles R lists (named/unnamed), vectors, formulas, and language objects. Provides sensible Python equivalents for all R types with special handling for edge cases.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>rpy2 R object</code> <p>R object to convert to Python</p> required <p>Returns:</p> Type Description <code>any</code> <p>Python representation of the R object: - R NULL \u2192 None - Named list \u2192 dict (recursively) - Unnamed list \u2192 list (recursively) - Length-1 vector \u2192 scalar (int, float, str, bool) - Length-N vector \u2192 list of scalars - Formula/Language object \u2192 str (descriptive representation) - Other objects \u2192 default rpy2 conversion or str fallback</p> Notes <p>Conversion Rules:</p> <ol> <li>R NULL: \u2192 Python None</li> <li>Atomic vectors (numeric, character, logical):</li> <li>Length 1: \u2192 Python scalar (int, float, str, bool)</li> <li>Length &gt;1: \u2192 Python list of scalars</li> <li>Named lists (ListVector with names): \u2192 Python dict, recursively</li> <li>Unnamed lists: \u2192 Python list, recursively</li> <li>Formulas (e.g., <code>y ~ x</code>): \u2192 String representation</li> <li>Language objects (calls, expressions): \u2192 String representation</li> <li>Functions: \u2192 String representation</li> <li>Everything else: Try default rpy2 conversion, fallback to string</li> </ol> <p>Recursive Conversion:</p> <p>List elements and dictionary values are recursively converted: <pre><code>list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n</code></pre></p> <p>Safe Fallback:</p> <p>R language objects, formulas, and functions are converted to descriptive strings rather than attempting complex conversions that might fail.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import r_to_py\nimport rpy2.robjects as ro\n\n# R NULL\nr_to_py(ro.NULL)  # None\n\n# Scalars\nr_to_py(ro.IntVector([5]))    # 5\nr_to_py(ro.FloatVector([3.14]))  # 3.14\nr_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n# Vectors\nr_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n</code></pre> See Also <p>py_to_r : Convert Python objects to R brmspy.brms.summary : Returns Python-friendly summary dict</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def r_to_py(obj: Sexp, shm: ShmPool | None = None) -&gt; PyObject:\n    \"\"\"\n    Convert R objects to Python objects via rpy2.\n\n    Comprehensive converter that handles R lists (named/unnamed), vectors,\n    formulas, and language objects. Provides sensible Python equivalents\n    for all R types with special handling for edge cases.\n\n    Parameters\n    ----------\n    obj : rpy2 R object\n        R object to convert to Python\n\n    Returns\n    -------\n    any\n        Python representation of the R object:\n        - R NULL \u2192 None\n        - Named list \u2192 dict (recursively)\n        - Unnamed list \u2192 list (recursively)\n        - Length-1 vector \u2192 scalar (int, float, str, bool)\n        - Length-N vector \u2192 list of scalars\n        - Formula/Language object \u2192 str (descriptive representation)\n        - Other objects \u2192 default rpy2 conversion or str fallback\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **R NULL**: \u2192 Python None\n    2. **Atomic vectors** (numeric, character, logical):\n       - Length 1: \u2192 Python scalar (int, float, str, bool)\n       - Length &gt;1: \u2192 Python list of scalars\n    3. **Named lists** (ListVector with names): \u2192 Python dict, recursively\n    4. **Unnamed lists**: \u2192 Python list, recursively\n    5. **Formulas** (e.g., `y ~ x`): \u2192 String representation\n    6. **Language objects** (calls, expressions): \u2192 String representation\n    7. **Functions**: \u2192 String representation\n    8. **Everything else**: Try default rpy2 conversion, fallback to string\n\n    **Recursive Conversion:**\n\n    List elements and dictionary values are recursively converted:\n    ```R\n    list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n    ```\n\n    **Safe Fallback:**\n\n    R language objects, formulas, and functions are converted to descriptive\n    strings rather than attempting complex conversions that might fail.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import r_to_py\n    import rpy2.robjects as ro\n\n    # R NULL\n    r_to_py(ro.NULL)  # None\n\n    # Scalars\n    r_to_py(ro.IntVector([5]))    # 5\n    r_to_py(ro.FloatVector([3.14]))  # 3.14\n    r_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n    # Vectors\n    r_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n    ```\n\n    See Also\n    --------\n    py_to_r : Convert Python objects to R\n    brmspy.brms.summary : Returns Python-friendly summary dict\n    \"\"\"\n    import rpy2.robjects as ro\n\n    from brmspy._singleton._shm_singleton import _get_shm\n\n    if obj is ro.NULL:\n        return None\n\n    _type = type(obj)\n    converter = None\n\n    if shm is None:\n        shm = _get_shm()\n\n    if _type in _registry._R2PY_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._R2PY_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._R2PY_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._R2PY_CONVERTERS) &gt; 0, \"NO R2PY CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj, shm)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._coerce_stan_types","title":"<code>_coerce_stan_types(stan_code, stan_data)</code>","text":"<p>Coerce Python numeric types to match Stan data block requirements.</p> <p>Parses the Stan program's data block to determine variable types (int vs real) and automatically coerces Python data to match. Handles both old Stan syntax (<code>int Y[N]</code>) and new array syntax (<code>array[N] int Y</code>). Converts single-element arrays to scalars when appropriate.</p> <p>Parameters:</p> Name Type Description Default <code>stan_code</code> <code>str</code> <p>Complete Stan program code containing a data block</p> required <code>stan_data</code> <code>dict</code> <p>Dictionary of data to pass to Stan, with keys matching Stan variable names</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Type-coerced data dictionary with: - Integer types coerced to int/int64 where Stan expects int - Single-element arrays converted to scalars - Multi-element arrays preserved with correct dtype</p> Notes <p>Stan Type Coercion:</p> <p>Stan requires strict type matching: - <code>int</code> variables must receive integer values - <code>real</code> variables can receive floats - Arrays must have consistent element types</p> <p>Syntax Support:</p> <p>Old Stan syntax (pre-2.26): <pre><code>data {\n  int N;\n  int Y[N];\n  real X[N];\n}\n</code></pre></p> <p>New Stan syntax (2.26+): <pre><code>data {\n  int N;\n  array[N] int Y;\n  array[N] real X;\n}\n</code></pre></p> <p>Scalar Coercion:</p> <p>Single-element numpy arrays are automatically converted to scalars: - <code>np.array([5])</code> \u2192 <code>5</code> - <code>np.array([5.0])</code> \u2192 <code>5.0</code></p> <p>Examples:</p> <pre><code>stan_code = '''\ndata {\n    int N;\n    array[N] int y;\n    array[N] real x;\n}\nmodel {\n    y ~ poisson_log(x);\n}\n'''\n\n# Python data with incorrect types\ndata = {\n    'N': 3.0,  # Should be int\n    'y': np.array([1.5, 2.5, 3.5]),  # Should be int\n    'x': np.array([0.1, 0.2, 0.3])  # OK as real\n}\n\n# Coerce to match Stan requirements\ncoerced = _coerce_stan_types(stan_code, data)\n# Result: {'N': 3, 'y': array([1, 2, 3]), 'x': array([0.1, 0.2, 0.3])}\n</code></pre> See Also <p>brmspy.brms.make_stancode : Generate Stan code from brms formula brmspy.brms.fit : Automatically applies type coercion during fitting</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _coerce_stan_types(stan_code: str, stan_data: dict) -&gt; dict:\n    \"\"\"\n    Coerce Python numeric types to match Stan data block requirements.\n\n    Parses the Stan program's data block to determine variable types (int vs real)\n    and automatically coerces Python data to match. Handles both old Stan syntax\n    (`int Y[N]`) and new array syntax (`array[N] int Y`). Converts single-element\n    arrays to scalars when appropriate.\n\n    Parameters\n    ----------\n    stan_code : str\n        Complete Stan program code containing a data block\n    stan_data : dict\n        Dictionary of data to pass to Stan, with keys matching Stan variable names\n\n    Returns\n    -------\n    dict\n        Type-coerced data dictionary with:\n        - Integer types coerced to int/int64 where Stan expects int\n        - Single-element arrays converted to scalars\n        - Multi-element arrays preserved with correct dtype\n\n    Notes\n    -----\n    **Stan Type Coercion:**\n\n    Stan requires strict type matching:\n    - `int` variables must receive integer values\n    - `real` variables can receive floats\n    - Arrays must have consistent element types\n\n    **Syntax Support:**\n\n    Old Stan syntax (pre-2.26):\n    ```stan\n    data {\n      int N;\n      int Y[N];\n      real X[N];\n    }\n    ```\n\n    New Stan syntax (2.26+):\n    ```stan\n    data {\n      int N;\n      array[N] int Y;\n      array[N] real X;\n    }\n    ```\n\n    **Scalar Coercion:**\n\n    Single-element numpy arrays are automatically converted to scalars:\n    - `np.array([5])` \u2192 `5`\n    - `np.array([5.0])` \u2192 `5.0`\n\n    Examples\n    --------\n\n    ```python\n    stan_code = '''\n    data {\n        int N;\n        array[N] int y;\n        array[N] real x;\n    }\n    model {\n        y ~ poisson_log(x);\n    }\n    '''\n\n    # Python data with incorrect types\n    data = {\n        'N': 3.0,  # Should be int\n        'y': np.array([1.5, 2.5, 3.5]),  # Should be int\n        'x': np.array([0.1, 0.2, 0.3])  # OK as real\n    }\n\n    # Coerce to match Stan requirements\n    coerced = _coerce_stan_types(stan_code, data)\n    # Result: {'N': 3, 'y': array([1, 2, 3]), 'x': array([0.1, 0.2, 0.3])}\n    ```\n\n    See Also\n    --------\n    brmspy.brms.make_stancode : Generate Stan code from brms formula\n    brmspy.brms.fit : Automatically applies type coercion during fitting\n    \"\"\"\n    pat_data = re.compile(r\"(?&lt;=data {)[^}]*\")\n    pat_identifiers = re.compile(r\"([\\w]+)\")\n\n    # Extract the data block and separate lines\n    data_lines = pat_data.findall(stan_code)[0].split(\"\\n\")\n\n    # Remove comments, &lt;&gt;-style bounds and []-style data size declarations\n    data_lines_no_comments = [l.split(\"//\")[0] for l in data_lines]\n    data_lines_no_bounds = [re.sub(\"&lt;[^&gt;]+&gt;\", \"\", l) for l in data_lines_no_comments]\n    data_lines_no_sizes = [re.sub(r\"\\[[^&gt;]+\\]\", \"\", l) for l in data_lines_no_bounds]\n\n    # Extract identifiers and handle both old and new Stan syntax\n    # Old: int Y; or int Y[N]; -&gt; type is first identifier\n    # New: array[N] int Y; -&gt; type is second identifier (after 'array')\n    identifiers = [pat_identifiers.findall(l) for l in data_lines_no_sizes]\n\n    var_types = []\n    var_names = []\n    for tokens in identifiers:\n        if len(tokens) == 0:\n            continue\n        # New syntax: array[...] type name\n        if tokens[0] == \"array\" and len(tokens) &gt;= 3:\n            var_types.append(tokens[1])  # Type is second token\n            var_names.append(tokens[-1])  # Name is last token\n        # Old syntax: type name\n        elif len(tokens) &gt;= 2:\n            var_types.append(tokens[0])  # Type is first token\n            var_names.append(tokens[-1])  # Name is last token\n\n    var_dict = dict(zip(var_names, var_types))\n\n    # Coerce integers to int and 1-size arrays to scalars\n    for k, v in stan_data.items():\n        # Convert to numpy array if not already\n        if not isinstance(v, np.ndarray):\n            v = np.asarray(v)\n            stan_data[k] = v\n\n        # First, convert 1-size arrays to scalars\n        if hasattr(v, \"size\") and v.size == 1 and hasattr(v, \"ndim\") and v.ndim &gt; 0:\n            v = v.item()\n            stan_data[k] = v\n\n        # Then coerce to int if Stan expects int\n        if k in var_names and var_dict[k] == \"int\":\n            # Handle both scalars and arrays\n            if isinstance(v, (int, float, np.number)):  # Scalar\n                stan_data[k] = int(v)\n            elif isinstance(v, np.ndarray):  # Array\n                stan_data[k] = v.astype(np.int64)\n\n    return stan_data\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._brmsfit_get_posterior","title":"<code>_brmsfit_get_posterior(brmsfit_obj, **kwargs)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _brmsfit_get_posterior(\n    brmsfit_obj: Sexp, **kwargs\n) -&gt; tuple[dict[str, np.ndarray], Sexp]:\n    import rpy2.robjects as ro\n    from rpy2.robjects import pandas2ri\n    from rpy2.robjects.conversion import localconverter\n\n    # -------------------------------------------------\n    # POSTERIOR (parameters) via posterior::as_draws_df\n    # -------------------------------------------------\n    as_draws_df = cast(Callable, ro.r(\"posterior::as_draws_df\"))\n    draws_r = as_draws_df(brmsfit_obj, **kwargs)\n\n    with localconverter(ro.default_converter + pandas2ri.converter):\n        df = pandas2ri.rpy2py(draws_r)\n\n    chain_col = \".chain\" if \".chain\" in df.columns else \"chain\"\n    draw_col = \".draw\" if \".draw\" in df.columns else \"draw\"\n\n    df[\"draw_idx\"] = df.groupby(chain_col)[draw_col].transform(\n        lambda x: np.arange(len(x), dtype=int)\n    )\n\n    chains = np.sort(df[chain_col].unique())\n    n_chains = len(chains)\n    n_draws = int(df[\"draw_idx\"].max()) + 1\n\n    posterior_dict: dict[str, np.ndarray] = {}\n\n    for col in df.columns:\n        if col in (chain_col, draw_col, \".iteration\", \"draw_idx\"):\n            continue\n\n        mat = (\n            df.pivot(index=\"draw_idx\", columns=chain_col, values=col)\n            .sort_index(axis=0)\n            .reindex(columns=chains)\n            .to_numpy()\n            .T\n        )\n        posterior_dict[col] = mat\n\n    return posterior_dict, draws_r\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._brmsfit_get_response_names","title":"<code>_brmsfit_get_response_names(brmsfit_obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _brmsfit_get_response_names(brmsfit_obj) -&gt; list[str]:\n    import rpy2.robjects as ro\n\n    # ------------------------------\n    # RESPONSE NAMES via brmsterms()\n    # ------------------------------\n    resp_names: list[str] = []\n    try:\n        # Method 1: Use brmsterms to get response variable names\n        r_code = \"\"\"\n        function(fit) {\n            bterms &lt;- brms::brmsterms(fit$formula)\n            if (inherits(bterms, \"mvbrmsterms\")) {\n                # Multivariate: extract response names from each term\n                names(bterms$terms)\n            } else {\n                # Univariate: get the single response\n                resp &lt;- bterms$respform\n                if (!is.null(resp)) {\n                    all.vars(resp)[1]\n                } else {\n                    # Fallback: parse from formula\n                    all.vars(fit$formula$formula)[1]\n                }\n            }\n        }\n        \"\"\"\n        get_resp_names = cast(Callable, ro.r(r_code))\n        resp_r = get_resp_names(brmsfit_obj)\n        resp_names = list(resp_r)\n    except Exception as e:\n        log_warning(\n            f\"[brmsfit_to_idata] Could not get response names via brmsterms: {e}\"\n        )\n\n        # Fallback: try to extract from model formula directly\n        try:\n            r_fallback = \"\"\"\n            function(fit) {\n                # Try to get response names from the model's data\n                y &lt;- brms::get_y(fit)\n                if (is.matrix(y) || is.data.frame(y)) {\n                    colnames(y)\n                } else if (!is.null(names(y))) {\n                    unique(names(y))[1]\n                } else {\n                    \"y\"\n                }\n            }\n            \"\"\"\n            get_resp_fallback = cast(Callable, ro.r(r_fallback))\n            resp_r = get_resp_fallback(brmsfit_obj)\n            if hasattr(resp_r, \"__iter__\") and not isinstance(resp_r, str):\n                resp_names = [str(r) for r in resp_r if r is not None]\n            else:\n                resp_names = [str(resp_r)]\n        except Exception as e2:\n            log_warning(f\"[brmsfit_to_idata] Fallback also failed: {e2}\")\n\n    return resp_names\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._is_unique","title":"<code>_is_unique(values)</code>","text":"<p>Return True if all values are unique (no duplicates).</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _is_unique(values) -&gt; bool:\n    \"\"\"Return True if all values are unique (no duplicates).\"\"\"\n    # np.unique is fine here; values are small-ish 1D vectors\n    vals = np.asarray(values)\n    return np.unique(vals).size == vals.size\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._get_obs_id_from_r_data","title":"<code>_get_obs_id_from_r_data(r_data, n_obs)</code>","text":"<p>Decide obs_id for in-sample data from brmsfit$data.</p> <p>Priority: 1. <code>_obs_id_</code> column if present and unique. 2. rownames if present and unique. 3. fallback: np.arange(n_obs).</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _get_obs_id_from_r_data(r_data, n_obs: int):\n    \"\"\"\n    Decide obs_id for in-sample data from brmsfit$data.\n\n    Priority:\n    1. `_obs_id_` column if present and unique.\n    2. rownames if present and unique.\n    3. fallback: np.arange(n_obs).\n    \"\"\"\n    import rpy2.robjects as ro\n\n    fun_colnames = cast(Callable, ro.r(\"colnames\"))\n    fun_rownames = cast(Callable, ro.r(\"rownames\"))\n    colnames = list(cast(ro.ListVector, fun_colnames(r_data)))\n\n    # 1) explicit obs_id column\n    if \"_obs_id_\" in colnames:\n        obs_col = np.asarray(r_data.rx2(\"_obs_id_\"))\n        if _is_unique(obs_col):\n            return obs_col\n        else:\n            log_warning(\n                \"Column '_obs_id_' in brmsfit$data is not unique; \"\n                \"falling back to rownames or sequential indices.\"\n            )\n    elif \"obs_id\" in colnames:\n        obs_col = np.asarray(r_data.rx2(\"obs_id\"))\n        if _is_unique(obs_col):\n            return obs_col\n        else:\n            log_warning(\n                \"Column 'obs_id' in brmsfit$data is not unique; \"\n                \"falling back to rownames or sequential indices.\"\n            )\n\n    # 2) unique rownames\n    rownames = np.asarray(fun_rownames(r_data))\n    if len(rownames) == n_obs and _is_unique(rownames):\n        return rownames\n\n    # 3) fallback: 0-based integer index\n    log_warning(\n        \"Unable to find a unique obs_id in brmsfit$data \"\n        \"(no unique '_obs_id_'/'obs_id' column or rownames). \"\n        \"Using sequential indices 0..N-1.\"\n    )\n    return np.arange(n_obs, dtype=np.int64)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._get_obs_id_from_newdata","title":"<code>_get_obs_id_from_newdata(newdata, n_obs)</code>","text":"<p>Decide obs_id for newdata (out-of-sample).</p> <p>Priority: 1. <code>obs_id</code> column if present and unique. 2. newdata.index (with warning if not unique).</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _get_obs_id_from_newdata(newdata: pd.DataFrame, n_obs: int):\n    \"\"\"\n    Decide obs_id for newdata (out-of-sample).\n\n    Priority:\n    1. `obs_id` column if present and unique.\n    2. newdata.index (with warning if not unique).\n    \"\"\"\n    if \"_obs_id_\" in newdata.columns:\n        obs_col = newdata[\"_obs_id_\"].to_numpy()\n        if _is_unique(obs_col):\n            return obs_col\n        else:\n            log_warning(\n                \"Column '_obs_id_' in newdata is not unique; \"\n                \"falling back to DataFrame index.\"\n            )\n    elif \"obs_id\" in newdata.columns:\n        obs_col = newdata[\"obs_id\"].to_numpy()\n        if _is_unique(obs_col):\n            return obs_col\n        else:\n            log_warning(\n                \"Column 'obs_id' in newdata is not unique; \"\n                \"falling back to DataFrame index.\"\n            )\n\n    index_vals = newdata.index.to_numpy()\n    if not _is_unique(index_vals):\n        log_warning(\n            \"newdata.index is not unique; using it as obs_id anyway. \"\n            \"This may cause ambiguous mapping in ArviZ.\"\n        )\n    return index_vals\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._brmsfit_get_dims_and_coords","title":"<code>_brmsfit_get_dims_and_coords(brmsfit_obj, newdata=None, resp_names=None)</code>","text":"<p>Infer dims/coords for ArviZ from a brmsfit object and optional newdata.</p> <p>Rules for obs_id: - If newdata is None:     1) If <code>obs_id</code> column exists in <code>fit$data</code> and is unique: use that.     2) Else, if rownames of <code>fit$data</code> are unique: use those.     3) Else: use a sequential integer range [0, N). - If newdata is not None:     1) If <code>obs_id</code> column exists in newdata and is unique: use that.     2) Else: use newdata.index (with a warning if not unique).</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _brmsfit_get_dims_and_coords(\n    brmsfit_obj,\n    newdata: None | pd.DataFrame = None,\n    resp_names: None | list[str] = None,\n) -&gt; tuple[TypeDims, TypeCoords]:\n    \"\"\"\n    Infer dims/coords for ArviZ from a brmsfit object and optional newdata.\n\n    Rules for obs_id:\n    - If newdata is None:\n        1) If `obs_id` column exists in `fit$data` and is unique: use that.\n        2) Else, if rownames of `fit$data` are unique: use those.\n        3) Else: use a sequential integer range [0, N).\n    - If newdata is not None:\n        1) If `obs_id` column exists in newdata and is unique: use that.\n        2) Else: use newdata.index (with a warning if not unique).\n    \"\"\"\n    import rpy2.robjects as ro\n\n    fun_nrow = cast(Callable, ro.r(\"nrow\"))\n\n    if resp_names is None:\n        resp_names = _brmsfit_get_response_names(brmsfit_obj)\n\n    if newdata is None:\n        # in-sample: look at brmsfit$data\n        r_data = brmsfit_obj.rx2(\"data\")\n        n_obs = int(fun_nrow(r_data)[0])\n\n        obs_id = _get_obs_id_from_r_data(r_data, n_obs)\n\n    else:\n        # out-of-sample: look at newdata\n        n_obs = int(len(newdata))\n        obs_id = _get_obs_id_from_newdata(newdata, n_obs)\n\n    obs_id_arr = np.asarray(obs_id)\n\n    dims: TypeDims = {}\n    coords: TypeCoords = {}\n\n    coords[\"obs_id\"] = obs_id_arr\n\n    for resp in resp_names:\n        dims[resp] = [\"obs_id\"]\n\n    # you can add more dims/coords for responses here later\n    # e.g. multi-response mapping, etc.\n\n    return dims, coords\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._brmsfit_get_observed_data","title":"<code>_brmsfit_get_observed_data(brmsfit_obj, resp_names=None)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _brmsfit_get_observed_data(\n    brmsfit_obj, resp_names: None | list[str] = None\n) -&gt; dict[str, np.ndarray]:\n    import rpy2.robjects as ro\n    from rpy2.robjects import pandas2ri\n    from rpy2.robjects.conversion import localconverter\n\n    if resp_names is None:\n        resp_names = _brmsfit_get_response_names(brmsfit_obj)\n\n    observed_data_dict: dict[str, np.ndarray] = {}\n    n_obs = 0\n\n    try:\n        r_get_y = cast(Callable, ro.r(\"brms::get_y\"))\n        y_r = r_get_y(brmsfit_obj)\n\n        with localconverter(ro.default_converter + pandas2ri.converter):\n            y_py = pandas2ri.rpy2py(y_r)\n\n        if isinstance(y_py, pd.DataFrame):\n            n_obs = y_py.shape[0]\n            if not resp_names:\n                resp_names = list(y_py.columns)\n            for resp in resp_names:\n                if resp in y_py.columns:\n                    observed_data_dict[resp] = y_py[resp].to_numpy()\n\n        elif isinstance(y_py, pd.Series):\n            n_obs = y_py.shape[0]\n            if not resp_names:\n                resp_names = [str(y_py.name) or \"y\"]\n            observed_data_dict[resp_names[0]] = y_py.to_numpy()\n\n        else:\n            arr = np.asarray(y_py)\n            if arr.ndim == 1:\n                n_obs = arr.shape[0]\n                if not resp_names:\n                    resp_names = [\"y\"]\n                observed_data_dict[resp_names[0]] = arr\n            elif arr.ndim == 2:\n                n_obs, k = arr.shape\n                if not resp_names:\n                    resp_names = [f\"y_{j}\" for j in range(k)]\n                for j, resp in enumerate(resp_names):\n                    observed_data_dict[resp] = arr[:, j]\n\n    except Exception as e:\n        log_warning(f\"[brmsfit_to_idata] Could not extract observed data: {e}\")\n\n    return observed_data_dict\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._reshape_to_arviz","title":"<code>_reshape_to_arviz(values, n_chains, n_draws)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _reshape_to_arviz(values: np.ndarray, n_chains: int, n_draws: int) -&gt; np.ndarray:\n    values = np.asarray(values)\n    total = values.shape[0]\n    expected = n_chains * n_draws\n    if total != expected:\n        raise ValueError(f\"Expected {expected} rows (chains*draws), got {total}\")\n    new_shape = (n_chains, n_draws) + values.shape[1:]\n    return values.reshape(new_shape)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._brmsfit_get_counts","title":"<code>_brmsfit_get_counts(brmsfit_obj)</code>","text":"<p>returns (ndraws, nchains) ndraws - draws per chain</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _brmsfit_get_counts(brmsfit_obj: Sexp) -&gt; tuple[int, int]:\n    \"\"\"\n    returns (ndraws, nchains)\n    ndraws - draws per chain\n    \"\"\"\n    import rpy2.robjects as ro\n\n    fun_ndraws = cast(Callable, ro.r(\"posterior::ndraws\"))\n    fun_nchains = cast(Callable, ro.r(\"posterior::nchains\"))\n\n    ndraws = int(fun_ndraws(brmsfit_obj)[0])\n    nchains = int(fun_nchains(brmsfit_obj)[0])\n\n    ndraws = ndraws // nchains\n\n    return nchains, ndraws\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._brmsfit_get_predict_generic","title":"<code>_brmsfit_get_predict_generic(brmsfit_obj, function='brms::posterior_predict', resp_names=None, **kwargs)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _brmsfit_get_predict_generic(\n    brmsfit_obj,\n    function: Literal[\n        \"brms::posterior_predict\",\n        \"brms::log_lik\",\n        \"brms::posterior_linpred\",\n        \"brms::posterior_epred\",\n    ] = \"brms::posterior_predict\",\n    resp_names: None | list[str] = None,\n    **kwargs,\n) -&gt; tuple[dict[str, np.ndarray], Sexp | dict[str, Sexp]]:\n    import rpy2.robjects as ro\n\n    if resp_names is None:\n        resp_names = _brmsfit_get_response_names(brmsfit_obj)\n\n    nchains, ndraws = _brmsfit_get_counts(brmsfit_obj)\n\n    post_pred_dict: dict[str, np.ndarray] = {}\n\n    r: dict[str, Sexp] | Sexp = ro.NULL\n    try:\n        r_pp_wrapper = cast(Callable, ro.r(function))\n\n        if not resp_names:\n            # No response names found - univariate default\n            pp_r = r_pp_wrapper(brmsfit_obj, **kwargs)\n            r = pp_r\n            post_pred_dict[\"y\"] = _reshape_to_arviz(np.asarray(pp_r), nchains, ndraws)\n\n        elif len(resp_names) == 1:\n            # Single response\n            resp = resp_names[0]\n            pp_r = r_pp_wrapper(\n                brmsfit_obj, **kwargs, resp=resp\n            )  # Pass as plain string\n            r = pp_r\n            post_pred_dict[resp] = _reshape_to_arviz(np.asarray(pp_r), nchains, ndraws)\n\n        else:\n            # Multivariate: loop over response names\n            r = {}\n            for resp in resp_names:\n                pp_r = r_pp_wrapper(\n                    brmsfit_obj, **kwargs, resp=resp\n                )  # Pass as plain string!\n                post_pred_dict[resp] = _reshape_to_arviz(\n                    np.asarray(pp_r), nchains, ndraws\n                )\n                r[resp] = pp_r\n\n    except Exception as e:\n        log_warning(\n            f\"[brmsfit_to_idata] Could not extract posterior predictive/log_lik: {e}\"\n        )\n        import traceback\n\n        traceback.print_exc()\n\n    return post_pred_dict, r\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._brmsfit_get_constant_data","title":"<code>_brmsfit_get_constant_data(brmsfit_obj, newdata=None, resp_names=None)</code>","text":"<p>Extract constant_data for ArviZ.</p> <ul> <li>If newdata is None: use brmsfit$data.</li> <li>Else: use the provided newdata.</li> <li>Drop response columns and 'obs_id' (responses go to observed_data,   obs_id is handled as a coord).</li> <li>Return a dict[var_name -&gt; np.ndarray] with length N (N = number of rows).</li> </ul> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _brmsfit_get_constant_data(\n    brmsfit_obj,\n    newdata: None | pd.DataFrame = None,\n    resp_names: None | list[str] = None,\n) -&gt; dict[str, np.ndarray]:\n    \"\"\"\n    Extract constant_data for ArviZ.\n\n    - If newdata is None: use brmsfit$data.\n    - Else: use the provided newdata.\n    - Drop response columns and 'obs_id' (responses go to observed_data,\n      obs_id is handled as a coord).\n    - Return a dict[var_name -&gt; np.ndarray] with length N (N = number of rows).\n    \"\"\"\n    import rpy2.robjects as ro\n    from rpy2.robjects import pandas2ri\n    from rpy2.robjects.conversion import localconverter\n\n    if resp_names is None:\n        resp_names = _brmsfit_get_response_names(brmsfit_obj)\n\n    if newdata is None:\n        # in-sample: use brmsfit$data (R data.frame) -&gt; pandas.DataFrame\n        r_data = brmsfit_obj.rx2(\"data\")\n        with localconverter(ro.default_converter + pandas2ri.converter):\n            df = pandas2ri.rpy2py(r_data)\n        if not isinstance(df, pd.DataFrame):\n            df = pd.DataFrame(df)\n    else:\n        # out-of-sample: use newdata as given\n        df = newdata.copy()\n\n    # Ensure we don't accidentally mutate caller's frame\n    df = df.copy()\n\n    # Drop response variables if present\n    drop_cols: set[str] = set(resp_names or [])\n\n    # Drop obs_id column if present; obs_id is handled as a coord\n    if \"_obs_id_\" in df.columns:\n        df = df.set_index(\"_obs_id_\", drop=True)\n\n    keep_cols = [c for c in df.columns if c not in drop_cols]\n\n    constant_data: dict[str, np.ndarray] = {}\n    for col in keep_cols:\n        # Just pass through whatever dtype it has; xarray can handle object too\n        constant_data[col] = df[col].to_numpy()\n\n    return constant_data\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._arviz_add_constant_data","title":"<code>_arviz_add_constant_data(idata, constant_data_dict, group_name='constant_data', obs_id=None)</code>","text":"<p>Add a non-draw group (constant_data or predictions_constant_data) to an idata.</p> <p>Extracts obs_id coords directly from the existing idata. This avoids ArviZ's auto (chain, draw) dims and keeps the group purely 1D along obs_id.</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _arviz_add_constant_data(\n    idata: az.InferenceData,\n    constant_data_dict: dict[str, np.ndarray],\n    group_name: Literal[\"constant_data\", \"predictions_constant_data\"] = \"constant_data\",\n    obs_id: None | list[str] | np.ndarray = None,\n) -&gt; az.InferenceData:\n    \"\"\"\n    Add a non-draw group (constant_data or predictions_constant_data) to an idata.\n\n    Extracts obs_id coords directly from the existing idata. This avoids ArviZ's\n    auto (chain, draw) dims and keeps the group purely 1D along obs_id.\n    \"\"\"\n    if not constant_data_dict:\n        return idata\n\n    # ---- 1) Extract obs_id coords from any existing group ----\n    if obs_id is None:\n        for group in idata.groups():\n            ds = idata[group]\n            if ds is not None and \"obs_id\" in ds.coords:\n                obs_id = ds.coords[\"obs_id\"].values\n                break\n\n        if obs_id is None:\n            raise ValueError(\n                \"Could not locate 'obs_id' in any existing idata group; \"\n                \"cannot attach constant_data.\"\n            )\n\n    # ---- 2) Build dims &amp; coords for the new constant group ----\n    const_dims = {name: [\"obs_id\"] for name in constant_data_dict.keys()}\n    const_coords = {\"obs_id\": obs_id}\n\n    # ---- 3) Build a small InferenceData and extend ----\n    if group_name == \"constant_data\":\n        const_idata = az.from_dict(\n            constant_data=constant_data_dict, coords=const_coords, dims=const_dims\n        )\n    else:\n        const_idata = az.from_dict(\n            predictions_constant_data=constant_data_dict,\n            coords=const_coords,\n            dims=const_dims,\n        )\n\n    idata.extend(const_idata)\n    return idata\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion._idata_add_resp_names_suffix","title":"<code>_idata_add_resp_names_suffix(idata, suffix, resp_names)</code>","text":"<p>In-place: append <code>suffix</code> to all variables in <code>resp_names</code> across all applicable InferenceData groups.</p> <p>Mutates <code>idata</code> directly.</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def _idata_add_resp_names_suffix(\n    idata: az.InferenceData,\n    suffix: str,\n    resp_names: list[str],\n) -&gt; None:\n    \"\"\"\n    In-place: append `suffix` to all variables in `resp_names` across all\n    applicable InferenceData groups.\n\n    Mutates `idata` directly.\n    \"\"\"\n    if not suffix or not resp_names:\n        return\n\n    for group in idata.groups():\n        ds = getattr(idata, group, None)\n        if ds is None:\n            continue\n\n        rename_map = {\n            resp: f\"{resp}{suffix}\" for resp in resp_names if resp in ds.data_vars\n        }\n\n        if rename_map:\n            ds = ds.rename(rename_map)\n            setattr(idata, group, ds)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.brmsfit_to_idata","title":"<code>brmsfit_to_idata(brmsfit_obj, model_data=None)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def brmsfit_to_idata(brmsfit_obj, model_data=None) -&gt; IDBrm:\n    posterior_dict, _ = _brmsfit_get_posterior(brmsfit_obj)\n    resp_names = _brmsfit_get_response_names(brmsfit_obj)\n    dims, coords = _brmsfit_get_dims_and_coords(brmsfit_obj, resp_names=resp_names)\n    observed_data_dict = _brmsfit_get_observed_data(brmsfit_obj, resp_names)\n    post_pred_dict, _ = _brmsfit_get_predict_generic(\n        brmsfit_obj, function=\"brms::posterior_predict\", resp_names=resp_names\n    )\n    log_lik_dict, _ = _brmsfit_get_predict_generic(\n        brmsfit_obj, function=\"brms::log_lik\", resp_names=resp_names\n    )\n    constant_data_dict = _brmsfit_get_constant_data(\n        brmsfit_obj, newdata=None, resp_names=resp_names\n    )\n    for name in constant_data_dict:\n        if name not in dims:\n            dims[name] = [\"obs_id\"]\n\n    idata = az.from_dict(\n        posterior=posterior_dict,\n        posterior_predictive=post_pred_dict or None,\n        log_likelihood=log_lik_dict or None,\n        observed_data=observed_data_dict or None,\n        coords=coords or None,\n        constant_data=constant_data_dict or None,\n        dims=dims or None,\n    )\n\n    return cast(IDBrm, idata)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_conversion/#brmspy.helpers._rpy2._conversion.kwargs_r","title":"<code>kwargs_r(kwargs)</code>","text":"<p>Convert Python keyword arguments to R-compatible format.</p> <p>Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict or None</code> <p>Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with same keys but R-compatible values, or empty dict if None</p> Notes <p>This is a thin wrapper around <code>py_to_r()</code> that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import kwargs_r\nimport pandas as pd\nimport numpy as np\n\n# Prepare kwargs for R function\npy_kwargs = {\n    'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n    'prior': {'b': [0, 1]},\n    'chains': 4,\n    'iter': 2000\n}\n\nr_kwargs = kwargs_r(py_kwargs)\n# All values converted to R objects\n# Can now call: r_function(**r_kwargs)\n</code></pre> See Also <p>py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R</p> Source code in <code>brmspy/helpers/_rpy2/_conversion.py</code> <pre><code>def kwargs_r(kwargs: dict | None) -&gt; dict:\n    \"\"\"\n    Convert Python keyword arguments to R-compatible format.\n\n    Convenience function that applies py_to_r() to all values in a\n    keyword arguments dictionary, preparing them for R function calls.\n\n    Parameters\n    ----------\n    kwargs : dict or None\n        Dictionary of keyword arguments where values may be Python objects\n        (dicts, lists, DataFrames, arrays, etc.)\n\n    Returns\n    -------\n    dict\n        Dictionary with same keys but R-compatible values, or empty dict if None\n\n    Notes\n    -----\n    This is a thin wrapper around `py_to_r()` that operates on dictionaries.\n    It's commonly used to prepare keyword arguments for R function calls via rpy2.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import kwargs_r\n    import pandas as pd\n    import numpy as np\n\n    # Prepare kwargs for R function\n    py_kwargs = {\n        'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n        'prior': {'b': [0, 1]},\n        'chains': 4,\n        'iter': 2000\n    }\n\n    r_kwargs = kwargs_r(py_kwargs)\n    # All values converted to R objects\n    # Can now call: r_function(**r_kwargs)\n    ```\n\n    See Also\n    --------\n    py_to_r : Underlying conversion function for individual values\n    brmspy.brms.fit : Uses this to prepare user kwargs for R\n    \"\"\"\n    if kwargs is None:\n        return {}\n    return {k: py_to_r(v) for k, v in kwargs.items()}\n</code></pre>"},{"location":"internals/helpers/_rpy2/_priors/","title":"_priors","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors-classes","title":"Classes","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec","title":"<code>PriorSpec</code>  <code>dataclass</code>","text":"<p>Python representation of a brms prior specification.</p> <p>This dataclass provides a typed interface to <code>brms::prior_string()</code> arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the <code>prior()</code> factory function to create instances.</p> <p>Attributes:</p> Name Type Description <code>prior</code> <code>str</code> <p>Prior distribution as string (e.g., <code>\"normal(0, 1)\"</code>, <code>\"exponential(2)\"</code>).</p> <code>class_</code> <code>(str, optional)</code> <p>Parameter class: <code>\"b\"</code> (fixed effects), <code>\"sd\"</code> (group SD), <code>\"Intercept\"</code>, <code>\"sigma\"</code>, <code>\"cor\"</code>, etc.</p> <code>coef</code> <code>(str, optional)</code> <p>Specific coefficient name for class-level priors.</p> <code>group</code> <code>(str, optional)</code> <p>Grouping variable for hierarchical effects.</p> <code>dpar</code> <code>(str, optional)</code> <p>Distributional parameter (e.g., <code>\"sigma\"</code>, <code>\"phi\"</code>, <code>\"zi\"</code>).</p> <code>resp</code> <code>(str, optional)</code> <p>Response variable for multivariate models.</p> <code>nlpar</code> <code>(str, optional)</code> <p>Non-linear parameter name.</p> <code>lb</code> <code>(float, optional)</code> <p>Lower bound for truncated priors.</p> <code>ub</code> <code>(float, optional)</code> <p>Upper bound for truncated priors.</p> See Also <p>prior : Factory function to create <code>PriorSpec</code> instances. brms::prior_string : R documentation</p> <p>Examples:</p> <p>Create prior specifications (prefer using <code>prior()</code>):</p> <pre><code>from brmspy.types import PriorSpec\n\n# Fixed effect prior\np1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n# Group-level SD prior\np2 = PriorSpec(prior=\"exponential(2)\", class_=\"sd\", group=\"patient\")\n\n# Coefficient-specific prior with bounds\np3 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\", coef=\"age\", lb=0)\n</code></pre> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass(frozen=True)\nclass PriorSpec:\n    \"\"\"\n    Python representation of a brms prior specification.\n\n    This dataclass provides a typed interface to `brms::prior_string()` arguments,\n    allowing Python developers to specify priors with IDE autocomplete and type\n    checking. Use the [`prior()`][brmspy.brms.prior] factory function to create\n    instances.\n\n    Attributes\n    ----------\n    prior : str\n        Prior distribution as string (e.g., ``\"normal(0, 1)\"``, ``\"exponential(2)\"``).\n    class_ : str, optional\n        Parameter class: ``\"b\"`` (fixed effects), ``\"sd\"`` (group SD),\n        ``\"Intercept\"``, ``\"sigma\"``, ``\"cor\"``, etc.\n    coef : str, optional\n        Specific coefficient name for class-level priors.\n    group : str, optional\n        Grouping variable for hierarchical effects.\n    dpar : str, optional\n        Distributional parameter (e.g., ``\"sigma\"``, ``\"phi\"``, ``\"zi\"``).\n    resp : str, optional\n        Response variable for multivariate models.\n    nlpar : str, optional\n        Non-linear parameter name.\n    lb : float, optional\n        Lower bound for truncated priors.\n    ub : float, optional\n        Upper bound for truncated priors.\n\n    See Also\n    --------\n    prior : Factory function to create `PriorSpec` instances.\n    brms::prior_string : [R documentation](https://paulbuerkner.com/brms/reference/prior_string.html)\n\n    Examples\n    --------\n    Create prior specifications (prefer using [`prior()`][brmspy.brms.prior]):\n\n    ```python\n    from brmspy.types import PriorSpec\n\n    # Fixed effect prior\n    p1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n    # Group-level SD prior\n    p2 = PriorSpec(prior=\"exponential(2)\", class_=\"sd\", group=\"patient\")\n\n    # Coefficient-specific prior with bounds\n    p3 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\", coef=\"age\", lb=0)\n    ```\n    \"\"\"\n\n    prior: str\n    class_: str | None = None\n    coef: str | None = None\n    group: str | None = None\n    dpar: str | None = None\n    resp: str | None = None\n    nlpar: str | None = None\n    lb: float | None = None\n    ub: float | None = None\n\n    def to_brms_kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Convert PriorSpec to keyword arguments for brms::prior_string().\n\n        Maps Python dataclass fields to R function arguments, handling\n        the `class_` -&gt; `class` parameter name conversion.\n\n        Returns\n        -------\n        dict\n            Keyword arguments ready for brms::prior_string()\n\n        Examples\n        --------\n        ```python\n        from brmspy import prior\n        p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n        kwargs = p.to_brms_kwargs()\n        print(kwargs)\n        # {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n        ```\n        \"\"\"\n        out: dict[str, Any] = {\"prior\": self.prior}\n        if self.class_ is not None:\n            out[\"class\"] = self.class_\n        if self.coef is not None:\n            out[\"coef\"] = self.coef\n        if self.group is not None:\n            out[\"group\"] = self.group\n        if self.dpar is not None:\n            out[\"dpar\"] = self.dpar\n        if self.resp is not None:\n            out[\"resp\"] = self.resp\n        if self.nlpar is not None:\n            out[\"nlpar\"] = self.nlpar\n        if self.lb is not None:\n            out[\"lb\"] = self.lb\n        if self.ub is not None:\n            out[\"ub\"] = self.ub\n        return out\n</code></pre>"},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec.prior","title":"<code>prior</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec.class_","title":"<code>class_ = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec.coef","title":"<code>coef = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec.group","title":"<code>group = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec.dpar","title":"<code>dpar = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec.resp","title":"<code>resp = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec.nlpar","title":"<code>nlpar = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec.lb","title":"<code>lb = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec.ub","title":"<code>ub = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec.to_brms_kwargs","title":"<code>to_brms_kwargs()</code>","text":"<p>Convert PriorSpec to keyword arguments for brms::prior_string().</p> <p>Maps Python dataclass fields to R function arguments, handling the <code>class_</code> -&gt; <code>class</code> parameter name conversion.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keyword arguments ready for brms::prior_string()</p> <p>Examples:</p> <pre><code>from brmspy import prior\np = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\nkwargs = p.to_brms_kwargs()\nprint(kwargs)\n# {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n</code></pre> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>def to_brms_kwargs(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert PriorSpec to keyword arguments for brms::prior_string().\n\n    Maps Python dataclass fields to R function arguments, handling\n    the `class_` -&gt; `class` parameter name conversion.\n\n    Returns\n    -------\n    dict\n        Keyword arguments ready for brms::prior_string()\n\n    Examples\n    --------\n    ```python\n    from brmspy import prior\n    p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n    kwargs = p.to_brms_kwargs()\n    print(kwargs)\n    # {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n    ```\n    \"\"\"\n    out: dict[str, Any] = {\"prior\": self.prior}\n    if self.class_ is not None:\n        out[\"class\"] = self.class_\n    if self.coef is not None:\n        out[\"coef\"] = self.coef\n    if self.group is not None:\n        out[\"group\"] = self.group\n    if self.dpar is not None:\n        out[\"dpar\"] = self.dpar\n    if self.resp is not None:\n        out[\"resp\"] = self.resp\n    if self.nlpar is not None:\n        out[\"nlpar\"] = self.nlpar\n    if self.lb is not None:\n        out[\"lb\"] = self.lb\n    if self.ub is not None:\n        out[\"ub\"] = self.ub\n    return out\n</code></pre>"},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors.PriorSpec.__init__","title":"<code>__init__(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None)</code>","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_priors/#brmspy.helpers._rpy2._priors._build_priors","title":"<code>_build_priors(priors=None)</code>","text":"<p>Build R brms prior object from Python PriorSpec specifications.</p> <p>Converts a sequence of PriorSpec objects to a single combined R brms prior object by calling brms::prior_string() for each spec and combining with <code>+</code>. Used internally by fit() to translate Python prior specifications to R.</p> <p>Parameters:</p> Name Type Description Default <code>priors</code> <code>sequence of PriorSpec</code> <p>List of prior specifications. Each PriorSpec contains: - prior: Prior distribution string (e.g., \"normal(0, 1)\") - class_: Parameter class (e.g., \"b\", \"Intercept\", \"sigma\") - coef: Specific coefficient name (optional) - group: Group-level effects (optional)</p> <p>If None or empty, returns empty list (brms uses default priors)</p> <code>None</code> <p>Returns:</p> Type Description <code>R brmsprior object or list</code> <p>Combined R brms prior object if priors provided, empty list otherwise</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If combined result is not a valid brmsprior object</p> Notes <p>Prior Combination:</p> <p>Multiple priors are combined using R's <code>+</code> operator: <pre><code>prior1 + prior2 + prior3\n</code></pre></p> <p>This creates a single brmsprior object containing all specifications.</p> <p>brms Prior Classes:</p> <p>Common parameter classes: - b: Population-level effects (regression coefficients) - Intercept: Model intercept - sigma: Residual standard deviation (for gaussian family) - sd: Standard deviation of group-level effects - cor: Correlation of group-level effects</p> <p>Prior String Format:</p> <p>brms uses Stan-style prior specifications: - Normal: \"normal(mean, sd)\" - Student-t: \"student_t(df, location, scale)\" - Cauchy: \"cauchy(location, scale)\" - Exponential: \"exponential(rate)\" - Uniform: \"uniform(lower, upper)\"</p> <p>Examples:</p> <pre><code>from brmspy.types import PriorSpec\nfrom brmspy.helpers.priors import _build_priors\n\n# Single prior for regression coefficients\npriors = [\n    PriorSpec(\n        prior=\"normal(0, 1)\",\n        class_=\"b\"\n    )\n]\nbrms_prior = _build_priors(priors)\n</code></pre> See Also <p>brmspy.types.PriorSpec : Prior specification class brmspy.brms.fit : Uses this to convert priors for model fitting brms::prior : R brms prior specification brms::set_prior : R function for setting priors</p> References <p>.. [1] brms prior documentation: https://paul-buerkner.github.io/brms/reference/set_prior.html .. [2] Stan prior choice recommendations: https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations</p> Source code in <code>brmspy/helpers/_rpy2/_priors.py</code> <pre><code>def _build_priors(\n    priors: None | Sequence[PriorSpec] = None,\n) -&gt; list[Sexp]:\n    \"\"\"\n    Build R brms prior object from Python PriorSpec specifications.\n\n    Converts a sequence of PriorSpec objects to a single combined R brms prior\n    object by calling brms::prior_string() for each spec and combining with `+`.\n    Used internally by fit() to translate Python prior specifications to R.\n\n    Parameters\n    ----------\n    priors : sequence of PriorSpec, optional\n        List of prior specifications. Each PriorSpec contains:\n        - prior: Prior distribution string (e.g., \"normal(0, 1)\")\n        - class_: Parameter class (e.g., \"b\", \"Intercept\", \"sigma\")\n        - coef: Specific coefficient name (optional)\n        - group: Group-level effects (optional)\n\n        If None or empty, returns empty list (brms uses default priors)\n\n    Returns\n    -------\n    R brmsprior object or list\n        Combined R brms prior object if priors provided, empty list otherwise\n\n    Raises\n    ------\n    AssertionError\n        If combined result is not a valid brmsprior object\n\n    Notes\n    -----\n    **Prior Combination:**\n\n    Multiple priors are combined using R's `+` operator:\n    ```R\n    prior1 + prior2 + prior3\n    ```\n\n    This creates a single brmsprior object containing all specifications.\n\n    **brms Prior Classes:**\n\n    Common parameter classes:\n    - **b**: Population-level effects (regression coefficients)\n    - **Intercept**: Model intercept\n    - **sigma**: Residual standard deviation (for gaussian family)\n    - **sd**: Standard deviation of group-level effects\n    - **cor**: Correlation of group-level effects\n\n    **Prior String Format:**\n\n    brms uses Stan-style prior specifications:\n    - Normal: \"normal(mean, sd)\"\n    - Student-t: \"student_t(df, location, scale)\"\n    - Cauchy: \"cauchy(location, scale)\"\n    - Exponential: \"exponential(rate)\"\n    - Uniform: \"uniform(lower, upper)\"\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.types import PriorSpec\n    from brmspy.helpers.priors import _build_priors\n\n    # Single prior for regression coefficients\n    priors = [\n        PriorSpec(\n            prior=\"normal(0, 1)\",\n            class_=\"b\"\n        )\n    ]\n    brms_prior = _build_priors(priors)\n    ```\n\n    See Also\n    --------\n    brmspy.types.PriorSpec : Prior specification class\n    brmspy.brms.fit : Uses this to convert priors for model fitting\n    brms::prior : R brms prior specification\n    brms::set_prior : R function for setting priors\n\n    References\n    ----------\n    .. [1] brms prior documentation: https://paul-buerkner.github.io/brms/reference/set_prior.html\n    .. [2] Stan prior choice recommendations: https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations\n    \"\"\"\n    if not priors:\n        return []\n    import rpy2.robjects as ro\n\n    from brmspy.helpers._rpy2._converters import r_to_py\n\n    fun_prior_string = cast(Callable, ro.r(\"brms::prior_string\"))\n\n    prior_objs = []\n    for p in priors:\n        kwargs = p.to_brms_kwargs()\n        # first argument is the prior string\n        prior_str = kwargs.pop(\"prior\")\n        prior_obj = fun_prior_string(prior_str, **kwargs)\n        prior_objs.append(prior_obj)\n\n    brms_prior = prior_objs[0]\n    for p in prior_objs[1:]:\n        brms_prior = brms_prior + p\n\n    return brms_prior\n</code></pre>"},{"location":"internals/helpers/_rpy2/_robject_iter/","title":"_robject_iter","text":""},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter._UNION_TYPES","title":"<code>_UNION_TYPES = (Union, UnionType)</code>  <code>module-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter-classes","title":"Classes","text":""},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter.IterConf","title":"<code>IterConf</code>  <code>dataclass</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_robject_iter.py</code> <pre><code>@dataclass\nclass IterConf:\n    cls: type[Any] = dict\n    optional: bool = False\n</code></pre>"},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter.IterConf-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter.IterConf.cls","title":"<code>cls = dict</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter.IterConf.optional","title":"<code>optional = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter.IterConf-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter.IterConf.__init__","title":"<code>__init__(cls=dict, optional=False)</code>","text":""},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter._normalize_annotation","title":"<code>_normalize_annotation(ann)</code>","text":"<p>Turn a typing annotation (Dict[str, int], Optional[dict], pd.DataFrame, ...) into (runtime_cls, optional_flag).</p> Source code in <code>brmspy/helpers/_rpy2/_robject_iter.py</code> <pre><code>def _normalize_annotation(ann: Any) -&gt; IterConf:\n    \"\"\"\n    Turn a typing annotation (Dict[str, int], Optional[dict], pd.DataFrame, ...)\n    into (runtime_cls, optional_flag).\n    \"\"\"\n    origin = get_origin(ann)\n\n    # Handle Optional[T] / T | None\n    if origin in _UNION_TYPES:\n        args = get_args(ann)\n        non_none = [a for a in args if a is not type(None)]\n\n        # Exactly Union[T, NoneType] -&gt; Optional[T]\n        if len(non_none) == 1 and len(args) == 2:\n            inner = non_none[0]\n            inner_origin = get_origin(inner)\n            if inner_origin is not None:\n                return IterConf(cls=inner_origin, optional=True)\n            elif isinstance(inner, type):\n                return IterConf(cls=inner, optional=True)\n            else:\n                return IterConf(cls=object, optional=True)\n\n        # Other weird unions: don't enforce at runtime\n        return IterConf(cls=object, optional=False)\n\n    # Normal generics: Dict[str, int] -&gt; dict, list[int] -&gt; list, etc.\n    if origin is not None:\n        return IterConf(cls=origin, optional=False)\n\n    # Plain classes: str, int, pd.DataFrame, ...\n    if isinstance(ann, type):\n        return IterConf(cls=ann, optional=False)\n\n    # Fallback\n    return IterConf(cls=object, optional=False)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter._build_iterconf_from_dataclass","title":"<code>_build_iterconf_from_dataclass(dc)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_robject_iter.py</code> <pre><code>def _build_iterconf_from_dataclass(dc: type[Any]) -&gt; dict[str, IterConf]:\n    if not is_dataclass(dc):\n        raise TypeError(\"target_dataclass must be a dataclass type\")\n\n    annotations = getattr(dc, \"__annotations__\", {})\n    return {\n        name: _normalize_annotation(tp)\n        for name, tp in annotations.items()\n    }\n</code></pre>"},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter._matches_iterconf","title":"<code>_matches_iterconf(value, conf)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_robject_iter.py</code> <pre><code>def _matches_iterconf(value: Any, conf: IterConf) -&gt; bool:\n    if value is None:\n        return conf.optional\n    return isinstance(value, conf.cls)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_robject_iter/#brmspy.helpers._rpy2._robject_iter.iterate_robject_to_dataclass","title":"<code>iterate_robject_to_dataclass(names, get, target_dataclass, r, iteration_params=None)</code>","text":"<p>Generic helper to iterate over R summary-like objects and convert them into a Python dataclass instance.</p> <ul> <li><code>names</code> is e.g. summary_r.names</li> <li><code>get(param)</code> should return the R slot already converted via rpy2 (or raw)</li> <li><code>target_dataclass</code> is a @dataclass whose field names mirror the params</li> </ul> Source code in <code>brmspy/helpers/_rpy2/_robject_iter.py</code> <pre><code>def iterate_robject_to_dataclass(\n    names: list[str],\n    get: Callable[[str], Any],\n    target_dataclass: type[Any],\n    r: ListSexpVector | None,\n    iteration_params: dict[str, IterConf] | None = None\n):\n    \"\"\"\n    Generic helper to iterate over R summary-like objects and convert them\n    into a Python dataclass instance.\n\n    - `names` is e.g. summary_r.names\n    - `get(param)` should return the R slot already converted via rpy2 (or raw)\n    - `target_dataclass` is a @dataclass whose field names mirror the params\n    \"\"\"\n    import rpy2.robjects as ro\n    _fun_repr = cast(Callable, ro.r('function(x) paste(capture.output(x), collapse = \"\\\\n\")'))\n\n    if target_dataclass is None:\n        raise ValueError(\"target_dataclass must be specified\")\n\n    if not is_dataclass(target_dataclass):\n        raise TypeError(\"target_dataclass must be a dataclass type\")\n\n    if iteration_params is None:\n        iteration_params = _build_iterconf_from_dataclass(target_dataclass)\n\n    out: dict[str, Any] = {}\n\n    for param, iterconf in iteration_params.items():\n        if param == \"_str\" and r:\n            try:\n                repr = cast(list[str], _fun_repr(r))\n                repr = str(repr[0])\n            except:\n                repr = None\n            out['_str'] = repr\n            continue\n\n        if param not in names:\n            continue\n\n        try:\n            data = get(param)\n\n            if data is None:\n                if not iterconf.optional:\n                    log_warning(\n                        f\"Param '{param}' is None, but IterConf does not mark it as optional. Skipping.\"\n                    )\n                    continue\n            else:\n                # Special handling for DataFrame fields\n                if iterconf.cls is pd.DataFrame and not isinstance(data, pd.DataFrame):\n                    try:\n                        data = pd.DataFrame(data)\n                    except Exception as e:\n                        log_warning(\n                            f\"Failed to convert '{param}' object to pd.DataFrame. \"\n                            f\"Passing default. {e}\"\n                        )\n\n                if not _matches_iterconf(data, iterconf):\n                    log_warning(\n                        f\"Type of param '{param}' {type(data)} does not match \"\n                        f\"expected '{iterconf.cls}'\"\n                    )\n\n            out[param] = data\n\n        except Exception as e:\n            log_warning(f\"Failed to parse {param} into python object: {e}\")\n\n    if r:\n        out['r'] = r\n\n    # Build the dataclass instance\n    return target_dataclass(**out)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/","title":"_arrays","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.PyObject","title":"<code>PyObject = Union[dict, list, str, float, int, np.dtype, None, Any, pd.DataFrame, pd.Series, np.ndarray, az.InferenceData, xr.DataArray, xr.Dataset]</code>  <code>module-attribute</code>","text":"<p>Union of common Python-side objects produced by R\u2192Python conversion.</p> <p>This is intentionally broad: brmspy frequently returns standard scientific Python types (NumPy/pandas/xarray/ArviZ), plus plain dict/list primitives.</p> Note <p>Avoid adding <code>Any</code> here unless absolutely necessary; it defeats the purpose of having this alias.</p>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays-classes","title":"Classes","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmPool","title":"<code>ShmPool</code>","text":"<p>Minimal interface for allocating and attaching shared-memory blocks.</p> <p>The concrete implementation lives in <code>brmspy._session.transport.ShmPool</code> and tracks blocks so they can be closed on teardown.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>class ShmPool:\n    \"\"\"\n    Minimal interface for allocating and attaching shared-memory blocks.\n\n    The concrete implementation lives in\n    [`brmspy._session.transport.ShmPool`][brmspy._session.transport.ShmPool] and tracks\n    blocks so they can be closed on teardown.\n    \"\"\"\n\n    def __init__(self, manager: SharedMemoryManager) -&gt; None:\n        \"\"\"\n        Create a pool bound to an existing `SharedMemoryManager`.\n\n        Parameters\n        ----------\n        manager : multiprocessing.managers.SharedMemoryManager\n            Manager used to allocate blocks.\n        \"\"\"\n        ...\n\n    def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n        \"\"\"\n        Allocate a new shared-memory block.\n\n        Parameters\n        ----------\n        size : int\n            Size in bytes.\n\n        Returns\n        -------\n        ShmBlock\n            Newly allocated block.\n        \"\"\"\n        ...\n\n    def attach(self, ref: ShmRef) -&gt; ShmBlock:\n        \"\"\"\n        Attach to an existing shared-memory block by name.\n\n        Returns\n        -------\n        ShmBlock\n            Attached block.\n        \"\"\"\n        ...\n\n    def close_all(self) -&gt; None:\n        \"\"\"\n        Close all tracked shared-memory handles owned by this pool.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        ...\n\n    def gc(self, name: str | None = None) -&gt; None: ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmPool-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmPool.__init__","title":"<code>__init__(manager)</code>","text":"<p>Create a pool bound to an existing <code>SharedMemoryManager</code>.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SharedMemoryManager</code> <p>Manager used to allocate blocks.</p> required Source code in <code>brmspy/types/shm.py</code> <pre><code>def __init__(self, manager: SharedMemoryManager) -&gt; None:\n    \"\"\"\n    Create a pool bound to an existing `SharedMemoryManager`.\n\n    Parameters\n    ----------\n    manager : multiprocessing.managers.SharedMemoryManager\n        Manager used to allocate blocks.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmPool.alloc","title":"<code>alloc(size, temporary=False)</code>","text":"<p>Allocate a new shared-memory block.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size in bytes.</p> required <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Newly allocated block.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n    \"\"\"\n    Allocate a new shared-memory block.\n\n    Parameters\n    ----------\n    size : int\n        Size in bytes.\n\n    Returns\n    -------\n    ShmBlock\n        Newly allocated block.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmPool.attach","title":"<code>attach(ref)</code>","text":"<p>Attach to an existing shared-memory block by name.</p> <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Attached block.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>def attach(self, ref: ShmRef) -&gt; ShmBlock:\n    \"\"\"\n    Attach to an existing shared-memory block by name.\n\n    Returns\n    -------\n    ShmBlock\n        Attached block.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmPool.close_all","title":"<code>close_all()</code>","text":"<p>Close all tracked shared-memory handles owned by this pool.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>brmspy/types/shm.py</code> <pre><code>def close_all(self) -&gt; None:\n    \"\"\"\n    Close all tracked shared-memory handles owned by this pool.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmPool.gc","title":"<code>gc(name=None)</code>","text":"Source code in <code>brmspy/types/shm.py</code> <pre><code>def gc(self, name: str | None = None) -&gt; None: ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmArray","title":"<code>ShmArray</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>NumPy array view backed by a shared-memory block.</p> <p>Attributes:</p> Name Type Description <code>block</code> <code>ShmRef</code> <p>Reference to the shared-memory block backing the array data.</p> Notes <p>This is a view over <code>SharedMemory.buf</code>. Closing/unlinking the underlying shared memory while the array is still in use will lead to undefined behavior.</p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>class ShmArray(np.ndarray):\n    \"\"\"\n    NumPy array view backed by a shared-memory block.\n\n    Attributes\n    ----------\n    block : ShmRef\n        Reference to the shared-memory block backing the array data.\n\n    Notes\n    -----\n    This is a *view* over `SharedMemory.buf`. Closing/unlinking the underlying\n    shared memory while the array is still in use will lead to undefined\n    behavior.\n    \"\"\"\n\n    _shm_metadata: ShmRef  # for type checkers\n\n    @classmethod\n    def from_metadata(\n        cls, meta: ShmArrayMetadata | dict[str, Any], block: ShmBlock\n    ) -&gt; np.ndarray:\n        dtype = np.dtype(meta[\"dtype\"])\n        shape = tuple(meta[\"shape\"])\n        order = meta[\"order\"]\n\n        return ShmArray.from_block(block=block, shape=shape, dtype=dtype, order=order)\n\n    @classmethod\n    def from_block(\n        cls, block: ShmBlock, shape: tuple[int, ...], dtype: np.dtype, **kwargs\n    ) -&gt; Union[\"ShmArray\", np.ndarray]:\n        \"\"\"\n        Create an array view backed by an existing shared-memory block.\n\n        Parameters\n        ----------\n        block : ShmBlock\n            Attached shared-memory block.\n        shape : tuple[int, ...]\n            Desired array shape.\n        dtype : numpy.dtype\n            NumPy dtype of the array.\n        **kwargs\n            Reserved for future compatibility. Currently unused.\n\n        Returns\n        -------\n        ShmArray\n            Array view into the shared-memory buffer.\n        \"\"\"\n        is_object = np.dtype(dtype) == np.dtype(\"O\")\n\n        if not is_object:\n            if block.shm.buf:\n                view = memoryview(block.shm.buf)\n                view = view[: block.content_size]\n            else:\n                view = None\n            base = np.ndarray(\n                shape=shape,\n                dtype=dtype,\n                buffer=view,\n                order=kwargs.get(\"order\", \"F\"),\n            )\n            obj = base.view(ShmArray)\n            obj._shm_metadata = block.to_ref()\n        else:\n            assert block.shm.buf\n            view = memoryview(block.shm.buf)\n            view = view[: block.content_size]\n            payload = bytes(view)\n            obj = pickle.loads(payload)\n            assert isinstance(obj, np.ndarray)\n\n        return obj\n\n    @classmethod\n    def array_order(cls, a: np.ndarray) -&gt; Literal[\"C\", \"F\", \"non-contiguous\"]:\n        \"\"\"\n        Determine how an array can be reconstructed from a raw buffer.\n\n        Returns `\"C\"` for C-contiguous arrays, `\"F\"` for Fortran-contiguous arrays,\n        otherwise `\"non-contiguous\"` (meaning: bytes were obtained by forcing\n        a contiguous copy during encoding).\n        \"\"\"\n        if a.flags[\"C_CONTIGUOUS\"]:\n            return \"C\"\n        if a.flags[\"F_CONTIGUOUS\"]:\n            return \"F\"\n        return \"non-contiguous\"\n\n    @classmethod\n    def is_string_object(cls, a: np.ndarray, sample: int = 1000):\n        if np.dtype(a.dtype) != np.dtype(\"O\"):\n            return False\n        it = a.flat\n        for _ in range(min(sample, a.size)):\n            v = next(it, None)\n            if v is not None and not isinstance(v, str):\n                return False\n        return True\n\n    @classmethod\n    def to_shm(\n        cls, obj: np.ndarray | pd.Series | list, shm_pool: Any\n    ) -&gt; tuple[np.ndarray | None, ShmRef, str, list[int], str]:\n        if isinstance(obj, pd.Series):\n            if isinstance(obj.dtype, pd.CategoricalDtype):\n                arr = obj.cat.codes.to_numpy(copy=False)\n            else:\n                arr = obj.to_numpy(copy=False)\n        elif not isinstance(obj, np.ndarray):\n            arr = np.asarray(obj)\n        else:\n            arr = obj\n\n        is_object = np.dtype(arr.dtype) == np.dtype(\"O\")\n        is_string = cls.is_string_object(arr)\n\n        arr_modified = None\n        if isinstance(arr, ShmArray):\n            ref = arr._shm_metadata\n\n        else:\n            temporary = False\n            if not is_object:\n                data = arr.tobytes(order=\"C\")\n            elif is_string:\n                arr = arr.astype(\"U\")\n                arr_modified = arr\n                data = arr.tobytes(order=\"C\")\n            else:\n                data = pickle.dumps(arr, protocol=pickle.HIGHEST_PROTOCOL)\n                temporary = True\n\n            nbytes = len(data)\n\n            # Ask for exactly nbytes; OS may round up internally, that's fine.\n            block = shm_pool.alloc(nbytes, temporary=temporary)\n            block.shm.buf[:nbytes] = data\n            ref = block.to_ref()\n\n        ref, dtype, shape, order = (\n            ref,\n            str(arr.dtype),\n            list(arr.shape),\n            cls.array_order(arr),\n        )\n\n        return arr_modified, ref, dtype, shape, order\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmArray-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmArray._shm_metadata","title":"<code>_shm_metadata</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmArray-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmArray.from_metadata","title":"<code>from_metadata(meta, block)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef from_metadata(\n    cls, meta: ShmArrayMetadata | dict[str, Any], block: ShmBlock\n) -&gt; np.ndarray:\n    dtype = np.dtype(meta[\"dtype\"])\n    shape = tuple(meta[\"shape\"])\n    order = meta[\"order\"]\n\n    return ShmArray.from_block(block=block, shape=shape, dtype=dtype, order=order)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmArray.from_block","title":"<code>from_block(block, shape, dtype, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create an array view backed by an existing shared-memory block.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>ShmBlock</code> <p>Attached shared-memory block.</p> required <code>shape</code> <code>tuple[int, ...]</code> <p>Desired array shape.</p> required <code>dtype</code> <code>dtype</code> <p>NumPy dtype of the array.</p> required <code>**kwargs</code> <p>Reserved for future compatibility. Currently unused.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ShmArray</code> <p>Array view into the shared-memory buffer.</p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef from_block(\n    cls, block: ShmBlock, shape: tuple[int, ...], dtype: np.dtype, **kwargs\n) -&gt; Union[\"ShmArray\", np.ndarray]:\n    \"\"\"\n    Create an array view backed by an existing shared-memory block.\n\n    Parameters\n    ----------\n    block : ShmBlock\n        Attached shared-memory block.\n    shape : tuple[int, ...]\n        Desired array shape.\n    dtype : numpy.dtype\n        NumPy dtype of the array.\n    **kwargs\n        Reserved for future compatibility. Currently unused.\n\n    Returns\n    -------\n    ShmArray\n        Array view into the shared-memory buffer.\n    \"\"\"\n    is_object = np.dtype(dtype) == np.dtype(\"O\")\n\n    if not is_object:\n        if block.shm.buf:\n            view = memoryview(block.shm.buf)\n            view = view[: block.content_size]\n        else:\n            view = None\n        base = np.ndarray(\n            shape=shape,\n            dtype=dtype,\n            buffer=view,\n            order=kwargs.get(\"order\", \"F\"),\n        )\n        obj = base.view(ShmArray)\n        obj._shm_metadata = block.to_ref()\n    else:\n        assert block.shm.buf\n        view = memoryview(block.shm.buf)\n        view = view[: block.content_size]\n        payload = bytes(view)\n        obj = pickle.loads(payload)\n        assert isinstance(obj, np.ndarray)\n\n    return obj\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmArray.array_order","title":"<code>array_order(a)</code>  <code>classmethod</code>","text":"<p>Determine how an array can be reconstructed from a raw buffer.</p> <p>Returns <code>\"C\"</code> for C-contiguous arrays, <code>\"F\"</code> for Fortran-contiguous arrays, otherwise <code>\"non-contiguous\"</code> (meaning: bytes were obtained by forcing a contiguous copy during encoding).</p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef array_order(cls, a: np.ndarray) -&gt; Literal[\"C\", \"F\", \"non-contiguous\"]:\n    \"\"\"\n    Determine how an array can be reconstructed from a raw buffer.\n\n    Returns `\"C\"` for C-contiguous arrays, `\"F\"` for Fortran-contiguous arrays,\n    otherwise `\"non-contiguous\"` (meaning: bytes were obtained by forcing\n    a contiguous copy during encoding).\n    \"\"\"\n    if a.flags[\"C_CONTIGUOUS\"]:\n        return \"C\"\n    if a.flags[\"F_CONTIGUOUS\"]:\n        return \"F\"\n    return \"non-contiguous\"\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmArray.is_string_object","title":"<code>is_string_object(a, sample=1000)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef is_string_object(cls, a: np.ndarray, sample: int = 1000):\n    if np.dtype(a.dtype) != np.dtype(\"O\"):\n        return False\n    it = a.flat\n    for _ in range(min(sample, a.size)):\n        v = next(it, None)\n        if v is not None and not isinstance(v, str):\n            return False\n    return True\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmArray.to_shm","title":"<code>to_shm(obj, shm_pool)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef to_shm(\n    cls, obj: np.ndarray | pd.Series | list, shm_pool: Any\n) -&gt; tuple[np.ndarray | None, ShmRef, str, list[int], str]:\n    if isinstance(obj, pd.Series):\n        if isinstance(obj.dtype, pd.CategoricalDtype):\n            arr = obj.cat.codes.to_numpy(copy=False)\n        else:\n            arr = obj.to_numpy(copy=False)\n    elif not isinstance(obj, np.ndarray):\n        arr = np.asarray(obj)\n    else:\n        arr = obj\n\n    is_object = np.dtype(arr.dtype) == np.dtype(\"O\")\n    is_string = cls.is_string_object(arr)\n\n    arr_modified = None\n    if isinstance(arr, ShmArray):\n        ref = arr._shm_metadata\n\n    else:\n        temporary = False\n        if not is_object:\n            data = arr.tobytes(order=\"C\")\n        elif is_string:\n            arr = arr.astype(\"U\")\n            arr_modified = arr\n            data = arr.tobytes(order=\"C\")\n        else:\n            data = pickle.dumps(arr, protocol=pickle.HIGHEST_PROTOCOL)\n            temporary = True\n\n        nbytes = len(data)\n\n        # Ask for exactly nbytes; OS may round up internally, that's fine.\n        block = shm_pool.alloc(nbytes, temporary=temporary)\n        block.shm.buf[:nbytes] = data\n        ref = block.to_ref()\n\n    ref, dtype, shape, order = (\n        ref,\n        str(arr.dtype),\n        list(arr.shape),\n        cls.array_order(arr),\n    )\n\n    return arr_modified, ref, dtype, shape, order\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns","title":"<code>ShmDataFrameColumns</code>","text":"<p>               Bases: <code>DataFrame</code></p> <p>pandas DataFrame backed by per-column shared-memory blocks (numeric only).</p> <p>Attributes:</p> Name Type Description <code>_blocks_columns</code> <code>dict[str, PandasColumnMetadata]</code> <p>Mapping from column name to data required for its reconstruction</p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>class ShmDataFrameColumns(pd.DataFrame):\n    \"\"\"\n    pandas DataFrame backed by per-column shared-memory blocks (numeric only).\n\n    Attributes\n    ----------\n    _blocks_columns : dict[str, PandasColumnMetadata]\n        Mapping from column name to data required for its reconstruction\n    \"\"\"\n\n    _metadata = [\"_shm_metadata\"]\n    _shm_metadata: dict[str, ShmSeriesMetadata]\n\n    @property\n    def _constructor(self):\n        # We INTENTIONALLY do not return ShmSeriesMetadata\n        # whenever the dataframe is reindexed, slices, we want to get rid of all _shm_metadata,\n        # as otherwise we will have immediate problems with buffer alignment\n        return pd.DataFrame\n\n    @classmethod\n    def _create_col_metadata(\n        cls, series: pd.Series, block: ShmRef, arr: np.ndarray | None = None, **params\n    ) -&gt; ShmSeriesMetadata:\n        pd_dtype = series.dtype\n\n        # Decide what ndarray is actually stored in SHM\n        if isinstance(pd_dtype, pd.CategoricalDtype):\n            # store dtype params\n            params[\"categories\"] = pd_dtype.categories.to_numpy(dtype=object).tolist()\n            params[\"ordered\"] = bool(pd_dtype.ordered)\n            params[\"categories_dtype\"] = pd_dtype.categories.dtype.name\n\n            # IMPORTANT: store integer codes, not values\n            # -1 means missing\n            array = series.cat.codes.to_numpy(copy=False)\n        elif arr is not None:\n            assert isinstance(arr, np.ndarray)\n            array = arr\n        else:\n            # for numeric-only SHM: require a real numpy array output here\n            array = series.to_numpy(copy=False)\n\n        # Optional param dtypes you mentioned (only if you support them)\n        if isinstance(pd_dtype, pd.PeriodDtype):\n            params[\"freq\"] = str(pd_dtype.freq)\n\n        if isinstance(pd_dtype, pd.IntervalDtype):\n            params[\"subtype\"] = np.dtype(pd_dtype.subtype).str\n            params[\"closed\"] = str(pd_dtype.closed)  # type: ignore[attr-defined]\n\n        meta: ShmSeriesMetadata = {\n            \"name\": series.name,\n            \"np_dtype\": str(array.dtype),\n            \"pd_dtype\": str(pd_dtype.name),\n            \"block\": block,\n            \"params\": params,\n        }\n\n        if np.dtype(meta[\"np_dtype\"]) == np.dtype(\"O\"):\n            # Sanity check. If this goes wrong, it will be frustrating to debug\n            if ShmArray.is_string_object(array, sample=25):\n                raise Exception(\n                    f\"{series.name} column is string, but stored as object!\"\n                )\n\n        return meta\n\n    def _set_col_raw(self, col: str, value) -&gt; None:\n        # bypass our __setitem__\n        pd.DataFrame.__setitem__(self, col, value)\n\n    def _set_shm_metadata(self, meta: dict[str, ShmSeriesMetadata]):\n        self._shm_metadata = meta\n\n    @classmethod\n    def _put_col_in_shm(\n        cls, df: \"ShmDataFrameColumns\", col: str, shm_pool: Any, replace=False\n    ):\n        vals = df[col].to_numpy(copy=False)\n        if (\n            isinstance(vals, ShmArray)\n            and hasattr(vals, \"_shm_metadata\")\n            and not replace\n        ):\n            pass\n        elif isinstance(vals, np.ndarray):\n            if col in df._shm_metadata:\n                del df._shm_metadata[col]\n            arr_modified, ref, dtype, shape, order = ShmArray.to_shm(df[col], shm_pool)\n\n            if arr_modified is not None:\n                # Only needed for string-object normalization; for numeric/codes it's None\n                df._set_col_raw(\n                    col, pd.Series(arr_modified, index=df.index, name=col, copy=False)\n                )\n            df._shm_metadata[col] = cls._create_col_metadata(df[col], ref, arr_modified)\n            return\n        else:\n            print(\n                f\"Failed to update shm metadata for column '{col}' dtype {vals.dtype}\"\n            )\n            return\n\n    @classmethod\n    def _reconstruct_series(\n        cls,\n        meta: ShmSeriesMetadata,\n        block: ShmBlock,\n        nrows: int,\n        index: list | None,\n    ) -&gt; pd.Series:\n        col_name = meta[\"name\"]\n        col_name = str(col_name)\n        dtype = np.dtype(meta[\"np_dtype\"])\n        pd_dtype = meta[\"pd_dtype\"]\n        params = meta[\"params\"]\n\n        arr = ShmArray.from_block(block=block, shape=(nrows,), dtype=dtype, order=\"C\")\n\n        if pd_dtype == \"category\":\n            cats = params.get(\"categories\", None)\n            ordered = bool(params.get(\"ordered\", False))\n\n            if cats is None:\n                raise ValueError(\"category dtype requires params['categories']\")\n\n            cats_pd_dtype = params.get(\"categories_dtype\")\n            if cats_pd_dtype is not None:\n                cats_index = pd.Index(cats, dtype=str(cats_pd_dtype))\n            else:\n                cats_index = pd.Index(cats)\n\n            cat_dtype = pd.CategoricalDtype(categories=cats_index, ordered=ordered)\n\n            # arr should hold integer codes\n            # If arr holds codes: build categorical from codes without copying codes.\n            # Pandas uses -1 for missing.\n            cat = pd.Categorical.from_codes(cast(Sequence[int], arr), dtype=cat_dtype)\n            return pd.Series(cat, name=col_name, index=index)\n\n        # 2) tz-aware datetimes\n        # Expect arr to be int64 ns timestamps\n        if pd_dtype.startswith(\"datetime64[ns,\") or pd_dtype == \"datetime64[ns, tz]\":\n            tz = params.get(\"tz\")\n            if not tz:\n                # if stored as a plain datetime64[ns] string, just fall through\n                pass\n            else:\n                dt = pd.to_datetime(arr, unit=\"ns\", utc=True).tz_convert(tz)\n                return pd.Series(dt, name=col_name, index=index)\n\n        return pd.Series(arr, name=col_name, index=index)\n\n    def __setitem__(self, key, value):\n        is_existing = key in self.columns\n\n        super().__setitem__(key, value)\n\n        if is_existing:\n            self._on_column_replaced(key)\n        else:\n            self._on_column_added(key)\n\n    def _on_column_added(self, col: str):\n        from brmspy._singleton._shm_singleton import _get_shm\n\n        shm = _get_shm()\n        if not shm:\n            return\n        self._put_col_in_shm(self, col, shm)\n\n    def _on_column_replaced(self, col: str):\n        from brmspy._singleton._shm_singleton import _get_shm\n\n        shm = _get_shm()\n        if not shm:\n            return\n        self._put_col_in_shm(self, col, shm, replace=True)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns._metadata","title":"<code>_metadata = ['_shm_metadata']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns._shm_metadata","title":"<code>_shm_metadata</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns._constructor","title":"<code>_constructor</code>  <code>property</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns._create_col_metadata","title":"<code>_create_col_metadata(series, block, arr=None, **params)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef _create_col_metadata(\n    cls, series: pd.Series, block: ShmRef, arr: np.ndarray | None = None, **params\n) -&gt; ShmSeriesMetadata:\n    pd_dtype = series.dtype\n\n    # Decide what ndarray is actually stored in SHM\n    if isinstance(pd_dtype, pd.CategoricalDtype):\n        # store dtype params\n        params[\"categories\"] = pd_dtype.categories.to_numpy(dtype=object).tolist()\n        params[\"ordered\"] = bool(pd_dtype.ordered)\n        params[\"categories_dtype\"] = pd_dtype.categories.dtype.name\n\n        # IMPORTANT: store integer codes, not values\n        # -1 means missing\n        array = series.cat.codes.to_numpy(copy=False)\n    elif arr is not None:\n        assert isinstance(arr, np.ndarray)\n        array = arr\n    else:\n        # for numeric-only SHM: require a real numpy array output here\n        array = series.to_numpy(copy=False)\n\n    # Optional param dtypes you mentioned (only if you support them)\n    if isinstance(pd_dtype, pd.PeriodDtype):\n        params[\"freq\"] = str(pd_dtype.freq)\n\n    if isinstance(pd_dtype, pd.IntervalDtype):\n        params[\"subtype\"] = np.dtype(pd_dtype.subtype).str\n        params[\"closed\"] = str(pd_dtype.closed)  # type: ignore[attr-defined]\n\n    meta: ShmSeriesMetadata = {\n        \"name\": series.name,\n        \"np_dtype\": str(array.dtype),\n        \"pd_dtype\": str(pd_dtype.name),\n        \"block\": block,\n        \"params\": params,\n    }\n\n    if np.dtype(meta[\"np_dtype\"]) == np.dtype(\"O\"):\n        # Sanity check. If this goes wrong, it will be frustrating to debug\n        if ShmArray.is_string_object(array, sample=25):\n            raise Exception(\n                f\"{series.name} column is string, but stored as object!\"\n            )\n\n    return meta\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns._set_col_raw","title":"<code>_set_col_raw(col, value)</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>def _set_col_raw(self, col: str, value) -&gt; None:\n    # bypass our __setitem__\n    pd.DataFrame.__setitem__(self, col, value)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns._set_shm_metadata","title":"<code>_set_shm_metadata(meta)</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>def _set_shm_metadata(self, meta: dict[str, ShmSeriesMetadata]):\n    self._shm_metadata = meta\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns._put_col_in_shm","title":"<code>_put_col_in_shm(df, col, shm_pool, replace=False)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef _put_col_in_shm(\n    cls, df: \"ShmDataFrameColumns\", col: str, shm_pool: Any, replace=False\n):\n    vals = df[col].to_numpy(copy=False)\n    if (\n        isinstance(vals, ShmArray)\n        and hasattr(vals, \"_shm_metadata\")\n        and not replace\n    ):\n        pass\n    elif isinstance(vals, np.ndarray):\n        if col in df._shm_metadata:\n            del df._shm_metadata[col]\n        arr_modified, ref, dtype, shape, order = ShmArray.to_shm(df[col], shm_pool)\n\n        if arr_modified is not None:\n            # Only needed for string-object normalization; for numeric/codes it's None\n            df._set_col_raw(\n                col, pd.Series(arr_modified, index=df.index, name=col, copy=False)\n            )\n        df._shm_metadata[col] = cls._create_col_metadata(df[col], ref, arr_modified)\n        return\n    else:\n        print(\n            f\"Failed to update shm metadata for column '{col}' dtype {vals.dtype}\"\n        )\n        return\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns._reconstruct_series","title":"<code>_reconstruct_series(meta, block, nrows, index)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef _reconstruct_series(\n    cls,\n    meta: ShmSeriesMetadata,\n    block: ShmBlock,\n    nrows: int,\n    index: list | None,\n) -&gt; pd.Series:\n    col_name = meta[\"name\"]\n    col_name = str(col_name)\n    dtype = np.dtype(meta[\"np_dtype\"])\n    pd_dtype = meta[\"pd_dtype\"]\n    params = meta[\"params\"]\n\n    arr = ShmArray.from_block(block=block, shape=(nrows,), dtype=dtype, order=\"C\")\n\n    if pd_dtype == \"category\":\n        cats = params.get(\"categories\", None)\n        ordered = bool(params.get(\"ordered\", False))\n\n        if cats is None:\n            raise ValueError(\"category dtype requires params['categories']\")\n\n        cats_pd_dtype = params.get(\"categories_dtype\")\n        if cats_pd_dtype is not None:\n            cats_index = pd.Index(cats, dtype=str(cats_pd_dtype))\n        else:\n            cats_index = pd.Index(cats)\n\n        cat_dtype = pd.CategoricalDtype(categories=cats_index, ordered=ordered)\n\n        # arr should hold integer codes\n        # If arr holds codes: build categorical from codes without copying codes.\n        # Pandas uses -1 for missing.\n        cat = pd.Categorical.from_codes(cast(Sequence[int], arr), dtype=cat_dtype)\n        return pd.Series(cat, name=col_name, index=index)\n\n    # 2) tz-aware datetimes\n    # Expect arr to be int64 ns timestamps\n    if pd_dtype.startswith(\"datetime64[ns,\") or pd_dtype == \"datetime64[ns, tz]\":\n        tz = params.get(\"tz\")\n        if not tz:\n            # if stored as a plain datetime64[ns] string, just fall through\n            pass\n        else:\n            dt = pd.to_datetime(arr, unit=\"ns\", utc=True).tz_convert(tz)\n            return pd.Series(dt, name=col_name, index=index)\n\n    return pd.Series(arr, name=col_name, index=index)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>def __setitem__(self, key, value):\n    is_existing = key in self.columns\n\n    super().__setitem__(key, value)\n\n    if is_existing:\n        self._on_column_replaced(key)\n    else:\n        self._on_column_added(key)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns._on_column_added","title":"<code>_on_column_added(col)</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>def _on_column_added(self, col: str):\n    from brmspy._singleton._shm_singleton import _get_shm\n\n    shm = _get_shm()\n    if not shm:\n        return\n    self._put_col_in_shm(self, col, shm)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameColumns._on_column_replaced","title":"<code>_on_column_replaced(col)</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>def _on_column_replaced(self, col: str):\n    from brmspy._singleton._shm_singleton import _get_shm\n\n    shm = _get_shm()\n    if not shm:\n        return\n    self._put_col_in_shm(self, col, shm, replace=True)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameSimple","title":"<code>ShmDataFrameSimple</code>","text":"<p>               Bases: <code>DataFrame</code></p> <p>pandas DataFrame backed by a single shared-memory block (numeric only).</p> <p>Attributes:</p> Name Type Description <code>block</code> <code>ShmRef</code> <p>Reference to the shared-memory block backing the DataFrame's values.</p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>class ShmDataFrameSimple(pd.DataFrame):\n    \"\"\"\n    pandas DataFrame backed by a single shared-memory block (numeric only).\n\n    Attributes\n    ----------\n    block : ShmRef\n        Reference to the shared-memory block backing the DataFrame's values.\n    \"\"\"\n\n    _metadata = [\"_shm_metadata\"]\n    _shm_metadata: ShmRef\n\n    @classmethod\n    def from_block(\n        cls,\n        block: ShmBlock,\n        nrows: int,\n        ncols: int,\n        columns: list[Any] | None,\n        index: list[Any] | None,\n        dtype: str | np.dtype,\n    ) -&gt; \"ShmDataFrameSimple\":\n        \"\"\"\n        Construct a DataFrame backed by a single SHM block.\n\n        Parameters\n        ----------\n        block : ShmBlock\n            Attached shared-memory block containing a contiguous 2D numeric matrix.\n        nrows, ncols : int\n            DataFrame shape.\n        columns, index : list[Any] or None\n            Column/index labels.\n        dtype : str or numpy.dtype\n            Dtype of the matrix stored in the block.\n\n        Returns\n        -------\n        ShmDataFrameSimple\n        \"\"\"\n        _dtype = np.dtype(dtype)\n        arr = ShmArray.from_block(shape=(ncols, nrows), dtype=_dtype, block=block)\n\n        df = ShmDataFrameSimple(data=arr.T, index=index, columns=columns)\n        df._set_shm_metadata(block.to_ref())\n        return df\n\n    def _set_shm_metadata(self, meta: ShmRef):\n        self._shm_metadata = meta\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameSimple-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameSimple._metadata","title":"<code>_metadata = ['_shm_metadata']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameSimple._shm_metadata","title":"<code>_shm_metadata</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameSimple-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameSimple.from_block","title":"<code>from_block(block, nrows, ncols, columns, index, dtype)</code>  <code>classmethod</code>","text":"<p>Construct a DataFrame backed by a single SHM block.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>ShmBlock</code> <p>Attached shared-memory block containing a contiguous 2D numeric matrix.</p> required <code>nrows</code> <code>int</code> <p>DataFrame shape.</p> required <code>ncols</code> <code>int</code> <p>DataFrame shape.</p> required <code>columns</code> <code>list[Any] or None</code> <p>Column/index labels.</p> required <code>index</code> <code>list[Any] or None</code> <p>Column/index labels.</p> required <code>dtype</code> <code>str or dtype</code> <p>Dtype of the matrix stored in the block.</p> required <p>Returns:</p> Type Description <code>ShmDataFrameSimple</code> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef from_block(\n    cls,\n    block: ShmBlock,\n    nrows: int,\n    ncols: int,\n    columns: list[Any] | None,\n    index: list[Any] | None,\n    dtype: str | np.dtype,\n) -&gt; \"ShmDataFrameSimple\":\n    \"\"\"\n    Construct a DataFrame backed by a single SHM block.\n\n    Parameters\n    ----------\n    block : ShmBlock\n        Attached shared-memory block containing a contiguous 2D numeric matrix.\n    nrows, ncols : int\n        DataFrame shape.\n    columns, index : list[Any] or None\n        Column/index labels.\n    dtype : str or numpy.dtype\n        Dtype of the matrix stored in the block.\n\n    Returns\n    -------\n    ShmDataFrameSimple\n    \"\"\"\n    _dtype = np.dtype(dtype)\n    arr = ShmArray.from_block(shape=(ncols, nrows), dtype=_dtype, block=block)\n\n    df = ShmDataFrameSimple(data=arr.T, index=index, columns=columns)\n    df._set_shm_metadata(block.to_ref())\n    return df\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.ShmDataFrameSimple._set_shm_metadata","title":"<code>_set_shm_metadata(meta)</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>def _set_shm_metadata(self, meta: ShmRef):\n    self._shm_metadata = meta\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays._get_rvector_memview","title":"<code>_get_rvector_memview(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_vectors.py</code> <pre><code>def _get_rvector_memview(\n    obj: Any,\n) -&gt; tuple[SexpVectorWithNumpyInterface | None, memoryview | None]:\n    try:\n        assert isinstance(obj, SexpVectorWithNumpyInterface) and isinstance(\n            obj, SexpVector\n        )  # assert types, shouldnt error by itself\n        if hasattr(obj, \"memoryview\"):\n            src = cast(Any, obj).memoryview()\n            return obj, src\n        else:\n            return None, None\n    except:\n        return None, None\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays._get_rvector_types","title":"<code>_get_rvector_types(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_vectors.py</code> <pre><code>def _get_rvector_types(obj: Any) -&gt; tuple[None | str, None | int]:\n    if not isinstance(obj, SexpVectorWithNumpyInterface):\n        return None, None\n\n    dtypestr = obj._NP_TYPESTR\n    itemsize = obj._R_SIZEOF_ELT\n\n    if not dtypestr or not itemsize:\n        return None, None\n\n    return dtypestr, itemsize\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays._r2py_vector","title":"<code>_r2py_vector(obj, shm=None, allow_scalar=True)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_vectors.py</code> <pre><code>def _r2py_vector(\n    obj: \"Vector\", shm: ShmPool | None = None, allow_scalar: bool | None = True\n) -&gt; PyObject:\n    import rpy2.robjects as ro\n    from rpy2.robjects import default_converter\n    from rpy2.robjects.conversion import localconverter\n\n    assert not isinstance(obj, ro.ListVector)\n\n    if allow_scalar:\n        obj_any = cast(Any, obj)\n        # length 1 \u2192 scalar\n        if obj_any.__len__ and len(obj_any) == 1:\n            # Try default R\u2192Python conversion\n            with localconverter(default_converter) as cv:\n                py = cv.rpy2py(obj[0])\n            return py\n\n    is_factor = isinstance(obj, ro.FactorVector)\n\n    dtypestr, itemsize = _get_rvector_types(obj)\n    rvecnp, src = _get_rvector_memview(obj)\n\n    # fallback\n    if not dtypestr or not itemsize or not shm or not rvecnp or not src:\n        return _fallback_rvector_iter(obj)\n\n    # numpy convertible\n    N = len(rvecnp)\n    expected_bytes = itemsize * N\n    dtype = np.dtype(dtypestr)\n\n    if src.nbytes != expected_bytes:\n        raise RuntimeError(f\"R vector bytes={src.nbytes}, expected={expected_bytes}\")\n\n    # Allocate shm once\n    block = shm.alloc(expected_bytes)\n    assert block.shm.buf\n\n    # Single bulk copy: R \u2192 shm, no intermediate ndarray\n    src_bytes = src.cast(\"B\")\n    block.shm.buf[:expected_bytes] = src_bytes\n\n    arr = ShmArray.from_block(block=block, shape=(N,), dtype=dtype)\n    if is_factor:\n        return _to_pandas_factor(arr, obj)\n\n    return arr\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays.log_warning","title":"<code>log_warning(msg, method_name=None)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The warning message to log</p> required <code>method_name</code> <code>str</code> <p>The name of the method/function. If None, will auto-detect from call stack.</p> <code>None</code> Source code in <code>brmspy/helpers/log.py</code> <pre><code>def log_warning(msg: str, method_name: str | None = None):\n    \"\"\"\n    Log a warning message.\n\n    Parameters\n    ----------\n    msg : str\n        The warning message to log\n    method_name : str, optional\n        The name of the method/function. If None, will auto-detect from call stack.\n\n    \"\"\"\n    log(msg, method_name=method_name, level=logging.WARNING)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays._rmatrix_info","title":"<code>_rmatrix_info(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_arrays.py</code> <pre><code>def _rmatrix_info(obj: \"Matrix\") -&gt; tuple[int, int, list[str] | None, list[str] | None]:\n    nrow, ncol = obj.dim\n\n    if obj.colnames != NULL:\n        colnames = [str(el) for el in obj.colnames]\n    else:\n        colnames = None\n    if obj.rownames != NULL:\n        rownames = [str(el) for el in obj.rownames]\n    else:\n        rownames = None\n\n    return nrow, ncol, rownames, colnames\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays._rmatrix_to_py_default","title":"<code>_rmatrix_to_py_default(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_arrays.py</code> <pre><code>def _rmatrix_to_py_default(obj: \"Matrix\") -&gt; pd.DataFrame | np.ndarray:\n    nrow, ncol, rownames, colnames = _rmatrix_info(obj)\n\n    if not rownames and not colnames:\n        return np.array(obj)\n\n    df = pd.DataFrame(data=np.array(obj), columns=colnames, index=rownames)\n    if \"_obs_id_\" in df.columns and not df[\"_obs_id_\"].duplicated().any():\n        df.index = df[\"_obs_id_\"]\n    elif \"obs_id\" in df.columns and not df[\"obs_id\"].duplicated().any():\n        df.index = df[\"obs_id\"]\n    return df\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays._rmatrix_to_py","title":"<code>_rmatrix_to_py(obj, shm=None)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_arrays.py</code> <pre><code>def _rmatrix_to_py(\n    obj: \"Matrix\", shm: ShmPool | None = None\n) -&gt; pd.DataFrame | np.ndarray | ShmArray | ShmDataFrameSimple:\n    if len(obj.dim) != 2:\n        raise Exception(\"Matrix with dims != 2. Unimplemented conversion\")\n\n    # No shm, fall back to regular numpy\n    if shm is None:\n        return np.array(obj)\n\n    dtypestr, itemsize = _get_rvector_types(obj)\n\n    if not dtypestr or not itemsize:\n        return _rmatrix_to_py_default(obj)\n\n    dtype = np.dtype(dtypestr)\n\n    rvecnp, src = _get_rvector_memview(obj)\n    if rvecnp is None or src is None:\n        return _rmatrix_to_py_default(obj)\n\n    nrow, ncol, rownames, colnames = _rmatrix_info(obj)\n\n    expected_bytes = nrow * ncol * itemsize\n\n    # Raw buffer view over R's underlying data (column-major)\n    if src.nbytes != expected_bytes:\n        raise RuntimeError(f\"R matrix bytes={src.nbytes}, expected={expected_bytes}\")\n\n    # Allocate shm once\n    block = shm.alloc(expected_bytes)\n    assert block.shm.buf\n\n    # Single bulk copy: R \u2192 shm, no intermediate ndarray\n    src_bytes = src.cast(\"B\")\n    block.shm.buf[:expected_bytes] = src_bytes\n\n    # Wrap shm buffer as a numpy array, matching R's column-major layout\n    if not rownames and not colnames:\n        return ShmArray.from_block(block=block, shape=(nrow, ncol), dtype=dtype)\n\n    df = ShmDataFrameSimple.from_block(\n        block=block,\n        nrows=nrow,\n        ncols=ncol,\n        columns=colnames,\n        index=rownames,\n        dtype=dtype,\n    )\n\n    if \"_obs_id_\" in df.columns and not df[\"_obs_id_\"].duplicated().any():\n        df.index = df[\"_obs_id_\"]\n    elif \"obs_id\" in df.columns and not df[\"obs_id\"].duplicated().any():\n        df.index = df[\"obs_id\"]\n\n    return df\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays._r2py_matrix","title":"<code>_r2py_matrix(obj, shm=None)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_arrays.py</code> <pre><code>def _r2py_matrix(obj: \"Matrix\", shm: ShmPool | None = None) -&gt; PyObject:\n    return _rmatrix_to_py(obj=obj, shm=shm)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays._r2py_dataframe_fallback","title":"<code>_r2py_dataframe_fallback(obj)</code>","text":"<p>Fallback conversion for R data.frame -&gt; pandas.DataFrame.</p> Notes <p>In some environments, rpy2/pandas2ri may convert R factors to their underlying integer codes instead of <code>pandas.Categorical</code>. Since brmspy relies on factors roundtripping as categoricals (and we have custom factor handling in <code>_r2py_vector()</code>), we patch factor columns explicitly here.</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_arrays.py</code> <pre><code>def _r2py_dataframe_fallback(obj: \"DataFrame\") -&gt; PyObject:\n    \"\"\"\n    Fallback conversion for R data.frame -&gt; pandas.DataFrame.\n\n    Notes\n    -----\n    In some environments, rpy2/pandas2ri may convert R factors to their underlying\n    integer codes instead of `pandas.Categorical`. Since brmspy relies on factors\n    roundtripping as categoricals (and we have custom factor handling in\n    [`_r2py_vector()`][brmspy.helpers._rpy2._converters._vectors._r2py_vector]),\n    we patch factor columns explicitly here.\n    \"\"\"\n    import rpy2.robjects as ro\n    from rpy2.robjects import pandas2ri\n    from rpy2.robjects.conversion import localconverter\n\n    with localconverter(pandas2ri.converter) as cv:\n        df = cv.rpy2py(obj)\n\n    # Ensure factor columns come back as pandas categoricals.\n    # (Otherwise they can appear as int32 codes with NA_INTEGER sentinel values.)\n    try:\n        if obj.names is not NULL:\n            for name in list(obj.names):\n                col_name = str(name)\n                if col_name not in df.columns:\n                    continue\n\n                col_r = obj.rx2(name)\n                if isinstance(col_r, ro.FactorVector):\n                    cat = _r2py_vector(col_r, shm=None, allow_scalar=False)\n                    df[col_name] = pd.Series(\n                        cast(np.ndarray, cat), index=df.index, name=col_name, copy=False\n                    )\n    except Exception:\n        # Best-effort: never let fallback conversion fail due to factor patching.\n        pass\n\n    return _adjust_df_for_py(df)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays._r2py_dataframe","title":"<code>_r2py_dataframe(obj, shm=None)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_arrays.py</code> <pre><code>def _r2py_dataframe(obj: \"DataFrame\", shm: ShmPool | None = None) -&gt; PyObject:\n    if not shm:\n        return _r2py_dataframe_fallback(obj)\n\n    try:\n        from rpy2.robjects.pandas2ri import _flatten_dataframe\n\n        rownames = list(obj.rownames)\n        if len(rownames) == 0:\n            return pd.DataFrame({})\n\n        # convert straight into ShmDataframeColumns\n        colnames_lst = []\n        od = OrderedDict()\n        od_r = OrderedDict()\n        for i, col in enumerate(_flatten_dataframe(obj, colnames_lst)):\n            arr = _r2py_vector(col, shm, allow_scalar=False)\n            od_r[i] = col\n            od[i] = arr\n\n        res = ShmDataFrameColumns(od)\n        res.columns = tuple(\n            \".\".join(_) if isinstance(_, list) else _ for _ in colnames_lst\n        )\n        res.index = rownames\n        res._set_shm_metadata({})\n\n        if res.empty:\n            return res\n\n        for col in res.columns:\n            # Side-effect: ShmDataFrameColumns overrides __setitem__/events;\n            # assigning the same Series forces the \"put column to SHM\" path\n            # DO NOT REMOVE!\n            res[col] = res[col]\n        res = _adjust_df_for_py(res)\n\n        return res\n    except Exception as e:\n        log_warning(\n            f\"ShmDataFrameColumns conversion failed, falling back to default. Reason: {e}\"\n        )\n        return _r2py_dataframe_fallback(obj)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays._adjust_df_for_r","title":"<code>_adjust_df_for_r(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_arrays.py</code> <pre><code>def _adjust_df_for_r(obj: pd.DataFrame) -&gt; pd.DataFrame:\n    if \"_obs_id_\" not in obj.columns:\n        if obj.index.nlevels == 1:\n            obj[\"_obs_id_\"] = obj.index\n        else:\n            obj = obj.assign(_obs_id_=range(len(obj)))\n\n    for c in obj.columns:\n        s = obj[c]\n        if isinstance(s.dtype, pd.CategoricalDtype):\n            cats = s.dtype.categories\n            # needs string categories for factor conversion\n            if cats.inferred_type != \"string\":\n                # log_warning(\n                #    f\"Column {c} has non-string categories, converting to string.\"\n                # )\n                obj[c] = s.cat.rename_categories(cats.map(str))\n\n        elif pd.api.types.is_integer_dtype(s.dtype) and s.dtype != np.int32:\n            obj[c] = obj[c].astype(\"int32\")\n        elif pd.api.types.is_float_dtype(s.dtype) and s.dtype != np.float64:\n            obj[c] = obj[c].astype(\"float64\")\n\n    return obj\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays._adjust_df_for_py","title":"<code>_adjust_df_for_py(df)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_arrays.py</code> <pre><code>def _adjust_df_for_py(df: pd.DataFrame) -&gt; pd.DataFrame:\n    if \"_obs_id_\" in df.columns:\n        df = df.set_index(\"_obs_id_\", drop=True)\n    return df\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays._py2r_dataframe","title":"<code>_py2r_dataframe(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_arrays.py</code> <pre><code>def _py2r_dataframe(obj: pd.DataFrame) -&gt; Sexp:\n    from rpy2.robjects import pandas2ri\n    from rpy2.robjects.conversion import localconverter\n\n    obj = _adjust_df_for_r(obj)\n\n    with localconverter(pandas2ri.converter) as cv:\n        return cv.py2rpy(obj)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_arrays/#brmspy.helpers._rpy2._converters._arrays._py2r_numpy","title":"<code>_py2r_numpy(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_arrays.py</code> <pre><code>def _py2r_numpy(obj: np.ndarray) -&gt; Sexp:\n    from rpy2.robjects import numpy2ri, pandas2ri\n    from rpy2.robjects.conversion import localconverter\n\n    with localconverter(pandas2ri.converter + numpy2ri.converter) as cv:\n        return cv.py2rpy(obj)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_dispatch/","title":"_dispatch","text":""},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.PyObject","title":"<code>PyObject = Union[dict, list, str, float, int, np.dtype, None, Any, pd.DataFrame, pd.Series, np.ndarray, az.InferenceData, xr.DataArray, xr.Dataset]</code>  <code>module-attribute</code>","text":"<p>Union of common Python-side objects produced by R\u2192Python conversion.</p> <p>This is intentionally broad: brmspy frequently returns standard scientific Python types (NumPy/pandas/xarray/ArviZ), plus plain dict/list primitives.</p> Note <p>Avoid adding <code>Any</code> here unless absolutely necessary; it defeats the purpose of having this alias.</p>"},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch-classes","title":"Classes","text":""},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.RListVectorExtension","title":"<code>RListVectorExtension</code>  <code>dataclass</code>","text":"<p>Generic result container with R objects.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R object from brms</p> Source code in <code>brmspy/types/brms_results.py</code> <pre><code>@dataclass\nclass RListVectorExtension:\n    \"\"\"Generic result container with R objects.\n\n    Attributes\n    ----------\n    r : robjects.ListVector\n        R object from brms\n    \"\"\"\n\n    r: ProxyListSexpVector\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.RListVectorExtension-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.RListVectorExtension.r","title":"<code>r</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.RListVectorExtension-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.RListVectorExtension.__init__","title":"<code>__init__(r)</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.ShmPool","title":"<code>ShmPool</code>","text":"<p>Minimal interface for allocating and attaching shared-memory blocks.</p> <p>The concrete implementation lives in <code>brmspy._session.transport.ShmPool</code> and tracks blocks so they can be closed on teardown.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>class ShmPool:\n    \"\"\"\n    Minimal interface for allocating and attaching shared-memory blocks.\n\n    The concrete implementation lives in\n    [`brmspy._session.transport.ShmPool`][brmspy._session.transport.ShmPool] and tracks\n    blocks so they can be closed on teardown.\n    \"\"\"\n\n    def __init__(self, manager: SharedMemoryManager) -&gt; None:\n        \"\"\"\n        Create a pool bound to an existing `SharedMemoryManager`.\n\n        Parameters\n        ----------\n        manager : multiprocessing.managers.SharedMemoryManager\n            Manager used to allocate blocks.\n        \"\"\"\n        ...\n\n    def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n        \"\"\"\n        Allocate a new shared-memory block.\n\n        Parameters\n        ----------\n        size : int\n            Size in bytes.\n\n        Returns\n        -------\n        ShmBlock\n            Newly allocated block.\n        \"\"\"\n        ...\n\n    def attach(self, ref: ShmRef) -&gt; ShmBlock:\n        \"\"\"\n        Attach to an existing shared-memory block by name.\n\n        Returns\n        -------\n        ShmBlock\n            Attached block.\n        \"\"\"\n        ...\n\n    def close_all(self) -&gt; None:\n        \"\"\"\n        Close all tracked shared-memory handles owned by this pool.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        ...\n\n    def gc(self, name: str | None = None) -&gt; None: ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.ShmPool-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.ShmPool.__init__","title":"<code>__init__(manager)</code>","text":"<p>Create a pool bound to an existing <code>SharedMemoryManager</code>.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SharedMemoryManager</code> <p>Manager used to allocate blocks.</p> required Source code in <code>brmspy/types/shm.py</code> <pre><code>def __init__(self, manager: SharedMemoryManager) -&gt; None:\n    \"\"\"\n    Create a pool bound to an existing `SharedMemoryManager`.\n\n    Parameters\n    ----------\n    manager : multiprocessing.managers.SharedMemoryManager\n        Manager used to allocate blocks.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.ShmPool.alloc","title":"<code>alloc(size, temporary=False)</code>","text":"<p>Allocate a new shared-memory block.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size in bytes.</p> required <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Newly allocated block.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n    \"\"\"\n    Allocate a new shared-memory block.\n\n    Parameters\n    ----------\n    size : int\n        Size in bytes.\n\n    Returns\n    -------\n    ShmBlock\n        Newly allocated block.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.ShmPool.attach","title":"<code>attach(ref)</code>","text":"<p>Attach to an existing shared-memory block by name.</p> <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Attached block.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>def attach(self, ref: ShmRef) -&gt; ShmBlock:\n    \"\"\"\n    Attach to an existing shared-memory block by name.\n\n    Returns\n    -------\n    ShmBlock\n        Attached block.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.ShmPool.close_all","title":"<code>close_all()</code>","text":"<p>Close all tracked shared-memory handles owned by this pool.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>brmspy/types/shm.py</code> <pre><code>def close_all(self) -&gt; None:\n    \"\"\"\n    Close all tracked shared-memory handles owned by this pool.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.ShmPool.gc","title":"<code>gc(name=None)</code>","text":"Source code in <code>brmspy/types/shm.py</code> <pre><code>def gc(self, name: str | None = None) -&gt; None: ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.r_to_py","title":"<code>r_to_py(obj, shm=None)</code>","text":"<p>Convert R objects to Python objects via rpy2.</p> <p>Comprehensive converter that handles R lists (named/unnamed), vectors, formulas, and language objects. Provides sensible Python equivalents for all R types with special handling for edge cases.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>rpy2 R object</code> <p>R object to convert to Python</p> required <p>Returns:</p> Type Description <code>any</code> <p>Python representation of the R object: - R NULL \u2192 None - Named list \u2192 dict (recursively) - Unnamed list \u2192 list (recursively) - Length-1 vector \u2192 scalar (int, float, str, bool) - Length-N vector \u2192 list of scalars - Formula/Language object \u2192 str (descriptive representation) - Other objects \u2192 default rpy2 conversion or str fallback</p> Notes <p>Conversion Rules:</p> <ol> <li>R NULL: \u2192 Python None</li> <li>Atomic vectors (numeric, character, logical):</li> <li>Length 1: \u2192 Python scalar (int, float, str, bool)</li> <li>Length &gt;1: \u2192 Python list of scalars</li> <li>Named lists (ListVector with names): \u2192 Python dict, recursively</li> <li>Unnamed lists: \u2192 Python list, recursively</li> <li>Formulas (e.g., <code>y ~ x</code>): \u2192 String representation</li> <li>Language objects (calls, expressions): \u2192 String representation</li> <li>Functions: \u2192 String representation</li> <li>Everything else: Try default rpy2 conversion, fallback to string</li> </ol> <p>Recursive Conversion:</p> <p>List elements and dictionary values are recursively converted: <pre><code>list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n</code></pre></p> <p>Safe Fallback:</p> <p>R language objects, formulas, and functions are converted to descriptive strings rather than attempting complex conversions that might fail.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import r_to_py\nimport rpy2.robjects as ro\n\n# R NULL\nr_to_py(ro.NULL)  # None\n\n# Scalars\nr_to_py(ro.IntVector([5]))    # 5\nr_to_py(ro.FloatVector([3.14]))  # 3.14\nr_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n# Vectors\nr_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n</code></pre> See Also <p>py_to_r : Convert Python objects to R brmspy.brms.summary : Returns Python-friendly summary dict</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def r_to_py(obj: Sexp, shm: ShmPool | None = None) -&gt; PyObject:\n    \"\"\"\n    Convert R objects to Python objects via rpy2.\n\n    Comprehensive converter that handles R lists (named/unnamed), vectors,\n    formulas, and language objects. Provides sensible Python equivalents\n    for all R types with special handling for edge cases.\n\n    Parameters\n    ----------\n    obj : rpy2 R object\n        R object to convert to Python\n\n    Returns\n    -------\n    any\n        Python representation of the R object:\n        - R NULL \u2192 None\n        - Named list \u2192 dict (recursively)\n        - Unnamed list \u2192 list (recursively)\n        - Length-1 vector \u2192 scalar (int, float, str, bool)\n        - Length-N vector \u2192 list of scalars\n        - Formula/Language object \u2192 str (descriptive representation)\n        - Other objects \u2192 default rpy2 conversion or str fallback\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **R NULL**: \u2192 Python None\n    2. **Atomic vectors** (numeric, character, logical):\n       - Length 1: \u2192 Python scalar (int, float, str, bool)\n       - Length &gt;1: \u2192 Python list of scalars\n    3. **Named lists** (ListVector with names): \u2192 Python dict, recursively\n    4. **Unnamed lists**: \u2192 Python list, recursively\n    5. **Formulas** (e.g., `y ~ x`): \u2192 String representation\n    6. **Language objects** (calls, expressions): \u2192 String representation\n    7. **Functions**: \u2192 String representation\n    8. **Everything else**: Try default rpy2 conversion, fallback to string\n\n    **Recursive Conversion:**\n\n    List elements and dictionary values are recursively converted:\n    ```R\n    list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n    ```\n\n    **Safe Fallback:**\n\n    R language objects, formulas, and functions are converted to descriptive\n    strings rather than attempting complex conversions that might fail.\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import r_to_py\n    import rpy2.robjects as ro\n\n    # R NULL\n    r_to_py(ro.NULL)  # None\n\n    # Scalars\n    r_to_py(ro.IntVector([5]))    # 5\n    r_to_py(ro.FloatVector([3.14]))  # 3.14\n    r_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n    # Vectors\n    r_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n    ```\n\n    See Also\n    --------\n    py_to_r : Convert Python objects to R\n    brmspy.brms.summary : Returns Python-friendly summary dict\n    \"\"\"\n    import rpy2.robjects as ro\n\n    from brmspy._singleton._shm_singleton import _get_shm\n\n    if obj is ro.NULL:\n        return None\n\n    _type = type(obj)\n    converter = None\n\n    if shm is None:\n        shm = _get_shm()\n\n    if _type in _registry._R2PY_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._R2PY_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._R2PY_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._R2PY_CONVERTERS) &gt; 0, \"NO R2PY CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj, shm)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_dispatch/#brmspy.helpers._rpy2._converters._dispatch.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def py_to_r(obj: PyObject) -&gt; Sexp:\n    \"\"\"\n    Convert arbitrary Python objects to R objects via rpy2.\n\n    Comprehensive converter that handles nested structures (dicts, lists),\n    DataFrames, arrays, and scalars. Uses rpy2's converters with special\n    handling for dictionaries (\u2192 R named lists) and lists of dicts.\n\n    Parameters\n    ----------\n    obj : any\n        Python object to convert. Supported types:\n        - None \u2192 R NULL\n        - dict \u2192 R named list (ListVector), recursively\n        - list/tuple of dicts \u2192 R list of named lists\n        - list/tuple (other) \u2192 R vector or list\n        - pd.DataFrame \u2192 R data.frame\n        - np.ndarray \u2192 R vector/matrix\n        - scalars (int, float, str, bool) \u2192 R atomic types\n\n    Returns\n    -------\n    rpy2 R object\n        R representation of the Python object\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **None**: \u2192 R NULL\n    2. **DataFrames**: \u2192 R data.frame (via pandas2ri)\n    3. **Dictionaries**: \u2192 R named list (ListVector), recursively converting values\n    4. **Lists of dicts**: \u2192 R list with 1-based indexed names containing named lists\n    5. **Other lists/tuples**: \u2192 R vectors or lists (via rpy2 default)\n    6. **NumPy arrays**: \u2192 R vectors/matrices (via numpy2ri)\n    7. **Scalars**: \u2192 R atomic values\n\n    **Recursive Conversion:**\n\n    Dictionary values are recursively converted, allowing nested structures:\n    ```python\n    {'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n    ```\n\n    **List of Dicts:**\n\n    Lists containing only dicts are converted to R lists with 1-based indexing:\n    ```python\n    [{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n    ```\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import py_to_r\n    import numpy as np\n    import pandas as pd\n\n    # Scalars\n    py_to_r(5)        # R: 5\n    py_to_r(\"hello\")  # R: \"hello\"\n    py_to_r(None)     # R: NULL\n\n    # Arrays\n    py_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n    # DataFrames\n    df = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\n    py_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n    ```\n\n    See Also\n    --------\n    r_to_py : Convert R objects back to Python\n    kwargs_r : Convert keyword arguments dict for R function calls\n    brmspy.brms.fit : Uses this for converting data to R\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if obj is None:\n        return ro.NULL\n\n    if isinstance(obj, ro.Sexp):\n        return obj\n\n    if isinstance(obj, RListVectorExtension) and isinstance(obj.r, ro.Sexp):\n        return obj.r\n\n    _type = type(obj)\n    converter = None\n\n    if _type in _registry._PY2R_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._PY2R_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._PY2R_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._PY2R_CONVERTERS) &gt; 0, \"NO PY2R CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_formula/","title":"_formula","text":""},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula._FORMULA_FUNCTION_WHITELIST","title":"<code>_FORMULA_FUNCTION_WHITELIST = Literal['bf', 'lf', 'nlf', 'acformula', 'set_rescor', 'set_mecor', 'set_nl']</code>  <code>module-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula-classes","title":"Classes","text":""},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula.FormulaPart","title":"<code>FormulaPart</code>  <code>dataclass</code>","text":"<p>A single formula helper invocation.</p> <p>Instances of this type represent a call like <code>bf(\"y ~ x\")</code> or <code>set_rescor(True)</code> without executing anything. They are primarily used as nodes inside a <code>FormulaConstruct</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_fun</code> <code>Literal[...]</code> <p>Whitelisted formula helper name.</p> required <code>_args</code> <code>Sequence[Primitive]</code> <p>Positional arguments for the helper.</p> required <code>_kwargs</code> <code>Mapping[str, Primitive]</code> <p>Keyword arguments for the helper.</p> required Notes <p>This is a low-level type. Most users should construct these via the public helper functions in <code>brmspy.brms</code>.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>@dataclass\nclass FormulaPart:\n    \"\"\"\n    A single formula helper invocation.\n\n    Instances of this type represent a call like `bf(\"y ~ x\")` or `set_rescor(True)`\n    without executing anything. They are primarily used as nodes inside a\n    [`FormulaConstruct`][brmspy.types.formula_dsl.FormulaConstruct].\n\n    Parameters\n    ----------\n    _fun : Literal[...]\n        Whitelisted formula helper name.\n    _args : Sequence[Primitive]\n        Positional arguments for the helper.\n    _kwargs : Mapping[str, Primitive]\n        Keyword arguments for the helper.\n\n    Notes\n    -----\n    This is a low-level type. Most users should construct these via the public\n    helper functions in [`brmspy.brms`][brmspy.brms].\n    \"\"\"\n\n    _fun: _FORMULA_FUNCTION_WHITELIST\n    _args: Sequence[Primitive]\n    _kwargs: Mapping[str, Primitive]\n\n    def __post_init__(self):\n        \"\"\"Validate `_fun`, `_args`, and `_kwargs` types after construction.\"\"\"\n        # Validate function name first\n        if self._fun not in get_args(_FORMULA_FUNCTION_WHITELIST):\n            raise ValueError(\n                f\"FormulaPart._fun must be one of {_FORMULA_FUNCTION_WHITELIST!r}, \"\n                f\"got {self._fun!r}\"\n            )\n\n        # Enforce _args is a list\n        if not isinstance(self._args, Sequence):\n            raise TypeError(\n                f\"FormulaPart._args must be a Sequence, got {type(self._args).__name__}\"\n            )\n\n        # Enforce _kwargs is a dict\n        if not isinstance(self._kwargs, Mapping):\n            raise TypeError(\n                f\"FormulaPart._kwargs must be a Mapping, got {type(self._kwargs).__name__}\"\n            )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Render a readable `fun(arg1, ..., kw=...)` representation.\"\"\"\n        args = \", \".join(repr(a) for a in self._args)\n        kwargs = \", \".join(f\"{k}={v!r}\" for k, v in self._kwargs.items())\n        inner = \", \".join(x for x in (args, kwargs) if x)\n        return f\"{self._fun}({inner})\"\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula.FormulaPart-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula.FormulaPart._fun","title":"<code>_fun</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula.FormulaPart._args","title":"<code>_args</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula.FormulaPart._kwargs","title":"<code>_kwargs</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula.FormulaPart-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula.FormulaPart.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate <code>_fun</code>, <code>_args</code>, and <code>_kwargs</code> types after construction.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validate `_fun`, `_args`, and `_kwargs` types after construction.\"\"\"\n    # Validate function name first\n    if self._fun not in get_args(_FORMULA_FUNCTION_WHITELIST):\n        raise ValueError(\n            f\"FormulaPart._fun must be one of {_FORMULA_FUNCTION_WHITELIST!r}, \"\n            f\"got {self._fun!r}\"\n        )\n\n    # Enforce _args is a list\n    if not isinstance(self._args, Sequence):\n        raise TypeError(\n            f\"FormulaPart._args must be a Sequence, got {type(self._args).__name__}\"\n        )\n\n    # Enforce _kwargs is a dict\n    if not isinstance(self._kwargs, Mapping):\n        raise TypeError(\n            f\"FormulaPart._kwargs must be a Mapping, got {type(self._kwargs).__name__}\"\n        )\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula.FormulaPart.__str__","title":"<code>__str__()</code>","text":"<p>Render a readable <code>fun(arg1, ..., kw=...)</code> representation.</p> Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Render a readable `fun(arg1, ..., kw=...)` representation.\"\"\"\n    args = \", \".join(repr(a) for a in self._args)\n    kwargs = \", \".join(f\"{k}={v!r}\" for k, v in self._kwargs.items())\n    inner = \", \".join(x for x in (args, kwargs) if x)\n    return f\"{self._fun}({inner})\"\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula.FormulaPart.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>brmspy/types/formula_dsl.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self.__str__()\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula.FormulaPart.__init__","title":"<code>__init__(_fun, _args, _kwargs)</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def py_to_r(obj: PyObject) -&gt; Sexp:\n    \"\"\"\n    Convert arbitrary Python objects to R objects via rpy2.\n\n    Comprehensive converter that handles nested structures (dicts, lists),\n    DataFrames, arrays, and scalars. Uses rpy2's converters with special\n    handling for dictionaries (\u2192 R named lists) and lists of dicts.\n\n    Parameters\n    ----------\n    obj : any\n        Python object to convert. Supported types:\n        - None \u2192 R NULL\n        - dict \u2192 R named list (ListVector), recursively\n        - list/tuple of dicts \u2192 R list of named lists\n        - list/tuple (other) \u2192 R vector or list\n        - pd.DataFrame \u2192 R data.frame\n        - np.ndarray \u2192 R vector/matrix\n        - scalars (int, float, str, bool) \u2192 R atomic types\n\n    Returns\n    -------\n    rpy2 R object\n        R representation of the Python object\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **None**: \u2192 R NULL\n    2. **DataFrames**: \u2192 R data.frame (via pandas2ri)\n    3. **Dictionaries**: \u2192 R named list (ListVector), recursively converting values\n    4. **Lists of dicts**: \u2192 R list with 1-based indexed names containing named lists\n    5. **Other lists/tuples**: \u2192 R vectors or lists (via rpy2 default)\n    6. **NumPy arrays**: \u2192 R vectors/matrices (via numpy2ri)\n    7. **Scalars**: \u2192 R atomic values\n\n    **Recursive Conversion:**\n\n    Dictionary values are recursively converted, allowing nested structures:\n    ```python\n    {'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n    ```\n\n    **List of Dicts:**\n\n    Lists containing only dicts are converted to R lists with 1-based indexing:\n    ```python\n    [{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n    ```\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import py_to_r\n    import numpy as np\n    import pandas as pd\n\n    # Scalars\n    py_to_r(5)        # R: 5\n    py_to_r(\"hello\")  # R: \"hello\"\n    py_to_r(None)     # R: NULL\n\n    # Arrays\n    py_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n    # DataFrames\n    df = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\n    py_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n    ```\n\n    See Also\n    --------\n    r_to_py : Convert R objects back to Python\n    kwargs_r : Convert keyword arguments dict for R function calls\n    brmspy.brms.fit : Uses this for converting data to R\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if obj is None:\n        return ro.NULL\n\n    if isinstance(obj, ro.Sexp):\n        return obj\n\n    if isinstance(obj, RListVectorExtension) and isinstance(obj.r, ro.Sexp):\n        return obj.r\n\n    _type = type(obj)\n    converter = None\n\n    if _type in _registry._PY2R_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._PY2R_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._PY2R_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._PY2R_CONVERTERS) &gt; 0, \"NO PY2R CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_formula/#brmspy.helpers._rpy2._converters._formula._py2r_formula_part","title":"<code>_py2r_formula_part(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_formula.py</code> <pre><code>def _py2r_formula_part(obj: FormulaPart) -&gt; Sexp:\n    import rpy2.robjects as ro\n\n    args = [py_to_r(o) for o in obj._args]\n    kwargs = {k: py_to_r(v) for k, v in obj._kwargs.items()}\n\n    assert obj._fun in get_args(_FORMULA_FUNCTION_WHITELIST)\n\n    fun = cast(Callable, ro.r(f\"brms::{obj._fun}\"))\n    return fun(*args, **kwargs)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_generic/","title":"_generic","text":""},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic.PyObject","title":"<code>PyObject = Union[dict, list, str, float, int, np.dtype, None, Any, pd.DataFrame, pd.Series, np.ndarray, az.InferenceData, xr.DataArray, xr.Dataset]</code>  <code>module-attribute</code>","text":"<p>Union of common Python-side objects produced by R\u2192Python conversion.</p> <p>This is intentionally broad: brmspy frequently returns standard scientific Python types (NumPy/pandas/xarray/ArviZ), plus plain dict/list primitives.</p> Note <p>Avoid adding <code>Any</code> here unless absolutely necessary; it defeats the purpose of having this alias.</p>"},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic-classes","title":"Classes","text":""},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic.ShmPool","title":"<code>ShmPool</code>","text":"<p>Minimal interface for allocating and attaching shared-memory blocks.</p> <p>The concrete implementation lives in <code>brmspy._session.transport.ShmPool</code> and tracks blocks so they can be closed on teardown.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>class ShmPool:\n    \"\"\"\n    Minimal interface for allocating and attaching shared-memory blocks.\n\n    The concrete implementation lives in\n    [`brmspy._session.transport.ShmPool`][brmspy._session.transport.ShmPool] and tracks\n    blocks so they can be closed on teardown.\n    \"\"\"\n\n    def __init__(self, manager: SharedMemoryManager) -&gt; None:\n        \"\"\"\n        Create a pool bound to an existing `SharedMemoryManager`.\n\n        Parameters\n        ----------\n        manager : multiprocessing.managers.SharedMemoryManager\n            Manager used to allocate blocks.\n        \"\"\"\n        ...\n\n    def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n        \"\"\"\n        Allocate a new shared-memory block.\n\n        Parameters\n        ----------\n        size : int\n            Size in bytes.\n\n        Returns\n        -------\n        ShmBlock\n            Newly allocated block.\n        \"\"\"\n        ...\n\n    def attach(self, ref: ShmRef) -&gt; ShmBlock:\n        \"\"\"\n        Attach to an existing shared-memory block by name.\n\n        Returns\n        -------\n        ShmBlock\n            Attached block.\n        \"\"\"\n        ...\n\n    def close_all(self) -&gt; None:\n        \"\"\"\n        Close all tracked shared-memory handles owned by this pool.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        ...\n\n    def gc(self, name: str | None = None) -&gt; None: ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic.ShmPool-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic.ShmPool.__init__","title":"<code>__init__(manager)</code>","text":"<p>Create a pool bound to an existing <code>SharedMemoryManager</code>.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SharedMemoryManager</code> <p>Manager used to allocate blocks.</p> required Source code in <code>brmspy/types/shm.py</code> <pre><code>def __init__(self, manager: SharedMemoryManager) -&gt; None:\n    \"\"\"\n    Create a pool bound to an existing `SharedMemoryManager`.\n\n    Parameters\n    ----------\n    manager : multiprocessing.managers.SharedMemoryManager\n        Manager used to allocate blocks.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic.ShmPool.alloc","title":"<code>alloc(size, temporary=False)</code>","text":"<p>Allocate a new shared-memory block.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size in bytes.</p> required <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Newly allocated block.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n    \"\"\"\n    Allocate a new shared-memory block.\n\n    Parameters\n    ----------\n    size : int\n        Size in bytes.\n\n    Returns\n    -------\n    ShmBlock\n        Newly allocated block.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic.ShmPool.attach","title":"<code>attach(ref)</code>","text":"<p>Attach to an existing shared-memory block by name.</p> <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Attached block.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>def attach(self, ref: ShmRef) -&gt; ShmBlock:\n    \"\"\"\n    Attach to an existing shared-memory block by name.\n\n    Returns\n    -------\n    ShmBlock\n        Attached block.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic.ShmPool.close_all","title":"<code>close_all()</code>","text":"<p>Close all tracked shared-memory handles owned by this pool.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>brmspy/types/shm.py</code> <pre><code>def close_all(self) -&gt; None:\n    \"\"\"\n    Close all tracked shared-memory handles owned by this pool.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic.ShmPool.gc","title":"<code>gc(name=None)</code>","text":"Source code in <code>brmspy/types/shm.py</code> <pre><code>def gc(self, name: str | None = None) -&gt; None: ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p> Source code in <code>brmspy/helpers/_rpy2/_converters/_dispatch.py</code> <pre><code>def py_to_r(obj: PyObject) -&gt; Sexp:\n    \"\"\"\n    Convert arbitrary Python objects to R objects via rpy2.\n\n    Comprehensive converter that handles nested structures (dicts, lists),\n    DataFrames, arrays, and scalars. Uses rpy2's converters with special\n    handling for dictionaries (\u2192 R named lists) and lists of dicts.\n\n    Parameters\n    ----------\n    obj : any\n        Python object to convert. Supported types:\n        - None \u2192 R NULL\n        - dict \u2192 R named list (ListVector), recursively\n        - list/tuple of dicts \u2192 R list of named lists\n        - list/tuple (other) \u2192 R vector or list\n        - pd.DataFrame \u2192 R data.frame\n        - np.ndarray \u2192 R vector/matrix\n        - scalars (int, float, str, bool) \u2192 R atomic types\n\n    Returns\n    -------\n    rpy2 R object\n        R representation of the Python object\n\n    Notes\n    -----\n    **Conversion Rules:**\n\n    1. **None**: \u2192 R NULL\n    2. **DataFrames**: \u2192 R data.frame (via pandas2ri)\n    3. **Dictionaries**: \u2192 R named list (ListVector), recursively converting values\n    4. **Lists of dicts**: \u2192 R list with 1-based indexed names containing named lists\n    5. **Other lists/tuples**: \u2192 R vectors or lists (via rpy2 default)\n    6. **NumPy arrays**: \u2192 R vectors/matrices (via numpy2ri)\n    7. **Scalars**: \u2192 R atomic values\n\n    **Recursive Conversion:**\n\n    Dictionary values are recursively converted, allowing nested structures:\n    ```python\n    {'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n    ```\n\n    **List of Dicts:**\n\n    Lists containing only dicts are converted to R lists with 1-based indexing:\n    ```python\n    [{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n    ```\n\n    Examples\n    --------\n\n    ```python\n    from brmspy.helpers.conversion import py_to_r\n    import numpy as np\n    import pandas as pd\n\n    # Scalars\n    py_to_r(5)        # R: 5\n    py_to_r(\"hello\")  # R: \"hello\"\n    py_to_r(None)     # R: NULL\n\n    # Arrays\n    py_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n    # DataFrames\n    df = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\n    py_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n    ```\n\n    See Also\n    --------\n    r_to_py : Convert R objects back to Python\n    kwargs_r : Convert keyword arguments dict for R function calls\n    brmspy.brms.fit : Uses this for converting data to R\n    \"\"\"\n    import rpy2.robjects as ro\n\n    if obj is None:\n        return ro.NULL\n\n    if isinstance(obj, ro.Sexp):\n        return obj\n\n    if isinstance(obj, RListVectorExtension) and isinstance(obj.r, ro.Sexp):\n        return obj.r\n\n    _type = type(obj)\n    converter = None\n\n    if _type in _registry._PY2R_CONVERTERS:\n        # O(1) lookup first\n        converter = _registry._PY2R_CONVERTERS[_type]\n    else:\n        for _type, _con in _registry._PY2R_CONVERTERS.items():\n            if isinstance(obj, _type):\n                converter = _con\n                break\n\n    assert len(_registry._PY2R_CONVERTERS) &gt; 0, \"NO PY2R CONVERTERS\"\n    assert (\n        converter\n    ), \"object fallback must be in place in __init__.py! This is an issue with the library, not the user!\"\n    return converter(obj)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic._r2py_fallback","title":"<code>_r2py_fallback(obj, shm=None)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_generic.py</code> <pre><code>def _r2py_fallback(obj: Sexp, shm: ShmPool | None = None) -&gt; PyObject:\n    from rpy2.robjects import default_converter\n    from rpy2.robjects.conversion import localconverter\n\n    try:\n        with localconverter(default_converter) as cv:\n            return cv.rpy2py(obj)\n    except Exception:\n        return str(obj)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic._py2r_fallback","title":"<code>_py2r_fallback(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_generic.py</code> <pre><code>def _py2r_fallback(obj: PyObject) -&gt; Sexp:\n    from rpy2.robjects import default_converter, numpy2ri, pandas2ri\n    from rpy2.robjects.conversion import localconverter\n\n    with localconverter(\n        default_converter + pandas2ri.converter + numpy2ri.converter\n    ) as cv:\n        return cv.py2rpy(obj)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic._r2py_language","title":"<code>_r2py_language(obj, shm=None)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_generic.py</code> <pre><code>def _r2py_language(\n    obj: Union[\"Formula\", \"LangSexpVector\", \"SignatureTranslatedFunction\"],\n    shm: ShmPool | None = None,\n) -&gt; PyObject:\n    return str(obj)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_generic/#brmspy.helpers._rpy2._converters._generic._py2r_mapping","title":"<code>_py2r_mapping(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_generic.py</code> <pre><code>def _py2r_mapping(\n    obj: Mapping,\n) -&gt; Sexp:\n    import rpy2.robjects as ro\n\n    converted = {str(k): py_to_r(v) for k, v in obj.items()}\n    return ro.ListVector(converted)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_registry/","title":"_registry","text":""},{"location":"internals/helpers/_rpy2/_converters/_registry/#brmspy.helpers._rpy2._converters._registry-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_converters/_registry/#brmspy.helpers._rpy2._converters._registry.Py2rConverter","title":"<code>Py2rConverter = Callable[[Any], Sexp]</code>  <code>module-attribute</code>","text":"<p>Callable signature for a Python\u2192R converter.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Python object to convert.</p> required <p>Returns:</p> Type Description <code>Sexp</code> <p>Low-level R object handle.</p>"},{"location":"internals/helpers/_rpy2/_converters/_registry/#brmspy.helpers._rpy2._converters._registry.R2pyConverter","title":"<code>R2pyConverter = Callable[[Any, ShmPool | None], PyObject]</code>  <code>module-attribute</code>","text":"<p>Callable signature for an R\u2192Python converter.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>R-side object (usually an rpy2 wrapper type).</p> required <code>shm</code> <code>ShmPool or None</code> <p>Shared memory pool used to allocate backing buffers for large numeric payloads.</p> required <p>Returns:</p> Type Description <code>PyObject</code>"},{"location":"internals/helpers/_rpy2/_converters/_registry/#brmspy.helpers._rpy2._converters._registry._R2PY_CONVERTERS","title":"<code>_R2PY_CONVERTERS = {}</code>  <code>module-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_registry/#brmspy.helpers._rpy2._converters._registry._PY2R_CONVERTERS","title":"<code>_PY2R_CONVERTERS = {}</code>  <code>module-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_vectors/","title":"_vectors","text":""},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.PyObject","title":"<code>PyObject = Union[dict, list, str, float, int, np.dtype, None, Any, pd.DataFrame, pd.Series, np.ndarray, az.InferenceData, xr.DataArray, xr.Dataset]</code>  <code>module-attribute</code>","text":"<p>Union of common Python-side objects produced by R\u2192Python conversion.</p> <p>This is intentionally broad: brmspy frequently returns standard scientific Python types (NumPy/pandas/xarray/ArviZ), plus plain dict/list primitives.</p> Note <p>Avoid adding <code>Any</code> here unless absolutely necessary; it defeats the purpose of having this alias.</p>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors-classes","title":"Classes","text":""},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmArray","title":"<code>ShmArray</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>NumPy array view backed by a shared-memory block.</p> <p>Attributes:</p> Name Type Description <code>block</code> <code>ShmRef</code> <p>Reference to the shared-memory block backing the array data.</p> Notes <p>This is a view over <code>SharedMemory.buf</code>. Closing/unlinking the underlying shared memory while the array is still in use will lead to undefined behavior.</p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>class ShmArray(np.ndarray):\n    \"\"\"\n    NumPy array view backed by a shared-memory block.\n\n    Attributes\n    ----------\n    block : ShmRef\n        Reference to the shared-memory block backing the array data.\n\n    Notes\n    -----\n    This is a *view* over `SharedMemory.buf`. Closing/unlinking the underlying\n    shared memory while the array is still in use will lead to undefined\n    behavior.\n    \"\"\"\n\n    _shm_metadata: ShmRef  # for type checkers\n\n    @classmethod\n    def from_metadata(\n        cls, meta: ShmArrayMetadata | dict[str, Any], block: ShmBlock\n    ) -&gt; np.ndarray:\n        dtype = np.dtype(meta[\"dtype\"])\n        shape = tuple(meta[\"shape\"])\n        order = meta[\"order\"]\n\n        return ShmArray.from_block(block=block, shape=shape, dtype=dtype, order=order)\n\n    @classmethod\n    def from_block(\n        cls, block: ShmBlock, shape: tuple[int, ...], dtype: np.dtype, **kwargs\n    ) -&gt; Union[\"ShmArray\", np.ndarray]:\n        \"\"\"\n        Create an array view backed by an existing shared-memory block.\n\n        Parameters\n        ----------\n        block : ShmBlock\n            Attached shared-memory block.\n        shape : tuple[int, ...]\n            Desired array shape.\n        dtype : numpy.dtype\n            NumPy dtype of the array.\n        **kwargs\n            Reserved for future compatibility. Currently unused.\n\n        Returns\n        -------\n        ShmArray\n            Array view into the shared-memory buffer.\n        \"\"\"\n        is_object = np.dtype(dtype) == np.dtype(\"O\")\n\n        if not is_object:\n            if block.shm.buf:\n                view = memoryview(block.shm.buf)\n                view = view[: block.content_size]\n            else:\n                view = None\n            base = np.ndarray(\n                shape=shape,\n                dtype=dtype,\n                buffer=view,\n                order=kwargs.get(\"order\", \"F\"),\n            )\n            obj = base.view(ShmArray)\n            obj._shm_metadata = block.to_ref()\n        else:\n            assert block.shm.buf\n            view = memoryview(block.shm.buf)\n            view = view[: block.content_size]\n            payload = bytes(view)\n            obj = pickle.loads(payload)\n            assert isinstance(obj, np.ndarray)\n\n        return obj\n\n    @classmethod\n    def array_order(cls, a: np.ndarray) -&gt; Literal[\"C\", \"F\", \"non-contiguous\"]:\n        \"\"\"\n        Determine how an array can be reconstructed from a raw buffer.\n\n        Returns `\"C\"` for C-contiguous arrays, `\"F\"` for Fortran-contiguous arrays,\n        otherwise `\"non-contiguous\"` (meaning: bytes were obtained by forcing\n        a contiguous copy during encoding).\n        \"\"\"\n        if a.flags[\"C_CONTIGUOUS\"]:\n            return \"C\"\n        if a.flags[\"F_CONTIGUOUS\"]:\n            return \"F\"\n        return \"non-contiguous\"\n\n    @classmethod\n    def is_string_object(cls, a: np.ndarray, sample: int = 1000):\n        if np.dtype(a.dtype) != np.dtype(\"O\"):\n            return False\n        it = a.flat\n        for _ in range(min(sample, a.size)):\n            v = next(it, None)\n            if v is not None and not isinstance(v, str):\n                return False\n        return True\n\n    @classmethod\n    def to_shm(\n        cls, obj: np.ndarray | pd.Series | list, shm_pool: Any\n    ) -&gt; tuple[np.ndarray | None, ShmRef, str, list[int], str]:\n        if isinstance(obj, pd.Series):\n            if isinstance(obj.dtype, pd.CategoricalDtype):\n                arr = obj.cat.codes.to_numpy(copy=False)\n            else:\n                arr = obj.to_numpy(copy=False)\n        elif not isinstance(obj, np.ndarray):\n            arr = np.asarray(obj)\n        else:\n            arr = obj\n\n        is_object = np.dtype(arr.dtype) == np.dtype(\"O\")\n        is_string = cls.is_string_object(arr)\n\n        arr_modified = None\n        if isinstance(arr, ShmArray):\n            ref = arr._shm_metadata\n\n        else:\n            temporary = False\n            if not is_object:\n                data = arr.tobytes(order=\"C\")\n            elif is_string:\n                arr = arr.astype(\"U\")\n                arr_modified = arr\n                data = arr.tobytes(order=\"C\")\n            else:\n                data = pickle.dumps(arr, protocol=pickle.HIGHEST_PROTOCOL)\n                temporary = True\n\n            nbytes = len(data)\n\n            # Ask for exactly nbytes; OS may round up internally, that's fine.\n            block = shm_pool.alloc(nbytes, temporary=temporary)\n            block.shm.buf[:nbytes] = data\n            ref = block.to_ref()\n\n        ref, dtype, shape, order = (\n            ref,\n            str(arr.dtype),\n            list(arr.shape),\n            cls.array_order(arr),\n        )\n\n        return arr_modified, ref, dtype, shape, order\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmArray-attributes","title":"Attributes","text":""},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmArray._shm_metadata","title":"<code>_shm_metadata</code>  <code>instance-attribute</code>","text":""},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmArray-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmArray.from_metadata","title":"<code>from_metadata(meta, block)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef from_metadata(\n    cls, meta: ShmArrayMetadata | dict[str, Any], block: ShmBlock\n) -&gt; np.ndarray:\n    dtype = np.dtype(meta[\"dtype\"])\n    shape = tuple(meta[\"shape\"])\n    order = meta[\"order\"]\n\n    return ShmArray.from_block(block=block, shape=shape, dtype=dtype, order=order)\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmArray.from_block","title":"<code>from_block(block, shape, dtype, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create an array view backed by an existing shared-memory block.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>ShmBlock</code> <p>Attached shared-memory block.</p> required <code>shape</code> <code>tuple[int, ...]</code> <p>Desired array shape.</p> required <code>dtype</code> <code>dtype</code> <p>NumPy dtype of the array.</p> required <code>**kwargs</code> <p>Reserved for future compatibility. Currently unused.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ShmArray</code> <p>Array view into the shared-memory buffer.</p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef from_block(\n    cls, block: ShmBlock, shape: tuple[int, ...], dtype: np.dtype, **kwargs\n) -&gt; Union[\"ShmArray\", np.ndarray]:\n    \"\"\"\n    Create an array view backed by an existing shared-memory block.\n\n    Parameters\n    ----------\n    block : ShmBlock\n        Attached shared-memory block.\n    shape : tuple[int, ...]\n        Desired array shape.\n    dtype : numpy.dtype\n        NumPy dtype of the array.\n    **kwargs\n        Reserved for future compatibility. Currently unused.\n\n    Returns\n    -------\n    ShmArray\n        Array view into the shared-memory buffer.\n    \"\"\"\n    is_object = np.dtype(dtype) == np.dtype(\"O\")\n\n    if not is_object:\n        if block.shm.buf:\n            view = memoryview(block.shm.buf)\n            view = view[: block.content_size]\n        else:\n            view = None\n        base = np.ndarray(\n            shape=shape,\n            dtype=dtype,\n            buffer=view,\n            order=kwargs.get(\"order\", \"F\"),\n        )\n        obj = base.view(ShmArray)\n        obj._shm_metadata = block.to_ref()\n    else:\n        assert block.shm.buf\n        view = memoryview(block.shm.buf)\n        view = view[: block.content_size]\n        payload = bytes(view)\n        obj = pickle.loads(payload)\n        assert isinstance(obj, np.ndarray)\n\n    return obj\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmArray.array_order","title":"<code>array_order(a)</code>  <code>classmethod</code>","text":"<p>Determine how an array can be reconstructed from a raw buffer.</p> <p>Returns <code>\"C\"</code> for C-contiguous arrays, <code>\"F\"</code> for Fortran-contiguous arrays, otherwise <code>\"non-contiguous\"</code> (meaning: bytes were obtained by forcing a contiguous copy during encoding).</p> Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef array_order(cls, a: np.ndarray) -&gt; Literal[\"C\", \"F\", \"non-contiguous\"]:\n    \"\"\"\n    Determine how an array can be reconstructed from a raw buffer.\n\n    Returns `\"C\"` for C-contiguous arrays, `\"F\"` for Fortran-contiguous arrays,\n    otherwise `\"non-contiguous\"` (meaning: bytes were obtained by forcing\n    a contiguous copy during encoding).\n    \"\"\"\n    if a.flags[\"C_CONTIGUOUS\"]:\n        return \"C\"\n    if a.flags[\"F_CONTIGUOUS\"]:\n        return \"F\"\n    return \"non-contiguous\"\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmArray.is_string_object","title":"<code>is_string_object(a, sample=1000)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef is_string_object(cls, a: np.ndarray, sample: int = 1000):\n    if np.dtype(a.dtype) != np.dtype(\"O\"):\n        return False\n    it = a.flat\n    for _ in range(min(sample, a.size)):\n        v = next(it, None)\n        if v is not None and not isinstance(v, str):\n            return False\n    return True\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmArray.to_shm","title":"<code>to_shm(obj, shm_pool)</code>  <code>classmethod</code>","text":"Source code in <code>brmspy/types/shm_extensions.py</code> <pre><code>@classmethod\ndef to_shm(\n    cls, obj: np.ndarray | pd.Series | list, shm_pool: Any\n) -&gt; tuple[np.ndarray | None, ShmRef, str, list[int], str]:\n    if isinstance(obj, pd.Series):\n        if isinstance(obj.dtype, pd.CategoricalDtype):\n            arr = obj.cat.codes.to_numpy(copy=False)\n        else:\n            arr = obj.to_numpy(copy=False)\n    elif not isinstance(obj, np.ndarray):\n        arr = np.asarray(obj)\n    else:\n        arr = obj\n\n    is_object = np.dtype(arr.dtype) == np.dtype(\"O\")\n    is_string = cls.is_string_object(arr)\n\n    arr_modified = None\n    if isinstance(arr, ShmArray):\n        ref = arr._shm_metadata\n\n    else:\n        temporary = False\n        if not is_object:\n            data = arr.tobytes(order=\"C\")\n        elif is_string:\n            arr = arr.astype(\"U\")\n            arr_modified = arr\n            data = arr.tobytes(order=\"C\")\n        else:\n            data = pickle.dumps(arr, protocol=pickle.HIGHEST_PROTOCOL)\n            temporary = True\n\n        nbytes = len(data)\n\n        # Ask for exactly nbytes; OS may round up internally, that's fine.\n        block = shm_pool.alloc(nbytes, temporary=temporary)\n        block.shm.buf[:nbytes] = data\n        ref = block.to_ref()\n\n    ref, dtype, shape, order = (\n        ref,\n        str(arr.dtype),\n        list(arr.shape),\n        cls.array_order(arr),\n    )\n\n    return arr_modified, ref, dtype, shape, order\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmPool","title":"<code>ShmPool</code>","text":"<p>Minimal interface for allocating and attaching shared-memory blocks.</p> <p>The concrete implementation lives in <code>brmspy._session.transport.ShmPool</code> and tracks blocks so they can be closed on teardown.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>class ShmPool:\n    \"\"\"\n    Minimal interface for allocating and attaching shared-memory blocks.\n\n    The concrete implementation lives in\n    [`brmspy._session.transport.ShmPool`][brmspy._session.transport.ShmPool] and tracks\n    blocks so they can be closed on teardown.\n    \"\"\"\n\n    def __init__(self, manager: SharedMemoryManager) -&gt; None:\n        \"\"\"\n        Create a pool bound to an existing `SharedMemoryManager`.\n\n        Parameters\n        ----------\n        manager : multiprocessing.managers.SharedMemoryManager\n            Manager used to allocate blocks.\n        \"\"\"\n        ...\n\n    def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n        \"\"\"\n        Allocate a new shared-memory block.\n\n        Parameters\n        ----------\n        size : int\n            Size in bytes.\n\n        Returns\n        -------\n        ShmBlock\n            Newly allocated block.\n        \"\"\"\n        ...\n\n    def attach(self, ref: ShmRef) -&gt; ShmBlock:\n        \"\"\"\n        Attach to an existing shared-memory block by name.\n\n        Returns\n        -------\n        ShmBlock\n            Attached block.\n        \"\"\"\n        ...\n\n    def close_all(self) -&gt; None:\n        \"\"\"\n        Close all tracked shared-memory handles owned by this pool.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        ...\n\n    def gc(self, name: str | None = None) -&gt; None: ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmPool-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmPool.__init__","title":"<code>__init__(manager)</code>","text":"<p>Create a pool bound to an existing <code>SharedMemoryManager</code>.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SharedMemoryManager</code> <p>Manager used to allocate blocks.</p> required Source code in <code>brmspy/types/shm.py</code> <pre><code>def __init__(self, manager: SharedMemoryManager) -&gt; None:\n    \"\"\"\n    Create a pool bound to an existing `SharedMemoryManager`.\n\n    Parameters\n    ----------\n    manager : multiprocessing.managers.SharedMemoryManager\n        Manager used to allocate blocks.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmPool.alloc","title":"<code>alloc(size, temporary=False)</code>","text":"<p>Allocate a new shared-memory block.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size in bytes.</p> required <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Newly allocated block.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>def alloc(self, size: int, temporary: bool = False) -&gt; ShmBlock:\n    \"\"\"\n    Allocate a new shared-memory block.\n\n    Parameters\n    ----------\n    size : int\n        Size in bytes.\n\n    Returns\n    -------\n    ShmBlock\n        Newly allocated block.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmPool.attach","title":"<code>attach(ref)</code>","text":"<p>Attach to an existing shared-memory block by name.</p> <p>Returns:</p> Type Description <code>ShmBlock</code> <p>Attached block.</p> Source code in <code>brmspy/types/shm.py</code> <pre><code>def attach(self, ref: ShmRef) -&gt; ShmBlock:\n    \"\"\"\n    Attach to an existing shared-memory block by name.\n\n    Returns\n    -------\n    ShmBlock\n        Attached block.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmPool.close_all","title":"<code>close_all()</code>","text":"<p>Close all tracked shared-memory handles owned by this pool.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>brmspy/types/shm.py</code> <pre><code>def close_all(self) -&gt; None:\n    \"\"\"\n    Close all tracked shared-memory handles owned by this pool.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors.ShmPool.gc","title":"<code>gc(name=None)</code>","text":"Source code in <code>brmspy/types/shm.py</code> <pre><code>def gc(self, name: str | None = None) -&gt; None: ...\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors-functions","title":"Functions","text":""},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors._get_rvector_types","title":"<code>_get_rvector_types(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_vectors.py</code> <pre><code>def _get_rvector_types(obj: Any) -&gt; tuple[None | str, None | int]:\n    if not isinstance(obj, SexpVectorWithNumpyInterface):\n        return None, None\n\n    dtypestr = obj._NP_TYPESTR\n    itemsize = obj._R_SIZEOF_ELT\n\n    if not dtypestr or not itemsize:\n        return None, None\n\n    return dtypestr, itemsize\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors._get_rvector_memview","title":"<code>_get_rvector_memview(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_vectors.py</code> <pre><code>def _get_rvector_memview(\n    obj: Any,\n) -&gt; tuple[SexpVectorWithNumpyInterface | None, memoryview | None]:\n    try:\n        assert isinstance(obj, SexpVectorWithNumpyInterface) and isinstance(\n            obj, SexpVector\n        )  # assert types, shouldnt error by itself\n        if hasattr(obj, \"memoryview\"):\n            src = cast(Any, obj).memoryview()\n            return obj, src\n        else:\n            return None, None\n    except:\n        return None, None\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors._r2py_listvector","title":"<code>_r2py_listvector(obj, shm=None)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_vectors.py</code> <pre><code>def _r2py_listvector(\n    obj: \"ListVector\", shm: ShmPool | None = None\n) -&gt; dict[str, PyObject] | list[PyObject]:\n    from ._dispatch import r_to_py\n\n    names = list(obj.names) if obj.names is not NULL else None\n\n    # Named list \u2192 dict\n    if names and any(n is not NULL and n != \"\" for n in names):\n        result = {}\n        for name in names:\n            key = str(name) if name not in (None, \"\") else None\n            if obj is NULL:\n                result[key] = None\n            else:\n                result[key] = r_to_py(obj.rx2(name))\n        return result\n\n    # Unnamed \u2192 list\n    return [r_to_py(el) for el in obj]\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors._fallback_rvector_iter","title":"<code>_fallback_rvector_iter(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_vectors.py</code> <pre><code>def _fallback_rvector_iter(obj):\n    from rpy2.robjects.conversion import localconverter\n    from rpy2.robjects import default_converter, FactorVector\n\n    is_factor = isinstance(obj, FactorVector)\n    if is_factor:\n        return _to_pandas_factor(np.array(obj), obj)\n\n    out = []\n    with localconverter(default_converter) as cv:\n        for el in obj:\n            py = cv.rpy2py(el)\n            out.append(py)\n\n    return out\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors._to_pandas_factor","title":"<code>_to_pandas_factor(arr, obj_r)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_vectors.py</code> <pre><code>def _to_pandas_factor(arr: Any, obj_r: \"FactorVector\"):\n    import rpy2.robjects as ro\n\n    # R factors are 1-based integer codes with missing values represented as NA_INTEGER\n    # (a negative sentinel). pandas expects 0-based codes with -1 for missing.\n    if not isinstance(arr, np.ndarray):\n        arr = np.asarray(arr)\n\n    # Avoid int32 overflow on NA_INTEGER when shifting codes:\n    # only positive values are valid factor codes.\n    valid = arr &gt; 0\n    arr = arr.astype(np.int32, copy=False)\n    arr[~valid] = -1\n    arr[valid] -= 1\n\n    res = pd.Categorical.from_codes(\n        arr,\n        categories=cast(pd.Index, list(cast(ro.ListVector, obj_r.do_slot(\"levels\")))),\n        ordered=\"ordered\" in obj_r.rclass,\n    )\n    return res\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors._r2py_vector","title":"<code>_r2py_vector(obj, shm=None, allow_scalar=True)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_vectors.py</code> <pre><code>def _r2py_vector(\n    obj: \"Vector\", shm: ShmPool | None = None, allow_scalar: bool | None = True\n) -&gt; PyObject:\n    import rpy2.robjects as ro\n    from rpy2.robjects import default_converter\n    from rpy2.robjects.conversion import localconverter\n\n    assert not isinstance(obj, ro.ListVector)\n\n    if allow_scalar:\n        obj_any = cast(Any, obj)\n        # length 1 \u2192 scalar\n        if obj_any.__len__ and len(obj_any) == 1:\n            # Try default R\u2192Python conversion\n            with localconverter(default_converter) as cv:\n                py = cv.rpy2py(obj[0])\n            return py\n\n    is_factor = isinstance(obj, ro.FactorVector)\n\n    dtypestr, itemsize = _get_rvector_types(obj)\n    rvecnp, src = _get_rvector_memview(obj)\n\n    # fallback\n    if not dtypestr or not itemsize or not shm or not rvecnp or not src:\n        return _fallback_rvector_iter(obj)\n\n    # numpy convertible\n    N = len(rvecnp)\n    expected_bytes = itemsize * N\n    dtype = np.dtype(dtypestr)\n\n    if src.nbytes != expected_bytes:\n        raise RuntimeError(f\"R vector bytes={src.nbytes}, expected={expected_bytes}\")\n\n    # Allocate shm once\n    block = shm.alloc(expected_bytes)\n    assert block.shm.buf\n\n    # Single bulk copy: R \u2192 shm, no intermediate ndarray\n    src_bytes = src.cast(\"B\")\n    block.shm.buf[:expected_bytes] = src_bytes\n\n    arr = ShmArray.from_block(block=block, shape=(N,), dtype=dtype)\n    if is_factor:\n        return _to_pandas_factor(arr, obj)\n\n    return arr\n</code></pre>"},{"location":"internals/helpers/_rpy2/_converters/_vectors/#brmspy.helpers._rpy2._converters._vectors._py2r_list","title":"<code>_py2r_list(obj)</code>","text":"Source code in <code>brmspy/helpers/_rpy2/_converters/_vectors.py</code> <pre><code>def _py2r_list(obj: list | tuple) -&gt; Sexp:\n    import rpy2.robjects as ro\n    from rpy2.robjects import default_converter, numpy2ri, pandas2ri\n    from rpy2.robjects.conversion import localconverter\n\n    if not obj:\n        return ro.ListVector({})\n\n    if isinstance(obj, tuple):\n        obj = list(obj)\n\n    from ._dispatch import py_to_r\n\n    if all(isinstance(el, Mapping) for el in obj):\n        # R lists are usually named or indexed; use 1-based index names\n        converted = {str(i + 1): py_to_r(el) for i, el in enumerate(obj)}\n        return ro.ListVector(converted)\n\n    # Homogeneous scalar lists \u2192 atomic R vectors (c(...))\n    # Strings\n    if all(isinstance(el, str) for el in obj):\n        return ro.StrVector(list(obj))\n\n    # Booleans\n    if all(isinstance(el, bool) for el in obj):\n        return ro.BoolVector(list(obj))\n\n    # Integers (avoid treating bools as ints)\n    if all(\n        isinstance(el, (int, np.integer)) and not isinstance(el, bool) for el in obj\n    ):\n        return ro.IntVector(list(obj))\n\n    # Numeric (mix of ints/floats/bools) \u2192 R \"numeric\" (double) vector\n    if all(isinstance(el, (int, float, np.integer, np.floating, bool)) for el in obj):\n        return ro.FloatVector([float(el) for el in obj])\n\n    # mixed / other lists: let rpy2 decide (vectors, lists, etc.)\n    with localconverter(\n        default_converter + pandas2ri.converter + numpy2ri.converter\n    ) as cv:\n        return cv.py2rpy(obj)\n</code></pre>"}]}