{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"brmspy","text":"<p>Python-first access to R's brms  with proper parameter names, ArviZ support, and cmdstanr performance. The easiest way to run brms models from Python.</p> <p>This is an early development version of the library, use with caution.</p> <p>Github repo and issues</p> <p> </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install brmspy\n</code></pre> <p>First-time setup (installs brms, cmdstanr, and CmdStan in R):</p> <pre><code>from brmspy import brms\nbrms.install_brms() # requires R to be installed already\n</code></pre>"},{"location":"#prebuilt-runtimes-optional","title":"Prebuilt Runtimes (Optional)","text":"<p>For faster installation (~20-60 seconds vs 20-30 minutes), use prebuilt runtime bundles:</p> <pre><code>from brmspy import brms\nbrms.install_brms(use_prebuilt_binaries=True)\n</code></pre>"},{"location":"#windows-rtools","title":"Windows RTools","text":"<p>In case you don't have RTools installed, you can use the flag install_rtools = True. This is disabled by default, because the flag runs the full rtools installer and modifies system path.  Use with caution!</p> <pre><code>from brmspy import brms\nbrms.install_brms(\n    use_prebuilt_binaries=True,\n    install_rtools=True # works for both prebuilt and compiled binaries.\n)\n</code></pre>"},{"location":"#system-requirements","title":"System Requirements","text":"<p>R &gt;= 4.0</p> <p>Linux (x86_64): - glibc &gt;= 2.27 (Ubuntu 18.04+, Debian 10+, RHEL 8+) - g++ &gt;= 9.0</p> <p>macOS (Intel &amp; Apple Silicon): - Xcode Command Line Tools: <code>xcode-select --install</code> - clang &gt;= 11.0</p> <p>Windows (x86_64): - Rtools 4.0+ with MinGW toolchain - g++ &gt;= 9.0</p> <p>Download Rtools from: https://cran.r-project.org/bin/windows/Rtools/</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from brmspy import brms, prior\nimport arviz as az\n\n# Load data\nepilepsy = brms.get_brms_data(\"epilepsy\")\n\n# Fit model\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    priors=[\n        prior(\"normal(0, 1)\", \"b\"),\n        prior(\"exponential(1)\", \"sd\", group=\"patient\"),\n        prior(\"student_t(3, 0, 2.5)\", \"Intercept\")\n    ],\n    chains=4,\n    iter=2000\n)\n\n# Analyze\naz.summary(model.idata)\naz.plot_posterior(model.idata)\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Proper parameter names: Returns <code>b_Intercept</code>, <code>b_zAge</code>, <code>sd_patient__Intercept</code> instead of generic names like <code>b_dim_0</code></li> <li>arviz integration: Returns <code>arviz.InferenceData</code> by default for Python workflow</li> <li>brms formula syntax: Full support for brms formula interface including random effects</li> <li>Dual access: Results include both <code>.idata</code> (arviz) and <code>.r</code> (brmsfit) attributes</li> <li>No reimplementation: Delegates all modeling logic to real brms. No Python-side reimplementation, no divergence from native behavior. Opinionated wrappers that rebuild formulas or stancode in Python inevitably drift from brms and accumulate their own bugs.</li> <li>Prebuilt Binaries: Fast installation with precompiled runtimes containing cmdstanr and brms (50x faster, 25 seconds on Google Colab)</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<p>brmspy documentation brms documentation</p>"},{"location":"#setup-functions","title":"Setup Functions","text":"<ul> <li><code>brms.install_brms()</code> - Install brms, cmdstanr, and CmdStan</li> <li><code>brms.get_brms_version()</code> - Get installed brms version</li> </ul>"},{"location":"#data-functions","title":"Data Functions","text":"<ul> <li><code>brms.get_brms_data()</code> - Load example datasets from brms</li> <li><code>brms.save_rds()</code> - Save brmsfit or another robject</li> <li><code>brms.load_rds_fit()</code> - Load saved brmsfit object as FitResult (with idata)</li> <li><code>brms.load_rds_raw()</code> - Load r object</li> </ul>"},{"location":"#model-functions","title":"Model Functions","text":"<ul> <li><code>brms.formula()</code> - Define formula with kwargs</li> <li><code>brms.fit()</code> or <code>brms.brm()</code> - Fit Bayesian regression model</li> <li><code>brms.make_stancode()</code> - Generate Stan code for model</li> </ul>"},{"location":"#diagnostics-functions","title":"Diagnostics Functions","text":"<ul> <li><code>brms.summary()</code> - Comprehensive model summary as SummaryResult dataclass</li> <li><code>brms.fixef()</code> - Extract population-level (fixed) effects</li> <li><code>brms.ranef()</code> - Extract group-level (random) effects as xarray</li> <li><code>brms.posterior_summary()</code> - Summary statistics for all parameters</li> <li><code>brms.prior_summary()</code> - Extract prior specifications used in model</li> <li><code>brms.loo()</code> - Leave-one-out cross-validation with PSIS</li> <li><code>brms.loo_compare()</code> - Compare multiple models using LOO-CV</li> <li><code>brms.validate_newdata()</code> - Validate new data for predictions</li> </ul>"},{"location":"#prior-functions","title":"Prior Functions","text":"<ul> <li><code>brms.prior()</code> - Define a prior with same syntax as r-s <code>prior_string</code></li> <li><code>brms.get_prior()</code> - Get pd.DataFrame describing default priors</li> <li><code>brms.default_prior()</code> - Get pd.DataFrame describing default priors</li> </ul>"},{"location":"#families-functions","title":"Families Functions","text":"<ul> <li><code>brms.family()</code> - Get family object of FitResult</li> <li><code>brms.brmsfamily()</code> - Construct family object from kwargs</li> <li><code>brms.families.gaussian()</code>, <code>...bernoulli()</code>, <code>...beta_binomial()</code>, etc - Wrappers around brmsfamily for faster family object construction</li> </ul>"},{"location":"#prediction-functions","title":"Prediction Functions","text":"<ul> <li><code>brms.posterior_epred()</code> - Expected value predictions (without noise)</li> <li><code>brms.posterior_predict()</code> - Posterior predictive samples (with noise)</li> <li><code>brms.posterior_linpred()</code> - Linear predictor values</li> <li><code>brms.log_lik()</code> - Log-likelihood values</li> </ul>"},{"location":"#generic-function-access","title":"Generic Function Access","text":"<ul> <li><code>brms.call()</code> - Call any brms/R function by name with automatic type conversion</li> </ul>"},{"location":"#usage","title":"Usage","text":""},{"location":"#basic-model","title":"Basic Model","text":"<pre><code>from brmspy import brms\n\nkidney = brms.get_brms_data(\"kidney\")\n\nmodel = brms.fit(\n    formula=\"time ~ age + disease\",\n    data=kidney,\n    family=\"gaussian\",\n    chains=4,\n    iter=2000\n)\n</code></pre>"},{"location":"#with-priors","title":"With Priors","text":"<pre><code>from brmspy import prior\n\nmodel = brms.fit(\n    formula=\"count ~ zAge + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    priors=[\n        prior(\"normal(0, 0.5)\", \"b\"),\n        prior(\"cauchy(0, 1)\", \"sd\")\n    ],\n    chains=4\n)\n</code></pre>"},{"location":"#model-summary","title":"Model Summary","text":"<pre><code>from brmspy import summary\n\n# Get summary statistics as DataFrame\nsummary_df = summary(model)\nprint(summary_df)\n</code></pre>"},{"location":"#predictions","title":"Predictions","text":"<pre><code># Expected value (without noise)\nepred = brms.posterior_epred(model, newdata=new_data)\n\n# Posterior predictive (with noise)\nypred = brms.posterior_predict(model, newdata=new_data)\n\n# Linear predictor\nlinpred = brms.posterior_linpred(model, newdata=new_data)\n\n# Log likelihood\nloglik = brms.log_lik(model, newdata=new_data)\n</code></pre>"},{"location":"#access-both-python-and-r-objects","title":"Access Both Python and R Objects","text":"<pre><code>model = brms.fit(formula=\"y ~ x\", data=data, chains=4)\n\n# Python workflow with arviz\naz.summary(model.idata)\naz.plot_trace(model.idata)\n\n# R workflow (if needed)\nimport rpy2.robjects as ro\nro.r('summary')(model.r)\n</code></pre>"},{"location":"#sampling-parameters","title":"Sampling Parameters","text":"<pre><code>model = brms.fit(\n    formula=\"y ~ x + (1|group)\",\n    data=data,\n    iter=2000,      # Total iterations per chain\n    warmup=1000,    # Warmup iterations\n    chains=4,       # Number of chains\n    cores=4,        # Parallel cores\n    thin=1,         # Thinning\n    seed=123        # Random seed\n)\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<p>Python: 3.10-3.14</p> <p>R packages (auto-installed via <code>brms.install_brms()</code>): - brms &gt;= 2.20.0 - cmdstanr - posterior</p> <p>Python dependencies: - rpy2 &gt;= 3.5.0 - pandas &gt;= 1.3.0 - numpy &gt;= 1.20.0 - arviz (optional, for InferenceData)</p>"},{"location":"#development","title":"Development","text":"<pre><code>git clone https://github.com/kaitumisuuringute-keskus/brmspy.git\ncd brmspy\n./init-venv.sh\npytest tests/ -v\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<p>brmspy uses: - brms::brm() with cmdstanr backend for fitting (ensures proper parameter naming) - posterior R package for conversion to draws format - arviz for Python-native analysis and visualization - rpy2 for Python-R communication</p> <p>Previous versions used CmdStanPy directly, which resulted in generic parameter names. Current version calls brms directly to preserve brms' parameter renaming logic.</p>"},{"location":"#license","title":"License","text":"<p>Apache License 2.0</p>"},{"location":"#credits","title":"Credits","text":"<ul> <li>Original concept: Adam Haber</li> <li>Current maintainer: Remi Sebastian Kits</li> <li>Built on brms by Paul-Christian B\u00fcrkner</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>API Reference</li> <li>Examples</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#0113-enhanced-diagnostics-type-safe-summaries","title":"0.1.13 - Enhanced Diagnostics &amp; Type-Safe Summaries","text":"<p>25.12.04</p>"},{"location":"changelog/#diagnostics-functions","title":"Diagnostics Functions","text":"<ul> <li><code>summary()</code> Complete Rewrite: Now returns a <code>SummaryResult</code> dataclass instead of a single DataFrame, providing structured access to all model components:</li> <li>Population-level effects (<code>summary.fixed</code>)</li> <li>Family-specific parameters (<code>summary.spec_pars</code>)</li> <li>Random effects (<code>summary.random</code>)</li> <li>Prior specifications (<code>summary.prior</code>)</li> <li>Model metadata (formula, chains, draws, diagnostics)</li> <li>Pretty-print support via <code>__str__()</code> and <code>__repr__()</code> for human-readable output in notebooks</li> <li> <p>Comprehensive docstring with all fields, types, and usage examples</p> </li> <li> <p><code>fixef()</code> Population-Level Effects: New function for extracting fixed effects with full control:</p> </li> <li>Returns pandas DataFrame with parameter estimates and uncertainty</li> <li>Supports <code>summary=True</code> (default) for statistics or <code>summary=False</code> for raw posterior samples</li> <li>Configurable credible intervals via <code>probs</code> parameter</li> <li>Robust estimates (median/MAD) via <code>robust=True</code></li> <li>Parameter subsetting with <code>pars</code> argument</li> <li> <p>Complete docstring with examples for common use cases</p> </li> <li> <p><code>ranef()</code> Group-Level Effects: New function for extracting random effects as xarray DataArrays:</p> </li> <li>Returns dict mapping grouping factors to multidimensional arrays</li> <li><code>summary=True</code> (default): 3D arrays with dimensions <code>(group, stat, coef)</code> containing estimates and intervals</li> <li><code>summary=False</code>: 3D arrays with dimensions <code>(draw, group, coef)</code> for full posterior draws</li> <li>Native xarray integration enables easy slicing and MCMC analysis</li> <li> <p>Comprehensive docstring with coord selection examples</p> </li> <li> <p><code>posterior_summary()</code> All Parameters: New function for comprehensive parameter extraction:</p> </li> <li>Returns pandas DataFrame with all model parameters (fixed, random, auxiliary)</li> <li>More comprehensive than <code>fixef()</code> or <code>ranef()</code> alone</li> <li>Supports variable selection and regex patterns</li> <li>Configurable credible intervals and robust estimates</li> <li> <p>Complete docstring with filtering examples</p> </li> <li> <p><code>prior_summary()</code> Prior Specifications: New function for documenting model priors:</p> </li> <li>Returns pandas DataFrame with all prior distributions used in model</li> <li>Option to show all priors (including defaults) or only user-specified</li> <li>Useful for reproducibility and model documentation</li> <li> <p>Complete docstring with comparison examples</p> </li> <li> <p><code>loo()</code> Leave-One-Out Cross-Validation: New function for model comparison and validation:</p> </li> <li>Computes efficient LOO-CV using Pareto smoothed importance sampling (PSIS)</li> <li>Returns <code>LooResult</code> dataclass with LOO metrics (elpd_loo, p_loo, looic) and standard errors</li> <li>Pareto k diagnostics for identifying problematic observations</li> <li>Support for moment matching and refitting for high Pareto k values</li> <li>Pretty-print support via <code>__repr__()</code> with formatted metrics and diagnostics</li> <li>Memory-efficient pointwise computation option for large datasets</li> <li> <p>Comprehensive docstring with model comparison examples</p> </li> <li> <p><code>loo_compare()</code> Model Comparison: New function for comparing multiple models using LOO-CV:</p> </li> <li>Compare 2 or more models using approximate leave-one-out cross-validation</li> <li>Returns <code>LooCompareResult</code> dataclass with comparison table ranked by performance</li> <li>Table includes <code>elpd_diff</code> (difference from best model) and standard errors</li> <li>Support for custom model names via <code>model_names</code> parameter</li> <li>Pretty-print support via <code>__repr__()</code> showing formatted comparison table</li> <li>Best model always listed first with elpd_diff = 0</li> <li> <p>Comprehensive docstring with usage examples</p> </li> <li> <p><code>validate_newdata()</code> Data Validation: New function for validating prediction data:</p> </li> <li>Validates new data against fitted model requirements before making predictions</li> <li>Checks for required variables, factor levels, and grouping structure</li> <li>Returns validated DataFrame ready for use in prediction functions</li> <li>Support for <code>allow_new_levels</code> parameter to permit new grouping factor levels</li> <li>Can skip response variable checking with <code>check_response=False</code></li> <li>Validates autocorrelation structures and group-level effects</li> <li>Primarily used internally by prediction methods but available for direct use</li> <li>Comprehensive Python-style docstring with parameter descriptions and examples</li> </ul>"},{"location":"changelog/#type-system-improvements","title":"Type System Improvements","text":"<ul> <li>DataFrame Detection: <code>r_to_py()</code> now correctly detects R DataFrames and preserves:</li> <li>Row indexes (rownames from R)</li> <li>Column names</li> <li> <p>Proper type conversion for all data types</p> </li> <li> <p>LooResult Dataclass: Added <code>__repr__()</code> for formatted LOO-CV output:</p> </li> <li>Displays ELPD LOO, p_loo, and LOOIC with standard errors</li> <li>Summary of Pareto k diagnostic categories</li> <li>Human-readable format for notebooks and interactive use</li> </ul>"},{"location":"changelog/#testing","title":"Testing","text":"<ul> <li>Added 14 comprehensive tests for diagnostics functions:</li> <li><code>summary()</code>: structure validation, component access, pretty printing</li> <li><code>fixef()</code>: summary statistics and parameter extraction</li> <li><code>ranef()</code>: both summary mode and raw posterior draws mode</li> <li><code>posterior_summary()</code>: all parameters extraction</li> <li><code>prior_summary()</code>: prior specifications with custom priors</li> <li><code>loo()</code>: basic LOO-CV computation and Pareto k diagnostics</li> <li><code>loo_compare()</code>: model comparison with default and custom model names</li> <li><code>validate_newdata()</code>: validation with valid data and error handling for invalid data</li> <li>All tests optimized with reduced iterations (<code>iter=100, warmup=50</code>) for faster CI execution</li> </ul>"},{"location":"changelog/#generic-function-access","title":"Generic Function Access","text":"<ul> <li><code>call()</code> Universal Function Wrapper: New generic function for calling any brms or R function:</li> <li>Call brms functions by name without dedicated Python wrappers</li> <li>Automatic bidirectional type conversion (Python \u2194 R)</li> <li>Tries <code>brms::function_name</code> first, falls back to base R</li> <li>Useful for accessing newer brms features or utility functions</li> <li> <p>Complete docstring with examples for various use cases</p> </li> <li> <p><code>sanitised_name()</code> Helper Function: Sanitizes function names for safe R execution:</p> </li> <li>Converts Python-style names to valid R identifiers</li> <li>Preserves namespace separators (e.g., <code>brms::loo</code>)</li> <li>Handles invalid characters and numeric prefixes</li> <li>Complete docstring with sanitization examples</li> </ul>"},{"location":"changelog/#api","title":"API","text":"<ul> <li>Exported <code>fixef</code>, <code>ranef</code>, <code>posterior_summary</code>, <code>prior_summary</code>, <code>loo</code>, <code>loo_compare</code>, <code>validate_newdata</code>, and <code>call</code> from <code>brmspy</code> module</li> <li>Added <code>LooResult</code> and <code>LooCompareResult</code> to public types for model comparison workflows</li> </ul>"},{"location":"changelog/#0112-rds-loadingsaving-families-functions-default-priors-functions","title":"0.1.12 - RDS loading/saving, families functions, default priors functions","text":"<p>25.12.03</p>"},{"location":"changelog/#new-features","title":"New Features","text":"<ul> <li>Added <code>save_rds()</code> for saving <code>brmsfit</code> or generic R objects.</li> <li>Added <code>load_rds_fit()</code> for loading saved <code>brmsfit</code> objects and returning a <code>FitResult</code> with attached <code>InferenceData</code>.</li> <li>Added <code>load_rds_raw()</code> for loading arbitrary R objects from RDS files.</li> <li>Added <code>fit</code> alias <code>brm</code>.</li> </ul>"},{"location":"changelog/#families","title":"Families","text":"<ul> <li>Added <code>brmspy.families</code> module with Python wrappers for <code>brmsfamily()</code> and <code>family()</code>.</li> <li>Implemented keyword-argument wrappers for the following families:   <code>student</code>, <code>bernoulli</code>, <code>beta_binomial</code>, <code>negbinomial</code>, <code>geometric</code>,   <code>lognormal</code>, <code>shifted_lognormal</code>, <code>skew_normal</code>, <code>exponential</code>, <code>weibull</code>,   <code>frechet</code>, <code>gen_extreme_value</code>, <code>exgaussian</code>, <code>wiener</code>,   <code>Beta</code>, <code>dirichlet</code>, <code>logistic_normal</code>, <code>von_mises</code>, <code>asym_laplace</code>, <code>cox</code>,   <code>hurdle_poisson</code>, <code>hurdle_negbinomial</code>, <code>hurdle_gamma</code>, <code>hurdle_lognormal</code>,   <code>hurdle_cumulative</code>, <code>zero_inflated_beta</code>, <code>zero_one_inflated_beta</code>,   <code>zero_inflated_poisson</code>, <code>zero_inflated_negbinomial</code>,   <code>zero_inflated_binomial</code>, <code>zero_inflated_beta_binomial</code>,   <code>categorical</code>, <code>multinomial</code>, <code>cumulative</code>, <code>sratio</code>, <code>cratio</code>, <code>acat</code>.</li> </ul>"},{"location":"changelog/#priors","title":"Priors","text":"<ul> <li>Added <code>default_prior()</code> for retrieving default priors for a model formula and dataset.</li> <li>Added <code>get_prior()</code> for inspecting prior structure before fitting.</li> </ul>"},{"location":"changelog/#api-organization","title":"API Organization","text":"<ul> <li>Reorganized brms wrappers into modular files under <code>brmspy/brms_functions/</code>   (<code>brm</code>, <code>diagnosis</code>, <code>families</code>, <code>formula</code>, <code>io</code>, <code>prediction</code>, <code>prior</code>, <code>stan</code>).</li> </ul>"},{"location":"changelog/#internal-typing","title":"Internal / Typing","text":"<ul> <li>Added <code>RListVectorExtension</code> protocol for return types that wrap R list-like structures.   Enables automatic extraction of underlying R objects in <code>py_to_r</code> and <code>kwargs_r</code>.</li> </ul>"},{"location":"changelog/#0111-persistent-runtimes-modern-packaging-and-stability","title":"0.1.11 - Persistent Runtimes, Modern Packaging, and Stability","text":"<p>25.12.01</p> <ul> <li>Persistent Runtimes: If a prebuilt runtime is activated, the path is now saved to <code>{HOME}/.brmspy/config.json</code> and automatically loaded on the next library import.</li> <li>Configurable Logging: Replaced scattered print statements with a centralized logger.</li> <li>Optimized Activation: Made <code>activate_runtime</code> aggressive unloading conditional, resulting in slightly faster runtime activation.</li> </ul>"},{"location":"changelog/#0110-windows-stability-ci-improvements","title":"0.1.10 - Windows stability &amp; CI improvements","text":"<p>25.12.01</p> <p>Windows Support</p> <ul> <li>Implemented aggressive R package unloading (detach, unloadNamespace, DLL unload) prior to installation to prevent file locking errors.</li> <li>Refined RTools detection logic; relaxed system <code>g++</code> version requirements when valid RTools installations are detected.</li> <li>Changed <code>install_rtools</code> default to <code>False</code> in <code>install_brms()</code> to prevent unintended system PATH modifications.</li> <li>Fixed PowerShell command syntax generation for internal system calls.</li> <li>Windows prebuilt binaries currently requires R4.5, more versions are coming.</li> </ul> <p>Build and CI</p> <ul> <li>Expanded continuous integration test matrix to cover Windows, macOS, and Ubuntu on Python 3.12.</li> <li>Optimized GitHub Actions caching strategy for R libraries and CmdStan, significantly reducing Windows workflow runtime.</li> <li>Fixed artifact pruning logic in runtime builder workflows to prevent test breakages.</li> </ul> <p>Bug Fixes</p> <ul> <li>Ensured <code>jsonlite</code> dependency is explicitly resolved during build manifest generation.</li> <li>Fixed workflow path referencing and quoting issues in installation scripts.</li> </ul>"},{"location":"changelog/#019-prebuilt-runtimes-windows-toolchain","title":"0.1.9 - Prebuilt runtimes, windows toolchain","text":"<p>25.11.30</p> <p>New Features</p> <ul> <li>Prebuilt Runtimes: Introduced <code>brmspy.binaries</code> subpackage to manage precompiled R environments containing <code>brms</code> and <code>cmdstanr</code> (installs up to 50x faster than default).</li> <li>Fast Installation: Added <code>use_prebuilt_binaries=True</code> argument to <code>install_brms()</code>, reducing setup time by bypassing source compilation.</li> <li>Windows Toolchain: Implemented automatic detection and installation of Rtools (MinGW-w64) within <code>install_brms()</code> to support compilation on Windows.</li> </ul> <p>Enhancements</p> <ul> <li>Linux Binaries: Updated Linux installation logic to prioritize Posit Package Manager (P3M) binary repositories based on OS codename detection.</li> <li>Extended documentation: Added docstring documentation to all public and internal functions.</li> </ul> <p>Infrastructure</p> <ul> <li>Docker: Added <code>.runtime_builder</code> Dockerfiles for creating reproducible Linux runtime environments.</li> </ul>"},{"location":"changelog/#018-rstan-support-version-pinning-and-cross-platform-fixes","title":"0.1.8 - Rstan support, version pinning, and cross-platform fixes","text":"<p>25.11.29</p> <p>Features</p> <ul> <li>Rstan Backend Support: Added <code>rstan</code> as an alternative backend. install_brms now takes <code>install_rstan</code> param and <code>fit()</code> now seamlessly accepts <code>backend=\"rstan\"</code> (defaults to \"cmdstanr\").</li> <li>Exact Version Installation: <code>install_brms()</code> now supports pinning specific R package versions (e.g., <code>version=\"2.21.0\"</code>) using <code>remotes</code> for all R dependencies.</li> </ul> <p>Installation &amp; Platform Support</p> <ul> <li>Windows Toolchain: Implemented automatic Rtools detection and setup within <code>install_brms()</code>, resolving compiler issues on Windows.</li> <li>macOS/Windows Binaries: Fixed installation failures for dependencies (like <code>data.table</code>) by defaulting to <code>type=\"both\"</code> instead of forcing source compilation.</li> </ul> <p>Infrastructure</p> <ul> <li>Added dedicated cross-platform CI workflow (Windows, macOS, Ubuntu) to ensure installation stability across operating systems.</li> </ul>"},{"location":"changelog/#017-automatic-r-imports-after-installation-and-import-failure-warning","title":"0.1.7 - Automatic r imports after installation and import failure warning","text":"<p>25.11.29</p> <ul> <li>Fixed an issue where the library could refuse import in case of missing R deps</li> <li>R libraries are now automatically imported after installation</li> </ul>"},{"location":"changelog/#016-fix-segfaults-stabilize-r-imports-faster-cold-starts","title":"0.1.6 - Fix segfaults, stabilize R imports, faster cold starts","text":"<p>25.11.29</p>"},{"location":"changelog/#core-stability","title":"Core stability","text":"<ul> <li> <p>Fixed a rare but catastrophic segfault that could occur when <code>fit()</code> was invoked inside a <code>tqdm</code> loop or any repeated call context with dynamic stdouts.</p> </li> <li> <p>Root cause: calling <code>rpackages.importr(\"cmdstanr\")</code> / <code>importr(\"brms\")</code> inside functions caused rpy2 to repeatedly rebuild R package proxies, which in some environments led to segfaults and the Python process or even the IDE being killed.</p> </li> <li>Resolution: All R-side imports (<code>brms</code>, <code>cmdstanr</code>, <code>posterior</code>, etc.) are now performed once at module import time, never inside functions. This completely eliminates the segfault and removes hidden global-state churn.</li> </ul> <p>Performance &amp; architecture</p> <ul> <li>Because heavy rpy2 <code>importr(...)</code> calls are no longer done on-demand during <code>fit()</code>, repeated model fits are now measurably faster (no repeated R namespace setup).</li> </ul> <p>API invariants &amp; guarantees</p> <ul> <li><code>fit(sample=False)</code> is now guaranteed safe to use in loops, notebooks, and benchmarking environments.</li> <li>Repeated calls to <code>fit()</code> no longer risk triggering implicit R package reloads, leading to consistent runtime semantics.</li> </ul> <p>Testing</p> <ul> <li> <p>Added a dedicated regression test:   <code>test_fit_tqdm_segfault()</code> \u2014 ensures that calling <code>fit()</code> inside a <code>tqdm</code> loop is stable and does not crash the interpreter.</p> </li> <li> <p>This test reproduces the exact minimal condition under which the old bug appeared and will prevent regressions long-term.</p> </li> </ul> <p>Misc</p> <ul> <li>Minor internal cleanups and defensive guards around lazy globals (<code>_brms</code>, etc.) to ensure they initialize exactly once and never re-import.</li> <li>Slightly reduced memory churn on repeated calls by eliminating redundant converter/namespace setup.</li> </ul>"},{"location":"changelog/#015-better-priors-kwargs-parsing-formula-helper-typed-arviz","title":"0.1.5 \u2013 Better priors, kwargs parsing, formula helper, typed ArviZ","text":"<p>25.11.28</p> <p>API &amp; types</p> <ul> <li>Bumped version to <code>0.1.5</code> and exported more typed return types from the top-level package.</li> <li>Added a public <code>formula()</code> helper and exported it from <code>brmspy</code> so you can pass kwargs to it, prebuild / reuse model formulas instead of always passing strings straight into <code>fit()</code>.</li> <li>Introduced typed ArviZ aliases for the different <code>InferenceData</code> shapes returned by various functions (<code>IDFit</code>, <code>IDPredict</code>, <code>IDLinpred</code>, <code>IDLogLik</code>, <code>IDEpred</code>) and re-exported them in <code>__all__</code> for IDE/type-checker friendliness. </li> <li>Tightened / clarified the main return types: <code>FitResult</code>, <code>PosteriorEpredResult</code>, <code>PosteriorPredictResult</code>, <code>PosteriorLinpredResult</code>, <code>LogLikResult</code>, <code>GenericResult</code> are now consistently exported and documented as the official public surface.</li> </ul> <p>Priors</p> <ul> <li>Promoted the <code>prior()</code> helper to the recommended way of specifying priors; examples and docs now use <code>prior(...)</code> instead of raw tuples.</li> <li> <p>Switched the main Quick Start example to more sensible defaults for the epilepsy model:</p> </li> <li> <p><code>prior(\"normal(0, 1)\", \"b\")</code></p> </li> <li><code>prior(\"exponential(1)\", \"sd\", group=\"patient\")</code></li> <li><code>prior(\"student_t(3, 0, 2.5)\", \"Intercept\")</code></li> <li>Added / refined internal prior-building logic (commit: \u201cproper prior building\u201d) so Python-side specs map more reliably onto <code>brms::set_prior()</code> and accept richer combinations of <code>class_</code>, <code>coef</code>, <code>group</code>, <code>dpar</code>, etc. </li> <li>Added tests around <code>prior()</code> and how priors are passed into <code>fit()</code>. (commit: \u201ctests for priors, get_stancode, summary, fit without sampling, poster\u2026\u201d)</li> </ul> <p><code>fit()</code> and kwargs</p> <ul> <li>Improved <code>fit()</code> kwargs parsing so that Python kwargs are forwarded more robustly to <code>brms</code>/<code>cmdstanr</code></li> <li>Makes it safer to pass through extra control arguments without silently dropping or misrouting them.</li> </ul> <p>Tooling &amp; infra</p> <ul> <li>Expanded and tightened test coverage in <code>tests/test_basic.py</code> and <code>tests/test_integration.py</code>, including coverage for priors, <code>get_stancode</code>/<code>make_stancode</code>, <code>summary</code>, and \u201cfit without sampling\u201d paths. </li> </ul>"},{"location":"api/brms/","title":"Main Module","text":""},{"location":"api/brms/#brmspy.brms-classes","title":"Classes","text":""},{"location":"api/brms/#brmspy.brms.FitResult","title":"<code>FitResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from fit() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with posterior, posterior_predictive, log_likelihood, and observed_data groups</p> <code>r</code> <code>ListVector</code> <p>brmsfit R object from brms::brm()</p>"},{"location":"api/brms/#brmspy.brms.FormulaResult","title":"<code>FormulaResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from formula() function.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R brmsformula object</p> <code>dict</code> <code>Dict</code> <p>Python dictionary representation of formula</p> See Also <p>brmspy.brms.formula : Creates FormulaResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\n# Create formula with options\nf = brms.formula(\"y ~ x\", decomp=\"QR\")\n\n# Use in fit()\nmodel = brms.fit(f, data=df, chains=4)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.GenericResult","title":"<code>GenericResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Generic result container with arviz and R objects.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData object</p> <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/brms/#brmspy.brms.LogLikResult","title":"<code>LogLikResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from log_lik() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>IDLogLik</code> <p>arviz InferenceData with log-likelihood values</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::log_lik()</p> See Also <p>brmspy.brms.log_lik : Creates LogLikResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nmodel = brms.fit(\"y ~ x\", data=df, chains=4)\nloglik = brms.log_lik(model)\n\n# Use for model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.LooResult","title":"<code>LooResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p>"},{"location":"api/brms/#brmspy.brms.LooResult-functions","title":"Functions","text":""},{"location":"api/brms/#brmspy.brms.LooResult.__repr__","title":"<code>__repr__()</code>","text":"<p>Pretty print LOO-CV results.</p>"},{"location":"api/brms/#brmspy.brms.PosteriorEpredResult","title":"<code>PosteriorEpredResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from posterior_epred() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with expected values in 'posterior' group</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_epred()</p>"},{"location":"api/brms/#brmspy.brms.PosteriorLinpredResult","title":"<code>PosteriorLinpredResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from posterior_linpred() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>IDLinpred</code> <p>arviz InferenceData with linear predictor values</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_linpred()</p> See Also <p>brmspy.brms.posterior_linpred : Creates PosteriorLinpredResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.fit(\"count ~ age\", data=df, family=\"poisson\", chains=4)\nlinpred = brms.posterior_linpred(model)\n\n# Linear predictor on log scale (for Poisson)\nprint(linpred.idata.predictions)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.PosteriorPredictResult","title":"<code>PosteriorPredictResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from posterior_predict() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with predictions in 'posterior_predictive' group</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_predict()</p>"},{"location":"api/brms/#brmspy.brms.RListVectorExtension","title":"<code>RListVectorExtension</code>  <code>dataclass</code>","text":"<p>Generic result container with R objects.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/brms/#brmspy.brms.IDLinpred","title":"<code>IDLinpred</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_linpred results.</p> <p>Contains linear predictor values (before applying link function).</p> <p>Attributes:</p> Name Type Description <code>predictions</code> <code>Dataset</code> <p>Linear predictor samples</p> See Also <p>brmspy.brms.posterior_linpred : Creates IDLinpred objects</p>"},{"location":"api/brms/#brmspy.brms.IDEpred","title":"<code>IDEpred</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_epred results.</p> <p>Contains expected values E[Y|X] without observation noise.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Expected value samples (no observation noise)</p> See Also <p>brmspy.brms.posterior_epred : Creates IDEpred objects</p>"},{"location":"api/brms/#brmspy.brms.IDFit","title":"<code>IDFit</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for fitted brms models.</p> <p>Extends arviz.InferenceData with type hints for IDE autocomplete. Guarantees the presence of specific data groups returned by <code>fit()</code>.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Posterior samples of model parameters</p> <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (with observation noise)</p> <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation</p> <code>observed_data</code> <code>Dataset</code> <p>Original observed response data</p> <code>coords</code> <code>dict</code> <p>Coordinate mappings for dimensions</p> <code>dims</code> <code>dict</code> <p>Dimension specifications for variables</p> See Also <p>brmspy.brms.fit : Creates IDFit objects arviz.InferenceData : Base class documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\nmodel = brms.fit(\"y ~ x\", data=df, chains=4)\n\n# Type checking and autocomplete\nassert isinstance(model.idata, IDFit)\nprint(model.idata.posterior)  # IDE autocomplete works!\n</code></pre>"},{"location":"api/brms/#brmspy.brms.IDLogLik","title":"<code>IDLogLik</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for log_lik results.</p> <p>Contains log-likelihood values for model comparison.</p> <p>Attributes:</p> Name Type Description <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation</p> See Also <p>brmspy.brms.log_lik : Creates IDLogLik objects arviz.loo : LOO-CV using log-likelihood</p>"},{"location":"api/brms/#brmspy.brms.IDPredict","title":"<code>IDPredict</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_predict results.</p> <p>Contains posterior predictive samples with observation noise.</p> <p>Attributes:</p> Name Type Description <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (includes observation noise)</p> See Also <p>brmspy.brms.posterior_predict : Creates IDPredict objects</p>"},{"location":"api/brms/#brmspy.brms.PriorSpec","title":"<code>PriorSpec</code>  <code>dataclass</code>","text":"<p>Python representation of a brms prior specification.</p> <p>This dataclass provides a typed interface to brms::prior_string() arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the <code>prior()</code> factory function to create instances.</p> <p>Attributes:</p> Name Type Description <code>prior</code> <code>str</code> <p>Prior distribution as string (e.g., \"normal(0, 1)\", \"exponential(2)\")</p> <code>class_</code> <code>(str, optional)</code> <p>Parameter class: \"b\" (fixed effects), \"sd\" (group SD), \"Intercept\", \"sigma\", \"cor\", etc.</p> <code>coef</code> <code>(str, optional)</code> <p>Specific coefficient name for class-level priors</p> <code>group</code> <code>(str, optional)</code> <p>Grouping variable for hierarchical effects</p> <code>dpar</code> <code>(str, optional)</code> <p>Distributional parameter (e.g., \"sigma\", \"phi\", \"zi\")</p> <code>resp</code> <code>(str, optional)</code> <p>Response variable for multivariate models</p> <code>nlpar</code> <code>(str, optional)</code> <p>Non-linear parameter name</p> <code>lb</code> <code>(float, optional)</code> <p>Lower bound for truncated priors</p> <code>ub</code> <code>(float, optional)</code> <p>Upper bound for truncated priors</p> See Also <p>prior : Factory function to create PriorSpec instances brms::prior_string : R documentation     https://paulbuerkner.com/brms/reference/prior_string.html</p> <p>Examples:</p> <p>Create prior specifications (prefer using <code>prior()</code> function):</p> <pre><code>from brmspy.types import PriorSpec\n\n# Fixed effect prior\np1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n# Group-level SD prior\np2 = PriorSpec(\n    prior=\"exponential(2)\",\n    class_=\"sd\",\n    group=\"patient\"\n)\n\n# Coefficient-specific prior with bounds\np3 = PriorSpec(\n    prior=\"normal(0, 1)\",\n    class_=\"b\",\n    coef=\"age\",\n    lb=0  # Truncated at zero\n)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.PriorSpec-functions","title":"Functions","text":""},{"location":"api/brms/#brmspy.brms.PriorSpec.to_brms_kwargs","title":"<code>to_brms_kwargs()</code>","text":"<p>Convert PriorSpec to keyword arguments for brms::prior_string().</p> <p>Maps Python dataclass fields to R function arguments, handling the <code>class_</code> -&gt; <code>class</code> parameter name conversion.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keyword arguments ready for brms::prior_string()</p> <p>Examples:</p> <pre><code>from brmspy import prior\np = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\nkwargs = p.to_brms_kwargs()\nprint(kwargs)\n# {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n</code></pre>"},{"location":"api/brms/#brmspy.brms-functions","title":"Functions","text":""},{"location":"api/brms/#brmspy.brms.install_brms","title":"<code>install_brms(brms_version='latest', repo=None, install_cmdstanr=True, install_rstan=False, cmdstanr_version='latest', rstan_version='latest', use_prebuilt_binaries=False, install_rtools=False)</code>","text":"<p>Install brms R package, optionally cmdstanr and CmdStan compiler, or rstan.</p> <p>Parameters:</p> Name Type Description Default <code>brms_version</code> <code>str</code> <p>brms version: \"latest\", \"2.23.0\", or \"&gt;= 2.20.0\"</p> <code>\"latest\"</code> <code>repo</code> <code>str | None</code> <p>Extra CRAN repository URL</p> <code>None</code> <code>install_cmdstanr</code> <code>bool</code> <p>Whether to install cmdstanr and build CmdStan compiler</p> <code>True</code> <code>install_rstan</code> <code>bool</code> <p>Whether to install rstan (alternative to cmdstanr)</p> <code>False</code> <code>cmdstanr_version</code> <code>str</code> <p>cmdstanr version: \"latest\", \"0.8.1\", or \"&gt;= 0.8.0\"</p> <code>\"latest\"</code> <code>rstan_version</code> <code>str</code> <p>rstan version: \"latest\", \"2.32.6\", or \"&gt;= 2.32.0\"</p> <code>\"latest\"</code> <code>use_prebuilt_binaries</code> <code>bool</code> <p>Uses fully prebuilt binaries for cmdstanr and brms and their dependencies.  Ignores system R libraries and uses the latest brms and cmdstanr available  for your system. Requires R&gt;=4 and might not be compatible with some older systems or missing toolchains. Can reduce setup time by 50x.</p> <code>False</code> <code>install_rtools</code> <code>bool</code> <p>Installs RTools (windows only) if they cant be found.  WARNING: Modifies system path and runs the full rtools installer.  Use with caution!</p> <code>False</code> <p>Examples:</p> <p>Basic installation:</p> <p><pre><code>from brmspy import brms\nbrms.install_brms()\n</code></pre> Install specific version:</p> <pre><code>brms.install_brms(brms_version=\"2.23.0\")\n</code></pre> <p>Use rstan instead of cmdstanr:</p> <pre><code>brms.install_brms(install_cmdstanr=False, install_rstan=True)\n</code></pre> <p>Fast installation with prebuilt binaries: <pre><code>brms.install_brms(use_prebuilt_binaries=True)\n</code></pre></p>"},{"location":"api/brms/#brmspy.brms.install_prebuilt","title":"<code>install_prebuilt(runtime_version='0.1.0', url=None, bundle=None, install_rtools=False)</code>","text":"<p>Install prebuilt brmspy runtime bundle for fast setup.</p> <p>Downloads and activates a precompiled runtime containing: - R packages (brms, cmdstanr, dependencies) - Compiled CmdStan binary - Complete environment ready for immediate use</p> <p>This reduces setup time from ~30 minutes to ~1 minute by avoiding compilation. Available for specific platform/R version combinations.</p> <p>This function reconfigures the running embedded R session to use an isolated  library environment from downloaded binaries. It does not mix or break the  default library tree already installed in the system.</p> <p>Parameters:</p> Name Type Description Default <code>runtime_version</code> <code>str</code> <p>Runtime schema version (not pip version)</p> <code>\"0.1.0\"</code> <code>url</code> <code>str</code> <p>Custom URL for runtime bundle. If None, uses GitHub releases</p> <code>None</code> <code>bundle</code> <code>str</code> <p>Local path to runtime bundle (.tar.gz or directory)</p> <code>None</code> <code>install_rtools</code> <code>bool</code> <p>Installs RTools (windows only) if they cant be found.  WARNING: Modifies system path and runs the full rtools installer.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if installation succeeded, False otherwise</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If prebuilt binaries not available for this platform</p> Notes <p>Platform Support: Prebuilt binaries are available for: - Linux: x86_64, glibc &gt;= 2.27, g++ &gt;= 9 - macOS: x86_64 and arm64, clang &gt;= 11 - Windows: x86_64 with Rtools</p> <p>R Version: Runtime includes all R packages, so they must match your R installation's major.minor version (e.g., R 4.3.x).</p> <p>System Fingerprint: Runtime is selected based on: - Operating system (linux/macos/windows) - CPU architecture (x86_64/arm64) - R version (major.minor)</p> <p>Example: <code>linux-x86_64-r4.3</code></p> See Also <p>install_brms : Main installation function brmspy.binaries.install_and_activate_runtime : Low-level installer brmspy.binaries.system_fingerprint : Platform detection</p> <p>Examples:</p> <p>Install from GitHub releases:</p> <pre><code>from brmspy.install import install_prebuilt\ninstall_prebuilt()\n</code></pre> <p>Install from local bundle:</p> <pre><code>install_prebuilt(bundle=\"/path/to/runtime.tar.gz\")\n</code></pre> <p>Install from custom URL:</p> <pre><code>    install_prebuilt(url=\"https://example.com/runtime.tar.gz\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.get_brms_version","title":"<code>get_brms_version()</code>","text":"<p>Get installed brms R package version.</p> <p>Returns:</p> Type Description <code>str</code> <p>Version object or None</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If brms is not installed</p> <p>Examples:</p> <pre><code>from brmspy import brms\nversion = brms.get_brms_version()\nprint(f\"brms version: {version}\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.get_brms_data","title":"<code>get_brms_data(dataset_name)</code>","text":"<p>Load example dataset from brms package.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Dataset name. Available datasets include: - 'epilepsy': Epileptic seizure counts - 'kidney': Kidney infection data with censoring - 'inhaler': Inhaler usage study - 'btdata': British Telecom share price data - And many more from brms package</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset as pandas DataFrame with column names preserved</p> See Also <p>brms::brmsdata : R documentation for available datasets     https://paulbuerkner.com/brms/reference/index.html#data</p> <p>Examples:</p> <p>Load epilepsy dataset:</p> <pre><code>from brmspy import brms\nepilepsy = brms.get_brms_data(\"epilepsy\")\nprint(epilepsy.head())\nprint(epilepsy.columns)\n</code></pre> <p>Load kidney dataset with censoring:</p> <pre><code>kidney = brms.get_brms_data(\"kidney\")\nprint(f\"Shape: {kidney.shape}\")\nprint(f\"Censored observations: {kidney['censored'].sum()}\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.read_rds_fit","title":"<code>read_rds_fit(file, **kwargs)</code>","text":"<p>Load saved brmsfit object as FitResult with arviz InferenceData.</p> <p>Reads a brmsfit object from an RDS file and converts it to a FitResult with both arviz InferenceData (.idata) and the raw R object (.r). This is the recommended way to load saved brms models for analysis and predictions in Python.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to RDS file containing saved brmsfit object</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to R's readRDS():</p> <ul> <li>refhook : function - Reference hook for deserialization</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Object with two attributes: - .idata : arviz.InferenceData with posterior samples and diagnostics - .r : R brmsfit object for use with brms functions</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If file doesn't exist or doesn't contain a valid brmsfit object</p> See Also <p>save_rds : Save brmsfit objects to RDS files read_rds_raw : Load as raw R object without conversion fit : Create brmsfit objects to save</p> <p>Examples:</p> <p>Basic loading and analysis:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\n# Load previously saved model\nmodel = brms.read_rds_fit(\"my_model.rds\")\n\n# Analyze with arviz\naz.summary(model.idata)\naz.plot_trace(model.idata)\n\n# Check diagnostics\nprint(az.rhat(model.idata))\n</code></pre> <p>Load and make predictions:</p> <pre><code>import pandas as pd\n\n# Load saved model\nmodel = brms.read_rds_fit(\"trained_model.rds\")\n\n# Create new data for predictions\nnewdata = pd.DataFrame({\n    'x': [1.0, 2.0, 3.0],\n    'group': ['A', 'B', 'A']\n})\n\n# Generate predictions\npredictions = brms.posterior_predict(model, newdata=newdata)\nprint(predictions.idata.posterior_predictive)\n</code></pre> <p>Load model for comparison:</p> <pre><code># Load multiple saved models\nmodel1 = brms.read_rds_fit(\"model1.rds\")\nmodel2 = brms.read_rds_fit(\"model2.rds\")\n\n# Compare with arviz\ncomparison = az.compare({\n    'model1': model1.idata,\n    'model2': model2.idata\n})\nprint(comparison)\n</code></pre> <p>Resume analysis from checkpoint:</p> <pre><code># Load model from checkpoint during long computation\ntry:\n    model = brms.read_rds_fit(\"checkpoint.rds\")\n    print(\"Loaded from checkpoint\")\nexcept:\n    # Checkpoint doesn't exist, fit from scratch\n    model = brms.fit(formula=\"y ~ x\", data=data, chains=4)\n    brms.save_rds(model, \"checkpoint.rds\")\n\n# Continue analysis\nsummary = brms.summary(model)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.read_rds_raw","title":"<code>read_rds_raw(file, **kwargs)</code>","text":"<p>Load R object from RDS file as raw ListVector.</p> <p>Reads an RDS file and returns the raw R object without any Python conversion or processing. Useful when you need direct access to the R object structure or want to inspect saved objects before full conversion.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to RDS file to load</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to R's readRDS():</p> <ul> <li>refhook : function - Reference hook for deserialization</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>ListVector</code> <p>Raw R ListVector object from the RDS file</p> See Also <p>read_rds_fit : Load as FitResult with arviz InferenceData save_rds : Save R objects to RDS files</p> <p>Examples:</p> <p>Load raw R object:</p> <pre><code>from brmspy import brms\n\n# Load raw brmsfit object\nraw_model = brms.read_rds_raw(\"model.rds\")\n\n# Access R object directly (for advanced users)\nprint(type(raw_model))  # rpy2.robjects.vectors.ListVector\n</code></pre> <p>Inspect object structure before conversion:</p> <pre><code># Load raw to check what's in the file\nraw_obj = brms.read_rds_raw(\"unknown_object.rds\")\n\n# Inspect R object attributes\nprint(raw_obj.names)\n\n# Then decide how to process it\nif \"fit\" in raw_obj.names:\n    # It's a brmsfit, convert properly\n    full_model = brms.read_rds_fit(\"unknown_object.rds\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.save_rds","title":"<code>save_rds(object, file, **kwargs)</code>","text":"<p>Save brmsfit object or R object to RDS file.</p> <p>Saves fitted brms models or other R objects to disk using R's saveRDS() function. This allows persisting models for later use, sharing fitted models, or creating model checkpoints during long computations.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Object to save. Can be: - FitResult from fit() - saves the underlying brmsfit R object - Any R ListVector object</p> required <code>file</code> <code>str</code> <p>File path where object will be saved. Typically uses .rds extension but not required</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to R's saveRDS():</p> <ul> <li>compress : bool or str - Compression method:     True (default), False, \"gzip\", \"bzip2\", \"xz\"</li> <li>version : int - RDS format version (2 or 3)</li> <li>ascii : bool - Use ASCII representation (default False)</li> <li>refhook : function - Reference hook for serialization (NOT tested)</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> See Also <p>read_rds_fit : Load saved brmsfit as FitResult read_rds_raw : Load saved object as raw R ListVector fit : Fit models that can be saved</p> <p>Examples:</p> <p>Save a fitted model:</p> <pre><code>from brmspy import brms\n\n# Fit model\nmodel = brms.fit(\n    formula=\"y ~ x + (1|group)\",\n    data=data,\n    family=\"gaussian\",\n    chains=4\n)\n\n# Save to file\nbrms.save_rds(model, \"my_model.rds\")\n</code></pre> <p>Save with compression options:</p> <pre><code># High compression for storage\nbrms.save_rds(model, \"model.rds\", compress=\"xz\")\n\n# No compression for faster saving\nbrms.save_rds(model, \"model.rds\", compress=False)\n</code></pre> <p>Save and later reload:</p> <pre><code># Save model\nbrms.save_rds(model, \"model.rds\")\n\n# Later session: reload model\nloaded_model = brms.read_rds_fit(\"model.rds\")\n\n# Use loaded model for predictions\npredictions = brms.posterior_predict(loaded_model, newdata=new_data)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.prior","title":"<code>prior(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None, **kwargs)</code>","text":"<p>Create a brms-style prior specification.</p> <p>This function mirrors the behavior of <code>brms::prior_string()</code> and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of <code>prior_string()</code> in brms.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>str</code> <p>The prior definition as a string, exactly as brms expects it. Examples include ::</p> <pre><code>\"normal(0, 1)\"\n\"student_t(3, 0, 1.5)\"\n\"exponential(2)\"\n\"lkj(2)\"\n</code></pre> required <code>class_</code> <code>str</code> <p>Parameter class (e.g. <code>\"b\"</code>, <code>\"sd\"</code>, <code>\"Intercept\"</code>). This corresponds to <code>class</code> in brms. <code>class</code> cannot be used as a parameter in Python (reserved keyword), so <code>class_</code> is used instead.</p> <code>None</code> <code>coef</code> <code>str</code> <p>Coefficient name for class-level effects.</p> <code>None</code> <code>group</code> <code>str</code> <p>Grouping variable for hierarchical/multilevel effects.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Distributional parameter (e.g. <code>\"sigma\"</code> or <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response variable name for multivariate models.</p> <code>None</code> <code>nlpar</code> <code>str</code> <p>Nonlinear parameter name if using nonlinear formulas.</p> <code>None</code> <code>lb</code> <code>float</code> <p>Lower bound for truncated priors.</p> <code>None</code> <code>ub</code> <code>float</code> <p>Upper bound for truncated priors.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Any additional keyword arguments supported by <code>brms::prior_string()</code>. These are forwarded unchanged.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriorSpec</code> <p>A typed prior specification object used by <code>brmspy.fit()</code> and <code>brmspy.make_stancode()</code>.</p> Notes <p>This function does not validate the prior expression string itself \u2014 validation occurs inside brms. Its purpose is to construct a structured, editor-friendly representation that seamlessly maps to rpy2 calls.</p> <p>Examples:</p> <p>Prior on the intercept ::</p> <pre><code>p = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\")\n</code></pre> <p>Prior on a coefficient ::</p> <pre><code>p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n</code></pre> <p>Group-level (hierarchical) SD prior ::</p> <pre><code>p = prior(\"exponential(2)\", class_=\"sd\", group=\"region\")\n</code></pre> <p>Truncated prior ::</p> <pre><code>p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0)\n</code></pre> <p>Multiple priors passed to <code>fit</code> ::</p> <pre><code>from brmspy import prior\npriors = [\n    prior(\"student_t(3, 0, 2)\", class_=\"b\", coef=\"zAge\"),\n    prior(\"exponential(2)\", class_=\"sd\", group=\"patient\"),\n]\nmodel = brms.fit(\"y ~ zAge + (1|patient)\", data=df, priors=priors)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.get_prior","title":"<code>get_prior(formula, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for all model parameters.</p> <p>Returns a DataFrame with default priors for each parameter class in the specified brms model. Useful for reviewing and customizing priors before fitting.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaResult</code> <p>Model formula (e.g., \"y ~ x + (1|group)\") or FormulaResult object</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\")</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row represents a parameter or parameter class that can have a custom prior.</p> See Also <p>default_prior : Generic function for getting default priors prior : Create custom prior specifications brms::get_prior : R documentation     https://paulbuerkner.com/brms/reference/get_prior.html</p> <p>Examples:</p> <p>Review default priors for a model:</p> <pre><code>from brmspy import brms\n\npriors = brms.get_prior(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\nprint(priors)\n#   prior       class    coef      group  ...\n#   student_t() Intercept  ...    ...     ...\n#   (flat)      b          zAge    ...    ...\n</code></pre> <p>Customize and use priors:</p> <pre><code>from brmspy import brms, prior\n\n# Get defaults\npriors_df = brms.get_prior(\"y ~ x\", data=df)\n\n# Create custom priors based on review\ncustom_priors = [\n    prior(\"normal(0, 0.5)\", class_=\"b\"),\n    prior(\"exponential(2)\", class_=\"sigma\")\n]\n\nmodel = brms.fit(\"y ~ x\", data=df, priors=custom_priors)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.default_prior","title":"<code>default_prior(object, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for brms model parameters (generic function).</p> <p>Generic function to retrieve default prior specifications for all parameters in a brms model. Accepts formula objects, brmsformula objects, or other model specification objects. This is the generic version of get_prior().</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>str, FormulaResult, or ListVector</code> <p>Model specification: formula string, brmsformula object, mvbrmsformula, or any object that can be coerced to these classes</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\"). Can be a list of families for multivariate models</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels, sparse)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row specifies a parameter class with its default prior. The 'prior' column is empty except for internal defaults.</p> See Also <p>get_prior : Convenience function with formula parameter prior : Create custom prior specifications brms::default_prior : R documentation     https://paulbuerkner.com/brms/reference/get_prior.html</p> <p>Examples:</p> <p>Get default priors for a Poisson model:</p> <pre><code>from brmspy import brms\n\npriors = brms.default_prior(\n    object=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\nprint(priors)\n</code></pre> <p>Use with formula object:</p> <pre><code>from brmspy import brms\n\nf = brms.formula(\"y ~ x + (1|group)\")\npriors = brms.default_prior(f, data=df, family=\"gaussian\")\n</code></pre>"},{"location":"api/brms/#brmspy.brms.fit","title":"<code>fit(formula, data, priors=None, family='gaussian', sample_prior='no', sample=True, backend='cmdstanr', formula_args=None, **brm_args)</code>","text":"<p>Fit Bayesian regression model using brms.</p> <p>Uses brms with cmdstanr backend for proper parameter naming. Returns FitResult with .idata (arviz.InferenceData) and .r (brmsfit) attributes.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>brms formula: formula string, e.g \"y ~ x + (1|group)\" or FormulaResult from formula()</p> required <code>data</code> <code>dict or DataFrame</code> <p>Model data</p> required <code>priors</code> <code>list</code> <p>Prior specifications: [(\"normal(0,1)\", \"b\"), (\"cauchy(0,2)\", \"sd\")]</p> <code>[]</code> <code>family</code> <code>str</code> <p>Distribution family: \"gaussian\", \"poisson\", \"binomial\", etc.</p> <code>\"gaussian\"</code> <code>sample_prior</code> <code>str</code> <p>Sample from prior: \"no\", \"yes\", \"only\"</p> <code>\"no\"</code> <code>sample</code> <code>bool</code> <p>Whether to sample. If False, returns compiled model with empty=TRUE</p> <code>True</code> <code>backend</code> <code>str</code> <p>Stan backend: \"cmdstanr\" (recommended), \"rstan\"</p> <code>\"cmdstanr\"</code> <code>**brm_args</code> <p>Additional brms::brm() arguments: chains=4, iter=2000, warmup=1000, cores=4, seed=123, thin=1, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Object with .idata (arviz.InferenceData) and .r (brmsfit) attributes</p> See Also <p>brms::brm : R documentation     https://paulbuerkner.com/brms/reference/brm.html posterior_epred : Expected value predictions posterior_predict : Posterior predictive samples formula : Create formula object with options</p> <p>Examples:</p> <p>Basic Poisson regression:</p> <p><pre><code>from brmspy import brms\nimport arviz as az\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    chains=4,\n    iter=2000\n)\n\naz.summary(model.idata)\n</code></pre> With custom priors:</p> <p><pre><code>from brmspy import prior\n\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    priors=[\n        prior(\"normal(0, 0.5)\", class_=\"b\"),\n        prior(\"exponential(2)\", class_=\"sd\", group=\"patient\")\n    ],\n    family=\"poisson\",\n    chains=4\n)\n</code></pre> Survival model with censoring:</p> <p><pre><code>kidney = brms.get_brms_data(\"kidney\")\n\nsurvival_model = brms.fit(\n    formula=\"time | cens(censored) ~ age + sex + disease + (1|patient)\",\n    data=kidney,\n    family=\"weibull\",\n    chains=4,\n    iter=4000,\n    warmup=2000,\n    cores=4,\n    seed=42\n)\n</code></pre> Gaussian model with distributional regression:</p> <pre><code>    # Model both mean and variance\n    model = brms.fit(\n        formula=brms.formula(\n            \"y ~ x\",\n            sigma ~ \"z\"  # Model heteroscedasticity\n        ),\n        data=data,\n        family=\"gaussian\",\n        chains=4\n    )\n</code></pre>"},{"location":"api/brms/#brmspy.brms.summary","title":"<code>summary(model, **kwargs)</code>","text":"<p>Generate comprehensive summary statistics for fitted brms model.</p> <p>Returns a <code>SummaryResult</code> dataclass containing model information, parameter estimates, and diagnostic information. The SummaryResult object provides pretty printing via <code>str()</code> or <code>print()</code> and structured access to all components.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from <code>fit()</code></p> required <code>**kwargs</code> <p>Additional arguments passed to brms::summary(), such as: - probs: Quantiles for credible intervals, e.g., <code>probs=(0.025, 0.975)</code> - robust: Use robust estimates (median, MAD), default False</p> <code>{}</code> <p>Returns:</p> Type Description <code>SummaryResult</code> <p>A dataclass containing:</p> <ul> <li>formula (str): Model formula as string</li> <li>data_name (str): Name of the data object used</li> <li>group (str): Grouping structure information</li> <li>nobs (int): Number of observations</li> <li>ngrps (Dict[str, int]): Number of groups per grouping variable</li> <li>autocor (Optional[dict]): Autocorrelation structure if present</li> <li>prior (pd.DataFrame): Prior specifications used</li> <li>algorithm (str): Sampling algorithm (e.g., \"sampling\")</li> <li>sampler (str): Sampler specification (e.g., \"sample(hmc)\")</li> <li>total_ndraws (int): Total number of post-warmup draws</li> <li>chains (float): Number of chains</li> <li>iter (float): Iterations per chain</li> <li>warmup (float): Warmup iterations per chain</li> <li>thin (float): Thinning interval</li> <li>has_rhat (bool): Whether Rhat diagnostics are reported</li> <li>fixed (pd.DataFrame): Population-level (fixed) effects estimates</li> <li>spec_pars (pd.DataFrame): Family-specific parameters (e.g., sigma)</li> <li>cor_pars (pd.DataFrame): Correlation parameters if present</li> <li>random (dict): Group-level (random) effects by grouping variable</li> </ul> See Also <p>brms::summary.brmsfit : R documentation     https://paulbuerkner.com/brms/reference/summary.brmsfit.html</p> <p>Examples:</p> <p>Basic usage with pretty printing:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x\", data=data, chains=4)\nsummary = brmspy.summary(model)\n\n# Pretty print full summary\nprint(summary)\n</code></pre> <p>Access specific components:</p> <pre><code># Get population-level effects as DataFrame\nfixed_effects = summary.fixed\nprint(fixed_effects)\n\n# Get family-specific parameters (e.g., sigma)\nspec_params = summary.spec_pars\nprint(spec_params)\n\n# Access random effects (if present)\nrandom_effects = summary.random\nfor group_name, group_df in random_effects.items():\n    print(f\"Random effects for {group_name}:\")\n    print(group_df)\n\n# Check model metadata\nprint(f\"Formula: {summary.formula}\")\nprint(f\"Total draws: {summary.total_ndraws}\")\nprint(f\"Rhat reported: {summary.has_rhat}\")\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Use 90% credible intervals instead of default 95%\nsummary_90 = brmspy.summary(model, probs=(0.05, 0.95))\nprint(summary_90.fixed)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.fixef","title":"<code>fixef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, **kwargs)</code>","text":"<p>Extract population-level (fixed) effects estimates from a fitted brms model.</p> <p>Returns a pandas DataFrame containing estimates and uncertainty intervals for all population-level parameters (fixed effects). By default, returns summary statistics (mean, standard error, credible intervals). Can also return raw posterior samples when <code>summary=False</code>.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>summary</code> <code>bool</code> <p>If True, return summary statistics (mean/median, SE/MAD, credible intervals). If False, return matrix of posterior samples (iterations \u00d7 parameters).</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics. Only used when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>list of str</code> <p>Specific parameter names to extract. If None, returns all fixed effects. Useful for subsetting when you only need specific coefficients.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::fixef()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>When <code>summary=True</code> (default):     DataFrame with parameters as rows and columns for Estimate, Est.Error,     Q2.5, Q97.5 (or other quantiles specified in <code>probs</code>), and optionally     Rhat and Bulk_ESS/Tail_ESS diagnostics.</p> <p>When <code>summary=False</code>:     DataFrame with posterior samples where rows are iterations and columns     are parameters. Shape is (n_iterations \u00d7 n_parameters).</p> See Also <p>brms::fixef.brmsfit : R documentation     https://paulbuerkner.com/brms/reference/fixef.brmsfit.html summary() : Full model summary with all parameter types</p> <p>Examples:</p> <p>Basic usage with summary statistics:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=data, chains=4)\n\n# Get fixed effects summary\nfixed_effects = brmspy.fixef(model)\nprint(fixed_effects)\n#             Estimate  Est.Error      Q2.5     Q97.5\n# Intercept  10.234567   0.123456  9.992345  10.47689\n# x1          0.456789   0.098765  0.263456   0.65012\n# x2         -0.234567   0.087654 -0.406789  -0.06234\n</code></pre> <p>Get specific parameters only:</p> <pre><code># Extract only specific coefficients\nx1_x2_effects = brmspy.fixef(model, pars=[\"x1\", \"x2\"])\nprint(x1_x2_effects)\n</code></pre> <p>Use robust estimates (median and MAD):</p> <pre><code># Use median and MAD instead of mean and SD\nrobust_effects = brmspy.fixef(model, robust=True)\nprint(robust_effects)\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Get 90% credible intervals\neffects_90 = brmspy.fixef(model, probs=(0.05, 0.95))\nprint(effects_90)\n</code></pre> <p>Get raw posterior samples:</p> <pre><code># Get full posterior samples matrix\nsamples = brmspy.fixef(model, summary=False)\nprint(samples.shape)  # (n_iterations, n_parameters)\n\n# Can then compute custom statistics\nimport numpy as np\ncustom_quantile = np.percentile(samples[\"x1\"], 90)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.ranef","title":"<code>ranef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, groups=None, **kwargs)</code>","text":"<p>Extract group-level (random) effects as xarray DataArrays.</p> <p>This is a wrapper around <code>brms::ranef()</code>. For <code>summary=True</code> (default), each grouping factor is returned as a 3D array with dimensions <code>(\"group\", \"stat\", \"coef\")</code>. For <code>summary=False</code>, each factor is returned as <code>(\"draw\", \"group\", \"coef\")</code> with one slice per posterior draw.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model returned by :func:<code>brmspy.brms.fit</code> or an R <code>brmsfit</code> object / summary list.</p> required <code>summary</code> <code>bool</code> <p>If True, return posterior summaries for the group-level effects (means, errors, intervals). If False, return per-draw random effects.</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use robust summaries (median and MAD) instead of mean and SD. Passed through to <code>brms::ranef()</code> when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Central posterior interval probabilities, as in <code>brms::ranef()</code>. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>str or sequence of str</code> <p>Subset of group-level parameters to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>groups</code> <code>str or sequence of str</code> <p>Subset of grouping factors to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments forwarded to <code>brms::ranef()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, DataArray]</code> <p>Mapping from grouping-factor name (e.g. <code>\"patient\"</code>) to a <code>DataArray</code>:</p> <ul> <li><code>summary=True</code>: dims <code>(\"group\", \"stat\", \"coef\")</code>,   with <code>stat</code> typically containing   <code>[\"Estimate\", \"Est.Error\", \"Q2.5\", \"Q97.5\"]</code>.</li> <li><code>summary=False</code>: dims <code>(\"draw\", \"group\", \"coef\")</code>,   where <code>draw</code> indexes posterior samples.</li> </ul> <p>Examples:</p> <p>Compute summary random effects and inspect all coefficients for a single group level:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms import ranef\n\nfit = brms.fit(\"count ~ zAge + zBase * Trt + (1 + zBase + Trt | patient)\",\n               data=data, family=\"poisson\")\n\nre = ranef(fit)  # summary=True by default\npatient_re = re[\"patient\"].sel(group=\"1\", stat=\"Estimate\")\n</code></pre> <p>Extract per-draw random effects for downstream MCMC analysis:</p> <pre><code>re_draws = ranef(fit, summary=False)\npatient_draws = re_draws[\"patient\"]       # dims: (\"draw\", \"group\", \"coef\")\nfirst_draw = patient_draws.sel(draw=0)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.posterior_summary","title":"<code>posterior_summary(object, variable=None, probs=(0.025, 0.975), robust=False, **kwargs)</code>","text":"<p>Extract posterior summary statistics for all or selected model parameters.</p> <p>Provides a DataFrame with estimates, standard errors, and credible intervals for all parameters in a brms model, including fixed effects, random effects, and auxiliary parameters. More comprehensive than <code>fixef()</code> or <code>ranef()</code> as it covers all parameter types.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>variable</code> <code>str or list of str</code> <p>Specific variable name(s) to extract. If None, returns all parameters. Supports regex patterns for flexible selection.</p> <code>None</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals.</p> <code>(0.025, 0.975)</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments passed to brms::posterior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with parameters as rows and columns for Estimate, Est.Error, and quantiles (e.g., Q2.5, Q97.5). Includes all model parameters: population-level effects, group-level effects, and auxiliary parameters.</p> See Also <p>brms::posterior_summary : R documentation     https://paulbuerkner.com/brms/reference/posterior_summary.brmsfit.html <code>fixef()</code> : Extract only population-level effects <code>ranef()</code> : Extract only group-level effects</p> <p>Examples:</p> <p>Get summary for all parameters:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + (1|group)\", data=data, chains=4)\n\n# Get all parameter summaries\nall_params = brmspy.posterior_summary(model)\nprint(all_params)\n</code></pre> <p>Extract specific parameters:</p> <pre><code># Get summary for specific parameters\nintercept = brmspy.posterior_summary(model, variable=\"b_Intercept\")\nprint(intercept)\n\n# Multiple parameters\nfixed_only = brmspy.posterior_summary(model, variable=[\"b_Intercept\", \"b_x1\"])\nprint(fixed_only)\n</code></pre> <p>Custom credible intervals with robust estimates:</p> <pre><code># 90% intervals with median/MAD\nrobust_summary = brmspy.posterior_summary(\n    model,\n    probs=(0.05, 0.95),\n    robust=True\n)\nprint(robust_summary)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.prior_summary","title":"<code>prior_summary(object, all=True, **kwargs)</code>","text":"<p>Extract prior specifications used in a fitted brms model.</p> <p>Returns a DataFrame containing all prior distributions that were used (either explicitly set or defaults) when fitting the model. Useful for documenting model specifications and understanding which priors were applied.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>all</code> <code>bool</code> <p>If True, return all priors including default priors. If False, return only explicitly set priors.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to brms::prior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns describing prior specifications: - prior: Prior distribution formula - class: Parameter class (b, sd, Intercept, etc.) - coef: Specific coefficient (if applicable) - group: Grouping factor (if applicable) - resp: Response variable (for multivariate models) - dpar: Distributional parameter (if applicable) - nlpar: Non-linear parameter (if applicable) - lb/ub: Bounds for truncated priors - source: Origin of prior (default, user, etc.)</p> See Also <p>brms::prior_summary : R documentation     https://paulbuerkner.com/brms/reference/prior_summary.brmsfit.html <code>get_prior()</code> : Get prior structure before fitting <code>default_prior()</code> : Get default priors for a model</p> <p>Examples:</p> <p>Get all priors used in a model:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\n    \"y ~ x1 + (1|group)\",\n    data=data,\n    priors=[brmspy.prior(\"normal(0, 1)\", \"b\")],\n    chains=4\n)\n\n# Get all priors (including defaults)\npriors = brmspy.prior_summary(model)\nprint(priors)\n</code></pre> <p>Get only explicitly set priors:</p> <pre><code># Get only user-specified priors\nuser_priors = brmspy.prior_summary(model, all=False)\nprint(user_priors)\n</code></pre> <p>Compare with what would be used before fitting:</p> <pre><code># Before fitting - check default priors\ndefault_priors = brmspy.get_prior(\"y ~ x1\", data=data)\n\n# After fitting - see what was actually used\nused_priors = brmspy.prior_summary(model)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.loo","title":"<code>loo(object, compare=True, resp=None, pointwise=False, moment_match=False, reloo=False, k_threshold=0.7, save_psis=False, moment_match_args=[], reloo_args=[], model_names=None, **kwargs)</code>","text":"<p>Compute efficient leave-one-out cross-validation (LOO-CV) for Bayesian models.</p> <p>Performs approximate LOO-CV using Pareto smoothed importance sampling (PSIS-LOO) from the loo package. Returns a <code>LooResult</code> dataclass with LOO estimates (elpd_loo, p_loo, looic) and diagnostic information including Pareto k diagnostics for identifying problematic observations.</p> <p>BRMS documentation LOO package</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>compare</code> <code>bool</code> <p>If True and multiple models provided, compare models using loo_compare. Only relevant when passing multiple models (not yet supported in this wrapper).</p> <code>True</code> <code>resp</code> <code>str or list of str</code> <p>Response variable names for multivariate models. If specified, compute LOO only for these responses.</p> <code>None</code> <code>pointwise</code> <code>bool</code> <p>If True, compute log-likelihood separately for each observation (slower but uses less memory). Useful when encountering memory issues with large datasets.</p> <code>False</code> <code>moment_match</code> <code>bool</code> <p>If True, apply moment matching for observations with high Pareto k values (k &gt; k_threshold). Requires <code>save_pars=save_pars(all=TRUE)</code> in original fit. Improves accuracy for problematic observations.</p> <code>False</code> <code>reloo</code> <code>bool</code> <p>If True, refit model excluding observations with high Pareto k values (k &gt; k_threshold). Provides exact LOO for problematic cases but is computationally expensive.</p> <code>False</code> <code>k_threshold</code> <code>float</code> <p>Pareto k threshold above which moment matching or refitting is applied. Values &gt; 0.7 indicate unreliable importance sampling.</p> <code>0.7</code> <code>save_psis</code> <code>bool</code> <p>If True, save the PSIS object in the result for further diagnostics.</p> <code>False</code> <code>moment_match_args</code> <code>list</code> <p>Additional arguments passed to loo_moment_match if moment_match=True.</p> <code>[]</code> <code>reloo_args</code> <code>list</code> <p>Additional arguments passed to reloo if reloo=True.</p> <code>[]</code> <code>model_names</code> <code>str or list of str</code> <p>Custom names for models when comparing multiple models.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::loo()</p> <code>{}</code> <p>Returns:</p> Type Description <code>LooResult</code> <p>Dataclass containing:</p> <ul> <li>elpd_loo (float): Expected log pointwise predictive density (higher is better)</li> <li>p_loo (float): Effective number of parameters</li> <li>looic (float): LOO information criterion (lower is better, -2 * elpd_loo)</li> <li>se_elpd_loo (float): Standard error of elpd_loo</li> <li>se_p_loo (float): Standard error of p_loo</li> <li>se_looic (float): Standard error of looic</li> <li>estimates (pd.DataFrame): Full estimates table with all metrics</li> <li>pointwise (pd.DataFrame): Pointwise contributions (if requested)</li> <li>diagnostics (pd.DataFrame): Pareto k diagnostics per observation</li> <li>psis_object (Optional): PSIS object if save_psis=True</li> </ul> See Also <p>brms::loo : R documentation     https://paulbuerkner.com/brms/reference/loo.brmsfit.html loo::loo : LOO package documentation     https://mc-stan.org/loo/reference/loo.html</p> <p>Examples:</p> <p>Basic LOO-CV for model comparison:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=data, chains=4)\n\n# Compute LOO-CV\nloo_result = brmspy.loo(model)\n\n# Print formatted summary\nprint(loo_result)\n\n# Access specific metrics\nprint(f\"ELPD LOO: {loo_result.elpd_loo:.2f} \u00b1 {loo_result.se_elpd_loo:.2f}\")\nprint(f\"LOOIC: {loo_result.looic:.2f}\")\nprint(f\"Effective parameters: {loo_result.p_loo:.2f}\")\n</code></pre> <p>Check for problematic observations:</p> <pre><code># Get Pareto k diagnostics\ndiagnostics = loo_result.diagnostics\n\n# Find observations with high Pareto k (unreliable importance sampling)\nproblematic = diagnostics[diagnostics['pareto_k'] &gt; 0.7]\nprint(f\"Found {len(problematic)} problematic observations\")\n</code></pre> <p>Handle problematic observations with moment matching:</p> <pre><code># Requires save_pars=save_pars(all=TRUE) in original fit\nmodel = brmspy.fit(\n    \"y ~ x1 + x2\",\n    data=data,\n    chains=4,\n    save_pars=brmspy.save_pars(all=True)\n)\n\n# Apply moment matching for high Pareto k values\nloo_mm = brmspy.loo(model, moment_match=True, k_threshold=0.7)\nprint(loo_mm)\n</code></pre> <p>Memory-efficient computation for large datasets:</p> <pre><code># Use pointwise computation to reduce memory usage\nloo_pointwise = brmspy.loo(model, pointwise=True)\nprint(loo_pointwise)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.loo_compare","title":"<code>loo_compare(*objects, criterion='loo', model_names=None)</code>","text":"<p>Compare multiple models using approximate LOO cross-validation.</p> <p>This function wraps <code>brms::loo()</code> and <code>loo::loo_compare()</code>:</p> <ol> <li>For each model, call <code>brms::loo()</code> to obtain a <code>loo</code> object.</li> <li>Call <code>loo::loo_compare()</code> on the resulting <code>loo</code> objects.</li> <li>Return the comparison matrix as a :class:<code>pandas.DataFrame</code>.</li> </ol> <p>Currently only the <code>'loo'</code> criterion is supported.</p> <p>Parameters:</p> Name Type Description Default <code>*objects</code> <code>FitResult or ListVector</code> <p>Two or more fitted models to compare. Typically the :class:<code>FitResult</code> objects returned by :func:<code>brmspy.brms.fit</code>.</p> <code>()</code> <code>criterion</code> <code>loo</code> <p>Information criterion to use. For now only <code>'loo'</code> is supported.</p> <code>'loo'</code> <code>model_names</code> <code>sequence of str</code> <p>Optional model names to use as row labels in the comparison table. If omitted, row names are taken from the R side and may be less informative when called via Python.</p> <code>None</code> <p>Returns:</p> Type Description <code>LooCompareResult</code> <p>Object holding:</p> <ul> <li><code>table</code>: a :class:<code>pandas.DataFrame</code> with one row per model   and columns such as <code>elpd_diff</code> and <code>se_diff</code>.</li> <li><code>criterion</code>: the criterion actually used (currently always   <code>'loo'</code>).</li> </ul> <p>Examples:</p> <pre><code>comp = loo_compare(fit1, fit2, model_names=[\"pl-only\", \"pl+subject\"])\nprint(comp)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.validate_newdata","title":"<code>validate_newdata(newdata, object, re_formula=None, allow_new_levels=False, newdata2=None, resp=None, check_response=True, incl_autocor=True, group_vars=None, req_vars=None, **kwargs)</code>","text":"<p>Validate new data for predictions from a fitted brms model.</p> <p>Ensures that new data contains all required variables and has the correct structure for making predictions. Checks variable types, factor levels, grouping variables, and autocorrelation structures. This function is primarily used internally by prediction methods but can be called directly for debugging or validation purposes.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>DataFrame</code> <p>DataFrame containing new data to be validated against the model. Must include all predictor variables used in the model formula.</p> required <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>re_formula</code> <code>str</code> <p>Formula string specifying group-level effects to include in validation. If None (default), include all group-level effects. If NA, include no group-level effects.</p> <code>None</code> <code>allow_new_levels</code> <code>bool</code> <p>Whether to allow new levels of grouping variables not present in the original training data. If False, raises an error for new levels.</p> <code>False</code> <code>newdata2</code> <code>DataFrame</code> <p>Additional data that cannot be passed via <code>newdata</code>, such as objects used in autocorrelation structures or stanvars.</p> <code>None</code> <code>resp</code> <code>str or list of str</code> <p>Names of response variables to validate. If specified, validation is performed only for the specified responses (relevant for multivariate models).</p> <code>None</code> <code>check_response</code> <code>bool</code> <p>Whether to check if response variables are present in newdata. Set to False when making predictions where response is not needed.</p> <code>True</code> <code>incl_autocor</code> <code>bool</code> <p>Whether to include autocorrelation structures originally specified in the model. If True, validates autocorrelation-related variables.</p> <code>True</code> <code>group_vars</code> <code>list of str</code> <p>Names of specific grouping variables to validate. If None (default), validates all grouping variables present in the model.</p> <code>None</code> <code>req_vars</code> <code>list of str</code> <p>Names of specific variables required in newdata. If None (default), all variables from the original training data are required (unless excluded by other parameters).</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::validate_newdata()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Validated DataFrame based on newdata, potentially with added or modified columns to ensure compatibility with the model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If newdata is missing required variables</p> <code>ValueError</code> <p>If factor levels in newdata don't match those in training data (when allow_new_levels=False)</p> <code>ValueError</code> <p>If grouping variables have invalid structure</p> See Also <p>brms::validate_newdata : R documentation     https://paulbuerkner.com/brms/reference/validate_newdata.html <code>posterior_predict()</code> : Uses validate_newdata internally <code>posterior_epred()</code> : Uses validate_newdata internally</p> <p>Examples:</p> <p>Basic validation for prediction data:</p> <pre><code>import brmspy\nimport pandas as pd\n\n# Fit model\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=train_data, chains=4)\n\n# Prepare new data\nnew_data = pd.DataFrame({\n    'x1': [1.0, 2.0, 3.0],\n    'x2': [0.5, 1.0, 1.5]\n})\n\n# Validate before prediction\nvalidated_data = brmspy.validate_newdata(new_data, model)\nprint(validated_data)\n</code></pre> <p>Validate with group-level effects:</p> <pre><code># Model with random effects\nmodel = brmspy.fit(\"y ~ x + (1|group)\", data=train_data, chains=4)\n\n# New data with grouping variable\nnew_data = pd.DataFrame({\n    'x': [1.0, 2.0],\n    'group': ['A', 'B']  # Must match training data groups\n})\n\n# Validate - will error if groups A or B weren't in training\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    allow_new_levels=False\n)\n</code></pre> <p>Allow new levels for population-level predictions:</p> <pre><code># Allow new group levels (makes population-level predictions only)\nnew_data_with_new_groups = pd.DataFrame({\n    'x': [3.0, 4.0],\n    'group': ['C', 'D']  # New groups not in training\n})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data_with_new_groups,\n    model,\n    allow_new_levels=True\n)\n</code></pre> <p>Skip response variable checking:</p> <pre><code># When making predictions, response not needed\nnew_data = pd.DataFrame({'x1': [1.0, 2.0]})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    check_response=False\n)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.call","title":"<code>call(function, *args, **kwargs)</code>","text":"<p>Call any brms or R function by name with automatic type conversion.</p> <p>Generic wrapper for calling brms functions that don't have dedicated Python wrappers. Automatically converts Python arguments to R objects and R results back to Python. Tries <code>brms::function_name</code> first, then falls back to base R.</p> <p>This function is useful for: - Accessing newer brms functions not yet wrapped in brmspy - Calling brms utility functions without writing custom wrappers - Quick exploration of brms functionality from Python</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Name of the R function to call. Will be prefixed with 'brms::' if possible. Can also include namespace (e.g., \"stats::predict\").</p> required <code>*args</code> <p>Positional arguments passed to the R function. Automatically converted from Python to R types (FitResult \u2192 brmsfit, DataFrame \u2192 data.frame, etc.).</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments passed to the R function. Python parameter names are automatically converted to R conventions.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Result from R function, automatically converted to appropriate Python type (R data.frame \u2192 pandas DataFrame, R vector \u2192 numpy array, etc.).</p> See Also <p><code>py_to_r</code> : Python to R type conversion <code>r_to_py</code> : R to Python type conversion</p> <p>Examples:</p> <p>Call brms functions not yet wrapped:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms_functions.generic import call\n\nmodel = brms.fit(\"y ~ x\", data=data, chains=4)\n\n# Call brms::neff_ratio (not yet wrapped)\nneff = call(\"neff_ratio\", model)\nprint(neff)\n\n# Call brms::rhat (not yet wrapped)\nrhat = call(\"rhat\", model)\nprint(rhat)\n</code></pre> <p>Call with keyword arguments:</p> <pre><code># Call brms::hypothesis for testing hypotheses\nhypothesis_result = call(\n    \"hypothesis\",\n    model,\n    hypothesis=\"b_x1 &gt; 0\",\n    alpha=0.05\n)\nprint(hypothesis_result)\n</code></pre> <p>Access functions from other R packages:</p> <pre><code># Call functions with namespace\nresult = call(\"stats::AIC\", model)\nprint(result)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.formula","title":"<code>formula(formula, **formula_args)</code>","text":"<p>Set up a model formula for brms package.</p> <p>Allows defining (potentially non-linear) additive multilevel models for all parameters of the assumed response distribution.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>brms formula specification, e.g., \"y ~ x + (1|group)\"</p> required <code>**formula_args</code> <code>dict</code> <p>Additional brms::brmsformula() arguments:</p> <ul> <li>decomp : str     Decomposition method (e.g., \"QR\" for QR decomposition)</li> <li>center : bool     Whether to center predictors (default True)</li> <li>sparse : bool     Use sparse matrix representation</li> <li>nl : bool     Whether formula is non-linear</li> <li>loop : bool     Use loop-based Stan code</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object with .r (R brmsformula object) and .dict (Python dict) attributes</p> See Also <p>brms::brmsformula : R documentation     https://paulbuerkner.com/brms/reference/brmsformula.html fit : Fit model using formula</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>    from brmspy import brms\n    f = brms.formula(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>With QR decomposition for numerical stability:</p> <pre><code>f = brms.formula(\n    \"reaction ~ days + (days|subject)\",\n    decomp=\"QR\"\n)\n</code></pre> <p>Multivariate formula: <pre><code>    f = brms.formula(\n        \"mvbind(y1, y2) ~ x1 + x2\",\n        center=True\n    )\n</code></pre></p>"},{"location":"api/brms/#brmspy.brms.posterior_epred","title":"<code>posterior_epred(model, newdata, **kwargs)</code>","text":"<p>Compute expected value of posterior predictive distribution.</p> <p>Calls brms::posterior_epred() to get E[Y|data] without observation noise.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions</p> required <code>**kwargs</code> <p>Additional arguments to brms::posterior_epred()</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorEpredResult</code> <p>Object with .idata and .r attributes</p>"},{"location":"api/brms/#brmspy.brms.posterior_linpred","title":"<code>posterior_linpred(model, newdata=None, **kwargs)</code>","text":"<p>Compute linear predictor of the model.</p> <p>Returns samples of the linear predictor (before applying the link function). Useful for understanding the model's predictions on the linear scale.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments to brms::posterior_linpred():</p> <ul> <li>transform : bool - Apply inverse link function (default False)</li> <li>ndraws : int - Number of posterior draws</li> <li>summary : bool - Return summary statistics</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorLinpredResult</code> <p>Object with .idata (IDLinpred) and .r (R matrix) attributes</p> See Also <p>brms::posterior_linpred : R documentation     https://paulbuerkner.com/brms/reference/posterior_linpred.brmsfit.html posterior_epred : Expected values on response scale</p> <p>Examples:</p> <pre><code>    from brmspy import brms\n\n    epilepsy = brms.get_brms_data(\"epilepsy\")\n    model = brms.fit(\n        \"count ~ zAge + zBase * Trt + (1|patient)\",\n        data=epilepsy,\n        family=\"poisson\",\n        chains=4\n    )\n\n    # Linear predictor (log scale for Poisson)\n    linpred = brms.posterior_linpred(model)\n    print(linpred.idata.predictions)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.posterior_predict","title":"<code>posterior_predict(model, newdata=None, **kwargs)</code>","text":"<p>Generate posterior predictive samples with observation noise.</p> <p>Calls brms::posterior_predict() to get samples of Y_new|data.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to brms::posterior_predict()</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorPredictResult</code> <p>Object with .idata and .r attributes</p>"},{"location":"api/brms/#brmspy.brms.log_lik","title":"<code>log_lik(model, newdata=None, **kwargs)</code>","text":"<p>Compute log-likelihood values.</p> <p>Returns log p(y|theta) for each observation. Essential for model comparison via LOO-CV and WAIC.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments to brms::log_lik():</p> <ul> <li>ndraws : int - Number of posterior draws</li> <li>combine_chains : bool - Combine chains (default True)</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>LogLikResult</code> <p>Object with .idata (IDLogLik) and .r (R matrix) attributes</p> See Also <p>brms::log_lik : R documentation     https://paulbuerkner.com/brms/reference/log_lik.brmsfit.html arviz.loo : Leave-One-Out Cross-Validation arviz.waic : Widely Applicable Information Criterion</p> <p>Examples:</p> <p>Compute log-likelihood for model comparison:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    \"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    chains=4\n)\n\n# LOO-CV for model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre> <p>Compare multiple models: <pre><code>model1 = brms.fit(\"count ~ zAge + (1|patient)\", data=epilepsy, family=\"poisson\", chains=4)\nmodel2 = brms.fit(\"count ~ zAge + zBase + (1|patient)\", data=epilepsy, family=\"poisson\", chains=4)\n\ncomp = az.compare({'model1': model1.idata, 'model2': model2.idata})\nprint(comp)\n</code></pre></p>"},{"location":"api/brms/#brmspy.brms.make_stancode","title":"<code>make_stancode(formula, data, priors=None, family='poisson', sample_prior='no', formula_args=None)</code>","text":"<p>Generate Stan code using brms::make_stancode().</p> <p>Useful for inspecting the generated Stan model before fitting, understanding the model structure, or using the code with other Stan interfaces.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaResult</code> <p>brms formula specification</p> required <code>data</code> <code>DataFrame</code> <p>Model data</p> required <code>priors</code> <code>list of PriorSpec</code> <p>Prior specifications from prior() function</p> <code>None</code> <code>family</code> <code>str</code> <p>Distribution family (gaussian, poisson, binomial, etc.)</p> <code>\"poisson\"</code> <code>sample_prior</code> <code>str</code> <p>Whether to sample from prior: - \"no\": No prior samples - \"yes\": Include prior samples alongside posterior - \"only\": Sample from prior only (no data)</p> <code>\"no\"</code> <code>formula_args</code> <code>dict</code> <p>Additional arguments passed to formula()</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Complete Stan program code as string</p> See Also <p>brms::make_stancode : R documentation     https://paulbuerkner.com/brms/reference/make_stancode.html fit : Fit model instead of just generating code make_standata : Generate Stan data block</p> <p>Examples:</p> <p>Generate Stan code for simple model:</p> <pre><code>from brmspy import brms\nepilepsy = brms.get_brms_data(\"epilepsy\")\n\nstan_code = brms.make_stancode(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\n\nprint(stan_code[:500])  # Print first 500 characters\n</code></pre> <p>With custom priors:</p> <pre><code>    from brmspy import prior\n\n    stan_code = brms.make_stancode(\n        formula=\"count ~ zAge\",\n        data=epilepsy,\n        priors=[prior(\"normal(0, 1)\", class_=\"b\")],\n        family=\"poisson\"\n    )\n</code></pre> <p>For prior predictive checks (sample_prior=\"only\"):</p> <pre><code>stan_code = brms.make_stancode(\n    formula=\"count ~ zAge\",\n    data=epilepsy,\n    family=\"poisson\",\n    sample_prior=\"only\"\n)\n</code></pre>"},{"location":"api/brms/#brmspy.brms.family","title":"<code>family(fit, **kwargs)</code>","text":"<p>Extract family object from a fitted model.</p> <p>Parameters:</p> Name Type Description Default <code>fit</code> <code>FitResult or ListVector</code> <p>Fitted brms model</p> required"},{"location":"api/brms/#brmspy.brms.brmsfamily","title":"<code>brmsfamily(family, link=None, link_sigma='log', link_shape='log', link_nu='logm1', link_phi='log', link_kappa='log', link_beta='log', link_zi='logit', link_hu='logit', link_zoi='logit', link_coi='logit', link_disc='log', link_bs='log', link_ndt='log', link_bias='logit', link_xi='log1p', link_alpha='identity', link_quantile='logit', threshold='flexible', refcat=None, **kwargs)</code>","text":"<p>Family objects provide a convenient way to specify the details of the models used by many model fitting functions. The family functions presented here are for use with brms only and will not work with other model fitting functions such as glm or glmer. However, the standard family functions as described in family will work with brms.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <p>A character string naming the distribution family of the response variable to be used in the model. Currently, the following families are supported: gaussian, student, binomial, bernoulli, beta-binomial, poisson, negbinomial, geometric, Gamma, skew_normal, lognormal, shifted_lognormal, exgaussian, wiener, inverse.gaussian, exponential, weibull, frechet, Beta, dirichlet, von_mises, asym_laplace, gen_extreme_value, categorical, multinomial, cumulative, cratio, sratio, acat, hurdle_poisson, hurdle_negbinomial, hurdle_gamma, hurdle_lognormal, hurdle_cumulative, zero_inflated_binomial, zero_inflated_beta_binomial, zero_inflated_beta, zero_inflated_negbinomial, zero_inflated_poisson, and zero_one_inflated_beta.</p> required <code>link</code> <code>Optional[str]</code> <p>A specification for the model link function. This can be a name/expression or character string. See the 'Details' section for more information on link functions supported by each family.</p> <code>None</code> <code>link_sigma</code> <code>str</code> <p>Link of auxiliary parameter sigma if being predicted.</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link of auxiliary parameter shape if being predicted.</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link of auxiliary parameter nu if being predicted.</p> <code>'logm1'</code> <code>link_phi</code> <code>str</code> <p>Link of auxiliary parameter phi if being predicted.</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link of auxiliary parameter kappa if being predicted.</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link of auxiliary parameter beta if being predicted.</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link of auxiliary parameter zi if being predicted.</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link of auxiliary parameter hu if being predicted.</p> <code>'logit'</code> <code>link_zoi</code> <code>str</code> <p>Link of auxiliary parameter zoi if being predicted.</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link of auxiliary parameter coi if being predicted.</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link of auxiliary parameter disc if being predicted.</p> <code>'log'</code> <code>link_bs</code> <code>str</code> <p>Link of auxiliary parameter bs if being predicted.</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link of auxiliary parameter ndt if being predicted.</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link of auxiliary parameter bias if being predicted.</p> <code>'logit'</code> <code>link_xi</code> <code>str</code> <p>Link of auxiliary parameter xi if being predicted.</p> <code>'log1p'</code> <code>link_alpha</code> <code>str</code> <p>Link of auxiliary parameter alpha if being predicted.</p> <code>'identity'</code> <code>link_quantile</code> <code>str</code> <p>Link of auxiliary parameter quantile if being predicted.</p> <code>'logit'</code> <code>threshold</code> <code>str</code> <p>A character string indicating the type of thresholds (i.e. intercepts) used in an ordinal model. \"flexible\" provides the standard unstructured thresholds, \"equidistant\" restricts the distance between consecutive thresholds to the same value, and \"sum_to_zero\" ensures the thresholds sum to zero.</p> <code>'flexible'</code> <code>refcat</code> <code>Optional[str]</code> <p>Optional name of the reference response category used in categorical, multinomial, dirichlet and logistic_normal models. If NULL (the default), the first category is used as the reference. If NA, all categories will be predicted, which requires strong priors or carefully specified predictor terms in order to lead to an identified model.</p> <code>None</code> <code>bhaz</code> <p>Currently for experimental purposes only.</p> required"},{"location":"api/install/","title":"Install","text":""},{"location":"api/install/#brmspy.install-functions","title":"Functions","text":""},{"location":"api/install/#brmspy.install.install_prebuilt","title":"<code>install_prebuilt(runtime_version='0.1.0', url=None, bundle=None, install_rtools=False)</code>","text":"<p>Install prebuilt brmspy runtime bundle for fast setup.</p> <p>Downloads and activates a precompiled runtime containing: - R packages (brms, cmdstanr, dependencies) - Compiled CmdStan binary - Complete environment ready for immediate use</p> <p>This reduces setup time from ~30 minutes to ~1 minute by avoiding compilation. Available for specific platform/R version combinations.</p> <p>This function reconfigures the running embedded R session to use an isolated  library environment from downloaded binaries. It does not mix or break the  default library tree already installed in the system.</p> <p>Parameters:</p> Name Type Description Default <code>runtime_version</code> <code>str</code> <p>Runtime schema version (not pip version)</p> <code>\"0.1.0\"</code> <code>url</code> <code>str</code> <p>Custom URL for runtime bundle. If None, uses GitHub releases</p> <code>None</code> <code>bundle</code> <code>str</code> <p>Local path to runtime bundle (.tar.gz or directory)</p> <code>None</code> <code>install_rtools</code> <code>bool</code> <p>Installs RTools (windows only) if they cant be found.  WARNING: Modifies system path and runs the full rtools installer.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if installation succeeded, False otherwise</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If prebuilt binaries not available for this platform</p> Notes <p>Platform Support: Prebuilt binaries are available for: - Linux: x86_64, glibc &gt;= 2.27, g++ &gt;= 9 - macOS: x86_64 and arm64, clang &gt;= 11 - Windows: x86_64 with Rtools</p> <p>R Version: Runtime includes all R packages, so they must match your R installation's major.minor version (e.g., R 4.3.x).</p> <p>System Fingerprint: Runtime is selected based on: - Operating system (linux/macos/windows) - CPU architecture (x86_64/arm64) - R version (major.minor)</p> <p>Example: <code>linux-x86_64-r4.3</code></p> See Also <p>install_brms : Main installation function brmspy.binaries.install_and_activate_runtime : Low-level installer brmspy.binaries.system_fingerprint : Platform detection</p> <p>Examples:</p> <p>Install from GitHub releases:</p> <pre><code>from brmspy.install import install_prebuilt\ninstall_prebuilt()\n</code></pre> <p>Install from local bundle:</p> <pre><code>install_prebuilt(bundle=\"/path/to/runtime.tar.gz\")\n</code></pre> <p>Install from custom URL:</p> <pre><code>    install_prebuilt(url=\"https://example.com/runtime.tar.gz\")\n</code></pre>"},{"location":"api/install/#brmspy.install.install_brms","title":"<code>install_brms(brms_version='latest', repo=None, install_cmdstanr=True, install_rstan=False, cmdstanr_version='latest', rstan_version='latest', use_prebuilt_binaries=False, install_rtools=False)</code>","text":"<p>Install brms R package, optionally cmdstanr and CmdStan compiler, or rstan.</p> <p>Parameters:</p> Name Type Description Default <code>brms_version</code> <code>str</code> <p>brms version: \"latest\", \"2.23.0\", or \"&gt;= 2.20.0\"</p> <code>\"latest\"</code> <code>repo</code> <code>str | None</code> <p>Extra CRAN repository URL</p> <code>None</code> <code>install_cmdstanr</code> <code>bool</code> <p>Whether to install cmdstanr and build CmdStan compiler</p> <code>True</code> <code>install_rstan</code> <code>bool</code> <p>Whether to install rstan (alternative to cmdstanr)</p> <code>False</code> <code>cmdstanr_version</code> <code>str</code> <p>cmdstanr version: \"latest\", \"0.8.1\", or \"&gt;= 0.8.0\"</p> <code>\"latest\"</code> <code>rstan_version</code> <code>str</code> <p>rstan version: \"latest\", \"2.32.6\", or \"&gt;= 2.32.0\"</p> <code>\"latest\"</code> <code>use_prebuilt_binaries</code> <code>bool</code> <p>Uses fully prebuilt binaries for cmdstanr and brms and their dependencies.  Ignores system R libraries and uses the latest brms and cmdstanr available  for your system. Requires R&gt;=4 and might not be compatible with some older systems or missing toolchains. Can reduce setup time by 50x.</p> <code>False</code> <code>install_rtools</code> <code>bool</code> <p>Installs RTools (windows only) if they cant be found.  WARNING: Modifies system path and runs the full rtools installer.  Use with caution!</p> <code>False</code> <p>Examples:</p> <p>Basic installation:</p> <p><pre><code>from brmspy import brms\nbrms.install_brms()\n</code></pre> Install specific version:</p> <pre><code>brms.install_brms(brms_version=\"2.23.0\")\n</code></pre> <p>Use rstan instead of cmdstanr:</p> <pre><code>brms.install_brms(install_cmdstanr=False, install_rstan=True)\n</code></pre> <p>Fast installation with prebuilt binaries: <pre><code>brms.install_brms(use_prebuilt_binaries=True)\n</code></pre></p>"},{"location":"api/install/#brmspy.install.get_brms_version","title":"<code>get_brms_version()</code>","text":"<p>Get installed brms R package version.</p> <p>Returns:</p> Type Description <code>str</code> <p>Version object or None</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If brms is not installed</p> <p>Examples:</p> <pre><code>from brmspy import brms\nversion = brms.get_brms_version()\nprint(f\"brms version: {version}\")\n</code></pre>"},{"location":"api/types/","title":"Types","text":"<p>Result types for brmspy functions.</p>"},{"location":"api/types/#brmspy.types-classes","title":"Classes","text":""},{"location":"api/types/#brmspy.types.PriorSpec","title":"<code>PriorSpec</code>  <code>dataclass</code>","text":"<p>Python representation of a brms prior specification.</p> <p>This dataclass provides a typed interface to brms::prior_string() arguments, allowing Python developers to specify priors with IDE autocomplete and type checking. Use the <code>prior()</code> factory function to create instances.</p> <p>Attributes:</p> Name Type Description <code>prior</code> <code>str</code> <p>Prior distribution as string (e.g., \"normal(0, 1)\", \"exponential(2)\")</p> <code>class_</code> <code>(str, optional)</code> <p>Parameter class: \"b\" (fixed effects), \"sd\" (group SD), \"Intercept\", \"sigma\", \"cor\", etc.</p> <code>coef</code> <code>(str, optional)</code> <p>Specific coefficient name for class-level priors</p> <code>group</code> <code>(str, optional)</code> <p>Grouping variable for hierarchical effects</p> <code>dpar</code> <code>(str, optional)</code> <p>Distributional parameter (e.g., \"sigma\", \"phi\", \"zi\")</p> <code>resp</code> <code>(str, optional)</code> <p>Response variable for multivariate models</p> <code>nlpar</code> <code>(str, optional)</code> <p>Non-linear parameter name</p> <code>lb</code> <code>(float, optional)</code> <p>Lower bound for truncated priors</p> <code>ub</code> <code>(float, optional)</code> <p>Upper bound for truncated priors</p> See Also <p>prior : Factory function to create PriorSpec instances brms::prior_string : R documentation     https://paulbuerkner.com/brms/reference/prior_string.html</p> <p>Examples:</p> <p>Create prior specifications (prefer using <code>prior()</code> function):</p> <pre><code>from brmspy.types import PriorSpec\n\n# Fixed effect prior\np1 = PriorSpec(prior=\"normal(0, 1)\", class_=\"b\")\n\n# Group-level SD prior\np2 = PriorSpec(\n    prior=\"exponential(2)\",\n    class_=\"sd\",\n    group=\"patient\"\n)\n\n# Coefficient-specific prior with bounds\np3 = PriorSpec(\n    prior=\"normal(0, 1)\",\n    class_=\"b\",\n    coef=\"age\",\n    lb=0  # Truncated at zero\n)\n</code></pre>"},{"location":"api/types/#brmspy.types.PriorSpec-functions","title":"Functions","text":""},{"location":"api/types/#brmspy.types.PriorSpec.to_brms_kwargs","title":"<code>to_brms_kwargs()</code>","text":"<p>Convert PriorSpec to keyword arguments for brms::prior_string().</p> <p>Maps Python dataclass fields to R function arguments, handling the <code>class_</code> -&gt; <code>class</code> parameter name conversion.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keyword arguments ready for brms::prior_string()</p> <p>Examples:</p> <pre><code>from brmspy import prior\np = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\nkwargs = p.to_brms_kwargs()\nprint(kwargs)\n# {'prior': 'normal(0, 1)', 'class': 'b', 'coef': 'age'}\n</code></pre>"},{"location":"api/types/#brmspy.types.IDFit","title":"<code>IDFit</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for fitted brms models.</p> <p>Extends arviz.InferenceData with type hints for IDE autocomplete. Guarantees the presence of specific data groups returned by <code>fit()</code>.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Posterior samples of model parameters</p> <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (with observation noise)</p> <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation</p> <code>observed_data</code> <code>Dataset</code> <p>Original observed response data</p> <code>coords</code> <code>dict</code> <p>Coordinate mappings for dimensions</p> <code>dims</code> <code>dict</code> <p>Dimension specifications for variables</p> See Also <p>brmspy.brms.fit : Creates IDFit objects arviz.InferenceData : Base class documentation</p> <p>Examples:</p> <pre><code>from brmspy import brms\nmodel = brms.fit(\"y ~ x\", data=df, chains=4)\n\n# Type checking and autocomplete\nassert isinstance(model.idata, IDFit)\nprint(model.idata.posterior)  # IDE autocomplete works!\n</code></pre>"},{"location":"api/types/#brmspy.types.IDEpred","title":"<code>IDEpred</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_epred results.</p> <p>Contains expected values E[Y|X] without observation noise.</p> <p>Attributes:</p> Name Type Description <code>posterior</code> <code>Dataset</code> <p>Expected value samples (no observation noise)</p> See Also <p>brmspy.brms.posterior_epred : Creates IDEpred objects</p>"},{"location":"api/types/#brmspy.types.IDPredict","title":"<code>IDPredict</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_predict results.</p> <p>Contains posterior predictive samples with observation noise.</p> <p>Attributes:</p> Name Type Description <code>posterior_predictive</code> <code>Dataset</code> <p>Posterior predictive samples (includes observation noise)</p> See Also <p>brmspy.brms.posterior_predict : Creates IDPredict objects</p>"},{"location":"api/types/#brmspy.types.IDLinpred","title":"<code>IDLinpred</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for posterior_linpred results.</p> <p>Contains linear predictor values (before applying link function).</p> <p>Attributes:</p> Name Type Description <code>predictions</code> <code>Dataset</code> <p>Linear predictor samples</p> See Also <p>brmspy.brms.posterior_linpred : Creates IDLinpred objects</p>"},{"location":"api/types/#brmspy.types.IDLogLik","title":"<code>IDLogLik</code>","text":"<p>               Bases: <code>InferenceData</code></p> <p>Typed InferenceData for log_lik results.</p> <p>Contains log-likelihood values for model comparison.</p> <p>Attributes:</p> Name Type Description <code>log_likelihood</code> <code>Dataset</code> <p>Log-likelihood values for each observation</p> See Also <p>brmspy.brms.log_lik : Creates IDLogLik objects arviz.loo : LOO-CV using log-likelihood</p>"},{"location":"api/types/#brmspy.types.RListVectorExtension","title":"<code>RListVectorExtension</code>  <code>dataclass</code>","text":"<p>Generic result container with R objects.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/types/#brmspy.types.GenericResult","title":"<code>GenericResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Generic result container with arviz and R objects.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData object</p> <code>r</code> <code>ListVector</code> <p>R object from brms</p>"},{"location":"api/types/#brmspy.types.FitResult","title":"<code>FitResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from fit() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with posterior, posterior_predictive, log_likelihood, and observed_data groups</p> <code>r</code> <code>ListVector</code> <p>brmsfit R object from brms::brm()</p>"},{"location":"api/types/#brmspy.types.PosteriorEpredResult","title":"<code>PosteriorEpredResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from posterior_epred() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with expected values in 'posterior' group</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_epred()</p>"},{"location":"api/types/#brmspy.types.PosteriorPredictResult","title":"<code>PosteriorPredictResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from posterior_predict() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>InferenceData</code> <p>arviz InferenceData with predictions in 'posterior_predictive' group</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_predict()</p>"},{"location":"api/types/#brmspy.types.LogLikResult","title":"<code>LogLikResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from log_lik() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>IDLogLik</code> <p>arviz InferenceData with log-likelihood values</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::log_lik()</p> See Also <p>brmspy.brms.log_lik : Creates LogLikResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nmodel = brms.fit(\"y ~ x\", data=df, chains=4)\nloglik = brms.log_lik(model)\n\n# Use for model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre>"},{"location":"api/types/#brmspy.types.PosteriorLinpredResult","title":"<code>PosteriorLinpredResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from posterior_linpred() function.</p> <p>Attributes:</p> Name Type Description <code>idata</code> <code>IDLinpred</code> <p>arviz InferenceData with linear predictor values</p> <code>r</code> <code>ListVector</code> <p>R matrix from brms::posterior_linpred()</p> See Also <p>brmspy.brms.posterior_linpred : Creates PosteriorLinpredResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\nmodel = brms.fit(\"count ~ age\", data=df, family=\"poisson\", chains=4)\nlinpred = brms.posterior_linpred(model)\n\n# Linear predictor on log scale (for Poisson)\nprint(linpred.idata.predictions)\n</code></pre>"},{"location":"api/types/#brmspy.types.FormulaResult","title":"<code>FormulaResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p> <p>Result from formula() function.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>ListVector</code> <p>R brmsformula object</p> <code>dict</code> <code>Dict</code> <p>Python dictionary representation of formula</p> See Also <p>brmspy.brms.formula : Creates FormulaResult objects</p> <p>Examples:</p> <pre><code>from brmspy import brms\n\n# Create formula with options\nf = brms.formula(\"y ~ x\", decomp=\"QR\")\n\n# Use in fit()\nmodel = brms.fit(f, data=df, chains=4)\n</code></pre>"},{"location":"api/types/#brmspy.types.LooResult","title":"<code>LooResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RListVectorExtension</code></p>"},{"location":"api/types/#brmspy.types.LooResult-functions","title":"Functions","text":""},{"location":"api/types/#brmspy.types.LooResult.__repr__","title":"<code>__repr__()</code>","text":"<p>Pretty print LOO-CV results.</p>"},{"location":"api/brms_functions/brm/","title":"brm","text":""},{"location":"api/brms_functions/brm/#brmspy.brms_functions.brm-classes","title":"Classes","text":""},{"location":"api/brms_functions/brm/#brmspy.brms_functions.brm-functions","title":"Functions","text":""},{"location":"api/brms_functions/brm/#brmspy.brms_functions.brm.fit","title":"<code>fit(formula, data, priors=None, family='gaussian', sample_prior='no', sample=True, backend='cmdstanr', formula_args=None, **brm_args)</code>","text":"<p>Fit Bayesian regression model using brms.</p> <p>Uses brms with cmdstanr backend for proper parameter naming. Returns FitResult with .idata (arviz.InferenceData) and .r (brmsfit) attributes.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>brms formula: formula string, e.g \"y ~ x + (1|group)\" or FormulaResult from formula()</p> required <code>data</code> <code>dict or DataFrame</code> <p>Model data</p> required <code>priors</code> <code>list</code> <p>Prior specifications: [(\"normal(0,1)\", \"b\"), (\"cauchy(0,2)\", \"sd\")]</p> <code>[]</code> <code>family</code> <code>str</code> <p>Distribution family: \"gaussian\", \"poisson\", \"binomial\", etc.</p> <code>\"gaussian\"</code> <code>sample_prior</code> <code>str</code> <p>Sample from prior: \"no\", \"yes\", \"only\"</p> <code>\"no\"</code> <code>sample</code> <code>bool</code> <p>Whether to sample. If False, returns compiled model with empty=TRUE</p> <code>True</code> <code>backend</code> <code>str</code> <p>Stan backend: \"cmdstanr\" (recommended), \"rstan\"</p> <code>\"cmdstanr\"</code> <code>**brm_args</code> <p>Additional brms::brm() arguments: chains=4, iter=2000, warmup=1000, cores=4, seed=123, thin=1, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Object with .idata (arviz.InferenceData) and .r (brmsfit) attributes</p> See Also <p>brms::brm : R documentation     https://paulbuerkner.com/brms/reference/brm.html posterior_epred : Expected value predictions posterior_predict : Posterior predictive samples formula : Create formula object with options</p> <p>Examples:</p> <p>Basic Poisson regression:</p> <p><pre><code>from brmspy import brms\nimport arviz as az\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    chains=4,\n    iter=2000\n)\n\naz.summary(model.idata)\n</code></pre> With custom priors:</p> <p><pre><code>from brmspy import prior\n\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    priors=[\n        prior(\"normal(0, 0.5)\", class_=\"b\"),\n        prior(\"exponential(2)\", class_=\"sd\", group=\"patient\")\n    ],\n    family=\"poisson\",\n    chains=4\n)\n</code></pre> Survival model with censoring:</p> <p><pre><code>kidney = brms.get_brms_data(\"kidney\")\n\nsurvival_model = brms.fit(\n    formula=\"time | cens(censored) ~ age + sex + disease + (1|patient)\",\n    data=kidney,\n    family=\"weibull\",\n    chains=4,\n    iter=4000,\n    warmup=2000,\n    cores=4,\n    seed=42\n)\n</code></pre> Gaussian model with distributional regression:</p> <pre><code>    # Model both mean and variance\n    model = brms.fit(\n        formula=brms.formula(\n            \"y ~ x\",\n            sigma ~ \"z\"  # Model heteroscedasticity\n        ),\n        data=data,\n        family=\"gaussian\",\n        chains=4\n    )\n</code></pre>"},{"location":"api/brms_functions/diagnostics/","title":"diagnostics","text":""},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics-classes","title":"Classes","text":""},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics-functions","title":"Functions","text":""},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.summary","title":"<code>summary(model, **kwargs)</code>","text":"<p>Generate comprehensive summary statistics for fitted brms model.</p> <p>Returns a <code>SummaryResult</code> dataclass containing model information, parameter estimates, and diagnostic information. The SummaryResult object provides pretty printing via <code>str()</code> or <code>print()</code> and structured access to all components.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from <code>fit()</code></p> required <code>**kwargs</code> <p>Additional arguments passed to brms::summary(), such as: - probs: Quantiles for credible intervals, e.g., <code>probs=(0.025, 0.975)</code> - robust: Use robust estimates (median, MAD), default False</p> <code>{}</code> <p>Returns:</p> Type Description <code>SummaryResult</code> <p>A dataclass containing:</p> <ul> <li>formula (str): Model formula as string</li> <li>data_name (str): Name of the data object used</li> <li>group (str): Grouping structure information</li> <li>nobs (int): Number of observations</li> <li>ngrps (Dict[str, int]): Number of groups per grouping variable</li> <li>autocor (Optional[dict]): Autocorrelation structure if present</li> <li>prior (pd.DataFrame): Prior specifications used</li> <li>algorithm (str): Sampling algorithm (e.g., \"sampling\")</li> <li>sampler (str): Sampler specification (e.g., \"sample(hmc)\")</li> <li>total_ndraws (int): Total number of post-warmup draws</li> <li>chains (float): Number of chains</li> <li>iter (float): Iterations per chain</li> <li>warmup (float): Warmup iterations per chain</li> <li>thin (float): Thinning interval</li> <li>has_rhat (bool): Whether Rhat diagnostics are reported</li> <li>fixed (pd.DataFrame): Population-level (fixed) effects estimates</li> <li>spec_pars (pd.DataFrame): Family-specific parameters (e.g., sigma)</li> <li>cor_pars (pd.DataFrame): Correlation parameters if present</li> <li>random (dict): Group-level (random) effects by grouping variable</li> </ul> See Also <p>brms::summary.brmsfit : R documentation     https://paulbuerkner.com/brms/reference/summary.brmsfit.html</p> <p>Examples:</p> <p>Basic usage with pretty printing:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x\", data=data, chains=4)\nsummary = brmspy.summary(model)\n\n# Pretty print full summary\nprint(summary)\n</code></pre> <p>Access specific components:</p> <pre><code># Get population-level effects as DataFrame\nfixed_effects = summary.fixed\nprint(fixed_effects)\n\n# Get family-specific parameters (e.g., sigma)\nspec_params = summary.spec_pars\nprint(spec_params)\n\n# Access random effects (if present)\nrandom_effects = summary.random\nfor group_name, group_df in random_effects.items():\n    print(f\"Random effects for {group_name}:\")\n    print(group_df)\n\n# Check model metadata\nprint(f\"Formula: {summary.formula}\")\nprint(f\"Total draws: {summary.total_ndraws}\")\nprint(f\"Rhat reported: {summary.has_rhat}\")\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Use 90% credible intervals instead of default 95%\nsummary_90 = brmspy.summary(model, probs=(0.05, 0.95))\nprint(summary_90.fixed)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.fixef","title":"<code>fixef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, **kwargs)</code>","text":"<p>Extract population-level (fixed) effects estimates from a fitted brms model.</p> <p>Returns a pandas DataFrame containing estimates and uncertainty intervals for all population-level parameters (fixed effects). By default, returns summary statistics (mean, standard error, credible intervals). Can also return raw posterior samples when <code>summary=False</code>.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>summary</code> <code>bool</code> <p>If True, return summary statistics (mean/median, SE/MAD, credible intervals). If False, return matrix of posterior samples (iterations \u00d7 parameters).</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics. Only used when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>list of str</code> <p>Specific parameter names to extract. If None, returns all fixed effects. Useful for subsetting when you only need specific coefficients.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::fixef()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>When <code>summary=True</code> (default):     DataFrame with parameters as rows and columns for Estimate, Est.Error,     Q2.5, Q97.5 (or other quantiles specified in <code>probs</code>), and optionally     Rhat and Bulk_ESS/Tail_ESS diagnostics.</p> <p>When <code>summary=False</code>:     DataFrame with posterior samples where rows are iterations and columns     are parameters. Shape is (n_iterations \u00d7 n_parameters).</p> See Also <p>brms::fixef.brmsfit : R documentation     https://paulbuerkner.com/brms/reference/fixef.brmsfit.html summary() : Full model summary with all parameter types</p> <p>Examples:</p> <p>Basic usage with summary statistics:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=data, chains=4)\n\n# Get fixed effects summary\nfixed_effects = brmspy.fixef(model)\nprint(fixed_effects)\n#             Estimate  Est.Error      Q2.5     Q97.5\n# Intercept  10.234567   0.123456  9.992345  10.47689\n# x1          0.456789   0.098765  0.263456   0.65012\n# x2         -0.234567   0.087654 -0.406789  -0.06234\n</code></pre> <p>Get specific parameters only:</p> <pre><code># Extract only specific coefficients\nx1_x2_effects = brmspy.fixef(model, pars=[\"x1\", \"x2\"])\nprint(x1_x2_effects)\n</code></pre> <p>Use robust estimates (median and MAD):</p> <pre><code># Use median and MAD instead of mean and SD\nrobust_effects = brmspy.fixef(model, robust=True)\nprint(robust_effects)\n</code></pre> <p>Custom credible intervals:</p> <pre><code># Get 90% credible intervals\neffects_90 = brmspy.fixef(model, probs=(0.05, 0.95))\nprint(effects_90)\n</code></pre> <p>Get raw posterior samples:</p> <pre><code># Get full posterior samples matrix\nsamples = brmspy.fixef(model, summary=False)\nprint(samples.shape)  # (n_iterations, n_parameters)\n\n# Can then compute custom statistics\nimport numpy as np\ncustom_quantile = np.percentile(samples[\"x1\"], 90)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.ranef","title":"<code>ranef(object, summary=True, robust=False, probs=(0.025, 0.975), pars=None, groups=None, **kwargs)</code>","text":"<p>Extract group-level (random) effects as xarray DataArrays.</p> <p>This is a wrapper around <code>brms::ranef()</code>. For <code>summary=True</code> (default), each grouping factor is returned as a 3D array with dimensions <code>(\"group\", \"stat\", \"coef\")</code>. For <code>summary=False</code>, each factor is returned as <code>(\"draw\", \"group\", \"coef\")</code> with one slice per posterior draw.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model returned by :func:<code>brmspy.brms.fit</code> or an R <code>brmsfit</code> object / summary list.</p> required <code>summary</code> <code>bool</code> <p>If True, return posterior summaries for the group-level effects (means, errors, intervals). If False, return per-draw random effects.</p> <code>True</code> <code>robust</code> <code>bool</code> <p>If True, use robust summaries (median and MAD) instead of mean and SD. Passed through to <code>brms::ranef()</code> when <code>summary=True</code>.</p> <code>False</code> <code>probs</code> <code>tuple of float</code> <p>Central posterior interval probabilities, as in <code>brms::ranef()</code>. Only used when <code>summary=True</code>.</p> <code>(0.025, 0.975)</code> <code>pars</code> <code>str or sequence of str</code> <p>Subset of group-level parameters to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>groups</code> <code>str or sequence of str</code> <p>Subset of grouping factors to include. Passed to <code>brms::ranef()</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments forwarded to <code>brms::ranef()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, DataArray]</code> <p>Mapping from grouping-factor name (e.g. <code>\"patient\"</code>) to a <code>DataArray</code>:</p> <ul> <li><code>summary=True</code>: dims <code>(\"group\", \"stat\", \"coef\")</code>,   with <code>stat</code> typically containing   <code>[\"Estimate\", \"Est.Error\", \"Q2.5\", \"Q97.5\"]</code>.</li> <li><code>summary=False</code>: dims <code>(\"draw\", \"group\", \"coef\")</code>,   where <code>draw</code> indexes posterior samples.</li> </ul> <p>Examples:</p> <p>Compute summary random effects and inspect all coefficients for a single group level:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms import ranef\n\nfit = brms.fit(\"count ~ zAge + zBase * Trt + (1 + zBase + Trt | patient)\",\n               data=data, family=\"poisson\")\n\nre = ranef(fit)  # summary=True by default\npatient_re = re[\"patient\"].sel(group=\"1\", stat=\"Estimate\")\n</code></pre> <p>Extract per-draw random effects for downstream MCMC analysis:</p> <pre><code>re_draws = ranef(fit, summary=False)\npatient_draws = re_draws[\"patient\"]       # dims: (\"draw\", \"group\", \"coef\")\nfirst_draw = patient_draws.sel(draw=0)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.posterior_summary","title":"<code>posterior_summary(object, variable=None, probs=(0.025, 0.975), robust=False, **kwargs)</code>","text":"<p>Extract posterior summary statistics for all or selected model parameters.</p> <p>Provides a DataFrame with estimates, standard errors, and credible intervals for all parameters in a brms model, including fixed effects, random effects, and auxiliary parameters. More comprehensive than <code>fixef()</code> or <code>ranef()</code> as it covers all parameter types.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>variable</code> <code>str or list of str</code> <p>Specific variable name(s) to extract. If None, returns all parameters. Supports regex patterns for flexible selection.</p> <code>None</code> <code>probs</code> <code>tuple of float</code> <p>Quantiles for credible intervals, e.g., (0.025, 0.975) for 95% intervals.</p> <code>(0.025, 0.975)</code> <code>robust</code> <code>bool</code> <p>If True, use median and MAD instead of mean and SD for summary statistics.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments passed to brms::posterior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with parameters as rows and columns for Estimate, Est.Error, and quantiles (e.g., Q2.5, Q97.5). Includes all model parameters: population-level effects, group-level effects, and auxiliary parameters.</p> See Also <p>brms::posterior_summary : R documentation     https://paulbuerkner.com/brms/reference/posterior_summary.brmsfit.html <code>fixef()</code> : Extract only population-level effects <code>ranef()</code> : Extract only group-level effects</p> <p>Examples:</p> <p>Get summary for all parameters:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + (1|group)\", data=data, chains=4)\n\n# Get all parameter summaries\nall_params = brmspy.posterior_summary(model)\nprint(all_params)\n</code></pre> <p>Extract specific parameters:</p> <pre><code># Get summary for specific parameters\nintercept = brmspy.posterior_summary(model, variable=\"b_Intercept\")\nprint(intercept)\n\n# Multiple parameters\nfixed_only = brmspy.posterior_summary(model, variable=[\"b_Intercept\", \"b_x1\"])\nprint(fixed_only)\n</code></pre> <p>Custom credible intervals with robust estimates:</p> <pre><code># 90% intervals with median/MAD\nrobust_summary = brmspy.posterior_summary(\n    model,\n    probs=(0.05, 0.95),\n    robust=True\n)\nprint(robust_summary)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.prior_summary","title":"<code>prior_summary(object, all=True, **kwargs)</code>","text":"<p>Extract prior specifications used in a fitted brms model.</p> <p>Returns a DataFrame containing all prior distributions that were used (either explicitly set or defaults) when fitting the model. Useful for documenting model specifications and understanding which priors were applied.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>all</code> <code>bool</code> <p>If True, return all priors including default priors. If False, return only explicitly set priors.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to brms::prior_summary()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns describing prior specifications: - prior: Prior distribution formula - class: Parameter class (b, sd, Intercept, etc.) - coef: Specific coefficient (if applicable) - group: Grouping factor (if applicable) - resp: Response variable (for multivariate models) - dpar: Distributional parameter (if applicable) - nlpar: Non-linear parameter (if applicable) - lb/ub: Bounds for truncated priors - source: Origin of prior (default, user, etc.)</p> See Also <p>brms::prior_summary : R documentation     https://paulbuerkner.com/brms/reference/prior_summary.brmsfit.html <code>get_prior()</code> : Get prior structure before fitting <code>default_prior()</code> : Get default priors for a model</p> <p>Examples:</p> <p>Get all priors used in a model:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\n    \"y ~ x1 + (1|group)\",\n    data=data,\n    priors=[brmspy.prior(\"normal(0, 1)\", \"b\")],\n    chains=4\n)\n\n# Get all priors (including defaults)\npriors = brmspy.prior_summary(model)\nprint(priors)\n</code></pre> <p>Get only explicitly set priors:</p> <pre><code># Get only user-specified priors\nuser_priors = brmspy.prior_summary(model, all=False)\nprint(user_priors)\n</code></pre> <p>Compare with what would be used before fitting:</p> <pre><code># Before fitting - check default priors\ndefault_priors = brmspy.get_prior(\"y ~ x1\", data=data)\n\n# After fitting - see what was actually used\nused_priors = brmspy.prior_summary(model)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.loo","title":"<code>loo(object, compare=True, resp=None, pointwise=False, moment_match=False, reloo=False, k_threshold=0.7, save_psis=False, moment_match_args=[], reloo_args=[], model_names=None, **kwargs)</code>","text":"<p>Compute efficient leave-one-out cross-validation (LOO-CV) for Bayesian models.</p> <p>Performs approximate LOO-CV using Pareto smoothed importance sampling (PSIS-LOO) from the loo package. Returns a <code>LooResult</code> dataclass with LOO estimates (elpd_loo, p_loo, looic) and diagnostic information including Pareto k diagnostics for identifying problematic observations.</p> <p>BRMS documentation LOO package</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>compare</code> <code>bool</code> <p>If True and multiple models provided, compare models using loo_compare. Only relevant when passing multiple models (not yet supported in this wrapper).</p> <code>True</code> <code>resp</code> <code>str or list of str</code> <p>Response variable names for multivariate models. If specified, compute LOO only for these responses.</p> <code>None</code> <code>pointwise</code> <code>bool</code> <p>If True, compute log-likelihood separately for each observation (slower but uses less memory). Useful when encountering memory issues with large datasets.</p> <code>False</code> <code>moment_match</code> <code>bool</code> <p>If True, apply moment matching for observations with high Pareto k values (k &gt; k_threshold). Requires <code>save_pars=save_pars(all=TRUE)</code> in original fit. Improves accuracy for problematic observations.</p> <code>False</code> <code>reloo</code> <code>bool</code> <p>If True, refit model excluding observations with high Pareto k values (k &gt; k_threshold). Provides exact LOO for problematic cases but is computationally expensive.</p> <code>False</code> <code>k_threshold</code> <code>float</code> <p>Pareto k threshold above which moment matching or refitting is applied. Values &gt; 0.7 indicate unreliable importance sampling.</p> <code>0.7</code> <code>save_psis</code> <code>bool</code> <p>If True, save the PSIS object in the result for further diagnostics.</p> <code>False</code> <code>moment_match_args</code> <code>list</code> <p>Additional arguments passed to loo_moment_match if moment_match=True.</p> <code>[]</code> <code>reloo_args</code> <code>list</code> <p>Additional arguments passed to reloo if reloo=True.</p> <code>[]</code> <code>model_names</code> <code>str or list of str</code> <p>Custom names for models when comparing multiple models.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::loo()</p> <code>{}</code> <p>Returns:</p> Type Description <code>LooResult</code> <p>Dataclass containing:</p> <ul> <li>elpd_loo (float): Expected log pointwise predictive density (higher is better)</li> <li>p_loo (float): Effective number of parameters</li> <li>looic (float): LOO information criterion (lower is better, -2 * elpd_loo)</li> <li>se_elpd_loo (float): Standard error of elpd_loo</li> <li>se_p_loo (float): Standard error of p_loo</li> <li>se_looic (float): Standard error of looic</li> <li>estimates (pd.DataFrame): Full estimates table with all metrics</li> <li>pointwise (pd.DataFrame): Pointwise contributions (if requested)</li> <li>diagnostics (pd.DataFrame): Pareto k diagnostics per observation</li> <li>psis_object (Optional): PSIS object if save_psis=True</li> </ul> See Also <p>brms::loo : R documentation     https://paulbuerkner.com/brms/reference/loo.brmsfit.html loo::loo : LOO package documentation     https://mc-stan.org/loo/reference/loo.html</p> <p>Examples:</p> <p>Basic LOO-CV for model comparison:</p> <pre><code>import brmspy\n\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=data, chains=4)\n\n# Compute LOO-CV\nloo_result = brmspy.loo(model)\n\n# Print formatted summary\nprint(loo_result)\n\n# Access specific metrics\nprint(f\"ELPD LOO: {loo_result.elpd_loo:.2f} \u00b1 {loo_result.se_elpd_loo:.2f}\")\nprint(f\"LOOIC: {loo_result.looic:.2f}\")\nprint(f\"Effective parameters: {loo_result.p_loo:.2f}\")\n</code></pre> <p>Check for problematic observations:</p> <pre><code># Get Pareto k diagnostics\ndiagnostics = loo_result.diagnostics\n\n# Find observations with high Pareto k (unreliable importance sampling)\nproblematic = diagnostics[diagnostics['pareto_k'] &gt; 0.7]\nprint(f\"Found {len(problematic)} problematic observations\")\n</code></pre> <p>Handle problematic observations with moment matching:</p> <pre><code># Requires save_pars=save_pars(all=TRUE) in original fit\nmodel = brmspy.fit(\n    \"y ~ x1 + x2\",\n    data=data,\n    chains=4,\n    save_pars=brmspy.save_pars(all=True)\n)\n\n# Apply moment matching for high Pareto k values\nloo_mm = brmspy.loo(model, moment_match=True, k_threshold=0.7)\nprint(loo_mm)\n</code></pre> <p>Memory-efficient computation for large datasets:</p> <pre><code># Use pointwise computation to reduce memory usage\nloo_pointwise = brmspy.loo(model, pointwise=True)\nprint(loo_pointwise)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.loo_compare","title":"<code>loo_compare(*objects, criterion='loo', model_names=None)</code>","text":"<p>Compare multiple models using approximate LOO cross-validation.</p> <p>This function wraps <code>brms::loo()</code> and <code>loo::loo_compare()</code>:</p> <ol> <li>For each model, call <code>brms::loo()</code> to obtain a <code>loo</code> object.</li> <li>Call <code>loo::loo_compare()</code> on the resulting <code>loo</code> objects.</li> <li>Return the comparison matrix as a :class:<code>pandas.DataFrame</code>.</li> </ol> <p>Currently only the <code>'loo'</code> criterion is supported.</p> <p>Parameters:</p> Name Type Description Default <code>*objects</code> <code>FitResult or ListVector</code> <p>Two or more fitted models to compare. Typically the :class:<code>FitResult</code> objects returned by :func:<code>brmspy.brms.fit</code>.</p> <code>()</code> <code>criterion</code> <code>loo</code> <p>Information criterion to use. For now only <code>'loo'</code> is supported.</p> <code>'loo'</code> <code>model_names</code> <code>sequence of str</code> <p>Optional model names to use as row labels in the comparison table. If omitted, row names are taken from the R side and may be less informative when called via Python.</p> <code>None</code> <p>Returns:</p> Type Description <code>LooCompareResult</code> <p>Object holding:</p> <ul> <li><code>table</code>: a :class:<code>pandas.DataFrame</code> with one row per model   and columns such as <code>elpd_diff</code> and <code>se_diff</code>.</li> <li><code>criterion</code>: the criterion actually used (currently always   <code>'loo'</code>).</li> </ul> <p>Examples:</p> <pre><code>comp = loo_compare(fit1, fit2, model_names=[\"pl-only\", \"pl+subject\"])\nprint(comp)\n</code></pre>"},{"location":"api/brms_functions/diagnostics/#brmspy.brms_functions.diagnostics.validate_newdata","title":"<code>validate_newdata(newdata, object, re_formula=None, allow_new_levels=False, newdata2=None, resp=None, check_response=True, incl_autocor=True, group_vars=None, req_vars=None, **kwargs)</code>","text":"<p>Validate new data for predictions from a fitted brms model.</p> <p>Ensures that new data contains all required variables and has the correct structure for making predictions. Checks variable types, factor levels, grouping variables, and autocorrelation structures. This function is primarily used internally by prediction methods but can be called directly for debugging or validation purposes.</p> <p>BRMS documentation</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>DataFrame</code> <p>DataFrame containing new data to be validated against the model. Must include all predictor variables used in the model formula.</p> required <code>object</code> <code>FitResult or ListVector</code> <p>Fitted model from <code>fit()</code> or R brmsfit object</p> required <code>re_formula</code> <code>str</code> <p>Formula string specifying group-level effects to include in validation. If None (default), include all group-level effects. If NA, include no group-level effects.</p> <code>None</code> <code>allow_new_levels</code> <code>bool</code> <p>Whether to allow new levels of grouping variables not present in the original training data. If False, raises an error for new levels.</p> <code>False</code> <code>newdata2</code> <code>DataFrame</code> <p>Additional data that cannot be passed via <code>newdata</code>, such as objects used in autocorrelation structures or stanvars.</p> <code>None</code> <code>resp</code> <code>str or list of str</code> <p>Names of response variables to validate. If specified, validation is performed only for the specified responses (relevant for multivariate models).</p> <code>None</code> <code>check_response</code> <code>bool</code> <p>Whether to check if response variables are present in newdata. Set to False when making predictions where response is not needed.</p> <code>True</code> <code>incl_autocor</code> <code>bool</code> <p>Whether to include autocorrelation structures originally specified in the model. If True, validates autocorrelation-related variables.</p> <code>True</code> <code>group_vars</code> <code>list of str</code> <p>Names of specific grouping variables to validate. If None (default), validates all grouping variables present in the model.</p> <code>None</code> <code>req_vars</code> <code>list of str</code> <p>Names of specific variables required in newdata. If None (default), all variables from the original training data are required (unless excluded by other parameters).</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to brms::validate_newdata()</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Validated DataFrame based on newdata, potentially with added or modified columns to ensure compatibility with the model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If newdata is missing required variables</p> <code>ValueError</code> <p>If factor levels in newdata don't match those in training data (when allow_new_levels=False)</p> <code>ValueError</code> <p>If grouping variables have invalid structure</p> See Also <p>brms::validate_newdata : R documentation     https://paulbuerkner.com/brms/reference/validate_newdata.html <code>posterior_predict()</code> : Uses validate_newdata internally <code>posterior_epred()</code> : Uses validate_newdata internally</p> <p>Examples:</p> <p>Basic validation for prediction data:</p> <pre><code>import brmspy\nimport pandas as pd\n\n# Fit model\nmodel = brmspy.fit(\"y ~ x1 + x2\", data=train_data, chains=4)\n\n# Prepare new data\nnew_data = pd.DataFrame({\n    'x1': [1.0, 2.0, 3.0],\n    'x2': [0.5, 1.0, 1.5]\n})\n\n# Validate before prediction\nvalidated_data = brmspy.validate_newdata(new_data, model)\nprint(validated_data)\n</code></pre> <p>Validate with group-level effects:</p> <pre><code># Model with random effects\nmodel = brmspy.fit(\"y ~ x + (1|group)\", data=train_data, chains=4)\n\n# New data with grouping variable\nnew_data = pd.DataFrame({\n    'x': [1.0, 2.0],\n    'group': ['A', 'B']  # Must match training data groups\n})\n\n# Validate - will error if groups A or B weren't in training\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    allow_new_levels=False\n)\n</code></pre> <p>Allow new levels for population-level predictions:</p> <pre><code># Allow new group levels (makes population-level predictions only)\nnew_data_with_new_groups = pd.DataFrame({\n    'x': [3.0, 4.0],\n    'group': ['C', 'D']  # New groups not in training\n})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data_with_new_groups,\n    model,\n    allow_new_levels=True\n)\n</code></pre> <p>Skip response variable checking:</p> <pre><code># When making predictions, response not needed\nnew_data = pd.DataFrame({'x1': [1.0, 2.0]})\n\nvalidated_data = brmspy.validate_newdata(\n    new_data,\n    model,\n    check_response=False\n)\n</code></pre>"},{"location":"api/brms_functions/families/","title":"families","text":"<p>Reference: https://paulbuerkner.com/brms/reference/brmsfamily.html</p> <p>family()</p>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families-classes","title":"Classes","text":""},{"location":"api/brms_functions/families/#brmspy.brms_functions.families-functions","title":"Functions","text":""},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.brmsfamily","title":"<code>brmsfamily(family, link=None, link_sigma='log', link_shape='log', link_nu='logm1', link_phi='log', link_kappa='log', link_beta='log', link_zi='logit', link_hu='logit', link_zoi='logit', link_coi='logit', link_disc='log', link_bs='log', link_ndt='log', link_bias='logit', link_xi='log1p', link_alpha='identity', link_quantile='logit', threshold='flexible', refcat=None, **kwargs)</code>","text":"<p>Family objects provide a convenient way to specify the details of the models used by many model fitting functions. The family functions presented here are for use with brms only and will not work with other model fitting functions such as glm or glmer. However, the standard family functions as described in family will work with brms.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <p>A character string naming the distribution family of the response variable to be used in the model. Currently, the following families are supported: gaussian, student, binomial, bernoulli, beta-binomial, poisson, negbinomial, geometric, Gamma, skew_normal, lognormal, shifted_lognormal, exgaussian, wiener, inverse.gaussian, exponential, weibull, frechet, Beta, dirichlet, von_mises, asym_laplace, gen_extreme_value, categorical, multinomial, cumulative, cratio, sratio, acat, hurdle_poisson, hurdle_negbinomial, hurdle_gamma, hurdle_lognormal, hurdle_cumulative, zero_inflated_binomial, zero_inflated_beta_binomial, zero_inflated_beta, zero_inflated_negbinomial, zero_inflated_poisson, and zero_one_inflated_beta.</p> required <code>link</code> <code>Optional[str]</code> <p>A specification for the model link function. This can be a name/expression or character string. See the 'Details' section for more information on link functions supported by each family.</p> <code>None</code> <code>link_sigma</code> <code>str</code> <p>Link of auxiliary parameter sigma if being predicted.</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link of auxiliary parameter shape if being predicted.</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link of auxiliary parameter nu if being predicted.</p> <code>'logm1'</code> <code>link_phi</code> <code>str</code> <p>Link of auxiliary parameter phi if being predicted.</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link of auxiliary parameter kappa if being predicted.</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link of auxiliary parameter beta if being predicted.</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link of auxiliary parameter zi if being predicted.</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link of auxiliary parameter hu if being predicted.</p> <code>'logit'</code> <code>link_zoi</code> <code>str</code> <p>Link of auxiliary parameter zoi if being predicted.</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link of auxiliary parameter coi if being predicted.</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link of auxiliary parameter disc if being predicted.</p> <code>'log'</code> <code>link_bs</code> <code>str</code> <p>Link of auxiliary parameter bs if being predicted.</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link of auxiliary parameter ndt if being predicted.</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link of auxiliary parameter bias if being predicted.</p> <code>'logit'</code> <code>link_xi</code> <code>str</code> <p>Link of auxiliary parameter xi if being predicted.</p> <code>'log1p'</code> <code>link_alpha</code> <code>str</code> <p>Link of auxiliary parameter alpha if being predicted.</p> <code>'identity'</code> <code>link_quantile</code> <code>str</code> <p>Link of auxiliary parameter quantile if being predicted.</p> <code>'logit'</code> <code>threshold</code> <code>str</code> <p>A character string indicating the type of thresholds (i.e. intercepts) used in an ordinal model. \"flexible\" provides the standard unstructured thresholds, \"equidistant\" restricts the distance between consecutive thresholds to the same value, and \"sum_to_zero\" ensures the thresholds sum to zero.</p> <code>'flexible'</code> <code>refcat</code> <code>Optional[str]</code> <p>Optional name of the reference response category used in categorical, multinomial, dirichlet and logistic_normal models. If NULL (the default), the first category is used as the reference. If NA, all categories will be predicted, which requires strong priors or carefully specified predictor terms in order to lead to an identified model.</p> <code>None</code> <code>bhaz</code> <p>Currently for experimental purposes only.</p> required"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.family","title":"<code>family(fit, **kwargs)</code>","text":"<p>Extract family object from a fitted model.</p> <p>Parameters:</p> Name Type Description Default <code>fit</code> <code>FitResult or ListVector</code> <p>Fitted brms model</p> required"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.student","title":"<code>student(link='identity', link_sigma='log', link_nu='logm1', **kwargs)</code>","text":"<p>Student's t distribution for robust regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for degrees of freedom parameter</p> <code>'logm1'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.bernoulli","title":"<code>bernoulli(link='logit', **kwargs)</code>","text":"<p>Bernoulli distribution for binary 0/1 outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.beta_binomial","title":"<code>beta_binomial(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta-binomial distribution for overdispersed binomial data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.negbinomial","title":"<code>negbinomial(link='log', link_shape='log', **kwargs)</code>","text":"<p>Negative binomial distribution for overdispersed count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.geometric","title":"<code>geometric(link='log', **kwargs)</code>","text":"<p>Geometric distribution for count data (negative binomial with shape=1).</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.lognormal","title":"<code>lognormal(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Lognormal distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean on log scale</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.shifted_lognormal","title":"<code>shifted_lognormal(link='identity', link_sigma='log', link_ndt='log', **kwargs)</code>","text":"<p>Shifted lognormal distribution with non-decision time parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.skew_normal","title":"<code>skew_normal(link='identity', link_sigma='log', link_alpha='identity', **kwargs)</code>","text":"<p>Skew normal distribution for asymmetric continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_alpha</code> <code>str</code> <p>Link function for skewness parameter</p> <code>'identity'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.exponential","title":"<code>exponential(link='log', **kwargs)</code>","text":"<p>Exponential distribution for time-to-event data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.weibull","title":"<code>weibull(link='log', link_shape='log', **kwargs)</code>","text":"<p>Weibull distribution for survival and reliability analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.frechet","title":"<code>frechet(link='log', link_nu='logm1', **kwargs)</code>","text":"<p>Frechet distribution for extreme value analysis.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_nu</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'logm1'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.gen_extreme_value","title":"<code>gen_extreme_value(link='identity', link_sigma='log', link_xi='log1p', **kwargs)</code>","text":"<p>Generalized extreme value distribution for extreme events.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location parameter</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the scale parameter</p> <code>'log'</code> <code>link_xi</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log1p'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.exgaussian","title":"<code>exgaussian(link='identity', link_sigma='log', link_beta='log', **kwargs)</code>","text":"<p>Ex-Gaussian distribution for reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for Gaussian SD parameter</p> <code>'log'</code> <code>link_beta</code> <code>str</code> <p>Link function for exponential rate parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.wiener","title":"<code>wiener(link='identity', link_bs='log', link_ndt='log', link_bias='logit', **kwargs)</code>","text":"<p>Wiener diffusion model for two-choice reaction time data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for drift rate</p> <code>'identity'</code> <code>link_bs</code> <code>str</code> <p>Link function for boundary separation</p> <code>'log'</code> <code>link_ndt</code> <code>str</code> <p>Link function for non-decision time</p> <code>'log'</code> <code>link_bias</code> <code>str</code> <p>Link function for initial bias</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.Beta","title":"<code>Beta(link='logit', link_phi='log', **kwargs)</code>","text":"<p>Beta distribution for data between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.xbeta","title":"<code>xbeta(link='logit', link_phi='log', link_kappa='log', **kwargs)</code>","text":"<p>Extended beta distribution with additional shape parameter.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_kappa</code> <code>str</code> <p>Link function for kappa shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.dirichlet","title":"<code>dirichlet(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for the precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.logistic_normal","title":"<code>logistic_normal(link='identity', link_sigma='log', refcat=None, **kwargs)</code>","text":"<p>Logistic-normal distribution for compositional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.von_mises","title":"<code>von_mises(link='tan_half', link_kappa='log', **kwargs)</code>","text":"<p>Von Mises distribution for circular/directional data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean direction</p> <code>'tan_half'</code> <code>link_kappa</code> <code>str</code> <p>Link function for concentration parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.asym_laplace","title":"<code>asym_laplace(link='identity', link_sigma='log', link_quantile='logit', **kwargs)</code>","text":"<p>Asymmetric Laplace distribution for quantile regression.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the location</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_quantile</code> <code>str</code> <p>Link function for the quantile parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.cox","title":"<code>cox(link='log', **kwargs)</code>","text":"<p>Cox proportional hazards model for survival data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the hazard rate</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.hurdle_poisson","title":"<code>hurdle_poisson(link='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Poisson distribution for zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.hurdle_negbinomial","title":"<code>hurdle_negbinomial(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle negative binomial for overdispersed zero-inflated count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.hurdle_gamma","title":"<code>hurdle_gamma(link='log', link_shape='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle Gamma distribution for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.hurdle_lognormal","title":"<code>hurdle_lognormal(link='identity', link_sigma='log', link_hu='logit', **kwargs)</code>","text":"<p>Hurdle lognormal for zero-inflated positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for sigma parameter</p> <code>'log'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.hurdle_cumulative","title":"<code>hurdle_cumulative(link='logit', link_hu='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Hurdle cumulative for zero-inflated ordinal data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the ordinal response</p> <code>'logit'</code> <code>link_hu</code> <code>str</code> <p>Link function for hurdle parameter</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.zero_inflated_beta","title":"<code>zero_inflated_beta(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta for data between 0 and 1 with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.zero_one_inflated_beta","title":"<code>zero_one_inflated_beta(link='logit', link_phi='log', link_zoi='logit', link_coi='logit', **kwargs)</code>","text":"<p>Zero-one-inflated beta for data between 0 and 1 with excess zeros and ones.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zoi</code> <code>str</code> <p>Link function for zero-or-one inflation parameter</p> <code>'logit'</code> <code>link_coi</code> <code>str</code> <p>Link function for conditional one inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.zero_inflated_poisson","title":"<code>zero_inflated_poisson(link='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated Poisson for count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.zero_inflated_negbinomial","title":"<code>zero_inflated_negbinomial(link='log', link_shape='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated negative binomial for overdispersed count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for shape parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.zero_inflated_binomial","title":"<code>zero_inflated_binomial(link='logit', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated binomial for binary count data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.zero_inflated_beta_binomial","title":"<code>zero_inflated_beta_binomial(link='logit', link_phi='log', link_zi='logit', **kwargs)</code>","text":"<p>Zero-inflated beta-binomial for overdispersed binomial data with excess zeros.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for probability parameter</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>link_zi</code> <code>str</code> <p>Link function for zero-inflation parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.categorical","title":"<code>categorical(link='logit', refcat=None, **kwargs)</code>","text":"<p>Categorical distribution for unordered multi-category outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.multinomial","title":"<code>multinomial(link='logit', refcat=None, **kwargs)</code>","text":"<p>Multinomial distribution for count data across multiple categories.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.dirichlet_multinomial","title":"<code>dirichlet_multinomial(link='logit', link_phi='log', refcat=None, **kwargs)</code>","text":"<p>Dirichlet-multinomial for overdispersed categorical count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for category probabilities</p> <code>'logit'</code> <code>link_phi</code> <code>str</code> <p>Link function for precision parameter</p> <code>'log'</code> <code>refcat</code> <code>str</code> <p>Reference category</p> <code>None</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.cumulative","title":"<code>cumulative(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Cumulative (proportional odds) model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for cumulative probabilities</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.sratio","title":"<code>sratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Sequential (stopping) ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for sequential ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.cratio","title":"<code>cratio(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Continuation ratio model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for continuation ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.acat","title":"<code>acat(link='logit', link_disc='log', threshold='flexible', **kwargs)</code>","text":"<p>Adjacent category model for ordinal outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for adjacent category ratios</p> <code>'logit'</code> <code>link_disc</code> <code>str</code> <p>Link function for discrimination parameter</p> <code>'log'</code> <code>threshold</code> <code>str</code> <p>Type of threshold structure</p> <code>'flexible'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.gaussian","title":"<code>gaussian(link='identity', link_sigma='log', **kwargs)</code>","text":"<p>Gaussian (normal) distribution for continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'identity'</code> <code>link_sigma</code> <code>str</code> <p>Link function for the standard deviation</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.poisson","title":"<code>poisson(link='log', **kwargs)</code>","text":"<p>Poisson distribution for count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the rate parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.binomial","title":"<code>binomial(link='logit', **kwargs)</code>","text":"<p>Binomial distribution for binary count data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the probability parameter</p> <code>'logit'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.Gamma","title":"<code>Gamma(link='log', link_shape='log', **kwargs)</code>","text":"<p>Gamma distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'log'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/families/#brmspy.brms_functions.families.inverse_gaussian","title":"<code>inverse_gaussian(link='1/mu^2', link_shape='log', **kwargs)</code>","text":"<p>Inverse Gaussian distribution for positive continuous data.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Link function for the mean</p> <code>'1/mu^2'</code> <code>link_shape</code> <code>str</code> <p>Link function for the shape parameter</p> <code>'log'</code>"},{"location":"api/brms_functions/formula/","title":"formula","text":""},{"location":"api/brms_functions/formula/#brmspy.brms_functions.formula-classes","title":"Classes","text":""},{"location":"api/brms_functions/formula/#brmspy.brms_functions.formula-functions","title":"Functions","text":""},{"location":"api/brms_functions/formula/#brmspy.brms_functions.formula.formula","title":"<code>formula(formula, **formula_args)</code>","text":"<p>Set up a model formula for brms package.</p> <p>Allows defining (potentially non-linear) additive multilevel models for all parameters of the assumed response distribution.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>brms formula specification, e.g., \"y ~ x + (1|group)\"</p> required <code>**formula_args</code> <code>dict</code> <p>Additional brms::brmsformula() arguments:</p> <ul> <li>decomp : str     Decomposition method (e.g., \"QR\" for QR decomposition)</li> <li>center : bool     Whether to center predictors (default True)</li> <li>sparse : bool     Use sparse matrix representation</li> <li>nl : bool     Whether formula is non-linear</li> <li>loop : bool     Use loop-based Stan code</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>FormulaResult</code> <p>Object with .r (R brmsformula object) and .dict (Python dict) attributes</p> See Also <p>brms::brmsformula : R documentation     https://paulbuerkner.com/brms/reference/brmsformula.html fit : Fit model using formula</p> <p>Examples:</p> <p>Basic formula:</p> <pre><code>    from brmspy import brms\n    f = brms.formula(\"y ~ x1 + x2 + (1|group)\")\n</code></pre> <p>With QR decomposition for numerical stability:</p> <pre><code>f = brms.formula(\n    \"reaction ~ days + (days|subject)\",\n    decomp=\"QR\"\n)\n</code></pre> <p>Multivariate formula: <pre><code>    f = brms.formula(\n        \"mvbind(y1, y2) ~ x1 + x2\",\n        center=True\n    )\n</code></pre></p>"},{"location":"api/brms_functions/generic/","title":"generic","text":""},{"location":"api/brms_functions/generic/#brmspy.brms_functions.generic-functions","title":"Functions","text":""},{"location":"api/brms_functions/generic/#brmspy.brms_functions.generic.sanitised_name","title":"<code>sanitised_name(function)</code>","text":"<p>Sanitize a function name for safe R execution.</p> <p>Converts Python-style function names to valid R identifiers by: - Replacing invalid characters with underscores - Ensuring the name doesn't start with a number - Preserving namespace separators (::)</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Function name to sanitize</p> required <p>Returns:</p> Type Description <code>str</code> <p>Sanitized function name safe for R execution</p> <p>Examples:</p> <pre><code>from brmspy.brms_functions.generic import sanitised_name\n\n# Basic sanitization\nprint(sanitised_name(\"my-function\"))  # \"my_function\"\nprint(sanitised_name(\"123func\"))       # \"_123func\"\n\n# Preserves namespace\nprint(sanitised_name(\"brms::loo\"))     # \"brms::loo\"\n</code></pre>"},{"location":"api/brms_functions/generic/#brmspy.brms_functions.generic.call","title":"<code>call(function, *args, **kwargs)</code>","text":"<p>Call any brms or R function by name with automatic type conversion.</p> <p>Generic wrapper for calling brms functions that don't have dedicated Python wrappers. Automatically converts Python arguments to R objects and R results back to Python. Tries <code>brms::function_name</code> first, then falls back to base R.</p> <p>This function is useful for: - Accessing newer brms functions not yet wrapped in brmspy - Calling brms utility functions without writing custom wrappers - Quick exploration of brms functionality from Python</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Name of the R function to call. Will be prefixed with 'brms::' if possible. Can also include namespace (e.g., \"stats::predict\").</p> required <code>*args</code> <p>Positional arguments passed to the R function. Automatically converted from Python to R types (FitResult \u2192 brmsfit, DataFrame \u2192 data.frame, etc.).</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments passed to the R function. Python parameter names are automatically converted to R conventions.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Result from R function, automatically converted to appropriate Python type (R data.frame \u2192 pandas DataFrame, R vector \u2192 numpy array, etc.).</p> See Also <p><code>py_to_r</code> : Python to R type conversion <code>r_to_py</code> : R to Python type conversion</p> <p>Examples:</p> <p>Call brms functions not yet wrapped:</p> <pre><code>from brmspy import brms\nfrom brmspy.brms_functions.generic import call\n\nmodel = brms.fit(\"y ~ x\", data=data, chains=4)\n\n# Call brms::neff_ratio (not yet wrapped)\nneff = call(\"neff_ratio\", model)\nprint(neff)\n\n# Call brms::rhat (not yet wrapped)\nrhat = call(\"rhat\", model)\nprint(rhat)\n</code></pre> <p>Call with keyword arguments:</p> <pre><code># Call brms::hypothesis for testing hypotheses\nhypothesis_result = call(\n    \"hypothesis\",\n    model,\n    hypothesis=\"b_x1 &gt; 0\",\n    alpha=0.05\n)\nprint(hypothesis_result)\n</code></pre> <p>Access functions from other R packages:</p> <pre><code># Call functions with namespace\nresult = call(\"stats::AIC\", model)\nprint(result)\n</code></pre>"},{"location":"api/brms_functions/io/","title":"io","text":""},{"location":"api/brms_functions/io/#brmspy.brms_functions.io-classes","title":"Classes","text":""},{"location":"api/brms_functions/io/#brmspy.brms_functions.io-functions","title":"Functions","text":""},{"location":"api/brms_functions/io/#brmspy.brms_functions.io.get_brms_data","title":"<code>get_brms_data(dataset_name)</code>","text":"<p>Load example dataset from brms package.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>Dataset name. Available datasets include: - 'epilepsy': Epileptic seizure counts - 'kidney': Kidney infection data with censoring - 'inhaler': Inhaler usage study - 'btdata': British Telecom share price data - And many more from brms package</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataset as pandas DataFrame with column names preserved</p> See Also <p>brms::brmsdata : R documentation for available datasets     https://paulbuerkner.com/brms/reference/index.html#data</p> <p>Examples:</p> <p>Load epilepsy dataset:</p> <pre><code>from brmspy import brms\nepilepsy = brms.get_brms_data(\"epilepsy\")\nprint(epilepsy.head())\nprint(epilepsy.columns)\n</code></pre> <p>Load kidney dataset with censoring:</p> <pre><code>kidney = brms.get_brms_data(\"kidney\")\nprint(f\"Shape: {kidney.shape}\")\nprint(f\"Censored observations: {kidney['censored'].sum()}\")\n</code></pre>"},{"location":"api/brms_functions/io/#brmspy.brms_functions.io.save_rds","title":"<code>save_rds(object, file, **kwargs)</code>","text":"<p>Save brmsfit object or R object to RDS file.</p> <p>Saves fitted brms models or other R objects to disk using R's saveRDS() function. This allows persisting models for later use, sharing fitted models, or creating model checkpoints during long computations.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>FitResult or ListVector</code> <p>Object to save. Can be: - FitResult from fit() - saves the underlying brmsfit R object - Any R ListVector object</p> required <code>file</code> <code>str</code> <p>File path where object will be saved. Typically uses .rds extension but not required</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to R's saveRDS():</p> <ul> <li>compress : bool or str - Compression method:     True (default), False, \"gzip\", \"bzip2\", \"xz\"</li> <li>version : int - RDS format version (2 or 3)</li> <li>ascii : bool - Use ASCII representation (default False)</li> <li>refhook : function - Reference hook for serialization (NOT tested)</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> See Also <p>read_rds_fit : Load saved brmsfit as FitResult read_rds_raw : Load saved object as raw R ListVector fit : Fit models that can be saved</p> <p>Examples:</p> <p>Save a fitted model:</p> <pre><code>from brmspy import brms\n\n# Fit model\nmodel = brms.fit(\n    formula=\"y ~ x + (1|group)\",\n    data=data,\n    family=\"gaussian\",\n    chains=4\n)\n\n# Save to file\nbrms.save_rds(model, \"my_model.rds\")\n</code></pre> <p>Save with compression options:</p> <pre><code># High compression for storage\nbrms.save_rds(model, \"model.rds\", compress=\"xz\")\n\n# No compression for faster saving\nbrms.save_rds(model, \"model.rds\", compress=False)\n</code></pre> <p>Save and later reload:</p> <pre><code># Save model\nbrms.save_rds(model, \"model.rds\")\n\n# Later session: reload model\nloaded_model = brms.read_rds_fit(\"model.rds\")\n\n# Use loaded model for predictions\npredictions = brms.posterior_predict(loaded_model, newdata=new_data)\n</code></pre>"},{"location":"api/brms_functions/io/#brmspy.brms_functions.io.read_rds_raw","title":"<code>read_rds_raw(file, **kwargs)</code>","text":"<p>Load R object from RDS file as raw ListVector.</p> <p>Reads an RDS file and returns the raw R object without any Python conversion or processing. Useful when you need direct access to the R object structure or want to inspect saved objects before full conversion.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to RDS file to load</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to R's readRDS():</p> <ul> <li>refhook : function - Reference hook for deserialization</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>ListVector</code> <p>Raw R ListVector object from the RDS file</p> See Also <p>read_rds_fit : Load as FitResult with arviz InferenceData save_rds : Save R objects to RDS files</p> <p>Examples:</p> <p>Load raw R object:</p> <pre><code>from brmspy import brms\n\n# Load raw brmsfit object\nraw_model = brms.read_rds_raw(\"model.rds\")\n\n# Access R object directly (for advanced users)\nprint(type(raw_model))  # rpy2.robjects.vectors.ListVector\n</code></pre> <p>Inspect object structure before conversion:</p> <pre><code># Load raw to check what's in the file\nraw_obj = brms.read_rds_raw(\"unknown_object.rds\")\n\n# Inspect R object attributes\nprint(raw_obj.names)\n\n# Then decide how to process it\nif \"fit\" in raw_obj.names:\n    # It's a brmsfit, convert properly\n    full_model = brms.read_rds_fit(\"unknown_object.rds\")\n</code></pre>"},{"location":"api/brms_functions/io/#brmspy.brms_functions.io.read_rds_fit","title":"<code>read_rds_fit(file, **kwargs)</code>","text":"<p>Load saved brmsfit object as FitResult with arviz InferenceData.</p> <p>Reads a brmsfit object from an RDS file and converts it to a FitResult with both arviz InferenceData (.idata) and the raw R object (.r). This is the recommended way to load saved brms models for analysis and predictions in Python.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to RDS file containing saved brmsfit object</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to R's readRDS():</p> <ul> <li>refhook : function - Reference hook for deserialization</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Object with two attributes: - .idata : arviz.InferenceData with posterior samples and diagnostics - .r : R brmsfit object for use with brms functions</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If file doesn't exist or doesn't contain a valid brmsfit object</p> See Also <p>save_rds : Save brmsfit objects to RDS files read_rds_raw : Load as raw R object without conversion fit : Create brmsfit objects to save</p> <p>Examples:</p> <p>Basic loading and analysis:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\n# Load previously saved model\nmodel = brms.read_rds_fit(\"my_model.rds\")\n\n# Analyze with arviz\naz.summary(model.idata)\naz.plot_trace(model.idata)\n\n# Check diagnostics\nprint(az.rhat(model.idata))\n</code></pre> <p>Load and make predictions:</p> <pre><code>import pandas as pd\n\n# Load saved model\nmodel = brms.read_rds_fit(\"trained_model.rds\")\n\n# Create new data for predictions\nnewdata = pd.DataFrame({\n    'x': [1.0, 2.0, 3.0],\n    'group': ['A', 'B', 'A']\n})\n\n# Generate predictions\npredictions = brms.posterior_predict(model, newdata=newdata)\nprint(predictions.idata.posterior_predictive)\n</code></pre> <p>Load model for comparison:</p> <pre><code># Load multiple saved models\nmodel1 = brms.read_rds_fit(\"model1.rds\")\nmodel2 = brms.read_rds_fit(\"model2.rds\")\n\n# Compare with arviz\ncomparison = az.compare({\n    'model1': model1.idata,\n    'model2': model2.idata\n})\nprint(comparison)\n</code></pre> <p>Resume analysis from checkpoint:</p> <pre><code># Load model from checkpoint during long computation\ntry:\n    model = brms.read_rds_fit(\"checkpoint.rds\")\n    print(\"Loaded from checkpoint\")\nexcept:\n    # Checkpoint doesn't exist, fit from scratch\n    model = brms.fit(formula=\"y ~ x\", data=data, chains=4)\n    brms.save_rds(model, \"checkpoint.rds\")\n\n# Continue analysis\nsummary = brms.summary(model)\n</code></pre>"},{"location":"api/brms_functions/prediction/","title":"prediction","text":""},{"location":"api/brms_functions/prediction/#brmspy.brms_functions.prediction-classes","title":"Classes","text":""},{"location":"api/brms_functions/prediction/#brmspy.brms_functions.prediction-functions","title":"Functions","text":""},{"location":"api/brms_functions/prediction/#brmspy.brms_functions.prediction.posterior_epred","title":"<code>posterior_epred(model, newdata, **kwargs)</code>","text":"<p>Compute expected value of posterior predictive distribution.</p> <p>Calls brms::posterior_epred() to get E[Y|data] without observation noise.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions</p> required <code>**kwargs</code> <p>Additional arguments to brms::posterior_epred()</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorEpredResult</code> <p>Object with .idata and .r attributes</p>"},{"location":"api/brms_functions/prediction/#brmspy.brms_functions.prediction.posterior_predict","title":"<code>posterior_predict(model, newdata=None, **kwargs)</code>","text":"<p>Generate posterior predictive samples with observation noise.</p> <p>Calls brms::posterior_predict() to get samples of Y_new|data.</p> <p>BRMS documentation and parameters</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to brms::posterior_predict()</p> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorPredictResult</code> <p>Object with .idata and .r attributes</p>"},{"location":"api/brms_functions/prediction/#brmspy.brms_functions.prediction.posterior_linpred","title":"<code>posterior_linpred(model, newdata=None, **kwargs)</code>","text":"<p>Compute linear predictor of the model.</p> <p>Returns samples of the linear predictor (before applying the link function). Useful for understanding the model's predictions on the linear scale.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments to brms::posterior_linpred():</p> <ul> <li>transform : bool - Apply inverse link function (default False)</li> <li>ndraws : int - Number of posterior draws</li> <li>summary : bool - Return summary statistics</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>PosteriorLinpredResult</code> <p>Object with .idata (IDLinpred) and .r (R matrix) attributes</p> See Also <p>brms::posterior_linpred : R documentation     https://paulbuerkner.com/brms/reference/posterior_linpred.brmsfit.html posterior_epred : Expected values on response scale</p> <p>Examples:</p> <pre><code>    from brmspy import brms\n\n    epilepsy = brms.get_brms_data(\"epilepsy\")\n    model = brms.fit(\n        \"count ~ zAge + zBase * Trt + (1|patient)\",\n        data=epilepsy,\n        family=\"poisson\",\n        chains=4\n    )\n\n    # Linear predictor (log scale for Poisson)\n    linpred = brms.posterior_linpred(model)\n    print(linpred.idata.predictions)\n</code></pre>"},{"location":"api/brms_functions/prediction/#brmspy.brms_functions.prediction.log_lik","title":"<code>log_lik(model, newdata=None, **kwargs)</code>","text":"<p>Compute log-likelihood values.</p> <p>Returns log p(y|theta) for each observation. Essential for model comparison via LOO-CV and WAIC.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FitResult</code> <p>Fitted model from fit()</p> required <code>newdata</code> <code>DataFrame</code> <p>Data for predictions. If None, uses original data</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments to brms::log_lik():</p> <ul> <li>ndraws : int - Number of posterior draws</li> <li>combine_chains : bool - Combine chains (default True)</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>LogLikResult</code> <p>Object with .idata (IDLogLik) and .r (R matrix) attributes</p> See Also <p>brms::log_lik : R documentation     https://paulbuerkner.com/brms/reference/log_lik.brmsfit.html arviz.loo : Leave-One-Out Cross-Validation arviz.waic : Widely Applicable Information Criterion</p> <p>Examples:</p> <p>Compute log-likelihood for model comparison:</p> <pre><code>from brmspy import brms\nimport arviz as az\n\nepilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    \"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    chains=4\n)\n\n# LOO-CV for model comparison\nloo = az.loo(model.idata)\nprint(loo)\n</code></pre> <p>Compare multiple models: <pre><code>model1 = brms.fit(\"count ~ zAge + (1|patient)\", data=epilepsy, family=\"poisson\", chains=4)\nmodel2 = brms.fit(\"count ~ zAge + zBase + (1|patient)\", data=epilepsy, family=\"poisson\", chains=4)\n\ncomp = az.compare({'model1': model1.idata, 'model2': model2.idata})\nprint(comp)\n</code></pre></p>"},{"location":"api/brms_functions/prior/","title":"prior","text":""},{"location":"api/brms_functions/prior/#brmspy.brms_functions.prior-classes","title":"Classes","text":""},{"location":"api/brms_functions/prior/#brmspy.brms_functions.prior-functions","title":"Functions","text":""},{"location":"api/brms_functions/prior/#brmspy.brms_functions.prior.prior","title":"<code>prior(prior, class_=None, coef=None, group=None, dpar=None, resp=None, nlpar=None, lb=None, ub=None, **kwargs)</code>","text":"<p>Create a brms-style prior specification.</p> <p>This function mirrors the behavior of <code>brms::prior_string()</code> and allows specifying priors for regression parameters, group-level effects, nonlinear parameters, distributional parameters, and more \u2014 using a typed Python interface. All arguments correspond directly to the parameters of <code>prior_string()</code> in brms.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>str</code> <p>The prior definition as a string, exactly as brms expects it. Examples include ::</p> <pre><code>\"normal(0, 1)\"\n\"student_t(3, 0, 1.5)\"\n\"exponential(2)\"\n\"lkj(2)\"\n</code></pre> required <code>class_</code> <code>str</code> <p>Parameter class (e.g. <code>\"b\"</code>, <code>\"sd\"</code>, <code>\"Intercept\"</code>). This corresponds to <code>class</code> in brms. <code>class</code> cannot be used as a parameter in Python (reserved keyword), so <code>class_</code> is used instead.</p> <code>None</code> <code>coef</code> <code>str</code> <p>Coefficient name for class-level effects.</p> <code>None</code> <code>group</code> <code>str</code> <p>Grouping variable for hierarchical/multilevel effects.</p> <code>None</code> <code>dpar</code> <code>str</code> <p>Distributional parameter (e.g. <code>\"sigma\"</code> or <code>\"phi\"</code>).</p> <code>None</code> <code>resp</code> <code>str</code> <p>Response variable name for multivariate models.</p> <code>None</code> <code>nlpar</code> <code>str</code> <p>Nonlinear parameter name if using nonlinear formulas.</p> <code>None</code> <code>lb</code> <code>float</code> <p>Lower bound for truncated priors.</p> <code>None</code> <code>ub</code> <code>float</code> <p>Upper bound for truncated priors.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Any additional keyword arguments supported by <code>brms::prior_string()</code>. These are forwarded unchanged.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PriorSpec</code> <p>A typed prior specification object used by <code>brmspy.fit()</code> and <code>brmspy.make_stancode()</code>.</p> Notes <p>This function does not validate the prior expression string itself \u2014 validation occurs inside brms. Its purpose is to construct a structured, editor-friendly representation that seamlessly maps to rpy2 calls.</p> <p>Examples:</p> <p>Prior on the intercept ::</p> <pre><code>p = prior(\"student_t(3, 0, 1.95)\", class_=\"Intercept\")\n</code></pre> <p>Prior on a coefficient ::</p> <pre><code>p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"age\")\n</code></pre> <p>Group-level (hierarchical) SD prior ::</p> <pre><code>p = prior(\"exponential(2)\", class_=\"sd\", group=\"region\")\n</code></pre> <p>Truncated prior ::</p> <pre><code>p = prior(\"normal(0, 1)\", class_=\"b\", coef=\"income\", lb=0)\n</code></pre> <p>Multiple priors passed to <code>fit</code> ::</p> <pre><code>from brmspy import prior\npriors = [\n    prior(\"student_t(3, 0, 2)\", class_=\"b\", coef=\"zAge\"),\n    prior(\"exponential(2)\", class_=\"sd\", group=\"patient\"),\n]\nmodel = brms.fit(\"y ~ zAge + (1|patient)\", data=df, priors=priors)\n</code></pre>"},{"location":"api/brms_functions/prior/#brmspy.brms_functions.prior.get_prior","title":"<code>get_prior(formula, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for all model parameters.</p> <p>Returns a DataFrame with default priors for each parameter class in the specified brms model. Useful for reviewing and customizing priors before fitting.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaResult</code> <p>Model formula (e.g., \"y ~ x + (1|group)\") or FormulaResult object</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\")</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row represents a parameter or parameter class that can have a custom prior.</p> See Also <p>default_prior : Generic function for getting default priors prior : Create custom prior specifications brms::get_prior : R documentation     https://paulbuerkner.com/brms/reference/get_prior.html</p> <p>Examples:</p> <p>Review default priors for a model:</p> <pre><code>from brmspy import brms\n\npriors = brms.get_prior(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\nprint(priors)\n#   prior       class    coef      group  ...\n#   student_t() Intercept  ...    ...     ...\n#   (flat)      b          zAge    ...    ...\n</code></pre> <p>Customize and use priors:</p> <pre><code>from brmspy import brms, prior\n\n# Get defaults\npriors_df = brms.get_prior(\"y ~ x\", data=df)\n\n# Create custom priors based on review\ncustom_priors = [\n    prior(\"normal(0, 0.5)\", class_=\"b\"),\n    prior(\"exponential(2)\", class_=\"sigma\")\n]\n\nmodel = brms.fit(\"y ~ x\", data=df, priors=custom_priors)\n</code></pre>"},{"location":"api/brms_functions/prior/#brmspy.brms_functions.prior.default_prior","title":"<code>default_prior(object, data=None, family='gaussian', **kwargs)</code>","text":"<p>Get default priors for brms model parameters (generic function).</p> <p>Generic function to retrieve default prior specifications for all parameters in a brms model. Accepts formula objects, brmsformula objects, or other model specification objects. This is the generic version of get_prior().</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>str, FormulaResult, or ListVector</code> <p>Model specification: formula string, brmsformula object, mvbrmsformula, or any object that can be coerced to these classes</p> required <code>data</code> <code>DataFrame or dict</code> <p>Dataset containing model variables. Required for data-dependent priors</p> <code>None</code> <code>family</code> <code>str or ListVector</code> <p>Distribution family (e.g., \"gaussian\", \"poisson\", \"binomial\"). Can be a list of families for multivariate models</p> <code>\"gaussian\"</code> <code>**kwargs</code> <p>Additional arguments passed to brms::get_prior() (e.g., autocor, data2, knots, drop_unused_levels, sparse)</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: prior, class, coef, group, resp, dpar, nlpar, lb, ub, source. Each row specifies a parameter class with its default prior. The 'prior' column is empty except for internal defaults.</p> See Also <p>get_prior : Convenience function with formula parameter prior : Create custom prior specifications brms::default_prior : R documentation     https://paulbuerkner.com/brms/reference/get_prior.html</p> <p>Examples:</p> <p>Get default priors for a Poisson model:</p> <pre><code>from brmspy import brms\n\npriors = brms.default_prior(\n    object=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\nprint(priors)\n</code></pre> <p>Use with formula object:</p> <pre><code>from brmspy import brms\n\nf = brms.formula(\"y ~ x + (1|group)\")\npriors = brms.default_prior(f, data=df, family=\"gaussian\")\n</code></pre>"},{"location":"api/brms_functions/stan/","title":"stan","text":""},{"location":"api/brms_functions/stan/#brmspy.brms_functions.stan-classes","title":"Classes","text":""},{"location":"api/brms_functions/stan/#brmspy.brms_functions.stan-functions","title":"Functions","text":""},{"location":"api/brms_functions/stan/#brmspy.brms_functions.stan.make_stancode","title":"<code>make_stancode(formula, data, priors=None, family='poisson', sample_prior='no', formula_args=None)</code>","text":"<p>Generate Stan code using brms::make_stancode().</p> <p>Useful for inspecting the generated Stan model before fitting, understanding the model structure, or using the code with other Stan interfaces.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str or FormulaResult</code> <p>brms formula specification</p> required <code>data</code> <code>DataFrame</code> <p>Model data</p> required <code>priors</code> <code>list of PriorSpec</code> <p>Prior specifications from prior() function</p> <code>None</code> <code>family</code> <code>str</code> <p>Distribution family (gaussian, poisson, binomial, etc.)</p> <code>\"poisson\"</code> <code>sample_prior</code> <code>str</code> <p>Whether to sample from prior: - \"no\": No prior samples - \"yes\": Include prior samples alongside posterior - \"only\": Sample from prior only (no data)</p> <code>\"no\"</code> <code>formula_args</code> <code>dict</code> <p>Additional arguments passed to formula()</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Complete Stan program code as string</p> See Also <p>brms::make_stancode : R documentation     https://paulbuerkner.com/brms/reference/make_stancode.html fit : Fit model instead of just generating code make_standata : Generate Stan data block</p> <p>Examples:</p> <p>Generate Stan code for simple model:</p> <pre><code>from brmspy import brms\nepilepsy = brms.get_brms_data(\"epilepsy\")\n\nstan_code = brms.make_stancode(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\"\n)\n\nprint(stan_code[:500])  # Print first 500 characters\n</code></pre> <p>With custom priors:</p> <pre><code>    from brmspy import prior\n\n    stan_code = brms.make_stancode(\n        formula=\"count ~ zAge\",\n        data=epilepsy,\n        priors=[prior(\"normal(0, 1)\", class_=\"b\")],\n        family=\"poisson\"\n    )\n</code></pre> <p>For prior predictive checks (sample_prior=\"only\"):</p> <pre><code>stan_code = brms.make_stancode(\n    formula=\"count ~ zAge\",\n    data=epilepsy,\n    family=\"poisson\",\n    sample_prior=\"only\"\n)\n</code></pre>"},{"location":"api/helpers/conversion/","title":"Conversion","text":""},{"location":"api/helpers/conversion/#brmspy.helpers.conversion-classes","title":"Classes","text":""},{"location":"api/helpers/conversion/#brmspy.helpers.conversion-functions","title":"Functions","text":""},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.brmsfit_to_idata","title":"<code>brmsfit_to_idata(brmsfit_obj, model_data=None)</code>","text":"<p>Convert brmsfit R object to ArviZ InferenceData format.</p> <p>Comprehensive conversion that extracts all MCMC diagnostics, predictions, and observed data from a brms fitted model into ArviZ's InferenceData format. Handles proper chain/draw indexing and coordinates for ArviZ compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted Bayesian model from R's brms::brm() function</p> required <code>model_data</code> <code>dict or DataFrame</code> <p>Additional model data (currently unused, reserved for future use)</p> <code>None</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>Complete InferenceData object containing: - posterior: Model parameters (\u03b2, \u03c3, etc.) with shape (chains, draws, ...) - posterior_predictive: Predicted outcomes y with observation noise - log_likelihood: Log-likelihood values for LOO-CV and model comparison - observed_data: Original response variable from training data - coords: Observation IDs and other coordinates - dims: Dimension labels for each variable</p> Notes <p>InferenceData Groups:</p> <ol> <li>Posterior: Parameter samples from MCMC</li> <li>Includes all model parameters (intercepts, slopes, sigmas, etc.)</li> <li>Shape: (n_chains, n_draws) for scalars, (n_chains, n_draws, ...) for arrays</li> <li> <p>Extracted via posterior::as_draws_df()</p> </li> <li> <p>Posterior Predictive: Predictions including observation noise</p> </li> <li>Generated via brms::posterior_predict()</li> <li>Useful for posterior predictive checks</li> <li> <p>Shape: (n_chains, n_draws, n_obs)</p> </li> <li> <p>Log Likelihood: Pointwise log-likelihood values</p> </li> <li>Generated via brms::log_lik()</li> <li>Required for LOO-CV and WAIC model comparison</li> <li> <p>Shape: (n_chains, n_draws, n_obs)</p> </li> <li> <p>Observed Data: Original response variable</p> </li> <li>Extracted from fit$data</li> <li>Uses first column (brms convention for response variable)</li> <li>Shape: (n_obs,)</li> </ol> <p>Reshaping Strategy:</p> <p>brms/rstan return flat arrays with shape (total_draws, ...) where total_draws = n_chains \u00d7 n_draws. This function reshapes to ArviZ's expected format (n_chains, n_draws, ...) by: 1. Tracking chain IDs from .chain column 2. Computing per-chain draw indices 3. Pivoting and reshaping to 3D arrays</p> <p>Examples:</p> <pre><code>from brmspy import fit\nfrom brmspy.helpers.conversion import brmsfit_to_idata\nimport arviz as az\n\n# Fit a model (returns InferenceData directly)\nresult = fit(\"y ~ x\", data=pd.DataFrame({\"y\": [1, 2, 3], \"x\": [1, 2, 3]}))\nidata = result.idata\n\n# Or manually convert brmsfit object\n# brmsfit_r = ...  # R brmsfit object\n# idata = brmsfit_to_idata(brmsfit_r)\n\n# Use ArviZ for diagnostics\naz.summary(idata, var_names=[\"b_Intercept\", \"b_x\"])\naz.plot_trace(idata)\naz.plot_posterior(idata, var_names=[\"sigma\"])\n</code></pre> <pre><code># Access different groups\nidata.posterior  # Parameter samples\nidata.posterior_predictive  # Predicted outcomes with noise\nidata.log_likelihood  # For model comparison\nidata.observed_data  # Original data\n\n# Model comparison with LOO-CV\naz.loo(idata)\naz.waic(idata)\n</code></pre> See Also <p>brmspy.brms.fit : High-level fitting function (returns InferenceData) brms_epred_to_idata : Convert expected value predictions brms_predict_to_idata : Convert posterior predictions arviz.InferenceData : ArviZ's data structure documentation</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.generic_pred_to_idata","title":"<code>generic_pred_to_idata(r_pred_obj, brmsfit_obj, newdata=None, var_name='pred', az_name='posterior')</code>","text":"<p>Generic converter for brms prediction matrices to ArviZ InferenceData.</p> <p>Flexible conversion function that handles various brms prediction types (posterior_predict, posterior_epred, posterior_linpred, log_lik) and stores them in appropriate InferenceData groups with proper structure.</p> <p>Parameters:</p> Name Type Description Default <code>r_pred_obj</code> <code>rpy2 R matrix</code> <p>Prediction matrix from any brms prediction function Shape: (total_draws, n_observations)</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model for extracting chain information</p> required <code>newdata</code> <code>DataFrame</code> <p>New data used for predictions. If provided, DataFrame index is used for observation coordinates</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Name for the variable in the InferenceData dataset</p> <code>\"pred\"</code> <code>az_name</code> <code>str</code> <p>InferenceData group name. Common values: - \"posterior\": For expected values (epred) - \"posterior_predictive\": For predictions with noise (predict) - \"predictions\": For linear predictor (linpred) - \"log_likelihood\": For log-likelihood values</p> <code>\"posterior\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with single group containing reshaped predictions as xarray DataArray with proper coordinates and dimensions</p> Notes <p>InferenceData Group Selection:</p> <p>Different prediction types should use appropriate groups: - Expected values (epred): 'posterior' - deterministic E[Y|X] - Predictions (predict): 'posterior_predictive' - with observation noise - Linear predictor (linpred): 'predictions' - before link function - Log-likelihood: 'log_likelihood' - for model comparison</p> <p>Coordinates:</p> <p>If newdata is a DataFrame, uses its index as observation coordinates. This preserves meaningful labels (dates, IDs, etc.) in ArviZ plots.</p> <p>Examples:</p> <pre><code>import pandas as pd\nfrom brmspy.helpers.conversion import generic_pred_to_idata\n\n# Assume we have fitted model and prediction matrix\n# r_epred = brms::posterior_epred(brmsfit, newdata=test_df)\n\ntest_df = pd.DataFrame({'x': [1, 2, 3]}, index=['A', 'B', 'C'])\n\nidata = generic_pred_to_idata(\n    r_pred_obj=r_epred,\n    brmsfit_obj=brmsfit,\n    newdata=test_df,\n    var_name=\"expected_y\",\n    az_name=\"posterior\"\n)\n\n# Access predictions\nprint(idata.posterior['expected_y'].dims)  # ('chain', 'draw', 'obs_id')\nprint(idata.posterior['expected_y'].coords['obs_id'])  # ['A', 'B', 'C']\n</code></pre> See Also <p>brms_epred_to_idata : Convenience wrapper for posterior_epred brms_predict_to_idata : Convenience wrapper for posterior_predict brms_linpred_to_idata : Convenience wrapper for posterior_linpred brms_log_lik_to_idata : Convenience wrapper for log_lik _reshape_r_prediction_to_arviz : Internal reshaping function</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.brms_epred_to_idata","title":"<code>brms_epred_to_idata(r_epred_obj, brmsfit_obj, newdata=None, var_name='epred')</code>","text":"<p>Convert brms::posterior_epred result to ArviZ InferenceData.</p> <p>Convenience wrapper for converting expected value predictions (posterior_epred) to InferenceData format. Stores in 'posterior' group as deterministic expected values E[Y|X] without observation noise.</p> <p>Parameters:</p> Name Type Description Default <code>r_epred_obj</code> <code>rpy2 R matrix</code> <p>Result from brms::posterior_epred()</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model</p> required <code>newdata</code> <code>DataFrame</code> <p>New data used for predictions</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Variable name in InferenceData</p> <code>\"epred\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with 'posterior' group containing expected values</p> Notes <p>posterior_epred computes the expected value of the posterior predictive distribution (i.e., the mean outcome for given predictors): - For linear regression: E[Y|X] = \u03bc = X\u00b7\u03b2 - For Poisson regression: E[Y|X] = exp(X\u00b7\u03b2) - For logistic regression: E[Y|X] = logit\u207b\u00b9(X\u00b7\u03b2)</p> <p>This is stored in the 'posterior' group (not 'posterior_predictive') because it represents deterministic expected values, not noisy predictions.</p> See Also <p>brmspy.brms.posterior_epred : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_predict_to_idata : For predictions with observation noise</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.brms_predict_to_idata","title":"<code>brms_predict_to_idata(r_predict_obj, brmsfit_obj, newdata=None, var_name='y')</code>","text":"<p>Convert brms::posterior_predict result to ArviZ InferenceData.</p> <p>Convenience wrapper for converting posterior predictions (posterior_predict) to InferenceData format. Stores in 'posterior_predictive' group as predictions including observation-level noise.</p> <p>Parameters:</p> Name Type Description Default <code>r_predict_obj</code> <code>rpy2 R matrix</code> <p>Result from brms::posterior_predict()</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model</p> required <code>newdata</code> <code>DataFrame</code> <p>New data used for predictions</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Variable name in InferenceData</p> <code>\"y\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with 'posterior_predictive' group containing predictions</p> Notes <p>posterior_predict generates predictions from the posterior predictive distribution, including observation-level noise: - For linear regression: Y ~ Normal(\u03bc, \u03c3) - For Poisson regression: Y ~ Poisson(\u03bb) - For logistic regression: Y ~ Bernoulli(p)</p> <p>These predictions include all sources of uncertainty (parameter and observation) and are useful for: - Posterior predictive checks - Generating realistic synthetic data - Assessing model fit to observed data</p> See Also <p>brmspy.brms.posterior_predict : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_epred_to_idata : For expected values without noise</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.brms_linpred_to_idata","title":"<code>brms_linpred_to_idata(r_linpred_obj, brmsfit_obj, newdata=None, var_name='linpred')</code>","text":"<p>Convert brms::posterior_linpred result to ArviZ InferenceData.</p> <p>Convenience wrapper for converting linear predictor values (posterior_linpred) to InferenceData format. Stores in 'predictions' group as linear predictor values before applying the link function.</p> <p>Parameters:</p> Name Type Description Default <code>r_linpred_obj</code> <code>rpy2 R matrix</code> <p>Result from brms::posterior_linpred()</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model</p> required <code>newdata</code> <code>DataFrame</code> <p>New data used for predictions</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Variable name in InferenceData</p> <code>\"linpred\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with 'predictions' group containing linear predictor</p> Notes <p>posterior_linpred returns the linear predictor \u03b7 = X\u00b7\u03b2 before applying the link function: - For linear regression: linpred = \u03bc (same as epred since link is identity) - For Poisson regression: linpred = log(\u03bb), epred = \u03bb - For logistic regression: linpred = logit(p), epred = p</p> <p>The linear predictor is useful for: - Understanding the scale of effects before transformation - Diagnosing model specification issues - Custom post-processing with different link functions</p> See Also <p>brmspy.brms.posterior_linpred : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function brms_epred_to_idata : For expected values on response scale</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.brms_log_lik_to_idata","title":"<code>brms_log_lik_to_idata(r_log_lik_obj, brmsfit_obj, newdata=None, var_name='log_lik')</code>","text":"<p>Convert brms::log_lik result to ArviZ InferenceData.</p> <p>Convenience wrapper for converting pointwise log-likelihood values (log_lik) to InferenceData format. Stores in 'log_likelihood' group for use in model comparison and diagnostics.</p> <p>Parameters:</p> Name Type Description Default <code>r_log_lik_obj</code> <code>rpy2 R matrix</code> <p>Result from brms::log_lik()</p> required <code>brmsfit_obj</code> <code>rpy2 R object (brmsfit)</code> <p>Fitted model</p> required <code>newdata</code> <code>DataFrame</code> <p>New data for log-likelihood calculation</p> <code>None</code> <code>var_name</code> <code>str</code> <p>Variable name in InferenceData</p> <code>\"log_lik\"</code> <p>Returns:</p> Type Description <code>InferenceData</code> <p>InferenceData with 'log_likelihood' group</p> Notes <p>log_lik computes pointwise log-likelihood values for each observation, which are essential for:</p> <ul> <li>LOO-CV: Leave-one-out cross-validation via <code>az.loo()</code></li> <li>WAIC: Widely applicable information criterion via <code>az.waic()</code></li> <li>Model Comparison: Compare multiple models with <code>az.compare()</code></li> <li>Outlier Detection: Identify poorly fit observations</li> </ul> <p>Each MCMC draw \u00d7 observation gets a log-likelihood value, representing how well that parameter draw explains that specific observation.</p> <p>Examples:</p> <pre><code>from brmspy import fit\nimport arviz as az\n\n# Fit model (log_lik included automatically)\nresult = fit(\"y ~ x\", data={\"y\": [1, 2, 3], \"x\": [1, 2, 3]})\n\n# Model comparison with LOO-CV\nloo_result = az.loo(result.idata)\nprint(loo_result)\n\n# Compare multiple models\nmodel1_idata = fit(\"y ~ x\", data=data1).idata\nmodel2_idata = fit(\"y ~ x + x2\", data=data2).idata\ncomparison = az.compare({\"model1\": model1_idata, \"model2\": model2_idata})\n</code></pre> See Also <p>brmspy.brms.log_lik : High-level wrapper that calls this generic_pred_to_idata : Generic conversion function arviz.loo : Leave-one-out cross-validation arviz.waic : WAIC computation arviz.compare : Model comparison</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.py_to_r","title":"<code>py_to_r(obj)</code>","text":"<p>Convert arbitrary Python objects to R objects via rpy2.</p> <p>Comprehensive converter that handles nested structures (dicts, lists), DataFrames, arrays, and scalars. Uses rpy2's converters with special handling for dictionaries (\u2192 R named lists) and lists of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>any</code> <p>Python object to convert. Supported types: - None \u2192 R NULL - dict \u2192 R named list (ListVector), recursively - list/tuple of dicts \u2192 R list of named lists - list/tuple (other) \u2192 R vector or list - pd.DataFrame \u2192 R data.frame - np.ndarray \u2192 R vector/matrix - scalars (int, float, str, bool) \u2192 R atomic types</p> required <p>Returns:</p> Type Description <code>rpy2 R object</code> <p>R representation of the Python object</p> Notes <p>Conversion Rules:</p> <ol> <li>None: \u2192 R NULL</li> <li>DataFrames: \u2192 R data.frame (via pandas2ri)</li> <li>Dictionaries: \u2192 R named list (ListVector), recursively converting values</li> <li>Lists of dicts: \u2192 R list with 1-based indexed names containing named lists</li> <li>Other lists/tuples: \u2192 R vectors or lists (via rpy2 default)</li> <li>NumPy arrays: \u2192 R vectors/matrices (via numpy2ri)</li> <li>Scalars: \u2192 R atomic values</li> </ol> <p>Recursive Conversion:</p> <p>Dictionary values are recursively converted, allowing nested structures: <pre><code>{'a': {'b': [1, 2, 3]}}  \u2192  list(a = list(b = c(1, 2, 3)))\n</code></pre></p> <p>List of Dicts:</p> <p>Lists containing only dicts are converted to R lists with 1-based indexing: <pre><code>[{'x': 1}, {'x': 2}]  \u2192  list(\"1\" = list(x = 1), \"2\" = list(x = 2))\n</code></pre></p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import py_to_r\nimport numpy as np\nimport pandas as pd\n\n# Scalars\npy_to_r(5)        # R: 5\npy_to_r(\"hello\")  # R: \"hello\"\npy_to_r(None)     # R: NULL\n\n# Arrays\npy_to_r(np.array([1, 2, 3]))  # R: c(1, 2, 3)\n\n# DataFrames\ndf = pd.DataFrame({'x': [1, 2], 'y': [3, 4]})\npy_to_r(df)  # R: data.frame(x = c(1, 2), y = c(3, 4))\n</code></pre> See Also <p>r_to_py : Convert R objects back to Python kwargs_r : Convert keyword arguments dict for R function calls brmspy.brms.fit : Uses this for converting data to R</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.r_to_py","title":"<code>r_to_py(obj)</code>","text":"<p>Convert R objects to Python objects via rpy2.</p> <p>Comprehensive converter that handles R lists (named/unnamed), vectors, formulas, and language objects. Provides sensible Python equivalents for all R types with special handling for edge cases.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>rpy2 R object</code> <p>R object to convert to Python</p> required <p>Returns:</p> Type Description <code>any</code> <p>Python representation of the R object: - R NULL \u2192 None - Named list \u2192 dict (recursively) - Unnamed list \u2192 list (recursively) - Length-1 vector \u2192 scalar (int, float, str, bool) - Length-N vector \u2192 list of scalars - Formula/Language object \u2192 str (descriptive representation) - Other objects \u2192 default rpy2 conversion or str fallback</p> Notes <p>Conversion Rules:</p> <ol> <li>R NULL: \u2192 Python None</li> <li>Atomic vectors (numeric, character, logical):</li> <li>Length 1: \u2192 Python scalar (int, float, str, bool)</li> <li>Length &gt;1: \u2192 Python list of scalars</li> <li>Named lists (ListVector with names): \u2192 Python dict, recursively</li> <li>Unnamed lists: \u2192 Python list, recursively</li> <li>Formulas (e.g., <code>y ~ x</code>): \u2192 String representation</li> <li>Language objects (calls, expressions): \u2192 String representation</li> <li>Functions: \u2192 String representation</li> <li>Everything else: Try default rpy2 conversion, fallback to string</li> </ol> <p>Recursive Conversion:</p> <p>List elements and dictionary values are recursively converted: <pre><code>list(a = list(b = c(1, 2)))  \u2192  {'a': {'b': [1, 2]}}\n</code></pre></p> <p>Safe Fallback:</p> <p>R language objects, formulas, and functions are converted to descriptive strings rather than attempting complex conversions that might fail.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import r_to_py\nimport rpy2.robjects as ro\n\n# R NULL\nr_to_py(ro.NULL)  # None\n\n# Scalars\nr_to_py(ro.IntVector([5]))    # 5\nr_to_py(ro.FloatVector([3.14]))  # 3.14\nr_to_py(ro.StrVector([\"hello\"]))  # \"hello\"\n\n# Vectors\nr_to_py(ro.IntVector([1, 2, 3]))  # [1, 2, 3]\n</code></pre> See Also <p>py_to_r : Convert Python objects to R brmspy.brms.summary : Returns Python-friendly summary dict</p>"},{"location":"api/helpers/conversion/#brmspy.helpers.conversion.kwargs_r","title":"<code>kwargs_r(kwargs)</code>","text":"<p>Convert Python keyword arguments to R-compatible format.</p> <p>Convenience function that applies py_to_r() to all values in a keyword arguments dictionary, preparing them for R function calls.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict or None</code> <p>Dictionary of keyword arguments where values may be Python objects (dicts, lists, DataFrames, arrays, etc.)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with same keys but R-compatible values, or empty dict if None</p> Notes <p>This is a thin wrapper around <code>py_to_r()</code> that operates on dictionaries. It's commonly used to prepare keyword arguments for R function calls via rpy2.</p> <p>Examples:</p> <pre><code>from brmspy.helpers.conversion import kwargs_r\nimport pandas as pd\nimport numpy as np\n\n# Prepare kwargs for R function\npy_kwargs = {\n    'data': pd.DataFrame({'y': [1, 2], 'x': [1, 2]}),\n    'prior': {'b': [0, 1]},\n    'chains': 4,\n    'iter': 2000\n}\n\nr_kwargs = kwargs_r(py_kwargs)\n# All values converted to R objects\n# Can now call: r_function(**r_kwargs)\n</code></pre> See Also <p>py_to_r : Underlying conversion function for individual values brmspy.brms.fit : Uses this to prepare user kwargs for R</p>"},{"location":"api/helpers/priors/","title":"Priors","text":""},{"location":"api/helpers/priors/#brmspy.helpers.priors-classes","title":"Classes","text":""},{"location":"api/helpers/rtools/","title":"RTools (Windows)","text":""},{"location":"api/helpers/rtools/#brmspy.helpers.rtools-functions","title":"Functions","text":""},{"location":"api/helpers/rtools/#brmspy.helpers.rtools.pick_rtools_for_r","title":"<code>pick_rtools_for_r(r_ver)</code>","text":"<p>Select appropriate Rtools version tag for given R version.</p> <p>Maps R version to compatible Rtools major version. Rtools is required on Windows to compile Stan models and R packages with C++ code.</p> <p>Parameters:</p> Name Type Description Default <code>r_ver</code> <code>Version</code> <p>R version to match</p> required <p>Returns:</p> Type Description <code>str or None</code> <p>Rtools version tag ('40', '42', '43', '44', '45') or None if R version is too old (&lt; 4.0.0) for automatic handling</p> Notes <p>R to Rtools Version Mapping:</p> <ul> <li>R 4.0.x - 4.1.x: Rtools 40</li> <li>R 4.2.x: Rtools 42</li> <li>R 4.3.x: Rtools 43</li> <li>R 4.4.x: Rtools 44</li> <li>R 4.5.x+: Rtools 45</li> <li>R &lt; 4.0.0: None (legacy, not supported)</li> </ul> <p>Rtools Purpose:</p> <p>Rtools provides MinGW-w64 compiler toolchain on Windows for: - Compiling Stan models (required by cmdstanr) - Building R packages from source - C++ compilation for brms/Stan</p> <p>Examples:</p> <pre><code>from packaging.version import Version\nfrom brmspy.helpers.rtools import pick_rtools_for_r\n\n# R 4.3.2 needs Rtools 43\ntag = pick_rtools_for_r(Version(\"4.3.2\"))\nprint(tag)  # \"43\"\n\n# R 4.4.1 needs Rtools 44\ntag = pick_rtools_for_r(Version(\"4.4.1\"))\nprint(tag)  # \"44\"\n\n# Legacy R not supported\ntag = pick_rtools_for_r(Version(\"3.6.3\"))\nprint(tag)  # None\n</code></pre> See Also <p>_install_rtools_for_current_r : Automatically install matching Rtools _get_r_version : Get current R version</p> References <p>.. [1] Rtools download page: https://cran.r-project.org/bin/windows/Rtools/</p>"},{"location":"api/helpers/singleton/","title":"Singleton","text":""},{"location":"api/helpers/singleton/#brmspy.helpers.singleton-functions","title":"Functions","text":""},{"location":"binaries/build/","title":"Build","text":""},{"location":"binaries/build/#brmspy.binaries.build-functions","title":"Functions","text":""},{"location":"binaries/build/#brmspy.binaries.build.collect_runtime_metadata","title":"<code>collect_runtime_metadata()</code>","text":"<p>Collect comprehensive R environment metadata for runtime bundle.</p> <p>Queries R via rpy2 to gather complete information about the current R installation, including R version, CmdStan installation, and full dependency closure of brms + cmdstanr with all package details.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Metadata dictionary containing: - r_version : str - R version (e.g., \"4.3.1\") - cmdstan_path : str - Path to CmdStan installation - cmdstan_version : str - CmdStan version - packages : list of dict - Package information with fields:     - Package : str - Package name     - Version : str - Package version     - LibPath : str - Installation library path     - Priority : str - Package priority level</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If required R packages (jsonlite) cannot be installed If build-manifest.R script cannot be read</p> Notes <p>This function executes the build-manifest.R script which uses R's package dependency resolution to find the complete dependency closure. It ensures all transitive dependencies are included.</p> <p>Examples:</p> <pre><code>metadata = collect_runtime_metadata()\nprint(f\"R version: {metadata['r_version']}\")\nprint(f\"CmdStan: {metadata['cmdstan_version']}\")\nprint(f\"Packages: {len(metadata['packages'])}\")\n\n# Check if brms is included\npkg_names = [p[\"Package\"] for p in metadata[\"packages\"]]\nassert \"brms\" in pkg_names\n</code></pre>"},{"location":"binaries/build/#brmspy.binaries.build.stage_runtime_tree","title":"<code>stage_runtime_tree(base_dir, metadata, runtime_version)</code>","text":"<p>Create runtime directory structure and copy all required files.</p> <p>Builds the complete runtime directory tree by: 1. Creating fingerprint-specific directory structure 2. Copying all R packages to Rlib/ 3. Copying CmdStan installation to cmdstan/ 4. Generating manifest.json with checksums</p> <p>The resulting structure: base_dir/   {fingerprint}/     manifest.json     Rlib/       {package1}/       {package2}/       ...     cmdstan/       {cmdstan files}</p> <p>Parameters:</p> Name Type Description Default <code>base_dir</code> <code>Path</code> <p>Base directory for runtime tree</p> required <code>metadata</code> <code>dict</code> <p>Metadata from collect_runtime_metadata() containing: - packages : list - R package information - cmdstan_path : str - CmdStan location - r_version : str - cmdstan_version : str</p> required <code>runtime_version</code> <code>str</code> <p>Runtime schema version (e.g., \"0.1.0\")</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to the runtime root directory (base_dir/fingerprint)</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If system_fingerprint() returns None If no package metadata provided If package directories don't exist If cmdstan_path doesn't exist</p> Notes <p>The fingerprint is determined by system_fingerprint() which includes: - OS (linux/macos/windows) - Architecture (x86_64/arm64) - R version (major.minor)</p> <p>The manifest.json includes a SHA256 hash for integrity verification.</p> <p>Examples:</p> <pre><code>from pathlib import Path\n\nmetadata = collect_runtime_metadata()\nbase = Path(\"./runtime_build\")\n\nruntime_root = stage_runtime_tree(\n    base,\n    metadata,\n    runtime_version=\"0.1.0\"\n)\n\nprint(f\"Runtime staged at: {runtime_root}\")\nprint(f\"Manifest: {runtime_root / 'manifest.json'}\")\nprint(f\"R packages: {runtime_root / 'Rlib'}\")\nprint(f\"CmdStan: {runtime_root / 'cmdstan'}\")\n</code></pre>"},{"location":"binaries/build/#brmspy.binaries.build.pack_runtime","title":"<code>pack_runtime(runtime_root, out_dir, runtime_version)</code>","text":"<p>Create compressed tar archive from runtime directory.</p> <p>Packages the staged runtime directory into a distributable .tar.gz archive with standardized naming for platform/version identification.</p> <p>Archive naming format: brmspy-runtime-{runtime_version}-{fingerprint}.tar.gz</p> <p>For example: brmspy-runtime-0.1.0-linux-x86_64-r4.3.tar.gz</p> <p>Parameters:</p> Name Type Description Default <code>runtime_root</code> <code>Path</code> <p>Path to staged runtime directory (from stage_runtime_tree)</p> required <code>out_dir</code> <code>Path</code> <p>Output directory for archive file</p> required <code>runtime_version</code> <code>str</code> <p>Runtime schema version (e.g., \"0.1.0\")</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to created .tar.gz archive file</p> Notes <p>The archive contains a top-level \"runtime/\" directory with all runtime files. This structure is expected by install_and_activate_runtime().</p> <p>The fingerprint is extracted from runtime_root.name, which should match the fingerprint used in stage_runtime_tree().</p> <p>Examples:</p> <pre><code>from pathlib import Path\n\nruntime_root = Path(\"./runtime_build/linux-x86_64-r4.3\")\nout_dir = Path(\"./dist\")\n\narchive = pack_runtime(\n    runtime_root,\n    out_dir,\n    runtime_version=\"0.1.0\"\n)\n\nprint(f\"Archive created: {archive}\")\nprint(f\"Size: {archive.stat().st_size / 1024 / 1024:.1f} MB\")\n</code></pre>"},{"location":"binaries/build/#brmspy.binaries.build.main","title":"<code>main()</code>","text":"<p>CLI entry point for building brmspy prebuilt runtime bundles.</p> <p>Command-line tool that orchestrates the complete runtime build process: 1. Collect R environment metadata 2. Stage runtime directory tree 3. Pack into distributable archive</p> Command-line Arguments <p>--output-dir : str, default=\"runtime_build\"     Directory where runtime tree and archive will be written --runtime-version : str, default=\"0.1.0\"     Runtime schema version identifier (not pip version)</p> <p>Examples:</p> <p>Build with defaults:</p> <pre><code>python -m brmspy.binaries.build\n</code></pre> <p>Specify custom output directory and version:</p> <pre><code>python -m brmspy.binaries.build         --output-dir /tmp/runtime         --runtime-version 0.2.0\n</code></pre> Notes <p>Requires: - R with brms and cmdstanr installed - CmdStan compiled and configured - Write permissions to output directory</p> <p>The build process can take 5-10 minutes depending on the number of dependencies and disk speed.</p> See Also <p>collect_runtime_metadata : Gathers R environment info stage_runtime_tree : Creates runtime directory structure pack_runtime : Creates distributable archive</p>"},{"location":"binaries/env/","title":"Env","text":""},{"location":"binaries/env/#brmspy.binaries.env-functions","title":"Functions","text":""},{"location":"binaries/env/#brmspy.binaries.env.get_r_version_tuple","title":"<code>get_r_version_tuple()</code>","text":"<p>Get R version as tuple of integers.</p> <p>Queries the active R installation via rpy2 to retrieve version information. Returns None if R is not available or rpy2 cannot communicate with R.</p> <p>Returns:</p> Type Description <code>tuple of (int, int, int) or None</code> <p>(major, minor, patch) version numbers, or None if unavailable</p> <p>Examples:</p> <pre><code>version = get_r_version_tuple()\nif version:\n    major, minor, patch = version\n    print(f\"R {major}.{minor}.{patch}\")\nelse:\n    print(\"R not available\")\n</code></pre> See Also <p>r_available_and_supported : Check if R meets minimum requirements</p>"},{"location":"binaries/env/#brmspy.binaries.env.r_available_and_supported","title":"<code>r_available_and_supported(min_major=4, min_minor=0)</code>","text":"<p>Check if R is available and meets minimum version requirements.</p> <p>Parameters:</p> Name Type Description Default <code>min_major</code> <code>int</code> <p>Minimum required R major version</p> <code>4</code> <code>min_minor</code> <code>int</code> <p>Minimum required R minor version</p> <code>2</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if R is available and &gt;= min_major.min_minor</p> <p>Examples:</p> <pre><code>if r_available_and_supported():\n    print(\"R 4.2+ is available\")\n\n# Check for R 4.3+\nif r_available_and_supported(min_major=4, min_minor=3):\n    print(\"R 4.3+ is available\")\n</code></pre> See Also <p>get_r_version_tuple : Get detailed R version</p>"},{"location":"binaries/env/#brmspy.binaries.env.extract_glibc_version","title":"<code>extract_glibc_version(ldd_output)</code>","text":"<p>Parse glibc version from ldd command output.</p> <p>Extracts glibc version number from the output of <code>ldd --version</code>. Used on Linux to verify minimum glibc requirement for prebuilt binaries.</p> <p>Parameters:</p> Name Type Description Default <code>ldd_output</code> <code>str</code> <p>Output from <code>ldd --version</code> command</p> required <p>Returns:</p> Type Description <code>tuple of (int, int) or None</code> <p>(major, minor) version, or None if not found</p> <p>Examples:</p> <pre><code>import subprocess\n\nout = subprocess.check_output([\"ldd\", \"--version\"], text=True)\nversion = extract_glibc_version(out)\nif version and version &gt;= (2, 27):\n    print(\"glibc 2.27+ available\")\n</code></pre> See Also <p>linux_can_use_prebuilt : Uses this for Linux compatibility check</p>"},{"location":"binaries/env/#brmspy.binaries.env.parse_clang_version","title":"<code>parse_clang_version(version_output)</code>","text":"<p>Parse clang compiler version from command output.</p> <p>Extracts clang version number from the output of <code>clang --version</code>. Used on macOS to verify minimum compiler requirement.</p> <p>Parameters:</p> Name Type Description Default <code>version_output</code> <code>str</code> <p>Output from <code>clang --version</code> command</p> required <p>Returns:</p> Type Description <code>tuple of (int, int) or None</code> <p>(major, minor) version, or None if parsing fails</p> <p>Examples:</p> <pre><code>import subprocess\n\nout = subprocess.check_output([\"clang\", \"--version\"], text=True)\nversion = parse_clang_version(out)\nif version and version &gt;= (11, 0):\n    print(\"clang 11+ available\")\n</code></pre> See Also <p>macos_can_use_prebuilt : macOS compatibility check</p>"},{"location":"binaries/env/#brmspy.binaries.env.linux_can_use_prebuilt","title":"<code>linux_can_use_prebuilt()</code>","text":"<p>Check if Linux system meets prebuilt binary requirements.</p> <p>Verifies that the Linux system has compatible toolchain versions required to use prebuilt brms runtime bundles. Checks glibc and g++ compiler versions.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if system meets all requirements: - glibc &gt;= 2.27 (for binary compatibility) - g++ &gt;= 9.0 (for C++17 Stan compilation)</p> Notes <p>Requirements for prebuilt Linux bundles: - glibc 2.27+: Ensures binary compatibility with precompiled Stan models - g++ 9+: Minimum compiler for C++17 features used by CmdStan</p> <p>Examples:</p> <pre><code>from brmspy.binaries.env import linux_can_use_prebuilt\n\nif linux_can_use_prebuilt():\n    print(\"System can use prebuilt Linux binaries\")\nelse:\n    print(\"Must build from source\")\n</code></pre> See Also <p>extract_glibc_version : Parse glibc version from ldd _parse_gxx_version : Parse g++ version toolchain_is_compatible : Master toolchain check for all platforms</p>"},{"location":"binaries/env/#brmspy.binaries.env.macos_can_use_prebuilt","title":"<code>macos_can_use_prebuilt()</code>","text":"<p>Check if macOS system meets prebuilt binary requirements.</p> <p>Verifies that the macOS system has Xcode Command Line Tools and a compatible clang compiler version for using prebuilt brms bundles.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if system meets all requirements: - Xcode Command Line Tools installed - clang &gt;= 11.0 (for C++17 Stan compilation)</p> Notes <p>Requirements for prebuilt macOS bundles: - Xcode CLT: Provides essential build tools and system headers - clang 11+: Minimum compiler for C++17 features used by CmdStan</p> <p>To install Xcode Command Line Tools: <pre><code>xcode-select --install\n</code></pre></p> <p>Examples:</p> <pre><code>    from brmspy.binaries.env import macos_can_use_prebuilt\n\n    if macos_can_use_prebuilt():\n        print(\"System can use prebuilt macOS binaries\")\n    else:\n        print(\"Install Xcode CLT or upgrade clang\")\n</code></pre> See Also <p>parse_clang_version : Parse clang version from command output toolchain_is_compatible : Master toolchain check for all platforms</p>"},{"location":"binaries/env/#brmspy.binaries.env.windows_can_use_prebuilt","title":"<code>windows_can_use_prebuilt()</code>","text":"<p>Check if Windows system meets prebuilt binary requirements.</p> <p>Verifies that the Windows system has Rtools with MinGW g++ compiler required for using prebuilt brms runtime bundles.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if system meets all requirements: - Rtools toolchain installed (MinGW g++ available) - g++ &gt;= 9.0 (for C++17 Stan compilation)</p> Notes <p>Requirements for prebuilt Windows bundles: - Rtools 4.0+: Provides MinGW-w64 toolchain for Stan compilation - g++ 9+: Minimum compiler for C++17 features used by CmdStan</p> <p>Rtools can be downloaded from: https://cran.r-project.org/bin/windows/Rtools/</p> <p>Examples:</p> <pre><code>from brmspy.binaries.env import windows_can_use_prebuilt\n\nif windows_can_use_prebuilt():\n    print(\"System can use prebuilt Windows binaries\")\nelse:\n    print(\"Install Rtools 4.0+\")\n</code></pre> See Also <p>parse_gxx_version : Parse g++ version from command output toolchain_is_compatible : Master toolchain check for all platforms</p>"},{"location":"binaries/env/#brmspy.binaries.env.supported_platform","title":"<code>supported_platform()</code>","text":"<p>Check if current platform is officially supported for prebuilt binaries.</p> <p>Validates that the operating system and architecture combination is one of the officially supported platforms for prebuilt brms bundles.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if platform is in the supported list</p> Notes <p>Currently supported platforms: - linux-x86_64: Linux on x86_64/AMD64 processors - macos-x86_64: macOS on Intel processors - macos-arm64: macOS on Apple Silicon (M1/M2/M3) - windows-x86_64: Windows on x86_64/AMD64 processors</p> <p>Unsupported combinations (e.g., linux-arm64, windows-arm64) will return False even if technically compatible.</p> <p>Examples:</p> <pre><code>from brmspy.binaries.env import supported_platform\n\nif supported_platform():\n    print(\"Platform is supported for prebuilts\")\n    # Further checks: toolchain, R version, etc.\nelse:\n    print(\"Platform not supported, must build from source\")\n</code></pre> See Also <p>_normalized_os_arch : Get normalized platform identifiers can_use_prebuilt : Complete prebuilt eligibility check</p>"},{"location":"binaries/env/#brmspy.binaries.env.toolchain_is_compatible","title":"<code>toolchain_is_compatible()</code>","text":"<p>Check if system toolchain is compatible with prebuilt binaries.</p> <p>Routes to the appropriate platform-specific toolchain verification function based on the detected operating system.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if system has compatible compiler toolchain for current OS</p> Notes <p>Platform-specific requirements: - Linux: glibc &gt;= 2.27, g++ &gt;= 9 - macOS: Xcode CLT installed, clang &gt;= 11 - Windows: Rtools installed (MinGW g++ &gt;= 9)</p> <p>This is a high-level check that delegates to OS-specific functions: - <code>linux_can_use_prebuilt()</code> for Linux - <code>macos_can_use_prebuilt()</code> for macOS - <code>windows_can_use_prebuilt()</code> for Windows</p> <p>Examples:</p> <pre><code>from brmspy.binaries.env import toolchain_is_compatible\n\nif toolchain_is_compatible():\n    print(\"Toolchain is compatible\")\nelse:\n    print(\"Upgrade compiler or install build tools\")\n</code></pre> See Also <p>linux_can_use_prebuilt : Linux toolchain check macos_can_use_prebuilt : macOS toolchain check windows_can_use_prebuilt : Windows toolchain check</p>"},{"location":"binaries/env/#brmspy.binaries.env.system_fingerprint","title":"<code>system_fingerprint()</code>","text":"<p>Generate system fingerprint for prebuilt bundle selection.</p> <p>Creates a unique identifier string combining OS, architecture, and R version to match against available prebuilt runtime bundles.</p> <p>Returns:</p> Type Description <code>str or None</code> <p>Fingerprint string in format '{os}-{arch}-r{major}.{minor}', or None if R version cannot be determined</p> Notes <p>The fingerprint format is: <code>{os}-{arch}-r{major}.{minor}</code></p> <p>Example fingerprints: - 'linux-x86_64-r4.3' - 'macos-arm64-r4.4' - 'windows-x86_64-r4.2'</p> <p>This fingerprint is used to: 1. Select the correct prebuilt bundle for download 2. Verify bundle compatibility with current system 3. Cache bundles in system-specific directories</p> <p>Examples:</p> <pre><code>from brmspy.binaries.env import system_fingerprint\n\nfp = system_fingerprint()\nif fp:\n    print(f\"System fingerprint: {fp}\")\n    # Use fingerprint to select bundle\nelse:\n    print(\"Cannot determine R version\")\n</code></pre> See Also <p>_normalized_os_arch : Get OS and architecture get_r_version_tuple : Get R version prebuilt_available_for : Check bundle availability</p>"},{"location":"binaries/env/#brmspy.binaries.env.prebuilt_available_for","title":"<code>prebuilt_available_for(fingerprint)</code>","text":"<p>Check if prebuilt bundle exists for given system fingerprint.</p> <p>Verifies whether a prebuilt runtime bundle is available for the specified system fingerprint. Currently checks against a static set, but designed to support dynamic manifest/GitHub Releases lookup.</p> <p>Parameters:</p> Name Type Description Default <code>fingerprint</code> <code>str or None</code> <p>System fingerprint string (e.g., 'linux-x86_64-r4.3') from <code>system_fingerprint()</code></p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if prebuilt bundle exists for this fingerprint</p> Notes <p>The <code>PREBUILT_FINGERPRINTS</code> set contains all available bundle identifiers. This can be populated from: - Static manifest file in package - Remote JSON manifest from CDN/GitHub - GitHub Releases API</p> <p>Future enhancement: Dynamic manifest fetching to auto-discover new bundles without package updates.</p> <p>Examples:</p> <pre><code>    from brmspy.binaries.env import (\n        system_fingerprint, prebuilt_available_for\n    )\n\n    fp = system_fingerprint()\n    if fp and prebuilt_available_for(fp):\n        print(f\"Prebuilt available for {fp}\")\n    else:\n        print(\"No prebuilt available, must build from source\")\n</code></pre> See Also <p>system_fingerprint : Generate fingerprint for current system can_use_prebuilt : Complete eligibility check</p>"},{"location":"binaries/env/#brmspy.binaries.env.can_use_prebuilt","title":"<code>can_use_prebuilt()</code>","text":"<p>Master check for prebuilt binary eligibility.</p> <p>Comprehensive validation that system meets ALL requirements for using prebuilt brms runtime bundles. Acts as the primary gate for deciding whether to use prebuilts or build from source.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True only if ALL conditions are met: - Platform is supported (OS-architecture combination) - R &gt;= 4.2 is available and usable via rpy2 - System toolchain meets minimum requirements - Prebuilt bundle exists for this fingerprint (commented out)</p> Notes <p>This function performs checks in order of increasing cost: 1. <code>supported_platform()</code>: Quick OS/arch validation 2. <code>r_available_and_supported()</code>: Check R via rpy2 3. <code>toolchain_is_compatible()</code>: Verify compiler versions 4. <code>prebuilt_available_for()</code>: Check bundle availability (currently disabled)</p> <p>The prebuilt availability check is commented out to allow installation even when bundle registry is not yet populated.</p> <p>Examples:</p> <pre><code>from brmspy.binaries.env import can_use_prebuilt\n\nif can_use_prebuilt():\n    print(\"Using prebuilt binaries for fast installation\")\n    # Proceed with prebuilt installation\nelse:\n    print(\"Building from source\")\n    # Proceed with source build\n</code></pre> <pre><code># Diagnostic check with detailed feedback\nfrom brmspy.binaries.env import (\n    supported_platform, r_available_and_supported,\n    toolchain_is_compatible, system_fingerprint,\n    prebuilt_available_for\n)\n\nprint(f\"Platform supported: {supported_platform()}\")\nprint(f\"R available: {r_available_and_supported()}\")\nprint(f\"Toolchain compatible: {toolchain_is_compatible()}\")\nfp = system_fingerprint()\nprint(f\"System fingerprint: {fp}\")\nprint(f\"Bundle available: {prebuilt_available_for(fp)}\")\nprint(f\"Can use prebuilt: {can_use_prebuilt()}\")\n</code></pre> See Also <p>supported_platform : Check platform support r_available_and_supported : Check R availability toolchain_is_compatible : Check compiler compatibility system_fingerprint : Get system identifier prebuilt_available_for : Check bundle availability</p>"},{"location":"binaries/use/","title":"Use","text":""},{"location":"binaries/use/#brmspy.binaries.use-functions","title":"Functions","text":""},{"location":"binaries/use/#brmspy.binaries.use.activate_runtime","title":"<code>activate_runtime(runtime_root)</code>","text":"<p>Activate a prebuilt brms runtime bundle in the current R session.</p> <p>Configures the embedded R session (via rpy2) to use libraries and CmdStan from a prebuilt runtime bundle. Updates R's library paths and sets cmdstanr's CmdStan path, then performs sanity checks.</p> <p>Parameters:</p> Name Type Description Default <code>runtime_root</code> <code>str or Path</code> <p>Path to runtime bundle root directory containing: - manifest.json: Bundle metadata and fingerprint - Rlib/: R package library with brms, cmdstanr, etc. - cmdstan/: CmdStan installation</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If required directories/files are missing or validation fails</p> Notes <p>Important Limitations:</p> <p>This function reconfigures the running embedded R session to use an isolated  library environment from downloaded binaries. It does not mix or break the  default library tree already installed in the system.</p> <p>What this function does:</p> <ol> <li>Validates runtime bundle structure (manifest, Rlib, cmdstan directories)</li> <li>Optionally verifies system fingerprint matches bundle fingerprint</li> <li>Unloads brms, cmdstanr and rstan (if they are loaded)</li> <li>Replaces R's .libPaths() with runtime Rlib directory</li> <li>Sets cmdstanr::set_cmdstan_path() to runtime cmdstan directory</li> <li>Performs sanity checks (brms and cmdstanr load successfully)</li> </ol> <p>Fingerprint Validation:</p> <p>If available, validates that the runtime bundle's fingerprint (from manifest.json) matches the current system fingerprint. This prevents incompatible bundles (e.g., Linux bundle on macOS) from being activated.</p> <p>Examples:</p> <pre><code>from pathlib import Path\nfrom brmspy.binaries.use import activate_runtime\n\n# Activate a previously installed runtime\nruntime_path = Path.home() / \".brmspy\" / \"runtime\" / \"linux-x86_64-r4.3\"\nactivate_runtime(runtime_path)\n\n# Now brms and cmdstanr use the prebuilt bundle\nfrom brmspy import fit\n\nresult = fit(\"y ~ x\", data={\"y\": [1, 2, 3], \"x\": [1, 2, 3]})\n</code></pre> See Also <p>install_and_activate_runtime : Download, install, and activate runtime brmspy.binaries.env.system_fingerprint : Get current system identifier</p>"},{"location":"binaries/use/#brmspy.binaries.use.install_and_activate_runtime","title":"<code>install_and_activate_runtime(url=None, bundle=None, runtime_version='0.1.0', base_dir=None, activate=True, expected_hash=None, require_attestation=True)</code>","text":"<p>Download, install, and optionally activate a prebuilt brms runtime bundle.</p> <p>This is the high-level orchestration function. It:</p> <ol> <li>Resolves the source (URL \u2192 temp file, or local archive/dir)</li> <li>Determines the canonical runtime_root for this system+version</li> <li>Optionally reuses an existing runtime if the stored hash matches</li> <li>Installs from archive or directory into runtime_root</li> <li>Stores the expected hash (if provided) for fast future reuse</li> <li>Optionally activates the runtime in the current R session</li> </ol> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to download runtime bundle archive (.tar.gz, .tar.bz2, etc.). Mutually exclusive with <code>bundle</code>.</p> <code>None</code> <code>bundle</code> <code>str or Path</code> <p>Local path to runtime bundle, either: - Archive file (.tar.gz, .tar.bz2, etc.) to extract, or - Directory containing an extracted runtime (with manifest.json). Mutually exclusive with <code>url</code>.</p> <code>None</code> <code>runtime_version</code> <code>str</code> <p>Logical runtime version used in the canonical runtime path {base_dir}/{system_fingerprint}-{runtime_version}.</p> <code>\"0.1.0\"</code> <code>base_dir</code> <code>str or Path</code> <p>Base directory for runtime installation. Default: ~/.brmspy/runtime/</p> <code>None</code> <code>activate</code> <code>bool</code> <p>If True, call <code>activate_runtime()</code> after installation/reuse.</p> <code>True</code> <code>expected_hash</code> <code>str</code> <p>Attested hash (e.g. sha256 from GitHub release assets). If provided, the installer will: - Reuse an existing runtime only if its stored hash matches this value. - Store the hash into {runtime_root}/hash after (re)install. If NOT provided, but the binary is an official kaitumisuuringute-keskus/brmspy  one, the expected_hash will be automatically fetched</p> <code>None</code> <code>require_attestation</code> <code>bool</code> <p>If True, <code>expected_hash</code> must be provided; otherwise a ValueError is raised. This lets callers enforce that only attested runtimes are used.</p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the installed (or reused) runtime root directory.</p>"},{"location":"development/development/","title":"Development Guide","text":"<p>This guide covers the development infrastructure, build processes, and CI/CD architecture for brmspy.</p>"},{"location":"development/development/#quick-start","title":"Quick Start","text":""},{"location":"development/development/#setup","title":"Setup","text":"<pre><code># Clone and setup\ngit clone https://github.com/kaitumisuuringute-keskus/brmspy.git\ncd brmspy\n\n# Install with dev dependencies\npython -m venv .venv\nsource .venv/bin/activate  # or .venv\\Scripts\\activate on Windows\npip install -e \".[all]\"\n\n# Install R dependencies\npython -c \"import brmspy; brmspy.install_brms()\"\n</code></pre>"},{"location":"development/development/#project-architecture","title":"Project Architecture","text":""},{"location":"development/development/#directory-structure","title":"Directory Structure","text":"<pre><code>brmspy/\n\u251c\u2500\u2500 brmspy/                    # Main package\n\u2502   \u251c\u2500\u2500 brms.py               # Core API exports\n\u2502   \u251c\u2500\u2500 types.py              # Type definitions and result dataclasses\n\u2502   \u251c\u2500\u2500 install.py            # R dependency installation\n\u2502   \u251c\u2500\u2500 brms_functions/       # Modular brms function wrappers\n\u2502   \u2502   \u251c\u2500\u2500 brm.py            # Model fitting (fit, brm)\n\u2502   \u2502   \u251c\u2500\u2500 diagnostics.py    # Model diagnostics (summary, loo, etc.)\n\u2502   \u2502   \u251c\u2500\u2500 families.py       # Family specifications\n\u2502   \u2502   \u251c\u2500\u2500 formula.py        # Formula construction\n\u2502   \u2502   \u251c\u2500\u2500 generic.py        # Generic function caller\n\u2502   \u2502   \u251c\u2500\u2500 io.py             # Data I/O (save_rds, read_rds, etc.)\n\u2502   \u2502   \u251c\u2500\u2500 prediction.py     # Predictions (posterior_predict, etc.)\n\u2502   \u2502   \u251c\u2500\u2500 prior.py          # Prior specifications\n\u2502   \u2502   \u2514\u2500\u2500 stan.py           # Stan code generation\n\u2502   \u251c\u2500\u2500 binaries/             # Prebuilt runtime system\n\u2502   \u2502   \u251c\u2500\u2500 build.py          # Create runtime bundles\n\u2502   \u2502   \u251c\u2500\u2500 env.py            # Platform detection\n\u2502   \u2502   \u251c\u2500\u2500 github.py         # GitHub releases integration\n\u2502   \u2502   \u251c\u2500\u2500 r.py              # R installation utilities\n\u2502   \u2502   \u2514\u2500\u2500 use.py            # Install runtimes\n\u2502   \u2514\u2500\u2500 helpers/              # Internal utilities\n\u2502       \u251c\u2500\u2500 conversion.py     # Python \u2194 R \u2194 ArviZ\n\u2502       \u251c\u2500\u2500 log.py            # Logging utilities\n\u2502       \u251c\u2500\u2500 priors.py         # Prior builders\n\u2502       \u251c\u2500\u2500 robject_iter.py   # R object iteration\n\u2502       \u251c\u2500\u2500 rtools.py         # Windows Rtools\n\u2502       \u2514\u2500\u2500 singleton.py      # R package caching\n\u251c\u2500\u2500 .github/workflows/        # CI/CD pipelines\n\u251c\u2500\u2500 .runtime_builder/         # Docker for Linux builds\n\u251c\u2500\u2500 docs/                     # mkdocs documentation\n\u2514\u2500\u2500 tests/                    # Test suite\n</code></pre>"},{"location":"development/development/#core-components","title":"Core Components","text":"<p>brmspy/brms.py - Main module that exports all public functions brmspy/types.py - Type definitions and result dataclasses (FitResult, SummaryResult, LooResult, etc.) brmspy/install.py - R dependency management and installation brmspy/brms_functions/ - Modular organization of brms function wrappers:   - brm.py - Model fitting functions   - diagnostics.py - 8 diagnostic functions (summary, fixef, ranef, loo, loo_compare, validate_newdata, etc.)   - prediction.py - Prediction functions (posterior_predict, posterior_epred, posterior_linpred, log_lik)   - prior.py - Prior specification functions   - families.py - Family specifications and wrappers   - formula.py - Formula construction helpers   - generic.py - Generic function caller for unwrapped brms functions   - io.py - Data I/O functions   - stan.py - Stan code generation</p> <p>brmspy/binaries/ - Prebuilt runtime bundle system brmspy/helpers/ - Internal conversion and utility functions</p>"},{"location":"development/development/#data-flow","title":"Data Flow","text":"<pre><code>Python Code\n    \u2193\nbrmspy.fit() [brms.py]\n    \u2193\nType Conversions [helpers/conversion.py]\n    \u2193\nR brms via rpy2\n    \u2193\nCmdStan MCMC Sampling\n    \u2193\nArviZ InferenceData\n    \u2193\nPython Result Objects\n</code></pre>"},{"location":"development/development/#runtime-binaries-system","title":"Runtime Binaries System","text":"<p>The runtime system provides prebuilt bundles to skip lengthy R package compilation.</p>"},{"location":"development/development/#system-fingerprint","title":"System Fingerprint","text":"<p>Each runtime is identified by: <code>{os}-{arch}-r{major}.{minor}</code></p> <p>Examples: - <code>linux-x86_64-r4.5</code> - <code>darwin-arm64-r4.5</code> (macOS Apple Silicon) - <code>windows-x86_64-r4.5</code></p>"},{"location":"development/development/#components","title":"Components","text":"<p>Platform Detection (<code>brmspy/binaries/env.py</code>): - Detect OS, architecture, R version - Generate system fingerprint - Check runtime compatibility</p> <p>Runtime Building (<code>brmspy/binaries/build.py</code>): - Bundle CmdStan binaries - Package R packages (cmdstanr, brms, posterior) - Include system libraries (Linux) - Create manifest with metadata</p> <p>Runtime Installation (<code>brmspy/binaries/use.py</code>): - Download from GitHub releases - Extract and activate runtime - Configure environment</p>"},{"location":"development/development/#bundle-structure","title":"Bundle Structure","text":"<pre><code>brmspy-runtime-{fingerprint}-{version}.tar.gz\n\u251c\u2500\u2500 manifest.json              # Metadata\n\u251c\u2500\u2500 cmdstan/                   # Compiled CmdStan\n\u251c\u2500\u2500 Rlib                       # R libraries\n</code></pre>"},{"location":"development/development/#usage","title":"Usage","text":"<pre><code>import brmspy\n\n# Install prebuilt runtime (2-3 minutes vs 20-30 from source)\nbrmspy.install_prebuilt(version=\"0.1.0\")\n\n# Build custom runtime locally\nfrom brmspy.binaries.build import build_runtime_bundle\nbuild_runtime_bundle(output_dir=\"dist/runtime\")\n</code></pre>"},{"location":"development/development/#cicd-pipelines","title":"CI/CD Pipelines","text":"<p>All workflows in <code>.github/workflows/</code>:</p>"},{"location":"development/development/#1-python-test-matrix-python-test-matrixyml","title":"1. Python Test Matrix (<code>python-test-matrix.yml</code>)","text":"<p>Trigger: Push/PR to master Purpose: Test Python 3.10, 3.12, 3.14 on Linux</p> <p>Workflow: 1. Build CmdStan once (cached) 2. Test matrix in parallel 3. Update coverage badge (3.12 only)</p> <p>Key Features: - Shared R/CmdStan cache - Parallel execution - Coverage reporting</p>"},{"location":"development/development/#2-r-dependencies-tests-r-dependencies-testsyml","title":"2. R Dependencies Tests (<code>r-dependencies-tests.yml</code>)","text":"<p>Trigger: Push/PR to master Purpose: Test on Linux, macOS, Windows</p> <p>Workflow: - Python 3.12 only - Tests marked with <code>@pytest.mark.crossplatform</code> - Fail-fast disabled</p>"},{"location":"development/development/#3-documentation-docsyml","title":"3. Documentation (<code>docs.yml</code>)","text":"<p>Trigger: Push to master Purpose: Deploy docs to GitHub Pages</p> <p>Stack: - mkdocstrings for API docs - Auto-deploys to https://kaitumisuuringute-keskus.github.io/brmspy/</p>"},{"location":"development/development/#4-pypi-publish-python-publishyml","title":"4. PyPI Publish (<code>python-publish.yml</code>)","text":"<p>Trigger: GitHub Release created Purpose: Publish to PyPI</p> <p>Workflow: 1. Run full test suite 2. Build: <code>python -m build</code> 3. Upload: <code>twine upload dist/*</code></p> <p>Requirements: <code>PYPI_USERNAME</code>, <code>PYPI_PASSWORD</code> secrets</p>"},{"location":"development/development/#5-runtime-publish-runtime-publishyml","title":"5. Runtime Publish (<code>runtime-publish.yml</code>)","text":"<p>Trigger: Manual dispatch Purpose: Build prebuilt runtimes for all platforms</p> <p>Architecture: 1. Create GitHub Release (tag: <code>runtime</code>) 2. Build runtimes in parallel (Linux in Docker, macOS/Windows native) 3. Upload to release with attestation</p> <p>Linux Build (Docker): <pre><code>- Pull: ghcr.io/.../brmspy-runtime-builder:ubuntu18-gcc9\n- Install R 4.5.0\n- Build runtime: python -m brmspy.binaries.build\n- Upload tarball\n</code></pre></p> <p>macOS/Windows Build (Native): <pre><code>- Setup Python 3.12 + R 4.5\n- Install dependencies\n- Build runtime\n- Upload tarball\n</code></pre></p>"},{"location":"development/development/#6-linux-runtime-builder-build-linux-runtime-imageyml","title":"6. Linux Runtime Builder (<code>build-linux-runtime-image.yml</code>)","text":"<p>Trigger: Manual dispatch Purpose: Build Docker image for Linux runtime compilation</p> <p>Image: Ubuntu 18.04 + GCC 9 + Python 3.12 (for old glibc compatibility)</p>"},{"location":"development/development/#runtime-builder-runtime_builderlinux","title":"Runtime Builder (<code>.runtime_builder/linux/</code>)","text":""},{"location":"development/development/#dockerfile","title":"Dockerfile","text":"<p>Creates build environment: - Base: Ubuntu 18.04 (glibc 2.27) - Toolchain: GCC 9, g++ 9, gfortran 9 - Python: 3.12.7 (compiled from source) - Dependencies: BLAS, LAPACK, V8, GLPK, graphics libs</p>"},{"location":"development/development/#install_rsh","title":"install_r.sh","text":"<p>Smart R installation: 1. Try APT (fast) 2. Fallback to source compilation if version unavailable</p>"},{"location":"development/development/#publishsh","title":"publish.sh","text":"<p>Builds and pushes Docker image to GHCR: <pre><code>docker build -t ghcr.io/{owner}/brmspy-runtime-builder:{tag}\ndocker push ghcr.io/{owner}/brmspy-runtime-builder:{tag}\n</code></pre></p>"},{"location":"development/development/#testing","title":"Testing","text":""},{"location":"development/development/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py              # Pytest fixtures (sample_dataframe, etc.)\n\u251c\u2500\u2500 test_basic.py            # Basic functionality tests\n\u251c\u2500\u2500 test_crossplatform.py    # Cross-platform compatibility tests\n\u251c\u2500\u2500 test_diagnostics.py      # Diagnostics functions tests (14 tests)\n\u251c\u2500\u2500 test_families.py         # Family specifications tests\n\u251c\u2500\u2500 test_generic.py          # Generic function caller tests\n\u251c\u2500\u2500 test_integration.py      # End-to-end integration tests\n\u251c\u2500\u2500 test_io.py               # I/O functions tests\n\u251c\u2500\u2500 test_predictions.py      # Prediction functions tests\n\u2514\u2500\u2500 test_priors.py           # Prior specification tests\n</code></pre> <p>Test Coverage: - 14 diagnostics tests covering summary, fixef, ranef, posterior_summary, prior_summary, loo, loo_compare, validate_newdata - 2 generic function tests for call() wrapper - All tests use <code>iter=100, warmup=50</code> for fast CI execution - Tests marked with <code>@pytest.mark.slow</code> and <code>@pytest.mark.requires_brms</code></p>"},{"location":"development/development/#running-tests","title":"Running Tests","text":"<pre><code>pytest tests/ -v                    # All tests\npytest tests/ -v --cov=brmspy      # With coverage\npytest -m crossplatform            # Cross-platform only\npytest -n auto                     # Parallel (requires pytest-xdist)\n</code></pre>"},{"location":"development/development/#test-markers","title":"Test Markers","text":"<pre><code>@pytest.mark.crossplatform\ndef test_basic_fit():\n    \"\"\"Runs on all platforms in CI\"\"\"\n    pass\n</code></pre>"},{"location":"development/development/#build-and-release","title":"Build and Release","text":""},{"location":"development/development/#version-management","title":"Version Management","text":"<p>Update in: - <code>pyproject.toml</code> - <code>settings.ini</code> - <code>brmspy/__init__.py</code></p>"},{"location":"development/development/#release-process","title":"Release Process","text":"<ol> <li>Update versions and CHANGELOG.md</li> <li>Test: <code>pytest</code></li> <li>Build: <code>make build</code></li> <li>Create GitHub Release (tag: <code>release-0...</code>)</li> <li>CI automatically tests and publishes to PyPI</li> </ol>"},{"location":"development/development/#building-runtimes","title":"Building Runtimes","text":"<p>Via GitHub Actions: 1. Go to Actions \u2192 runtime-publish 2. Run workflow with version and tag 3. Runtimes published to: <code>releases/tag/runtime</code></p> <p>Locally: <pre><code>python -m brmspy.binaries.build --output-dir dist/runtime\n</code></pre></p>"},{"location":"development/development/#documentation","title":"Documentation","text":""},{"location":"development/development/#mkdocs-configuration","title":"mkdocs Configuration","text":"<p>File: <code>mkdocs.yml</code></p> <pre><code>site_name: brmspy\ntheme:\n  name: shadcn\nplugins:\n  ...\n</code></pre>"},{"location":"development/development/#docstring-style","title":"Docstring Style","text":"<p>All docstrings use NumPy style with <code>```python</code> code blocks (no <code>.. code-block::</code>):</p> <pre><code>def example(param: str) -&gt; dict:\n    \"\"\"\n    One-line summary.\n\n    Detailed description.\n\n    Parameters\n    ----------\n    param : str\n        Parameter description\n\n    Returns\n    -------\n    dict\n        Return description\n\n    Examples\n    --------\n    Basic usage:\n\n    ```python\n    result = example(\"hello\")\n    print(result)\n    ```\n    \"\"\"\n    return {\"param\": param}\n</code></pre>"},{"location":"development/development/#performance","title":"Performance","text":""},{"location":"development/development/#r-package-caching","title":"R Package Caching","text":"<p>Singleton pattern in <code>brmspy/helpers/singleton.py</code>:</p> <pre><code>from brmspy.helpers.singleton import get_r_package\n\nbrms = get_r_package(\"brms\")  # First call: imports\nbrms = get_r_package(\"brms\")  # Cached, instant\n</code></pre>"},{"location":"development/development/#prebuilt-runtimes","title":"Prebuilt Runtimes","text":"Method Installation Time From source 20-30 minutes Prebuilt runtime 20-60 seconds"},{"location":"development/development/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/development/#r-package-installation-fails","title":"R Package Installation Fails","text":"<pre><code># Check R version (need 4.0+)\nR --version\n\n# Manual install\nR -e \"install.packages(c('cmdstanr', 'brms', 'posterior'))\"\n</code></pre>"},{"location":"development/development/#cmdstan-compilation-fails","title":"CmdStan Compilation Fails","text":"<p>Linux: <pre><code>sudo apt-get install build-essential\n</code></pre></p> <p>macOS: <pre><code>xcode-select --install\n</code></pre></p> <p>Windows: <pre><code>import brmspy.helpers.rtools as rtools\nrtools.install_rtools()\n</code></pre></p>"},{"location":"development/development/#runtime-incompatibility","title":"Runtime Incompatibility","text":"<pre><code># Build local runtime\nfrom brmspy.binaries.build import build_runtime_bundle\nbuild_runtime_bundle(output_dir=\"custom\")\n\n# Or install matching prebuilt\nbrmspy.install_prebuilt()  # Auto-detects platform\n</code></pre>"},{"location":"development/development/#contributing","title":"Contributing","text":""},{"location":"development/development/#code-style","title":"Code Style","text":"<ul> <li>Docstrings: NumPy style</li> <li>Type hints: Required for public APIs</li> </ul>"},{"location":"development/development/#pr-process","title":"PR Process","text":"<ol> <li>Fork and create feature branch</li> <li>Make changes and add tests</li> <li>Run: <code>make format &amp;&amp; make lint &amp;&amp; make test</code></li> <li>Commit with conventional commits format</li> <li>Open PR with clear description</li> </ol>"},{"location":"development/development/#resources","title":"Resources","text":"<ul> <li>Documentation: https://kaitumisuuringute-keskus.github.io/brmspy/</li> <li>Repository: https://github.com/kaitumisuuringute-keskus/brmspy</li> <li>Issues: https://github.com/kaitumisuuringute-keskus/brmspy/issues</li> <li>PyPI: https://pypi.org/project/brmspy/</li> </ul>"},{"location":"examples/advanced/","title":"Advanced Usage","text":""},{"location":"examples/advanced/#custom-sampling-parameters","title":"Custom Sampling Parameters","text":"<pre><code>from brmspy import brms\n\nmodel = brms.fit(\n    formula=\"y ~ x + (1|group)\",\n    data=data,\n    iter=2000,      # Total iterations per chain\n    warmup=1000,    # Warmup iterations\n    chains=4,       # Number of chains\n    cores=4,        # Parallel cores\n    thin=1,         # Thinning\n    seed=123,       # Random seed\n    control={'adapt_delta': 0.95}  # Stan control parameters\n)\n</code></pre>"},{"location":"examples/advanced/#multiple-prediction-types","title":"Multiple Prediction Types","text":"<pre><code># Expected value (without observation noise)\nepred = brms.posterior_epred(model, newdata=new_data)\n\n# Posterior predictive (with observation noise)\nypred = brms.posterior_predict(model, newdata=new_data)\n\n# Linear predictor\nlinpred = brms.posterior_linpred(model, newdata=new_data)\n\n# Log likelihood\nloglik = brms.log_lik(model, newdata=new_data)\n</code></pre>"},{"location":"examples/advanced/#dual-python-r-workflow","title":"Dual Python-R Workflow","text":"<pre><code>import arviz as az\nimport rpy2.robjects as ro\n\nmodel = brms.fit(formula=\"count ~ zAge + (1|patient)\", data=data, family=\"poisson\")\n\n# Python analysis\naz.summary(model.idata)\naz.plot_trace(model.idata)\n\n# R analysis (if needed)\nro.r('summary')(model.r)\nro.r('plot')(model.r)\nro.r('loo')(model.r)  # Leave-one-out cross-validation\n</code></pre>"},{"location":"examples/advanced/#different-families","title":"Different Families","text":""},{"location":"examples/advanced/#gaussian-default","title":"Gaussian (default)","text":"<pre><code>model = brms.fit(\n    formula=\"y ~ x\",\n    data=data,\n    family=\"gaussian\"\n)\n</code></pre>"},{"location":"examples/advanced/#poisson-count-data","title":"Poisson (count data)","text":"<pre><code>model = brms.fit(\n    formula=\"count ~ treatment + (1|subject)\",\n    data=data,\n    family=\"poisson\"\n)\n</code></pre>"},{"location":"examples/advanced/#binomial-binary-outcomes","title":"Binomial (binary outcomes)","text":"<pre><code>model = brms.fit(\n    formula=\"success | trials(n) ~ x\",\n    data=data,\n    family=\"binomial\"\n)\n</code></pre>"},{"location":"examples/advanced/#student-t-robust-to-outliers","title":"Student-t (robust to outliers)","text":"<pre><code>model = brms.fit(\n    formula=\"y ~ x\",\n    data=data,\n    family=\"student\"\n)\n</code></pre>"},{"location":"examples/advanced/#complex-random-effects","title":"Complex Random Effects","text":""},{"location":"examples/advanced/#nested-random-effects","title":"Nested Random Effects","text":"<pre><code>model = brms.fit(\n    formula=\"y ~ x + (1|country/region/city)\",\n    data=data\n)\n</code></pre>"},{"location":"examples/advanced/#random-slopes","title":"Random Slopes","text":"<pre><code>model = brms.fit(\n    formula=\"y ~ x + (x|subject)\",\n    data=data\n)\n</code></pre>"},{"location":"examples/advanced/#correlated-random-effects","title":"Correlated Random Effects","text":"<pre><code>model = brms.fit(\n    formula=\"y ~ x + (x + z|subject)\",\n    data=data\n)\n</code></pre>"},{"location":"examples/advanced/#working-with-results","title":"Working with Results","text":""},{"location":"examples/advanced/#extract-posterior-samples","title":"Extract Posterior Samples","text":"<pre><code># Get posterior as xarray Dataset\nposterior = model.idata.posterior\n\n# Extract specific parameter\nb_intercept = posterior['b_Intercept'].values\n\n# Extract all coefficients\ncoefficients = {\n    var: posterior[var].values \n    for var in posterior.data_vars \n    if var.startswith('b_')\n}\n</code></pre>"},{"location":"examples/advanced/#model-comparison","title":"Model Comparison","text":"<pre><code>import arviz as az\n\nmodel1 = brms.fit(formula=\"y ~ x\", data=data)\nmodel2 = brms.fit(formula=\"y ~ x + z\", data=data)\n\n# Compare models\ncomparison = az.compare({\n    'model1': model1.idata,\n    'model2': model2.idata\n})\nprint(comparison)\n</code></pre>"},{"location":"examples/advanced/#debugging","title":"Debugging","text":""},{"location":"examples/advanced/#check-stan-code","title":"Check Stan Code","text":"<pre><code>stan_code = brms.make_stancode(\n    formula=\"count ~ zAge + (1|patient)\",\n    data=data,\n    priors=[],\n    family=\"poisson\"\n)\nprint(stan_code)\n</code></pre>"},{"location":"examples/advanced/#compile-without-sampling","title":"Compile Without Sampling","text":"<p>```python</p>"},{"location":"examples/advanced/#just-compile-the-model","title":"Just compile the model","text":"<p>model = brms.fit(     formula=\"y ~ x\",     data=data,     sample=False  # Don't sample, just compile )</p>"},{"location":"examples/google-colab-example/","title":"Google colab example","text":"<p>This example runs in Google Colab environment. Dependency installation takes &lt;50s.</p> <p>The notebook can be run HERE</p> <pre><code>!pip install brmspy\n</code></pre> <pre><code>from brmspy import brms\n</code></pre> <pre><code>brms.install_brms(use_prebuilt_binaries=True)\n</code></pre> <pre><code>epilepsy = brms.get_brms_data(\"epilepsy\")\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    warmup=500,\n    iter=1000,\n    chains=4\n)\nidata = model.idata\n</code></pre> <pre><code>brms.save_rds(model, \"epilepsy_fixed_effects.rds\")\n# load later using: brms.load_rds_fit(\"epilepsy_fixed_effects.rds\")\n</code></pre> <pre><code>import arviz as az\nsummary = az.summary(\n    idata,\n    hdi_prob=0.95,\n    kind=\"stats\",\n    round_to=3\n)\n\nprint(\"Posterior Summary\")\nprint(\"=\"*60)\nprint(summary)\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nimport seaborn as sns\n\nfig = az.plot_posterior(\n    idata,\n    var_names=['b_Intercept', 'b_zAge', 'b_zBase', 'b_Trt1', 'b_zBase:Trt1'],\n    figsize=(12, 8),\n    textsize=10\n)\nplt.suptitle('Posterior Distributions - Fixed Effects', y=1.02, fontsize=14, fontweight='bold')\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"examples/quickstart/","title":"Quick Start Guide","text":""},{"location":"examples/quickstart/#installation","title":"Installation","text":"<pre><code>pip install brmspy\n</code></pre>"},{"location":"examples/quickstart/#first-time-setup","title":"First Time Setup","text":"<p>Install brms and CmdStan:</p> <pre><code>from brmspy import brms\nbrms.install_brms()\n</code></pre>"},{"location":"examples/quickstart/#basic-model","title":"Basic Model","text":"<pre><code>from brmspy import brms, prior\nimport arviz as az\n\n# Load example data\nepilepsy = brms.get_brms_data(\"epilepsy\")\n\n# Fit model\nmodel = brms.fit(\n    formula=\"count ~ zAge + zBase * Trt + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    priors=[\n        prior(\"normal(0, 1)\", \"b\"),\n        prior(\"exponential(1)\", \"sd\", group=\"patient\"),\n        prior(\"student_t(3, 0, 2.5)\", \"Intercept\")\n    ],\n    chains=4,\n    iter=2000\n)\n\n# Analyze with arviz\naz.summary(model.idata)\naz.plot_posterior(model.idata)\n</code></pre>"},{"location":"examples/quickstart/#with-priors","title":"With Priors","text":"<pre><code>from brmspy import prior\n\nmodel = brms.fit(\n    formula=\"count ~ zAge + (1|patient)\",\n    data=epilepsy,\n    family=\"poisson\",\n    priors=[\n        prior(\"normal(0, 0.5)\", class_=\"b\"),\n        prior(\"cauchy(0, 1)\", class_=\"sd\")\n    ],\n    chains=4\n)\n</code></pre>"},{"location":"examples/quickstart/#model-summary","title":"Model Summary","text":"<pre><code>from brmspy import summary\n\n# Get summary as DataFrame\nsummary_df = summary(model)\nprint(summary_df)\n</code></pre>"},{"location":"examples/quickstart/#predictions","title":"Predictions","text":"<pre><code>import pandas as pd\n\n# New data for predictions\nnew_data = pd.DataFrame({\n    'zAge': [0, 0.5, 1.0],\n    'zBase': [0, 0, 0],\n    'Trt': [0, 0, 0],\n    'patient': [1, 1, 1]\n})\n\n# Expected value predictions\nepred = brms.posterior_epred(model, newdata=new_data)\n\n# Posterior predictive samples\nypred = brms.posterior_predict(model, newdata=new_data)\n</code></pre>"},{"location":"examples/quickstart/#access-r-object","title":"Access R Object","text":"<p>If you need direct R functionality:</p> <p>```python import rpy2.robjects as ro</p>"},{"location":"examples/quickstart/#access-r-brmsfit-object","title":"Access R brmsfit object","text":"<p>ro.r('summary')(model.r) ro.r('plot')(model.r)</p>"}]}